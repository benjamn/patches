# HG changeset patch
# Parent 22f239687944fbab72957dd20bbc1133c55b5e16

diff --git a/js/ipc/Handle.h b/js/ipc/Handle.h
--- a/js/ipc/Handle.h
+++ b/js/ipc/Handle.h
@@ -94,17 +94,17 @@ public:
     JSObject* ToJSObject(JSContext* cx) const {
         if (!mObj && !mRuntime) {
             JSAutoRequest request(cx);
 
             JSClass* clasp = const_cast<JSClass*>(&sHandle_JSClass);
             JSObject* obj = JS_NewObject(cx, clasp, NULL, NULL);
             if (!obj)
                 return NULL;
-            js::AutoValueRooter avr(cx, obj);
+            js::AutoObjectRooter root(cx, obj);
 
             JSPropertySpec* ps = const_cast<JSPropertySpec*>(sHandle_Properties);
             JSFunctionSpec* fs = const_cast<JSFunctionSpec*>(sHandle_Functions);
             JSRuntime* rt;
 
             const char* name = IsParent(this)
                 ? "mozilla::jsipc::Handle<PHandleParent>::mObj"
                 : "mozilla::jsipc::Handle<PHandleChild>::mObj";
diff --git a/js/jetpack/JetpackActorCommon.cpp b/js/jetpack/JetpackActorCommon.cpp
--- a/js/jetpack/JetpackActorCommon.cpp
+++ b/js/jetpack/JetpackActorCommon.cpp
@@ -31,85 +31,290 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
+#include "base/basictypes.h"
 #include "jscntxt.h"
 
 #include "mozilla/jetpack/JetpackActorCommon.h"
+#include "mozilla/jetpack/PJetpack.h"
+#include "mozilla/jsipc/PHandleParent.h"
+#include "mozilla/jsipc/PHandleChild.h"
+#include "mozilla/jsipc/Handle.h"
 
 #include "jsapi.h"
+#include "jstl.h"
+#include "jshashtable.h"
 
 using mozilla::jetpack::JetpackActorCommon;
+using mozilla::jetpack::Variant;
+using mozilla::jsipc::PHandleParent;
+using mozilla::jsipc::HandleParent;
+using mozilla::jsipc::PHandleChild;
+using mozilla::jsipc::HandleChild;
+
+struct JetpackActorCommon::OpaqueSeenType {
+  typedef js::HashSet<
+    JSObject*,
+    js::DefaultHasher<JSObject*>,
+    js::SystemAllocPolicy
+  > SetType;
+
+  OpaqueSeenType() {
+    NS_ASSERTION(set.init(1), "Failed to allocate HashSet");
+  }
+
+  bool ok() { return set.initialized(); }
+
+  SetType set;
+};
+
+bool
+JetpackActorCommon::jsval_to_Variant(JSContext* cx, jsval from, Variant* to,
+                                     OpaqueSeenType* seen)
+{
+  switch (JS_TypeOfValue(cx, from)) {
+  case JSTYPE_VOID:
+    *to = void_t();
+    return true;
+  case JSTYPE_NULL:
+    *to = null_t();
+    return true;
+  case JSTYPE_FUNCTION:
+    return false;
+  case JSTYPE_OBJECT: {
+    HandleParent* hp = HandleParent::FromJSVal(cx, from);
+    HandleChild* hc = HandleChild::FromJSVal(cx, from);
+    NS_ASSERTION(!hc || !hp, "Can't be both a parent and a child");
+    if (hp) {
+      *to = hp;
+      return true;
+    }
+    if (hc) {
+      *to = hc;
+      return true;
+    }
+
+    JSObject* obj = JSVAL_TO_OBJECT(from);
+
+    js::LazilyConstructed<OpaqueSeenType> lost;
+    if (!seen) {
+      lost.construct();
+      seen = lost.addr();
+      if (!seen->ok())
+        return false;
+    }
+    OpaqueSeenType::SetType::AddPtr ap =
+      seen->set.lookupForAdd(obj);
+    if (ap || !seen->set.add(ap, obj))
+      return false;
+
+    if (JS_IsArrayObject(cx, obj)) {
+      nsTArray<Variant> elems;
+      jsuint len;
+      if (!JS_GetArrayLength(cx, obj, &len))
+        return false;
+      for (jsuint i = 0; i < len; ++i) {
+        jsval val;
+        Variant* vp = elems.AppendElement();
+        if (!JS_GetElement(cx, obj, i, &val) ||
+            !jsval_to_Variant(cx, val, vp, seen))
+          *vp = void_t();
+      }
+      *to = elems;
+      return true;
+    }
+
+    js::AutoIdArray ida(cx, JS_Enumerate(cx, obj));
+    if (!ida)
+      return false;
+
+    nsTArray<KeyValue> kvs;
+    for (size_t i = 0; i < ida.length(); ++i) {
+      jsval val; // reused for both key and value
+      if (!JS_IdToValue(cx, ida[i], &val))
+        return false;
+      JSString* idStr = JS_ValueToString(cx, val);
+      if (!idStr)
+        return false;
+      if (!JS_GetPropertyById(cx, obj, ida[i], &val))
+        return false;
+      KeyValue* kv = kvs.AppendElement();
+      kv->key() = nsString((PRUnichar*)JS_GetStringChars(idStr),
+                           JS_GetStringLength(idStr));
+      if (!jsval_to_Variant(cx, val, &kv->value(), seen))
+        return false;
+    }
+    *to = kvs;
+    return true;
+  }
+  case JSTYPE_STRING:
+    *to = nsDependentString((PRUnichar*)JS_GetStringChars(JSVAL_TO_STRING(from)),
+                            JS_GetStringLength(JSVAL_TO_STRING(from)));
+    return true;
+  case JSTYPE_NUMBER:
+    if (JSVAL_IS_INT(from))
+      *to = JSVAL_TO_INT(from);
+    else if (JSVAL_IS_DOUBLE(from))
+      *to = *JSVAL_TO_DOUBLE(from);
+    else
+      return false;
+    return true;
+  case JSTYPE_BOOLEAN:
+    *to = !!JSVAL_TO_BOOLEAN(from);
+    return true;
+  case JSTYPE_XML:
+    // fall through
+  default:
+    return false;
+  }
+}
+
+bool
+JetpackActorCommon::jsval_from_Variant(JSContext* cx, const Variant& from,
+                                       jsval* to)
+{
+  switch (from.type()) {
+  case Variant::Tvoid_t:
+    *to = JSVAL_VOID;
+    return true;
+  case Variant::Tnull_t:
+    *to = JSVAL_NULL;
+    return true;
+  case Variant::Tbool:
+    *to = from.get_bool() ? JSVAL_TRUE : JSVAL_FALSE;
+    return true;
+  case Variant::Tint:
+    *to = INT_TO_JSVAL(from.get_int());
+    return true;
+  case Variant::Tdouble:
+    return !!JS_NewDoubleValue(cx, from.get_double(), to);
+  case Variant::TnsString: {
+    const nsString& str = from.get_nsString();
+    if (!str.Length()) {
+      *to = JS_GetEmptyStringValue(cx);
+      return true;
+    }
+    JSString* s =
+      JS_NewUCStringCopyN(cx, str.BeginReading(), str.Length());
+    if (!s)
+      return false;
+    *to = STRING_TO_JSVAL(s);
+    return true;
+  }
+  case Variant::TPHandleParent: {
+    JSObject* hobj =
+      static_cast<const HandleParent*>(from.get_PHandleParent())->ToJSObject(cx);
+    if (!hobj)
+      return false;
+    *to = OBJECT_TO_JSVAL(hobj);
+    return true;
+  }    
+  case Variant::TPHandleChild: {
+    JSObject* hobj =
+      static_cast<const HandleChild*>(from.get_PHandleChild())->ToJSObject(cx);
+    if (!hobj)
+      return false;
+    *to = OBJECT_TO_JSVAL(hobj);
+    return true;
+  }
+  case Variant::TArrayOfKeyValue: {
+    const nsTArray<KeyValue>& kvs = from.get_ArrayOfKeyValue();
+    JSObject* obj = JS_NewObject(cx, NULL, NULL, NULL);
+    if (!obj)
+      return false;
+    js::AutoObjectRooter root(cx, obj);
+    for (PRUint32 i = 0; i < kvs.Length(); ++i) {
+      const KeyValue& kv = kvs.ElementAt(i);
+      jsval val;
+      if (!jsval_from_Variant(cx, kv.value(), &val) ||
+          !JS_SetUCProperty(cx, obj,
+                            kv.key().BeginReading(),
+                            kv.key().Length(),
+                            &val))
+        return false;
+    }
+    *to = OBJECT_TO_JSVAL(obj);
+    return true;
+  }
+  case Variant::TArrayOfVariant: {
+    const nsTArray<Variant>& vs = from.get_ArrayOfVariant();
+    jsval* elems;
+    JSObject* arrObj =
+      js_NewArrayObjectWithCapacity(cx, vs.Length(), &elems);
+    if (!arrObj || !elems)
+      return false;
+    js::AutoObjectRooter root(cx, arrObj);
+    for (PRUint32 i = 0; i < vs.Length(); ++i)
+      if (!jsval_from_Variant(cx, vs.ElementAt(i), elems + i))
+        return false;
+    *to = OBJECT_TO_JSVAL(arrObj);
+    return true;
+  }
+  default:
+    return false;
+  }
+}
 
 bool
 JetpackActorCommon::RecvMessage(JSContext* cx,
                                 const nsString& messageName,
-                                const nsString& inData,
-                                JSObject* obj,
-                                nsTArray<nsString>* outData)
+                                const nsTArray<Variant>& data,
+                                nsTArray<Variant>* results)
 {
-  if (outData)
-    outData->Clear();
+  if (results)
+    results->Clear();
 
   nsAutoTArray<jsval, 4> snapshot;
   TakeSnapshot(messageName, snapshot);
   if (!snapshot.Length())
     return true;
-  
+  js::AutoArrayRooter
+    snapshotRooter(cx, snapshot.Length(), snapshot.Elements());
   JSAutoRequest request(cx);
 
-  jsval argv[3];
-  js::AutoArrayRooter argvRooter(cx, 3, argv);
+  nsAutoTArray<jsval, 4> args;
+  PRUint32 argc = data.Length() + 1;
+  jsval* argv = args.AppendElements(argc);
+  if (!argv)
+    return false;
+  for (PRUint32 i = 0; i < argc; ++i)
+    argv[i] = JSVAL_VOID;
+  js::AutoArrayRooter argvRooter(cx, argc, argv);
 
   JSString* msgNameStr =
     JS_NewUCStringCopyN(cx,
                         messageName.BeginReading(),
                         messageName.Length());
   if (!msgNameStr)
     return false;
   argv[0] = STRING_TO_JSVAL(msgNameStr);
 
-  if (inData.Length()) {
-    JSString* inDataStr =
-      JS_NewUCStringCopyN(cx,
-                          inData.BeginReading(),
-                          inData.Length());
-    if (!inDataStr)
+  for (PRUint32 i = 0; i < data.Length(); ++i)
+    if (!jsval_from_Variant(cx, data.ElementAt(i), argv + i + 1))
       return false;
-    argv[1] = STRING_TO_JSVAL(inDataStr);
-  } else {
-    argv[1] = JS_GetEmptyStringValue(cx);
-  }
-
-  if (obj)
-    argv[2] = OBJECT_TO_JSVAL(obj);
 
   JSObject* implGlobal = JS_GetGlobalObject(cx);
   for (PRUint32 i = 0; i < snapshot.Length(); ++i) {
     jsval rval;
-    if (!JS_CallFunctionValue(cx, implGlobal, snapshot.ElementAt(i),
-                              obj ? 3 : 2, argv, &rval))
+    if (!JS_CallFunctionValue(cx, implGlobal, snapshot.ElementAt(i), argc, argv,
+                              &rval))
       break;
 
-    if (!outData)
+    if (!results)
       continue;
 
-    nsString* elem = outData->AppendElement();
-    JSString* rstr = JS_ValueToString(cx, rval);
-
-    if (rstr)
-      *elem = nsString((PRUnichar*)JS_GetStringChars(rstr),
-                       JS_GetStringLength(rstr));
-    else
-      elem->Truncate();
+    Variant* vp = results->AppendElement();
+    if (!jsval_to_Variant(cx, rval, vp))
+      *vp = void_t();
   }
 
   return true;
 }
 
 nsresult
 JetpackActorCommon::RegisterReceiver(JSContext* cx,
                                      const nsString& messageName,
diff --git a/js/jetpack/JetpackActorCommon.h b/js/jetpack/JetpackActorCommon.h
--- a/js/jetpack/JetpackActorCommon.h
+++ b/js/jetpack/JetpackActorCommon.h
@@ -45,26 +45,28 @@
 #include "nsAutoJSValHolder.h"
 #include "nsString.h"
 
 struct JSContext;
 
 namespace mozilla {
 namespace jetpack {
 
+class KeyValue;
+class Variant;
+
 class JetpackActorCommon
 {
 public:
 
   bool
   RecvMessage(JSContext* cx,
               const nsString& messageName,
-              const nsString& inData, // TODO
-              JSObject* handle,
-              nsTArray<nsString>* outData); // TODO
+              const nsTArray<Variant>& data,
+              nsTArray<Variant>* results);
 
   nsresult
   RegisterReceiver(JSContext* cx,
                    const nsString& messageName,
                    jsval receiver);
 
   void
   UnregisterReceiver(const nsString& messageName,
@@ -74,16 +76,21 @@ public:
   UnregisterReceivers(const nsString& messageName) {
     mReceivers.Remove(messageName);
   }
 
   void ClearReceivers() {
     mReceivers.Clear();
   }
 
+  struct OpaqueSeenType;
+  static bool jsval_to_Variant(JSContext* cx, jsval from, Variant* to,
+                               OpaqueSeenType* seen = NULL);
+  static bool jsval_from_Variant(JSContext* cx, const Variant& from, jsval* to);
+
 protected:
 
   JetpackActorCommon() {
     mReceivers.Init();
   }
 
 private:
 
diff --git a/js/jetpack/JetpackChild.cpp b/js/jetpack/JetpackChild.cpp
--- a/js/jetpack/JetpackChild.cpp
+++ b/js/jetpack/JetpackChild.cpp
@@ -82,46 +82,56 @@ JetpackChild::sImplMethods[] = {
   JS_FN("unregisterReceivers", UnregisterReceivers, 1, IMPL_METHOD_FLAGS),
   JS_FN("wrap", Wrap, 1, IMPL_METHOD_FLAGS),
   JS_FN("createHandle", CreateHandle, 0, IMPL_METHOD_FLAGS),
   JS_FS_END
 };
 
 #undef IMPL_METHOD_FLAGS
 
+const JSClass
+JetpackChild::sGlobalClass = {
+  "JetpackChild::sGlobalClass", JSCLASS_GLOBAL_FLAGS,
+  JS_PropertyStub,  JS_PropertyStub, JS_PropertyStub, JS_PropertyStub,
+  JS_EnumerateStub, JS_ResolveStub,  JS_ConvertStub,  JS_FinalizeStub,
+  JSCLASS_NO_OPTIONAL_MEMBERS
+};
+  
 bool
 JetpackChild::Init(base::ProcessHandle aParentProcessHandle,
                    MessageLoop* aIOLoop,
                    IPC::Channel* aChannel)
 {
   if (!Open(aChannel, aParentProcessHandle, aIOLoop))
     return false;
 
   if (!(mRuntime = JS_NewRuntime(32L * 1024L * 1024L)) ||
       !(mImplCx = JS_NewContext(mRuntime, 8192)) ||
       !(mUserCx = JS_NewContext(mRuntime, 8192)))
     return false;
 
   {
     JSAutoRequest request(mImplCx);
     JS_SetContextPrivate(mImplCx, this);
-    JSObject* implGlobal = JS_NewObject(mImplCx, NULL, NULL, NULL);
+    JSObject* implGlobal =
+      JS_NewObject(mImplCx, const_cast<JSClass*>(&sGlobalClass), NULL, NULL);
     if (!implGlobal ||
         !JS_InitStandardClasses(mImplCx, implGlobal) ||
         !JS_DefineProperties(mImplCx, implGlobal,
                              const_cast<JSPropertySpec*>(sImplProperties)) ||
         !JS_DefineFunctions(mImplCx, implGlobal,
                             const_cast<JSFunctionSpec*>(sImplMethods)))
       return false;
   }
 
   {
     JSAutoRequest request(mUserCx);
     JS_SetContextPrivate(mUserCx, this);
-    JSObject* userGlobal = JS_NewObject(mUserCx, NULL, NULL, NULL);
+    JSObject* userGlobal =
+      JS_NewObject(mUserCx, const_cast<JSClass*>(&sGlobalClass), NULL, NULL);
     if (!userGlobal ||
         !JS_InitStandardClasses(mUserCx, userGlobal))
       return false;
   }
 
   return true;
 }
 
@@ -131,24 +141,19 @@ JetpackChild::CleanUp()
   JS_DestroyContext(mUserCx);
   JS_DestroyContext(mImplCx);
   JS_DestroyRuntime(mRuntime);
   JS_ShutDown();
 }
 
 bool
 JetpackChild::RecvSendMessage(const nsString& messageName,
-                              const nsString& data,
-                              PHandleChild* handle)
+                              const nsTArray<Variant>& data)
 {
-  JSObject* hobj = NULL;
-  if (handle)
-    hobj = static_cast<HandleChild*>(handle)->ToJSObject(mImplCx);
-  return JetpackActorCommon::RecvMessage(mImplCx, messageName, data, hobj,
-                                         NULL);
+  return JetpackActorCommon::RecvMessage(mImplCx, messageName, data, NULL);
 }
 
 static bool
 Evaluate(JSContext* cx, const nsCString& code)
 {
   JSAutoRequest request(cx);
   jsval v;
   JS_EvaluateScript(cx, JS_GetGlobalObject(cx), code.get(),
@@ -198,67 +203,61 @@ JetpackChild::UserJetpackGetter(JSContex
   JSObject* userGlobal = JS_GetGlobalObject(GetThis(cx)->mUserCx);
   JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(userGlobal));
   return JS_TRUE;
 }
 
 struct MessageResult {
   PRUnichar* msgNameChars;
   size_t msgNameLength;
-  PRUnichar* dataChars;
-  size_t dataLength;
-  HandleChild* handleObj;
+  nsTArray<Variant> data;
 };
 
 static JSBool
 MessageCommon(JSContext* cx, uintN argc, jsval* vp,
               MessageResult* result)
 {
-  if (argc < 1 || argc > 3) {
-    // XXX CallMessage takes only one or two, strictly speaking.
-    JS_ReportError(cx, "message takes one, two, or three arguments");
+  if (argc < 1) {
+    JS_ReportError(cx, "Message requires a name, at least");
     return JS_FALSE;
   }
 
   jsval* argv = JS_ARGV(cx, vp);
 
-  JSString
-    * msgNameStr = JS_ValueToString(cx, argv[0]),
-    * dataStr = (argc > 1 ?
-                 JS_ValueToString(cx, argv[1]) :
-                 JSVAL_TO_STRING(JS_GetEmptyStringValue(cx)));
-
-  if (!msgNameStr || !dataStr) {
+  JSString* msgNameStr = JS_ValueToString(cx, argv[0]);
+  if (!msgNameStr) {
     JS_ReportOutOfMemory(cx);
     return JS_FALSE;
   }
 
   result->msgNameChars = (PRUnichar*)JS_GetStringChars(msgNameStr);
   result->msgNameLength = JS_GetStringLength(msgNameStr);
-  result->dataChars = (PRUnichar*)JS_GetStringChars(dataStr);
-  result->dataLength = JS_GetStringLength(dataStr);
-  result->handleObj = NULL;
-  if (argc > 2)
-    result->handleObj = HandleChild::FromJSVal(cx, argv[2]);
+
+  result->data.Clear();
+  for (uintN i = 1; i < argc; ++i) {
+    Variant* vp = result->data.AppendElement();
+    if (!JetpackActorCommon::jsval_to_Variant(cx, argv[i], vp)) {
+      JS_ReportError(cx, "Invalid message argument at position %d", i);
+      return JS_FALSE;
+    }
+  }
 
   return JS_TRUE;
 }
 
 JSBool
 JetpackChild::SendMessage(JSContext* cx, uintN argc, jsval* vp)
 {
   MessageResult smr;
   if (!MessageCommon(cx, argc, vp, &smr))
     return JS_FALSE;
 
   if (!GetThis(cx)->SendSendMessage(nsDependentString(smr.msgNameChars,
                                                       smr.msgNameLength),
-                                    nsDependentString(smr.dataChars,
-                                                      smr.dataLength),
-                                    smr.handleObj))
+                                    smr.data))
   {
     JS_ReportError(cx, "Failed to sendMessage");
     return JS_FALSE;
   }
 
   JS_SET_RVAL(cx, vp, JSVAL_VOID);
 
   return JS_TRUE;
@@ -266,47 +265,40 @@ JetpackChild::SendMessage(JSContext* cx,
 
 JSBool
 JetpackChild::CallMessage(JSContext* cx, uintN argc, jsval* vp)
 {
   MessageResult smr;
   if (!MessageCommon(cx, argc, vp, &smr))
     return JS_FALSE;
 
-  nsTArray<nsString> outData;
+  nsTArray<Variant> results;
   if (!GetThis(cx)->SendCallMessage(nsDependentString(smr.msgNameChars,
                                                       smr.msgNameLength),
-                                    nsDependentString(smr.dataChars,
-                                                      smr.dataLength),
-                                    &outData))
+                                    smr.data,
+                                    &results))
   {
     JS_ReportError(cx, "Failed to callMessage");
     return JS_FALSE;
   }
 
-  jsval* outVals;
+  jsval* rvals;
   JSObject* arrObj =
-    js_NewArrayObjectWithCapacity(cx, outData.Length(), &outVals);
-  if (!arrObj || !outVals) {
+    js_NewArrayObjectWithCapacity(cx, results.Length(), &rvals);
+  if (!arrObj || !rvals) {
     JS_ReportOutOfMemory(cx);
     return JS_FALSE;
   }
   js::AutoValueRooter root(cx, arrObj);
 
-  for (PRUint32 i = 0; i < outData.Length(); ++i) {
-    JSString* rstr =
-      JS_NewUCStringCopyN(cx,
-                          outData[i].BeginReading(),
-                          outData[i].Length());
-    if (!rstr) {
-      JS_ReportOutOfMemory(cx);
+  for (PRUint32 i = 0; i < results.Length(); ++i)
+    if (!jsval_from_Variant(cx, results.ElementAt(i), rvals + i)) {
+      JS_ReportError(cx, "Invalid result from handler %d", i);
       return JS_FALSE;
     }
-    outVals[i] = STRING_TO_JSVAL(rstr);
-  }
 
   JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(arrObj));
 
   return JS_TRUE;
 }
 
 struct ReceiverResult
 {
diff --git a/js/jetpack/JetpackChild.h b/js/jetpack/JetpackChild.h
--- a/js/jetpack/JetpackChild.h
+++ b/js/jetpack/JetpackChild.h
@@ -36,16 +36,18 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_jetpack_JetpackChild_h
 #define mozilla_jetpack_JetpackChild_h
 
 #include "mozilla/jetpack/PJetpackChild.h"
 #include "mozilla/jetpack/JetpackActorCommon.h"
 
+#include "nsTArray.h"
+
 namespace mozilla {
 
 namespace jsipc {
 class PHandleChild;
 }
 
 namespace jetpack {
 
@@ -62,18 +64,17 @@ public:
   bool Init(base::ProcessHandle aParentProcessHandle,
             MessageLoop* aIOLoop,
             IPC::Channel* aChannel);
 
   void CleanUp();
 
 protected:
   NS_OVERRIDE virtual bool RecvSendMessage(const nsString& messageName,
-                                           const nsString& data,
-                                           PHandleChild* handle);
+                                           const nsTArray<Variant>& data);
   NS_OVERRIDE virtual bool RecvLoadImplementation(const nsCString& code);
   NS_OVERRIDE virtual bool RecvLoadUserScript(const nsCString& code);
 
   NS_OVERRIDE virtual PHandleChild* AllocPHandle();
   NS_OVERRIDE virtual bool DeallocPHandle(PHandleChild* actor);
 
 private:
   JSRuntime* mRuntime;
@@ -89,16 +90,18 @@ private:
   static JSBool SendMessage(JSContext* cx, uintN argc, jsval *vp);
   static JSBool CallMessage(JSContext* cx, uintN argc, jsval *vp);
   static JSBool RegisterReceiver(JSContext* cx, uintN argc, jsval *vp);
   static JSBool UnregisterReceiver(JSContext* cx, uintN argc, jsval *vp);
   static JSBool UnregisterReceivers(JSContext* cx, uintN argc, jsval *vp);
   static JSBool Wrap(JSContext* cx, uintN argc, jsval *vp);
   static JSBool CreateHandle(JSContext* cx, uintN argc, jsval *vp);
 
+  static const JSClass sGlobalClass;
+
   DISALLOW_EVIL_CONSTRUCTORS(JetpackChild);
 };
 
 } // namespace jetpack
 } // namespace mozilla
 
 
 #endif // mozilla_jetpack_JetpackChild_h
diff --git a/js/jetpack/JetpackParent.cpp b/js/jetpack/JetpackParent.cpp
--- a/js/jetpack/JetpackParent.cpp
+++ b/js/jetpack/JetpackParent.cpp
@@ -93,64 +93,65 @@ ReadFromURI(const nsAString& aURI,
       }
     }
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
-JetpackParent::SendMessage(const nsAString& aMessageName,
-                           const nsAString& aData,
-                           nsIVariant* aHandle,
-                           PRUint8 optArgc)
+JetpackParent::SendMessage(const nsAString& aMessageName)
 {
-  jsval hval = JSVAL_NULL;
-  if (optArgc == 2 && aHandle)
-    aHandle->GetAsJSVal(&hval);
+  nsresult rv;
+  nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
+  NS_ENSURE_SUCCESS(rv, rv);
 
-  if (!SendSendMessage(nsString(aMessageName),
-                       nsString(aData),
-                       HandleParent::FromJSVal(mContext, hval)))
+  nsAXPCNativeCallContext* ncc = NULL;
+  rv = xpc->GetCurrentNativeCallContext(&ncc);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  JSContext* cx;
+  rv = ncc->GetJSContext(&cx);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  PRUint32 argc;
+  rv = ncc->GetArgc(&argc);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  jsval* argv;
+  rv = ncc->GetArgvPtr(&argv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsTArray<Variant> data;
+
+  for (PRUint32 i = 1; i < argc; ++i)
+    if (!jsval_to_Variant(cx, argv[i], data.AppendElement()))
+      return NS_ERROR_INVALID_ARG;
+
+  if (!SendSendMessage(nsString(aMessageName), data))
     return NS_ERROR_FAILURE;
 
   return NS_OK;
 }
 
-static bool
-GetReceiver(JSContext* cx, nsIVariant* receiver, jsval* rval)
-{
-  return (NS_SUCCEEDED(receiver->GetAsJSVal(rval)) &&
-          JSVAL_IS_OBJECT(*rval) &&
-          JS_ObjectIsFunction(cx, JSVAL_TO_OBJECT(*rval)));
-}
-            
 NS_IMETHODIMP
 JetpackParent::RegisterReceiver(const nsAString& aMessageName,
-                                nsIVariant* aReceiver)
+                                jsval aReceiver)
 {
-  jsval receiver;
-  if (!GetReceiver(mContext, aReceiver, &receiver))
-    return NS_ERROR_INVALID_ARG;
-
   return JetpackActorCommon::RegisterReceiver(mContext,
                                               nsString(aMessageName),
-                                              receiver);
+                                              aReceiver);
 }
 
 NS_IMETHODIMP
 JetpackParent::UnregisterReceiver(const nsAString& aMessageName,
-                                  nsIVariant* aReceiver)
+                                  jsval aReceiver)
 {
-  jsval receiver;
-  if (!GetReceiver(mContext, aReceiver, &receiver))
-    return NS_ERROR_INVALID_ARG;
-
   JetpackActorCommon::UnregisterReceiver(nsString(aMessageName),
-                                         receiver);
+                                         aReceiver);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 JetpackParent::UnregisterReceivers(const nsAString& aMessageName)
 {
   JetpackActorCommon::UnregisterReceivers(nsString(aMessageName));
   return NS_OK;
@@ -181,33 +182,27 @@ JetpackParent::LoadUserScript(const nsAS
       !SendLoadUserScript(code))
     rv = NS_ERROR_FAILURE;
 
   return rv;
 }
 
 bool
 JetpackParent::RecvSendMessage(const nsString& messageName,
-                               const nsString& data,
-                               PHandleParent* handle)
+                               const nsTArray<Variant>& data)
 {
-  JSObject* hobj = NULL;
-  if (handle)
-    hobj = static_cast<HandleParent*>(handle)->ToJSObject(mContext);
-  return JetpackActorCommon::RecvMessage(mContext, messageName, data, hobj,
-                                         NULL);
+  return JetpackActorCommon::RecvMessage(mContext, messageName, data, NULL);
 }
 
 bool
 JetpackParent::RecvCallMessage(const nsString& messageName,
-                               const nsString& inData, // TODO
-                               nsTArray<nsString>* outData) // TODO
+                               const nsTArray<Variant>& data,
+                               nsTArray<Variant>* results)
 {
-  return JetpackActorCommon::RecvMessage(mContext, messageName, inData, NULL,
-                                         outData);
+  return JetpackActorCommon::RecvMessage(mContext, messageName, data, results);
 }
 
 NS_IMETHODIMP
 JetpackParent::CreateHandle(nsIVariant** aResult)
 {
   HandleParent* handle =
     static_cast<HandleParent*>(SendPHandleConstructor());
   NS_ENSURE_TRUE(handle, NS_ERROR_OUT_OF_MEMORY);
diff --git a/js/jetpack/JetpackParent.h b/js/jetpack/JetpackParent.h
--- a/js/jetpack/JetpackParent.h
+++ b/js/jetpack/JetpackParent.h
@@ -64,21 +64,20 @@ public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIJETPACK
 
   JetpackParent(JSContext* cx);
   ~JetpackParent();
 
 protected:
   NS_OVERRIDE virtual bool RecvSendMessage(const nsString& messageName,
-                                           const nsString& data,
-                                           PHandleParent* handle);
+                                           const nsTArray<Variant>& data);
   NS_OVERRIDE virtual bool RecvCallMessage(const nsString& messageName,
-                                           const nsString& inData, // TODO
-                                           nsTArray<nsString>* outData); // TODO
+                                           const nsTArray<Variant>& data,
+                                           nsTArray<Variant>* results);
 
   NS_OVERRIDE virtual PHandleParent* AllocPHandle();
   NS_OVERRIDE virtual bool DeallocPHandle(PHandleParent* actor);
 
 private:
   JetpackProcessParent* mSubprocess;
   JSContext* mContext;
 
diff --git a/js/jetpack/PJetpack.ipdl b/js/jetpack/PJetpack.ipdl
--- a/js/jetpack/PJetpack.ipdl
+++ b/js/jetpack/PJetpack.ipdl
@@ -32,33 +32,51 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 include protocol PHandle;
 
+using mozilla::void_t;
+using mozilla::null_t;
+
 namespace mozilla {
 namespace jetpack {
 
+struct KeyValue {
+  nsString key;
+  Variant value;
+};
+
+union Variant {
+  void_t;
+  null_t;
+  bool;
+  int;
+  double;
+  nsString;
+  PHandle;
+  KeyValue[];
+  Variant[];
+};
+
 sync protocol PJetpack
 {
   manages PHandle;
 both:
   async SendMessage(nsString messageName,
-                    nsString data,
-                    nullable PHandle handle);
+                    Variant[] data);
   async PHandle();
 
 child:
   async LoadImplementation(nsCString code);
   async LoadUserScript(nsCString code);
 
 parent:
   sync CallMessage(nsString messageName,
-                   nsString inData) // TODO
-    returns (nsString[] outData); // TODO
+                   Variant[] data)
+    returns (Variant[] results);
 
 };
 
-}
-}
+}}
diff --git a/js/jetpack/nsIJetpack.idl b/js/jetpack/nsIJetpack.idl
--- a/js/jetpack/nsIJetpack.idl
+++ b/js/jetpack/nsIJetpack.idl
@@ -37,24 +37,24 @@
 
 #include "nsISupports.idl"
 
 interface nsIVariant;
 
 [scriptable, uuid(563afdf8-5d2f-4bb2-9ac0-fb82461d2922)]
 interface nsIJetpack : nsISupports
 {
-  [optional_argc]
-  void sendMessage(in AString aMessageName,
-                   [optional] in AString aData,
-                   [optional] in nsIVariant handle); // TODO
+  void sendMessage(in AString aMessageName
+                   /* [optional] in jsval v1,
+                      [optional] in jsval v2,
+                      ... */);
 
   void registerReceiver(in AString aMessageName,
-                        in nsIVariant aReceiver);
+                        in jsval aReceiver);
   void unregisterReceiver(in AString aMessageName,
-                          in nsIVariant aReceiver);
+                          in jsval aReceiver);
   void unregisterReceivers(in AString aMessageName);
 
   void loadImplementation(in AString aURI);
   void loadUserScript(in AString aURI);
 
   nsIVariant createHandle();
 };
diff --git a/js/jetpack/tests/unit/impl.js b/js/jetpack/tests/unit/impl.js
--- a/js/jetpack/tests/unit/impl.js
+++ b/js/jetpack/tests/unit/impl.js
@@ -14,8 +14,24 @@ registerReceiver("gimmeHandle",
                  function(msgName) {
                    sendMessage("recvHandle", "ok", createHandle());
                  });
 
 registerReceiver("kthx",
                  function(msgName, data, child) {
                    sendMessage("recvHandleAgain", data + data, child.parent);
                  });
+
+registerReceiver("echo2",
+                 function(msgName, obj1, obj2) {
+                   sendMessage("echo2", obj1, obj2);
+                 });
+
+registerReceiver("multireturn begin",
+                 function() {
+                   var results = callMessage("multireturn");
+                   sendMessage.apply(null, ["multireturn check"].concat(results));
+                 });
+
+registerReceiver("testarray",
+                 function(msgName, array) {
+                   sendMessage("testarray", array.reverse());
+                 });
diff --git a/js/jetpack/tests/unit/test_jetpack.js b/js/jetpack/tests/unit/test_jetpack.js
--- a/js/jetpack/tests/unit/test_jetpack.js
+++ b/js/jetpack/tests/unit/test_jetpack.js
@@ -3,16 +3,26 @@ var jps = jps || Components.classes["@mo
 
 function run_test() {
   var jetpack = jps.createJetpack();
   jetpack.loadImplementation(
     "chrome://global/content/jetpack/test-impl.js");
   jetpack.loadUserScript(
     "chrome://global/content/jetpack/test-user.js");
 
+  var circ1 = {},
+      circ2 = {},
+      circ3 = {},
+      str = "circular references forbidden",
+      threw;
+  ((circ1.obj = circ2).obj = circ3).obj = circ1;
+  try { jetpack.sendMessage(str, circ3, circ1) }
+  catch (x) { threw = str }
+  do_check_eq(threw, str);
+
   var echoHandle = jetpack.createHandle();
   echoHandle.payload = { weight: 10 };
   jetpack.registerReceiver("echo",
                            function(msgName, data, handle) {
                              do_check_eq(arguments.length, 3);
                              do_check_eq(msgName, "echo");
                              do_check_eq(data, "echo this");
                              do_check_true(handle.isValid);
@@ -43,17 +53,60 @@ function run_test() {
                              jetpack.sendMessage("kthx", data + data, handle.createHandle());
                            });
   jetpack.registerReceiver("recvHandleAgain",
                            function(msgName, data, handle) {
                              do_check_eq(data, "okokokok");
                              do_check_eq(handle.mark, obj);
                              do_test_finished();
                            });
+  var obj1 = {
+    id: Math.random() + ""
+  }, obj2 = {
+    id: Math.random() + "",
+    obj: obj1
+  };
+  jetpack.registerReceiver("echo2",
+                           function(msgName, a, b) {
+                             do_check_neq(obj1, a);
+                             do_check_neq(obj2, b);
+                             do_check_eq(obj1.id, a.id);
+                             do_check_eq(obj2.id, b.id);
+                             do_check_eq(obj1.id, obj2.obj.id);
+                             do_test_finished();
+                           });
 
+  var undefined;
+  jetpack.registerReceiver("multireturn", function() { return obj1 });
+  jetpack.registerReceiver("multireturn", function() { return circ1 });
+  jetpack.registerReceiver("multireturn", function() { return obj2 });
+  jetpack.registerReceiver("multireturn check",
+                           function(msgName, rval1, rval2, rval3) {
+                             do_check_eq(rval1.id, obj1.id);
+                             do_check_eq(rval2, undefined);
+                             do_check_eq(rval3.id, obj2.id);
+                             do_check_eq(rval3.obj.id, obj1.id);
+                             do_test_finished();
+                           });
+
+  var testarray = [1, 1, 2, 3, 5, 8, 13];
+  jetpack.registerReceiver("testarray",
+                           function(msgName, reversed) {
+                             for (var i = 0; i < testarray.length; ++i)
+                               do_check_eq(testarray[i],
+                                           reversed[reversed.length - i - 1]);
+                             do_test_finished();
+                           });
+
+  do_test_pending();
+  do_test_pending();
+  do_test_pending();
   do_test_pending();
   do_test_pending();
   do_test_pending();
 
   jetpack.sendMessage("echo", "echo this", echoHandle);
   jetpack.sendMessage("callback", "call me back", callbackHandle);
   jetpack.sendMessage("gimmeHandle");
+  jetpack.sendMessage("echo2", obj1, obj2);
+  jetpack.sendMessage("multireturn begin");
+  jetpack.sendMessage("testarray", testarray);
 }
