Runnable interface for Functors (bug 486440).

diff --git a/xpcom/glue/Functor.h b/xpcom/glue/Functor.h
--- a/xpcom/glue/Functor.h
+++ b/xpcom/glue/Functor.h
@@ -39,16 +39,17 @@
 #ifndef Functor_h__
 #define Functor_h__
 
 #include "nsISupports.h"
 #include "nsIRunnable.h"
 #include "nsAutoPtr.h"
 #include "TList.h"
 #include "Location.h"
+#include "RunnableFunctor.h"
 
 /**
  * For an overview of Functor usage, see bug 486440.
  *
  * This implementation was inspired by Andrei Alexandrescu's book
  *
  *   Modern C++ Design: Generic Programming and Design Patterns Applied,
  *
@@ -218,16 +219,20 @@ public:
   typedef FunctorImpl<Result, Params> ImplType;
   typedef Result ResultType;
   typedef Params ParamList;
 
   Functor(const Functor& f) : mImpl(f.mImpl) {}
   Functor(ImplType* impl)   : mImpl(impl) {}
  ~Functor() {} // deliberately non-virtual
 
+  nsRefPtr<RunnableFunctor<Result> >
+  proxy(nsIThread* target,
+        PRUint32 flags = NS_DISPATCH_NORMAL);
+
   template <typename Callable>
   static Functor callable(Callable c) {
     return Functor(new CallableHandler<Functor, Callable>(c));
   }
 
   template <typename Method>
   static Functor method(Method m) {
     return Functor(new MethodHandler<Functor, Method>(m));
@@ -850,9 +855,27 @@ template <typename R, typename P0, typen
 Functor<R, TLIST10(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9)>
 functor(R (*f)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9)) {
   return Functor<R, TLIST10(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9)>::callable(f);
 }
 
 // [[[end]]]
 
 
+template <typename Result, class Params>
+nsRefPtr<RunnableFunctor<Result> >
+Functor<Result, Params>::proxy(nsIThread* target, PRUint32 flags)
+{
+  static nsIThread* mainThread = nsnull;
+  if (!target && (mainThread || NS_SUCCEEDED(NS_GetMainThread(&mainThread))))
+      target = mainThread;
+
+  nsRefPtr<RunnableFunctor<Result> > event =
+    new RunnableFunctorImpl<Result, Functor>(*this);
+
+  PRBool dispatched = target && NS_SUCCEEDED(target->Dispatch(event, flags));
+  NS_ASSERTION(dispatched, "Failed to dispatch event to thread.");
+
+  return event; // event->Wait() will block forever if Dispatch failed
+}
+
+
 #endif
diff --git a/xpcom/glue/Makefile.in b/xpcom/glue/Makefile.in
--- a/xpcom/glue/Makefile.in
+++ b/xpcom/glue/Makefile.in
@@ -124,16 +124,17 @@ SDK_HEADERS = \
 EXPORTS_NAMESPACES = mozilla
 
 EXPORTS = \
 		nsThreadUtils.h \
 		nsProxyRelease.h \
 		nsXPTCUtils.h \
 		Location.h \
 		TList.h \
+		RunnableFunctor.h \
 		Functor.h \
 		Bind.h \
 		$(NULL)
 
 EXPORTS_mozilla = \
   BlockingResourceBase.h \
   CondVar.h \
   DeadlockDetector.h \
diff --git a/xpcom/glue/RunnableFunctor.h b/xpcom/glue/RunnableFunctor.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/RunnableFunctor.h
@@ -0,0 +1,142 @@
+#ifndef RunnableFunctor_h__
+#define RunnableFunctor_h__
+
+#include "nsISupports.h"
+#include "nsAutoPtr.h"
+#include "nsAutoLock.h"
+#include "nsIEventTarget.h"
+#include "nsThreadUtils.h"
+#include "nsProxyRelease.h"
+#include "nsIRunnable.h"
+
+class RunnableSupports : public nsIRunnable {
+  NS_DECL_ISUPPORTS
+protected:
+  virtual ~RunnableSupports() {}
+};
+inline NS_IMPL_THREADSAFE_ADDREF(RunnableSupports)
+inline NS_IMPL_THREADSAFE_RELEASE(RunnableSupports)
+inline NS_IMPL_THREADSAFE_QUERY_INTERFACE1(RunnableSupports, nsIRunnable)
+
+/**
+ * AbstractRunnableFunctor is so named because it inherits from
+ * RunnableSupports but does not implement the required Run method.
+ */
+template <typename Result>
+class RunnableFunctor
+  : public RunnableSupports
+{
+  PRMonitor* const mMon;
+  PRBool mRun;
+
+public:
+
+  RunnableFunctor()
+    : mMon(nsAutoMonitor::NewMonitor("RunnableFunctor"))
+    , mRun(PR_FALSE)
+  {}
+
+  /**
+   * If Wait is called before AfterRun, the Wait call will block until the
+   * monitor is notified.  If Wait is called after AfterRun, it will return
+   * immediately.
+   */
+  virtual Result Wait() = 0;
+
+protected:
+
+  ~RunnableFunctor()
+  {
+    nsAutoMonitor::DestroyMonitor(mMon);
+  }
+
+  void VoidWait() {
+    nsAutoMonitor mon(mMon);
+    if (!mRun)
+      mon.Wait();
+  }
+
+  /**
+   * Subclasses call this method just before their Run methods return.
+   */
+  nsresult AfterRun()
+  {
+    nsAutoMonitor mon(mMon);
+    mRun = PR_TRUE;
+    mon.NotifyAll();
+    return NS_OK;
+  }
+};
+
+/**
+ * This specialization of the RunnableFunctorImpl class provides space for the
+ * non-void value returned by the underlying Functor.  Its Wait method returns
+ * this stored value.
+ *
+ * TODO Return a reference to the stored value when possible; i.e., when the
+ * Result type is not already a reference.
+ */
+template <typename Result, typename Thunk>
+class RunnableFunctorImpl
+  : public RunnableFunctor<Result>
+{
+  Result mResult;
+  Thunk mThunk;
+
+  typedef RunnableFunctor<Result> BaseType;
+
+public:
+
+  // Using the term "thunk" to emphasize that the callable entity passed into
+  // the constructor must accept zero arguments, and also to avoid confusion
+  // with the Functor template class defined in Functor.h.
+  RunnableFunctorImpl(Thunk thunk)
+    : mThunk(thunk)
+  {}
+
+  Result Wait()
+  {
+    BaseType::VoidWait();
+    return mResult;
+  }
+
+  NS_IMETHOD Run()
+  {
+    mResult = mThunk();
+    return BaseType::AfterRun();
+  }
+
+};
+
+/**
+ * This specialization of the RunnableFunctorImpl class allocates no space for
+ * the return value of the underlying Functor, since the Functor is void.  In
+ * this case, it suffices to inherit the Wait method of RunnableFunctor.
+ */
+template <typename Thunk>
+class RunnableFunctorImpl<void, Thunk>
+  : public RunnableFunctor<void>
+{
+  Thunk mThunk;
+
+  typedef RunnableFunctor<void> BaseType;
+
+public:
+
+  RunnableFunctorImpl(Thunk thunk)
+    : mThunk(thunk)
+  {}
+
+  void Wait() {
+    BaseType::VoidWait();
+  }
+
+  NS_IMETHOD Run()
+  {
+    mThunk();
+    return BaseType::AfterRun();
+  }
+
+};
+
+#endif
diff --git a/xpcom/tests/functors/Makefile.in b/xpcom/tests/functors/Makefile.in
--- a/xpcom/tests/functors/Makefile.in
+++ b/xpcom/tests/functors/Makefile.in
@@ -45,16 +45,17 @@ VPATH = @srcdir@
 # We will do compilations that create dependency files.
 NEED_MDDEPDIR = 1
 
 include $(DEPTH)/config/autoconf.mk
 
 CPP_UNIT_TESTS = \
 	TestFunctor.cpp \
 	TestLocation.cpp \
+	TestRunnableFunctor.cpp \
 	$(NULL)
 
 # Testcases that SHOULD fail to compile.
 STATIC_FAILURE_TESTCASES = \
   CrefAssignmentError.cpp \
   ArgConversionError.cpp \
   TooManyParamsError.cpp \
   BindResultReferenceError.cpp \
diff --git a/xpcom/tests/functors/TestLocation.cpp b/xpcom/tests/functors/TestLocation.cpp
--- a/xpcom/tests/functors/TestLocation.cpp
+++ b/xpcom/tests/functors/TestLocation.cpp
@@ -73,17 +73,17 @@ nsresult test_ref_counting_storage_polic
 
   rv |= test_Location_conversion(IntLocation());
 
   return rv;
 }
 
 int main()
 {
-  ScopedXPCOM xpcom("FunctorTests");
+  ScopedXPCOM xpcom("LocationTests");
   if (xpcom.failed())
     return NS_ERROR_FAILURE;
 
   RUN_TEST(test_client_managed_storage_policy());
   RUN_TEST(test_ref_counting_storage_policy());
 
   return NS_OK;
 }
diff --git a/xpcom/tests/functors/TestRunnableFunctor.cpp b/xpcom/tests/functors/TestRunnableFunctor.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/TestRunnableFunctor.cpp
@@ -0,0 +1,96 @@
+#include "TestUtils.h"
+#include "Functor.h"
+#include "nsAutoPtr.h"
+#include "nsThreadUtils.h"
+
+int one() { return 1; }
+int plus_two(int x) { return x + 2; }
+
+class Blocker : public nsRunnable
+{
+  const double mSecs;
+public:
+  Blocker(double secs) : mSecs(secs) {}
+  NS_IMETHOD Run()
+  {
+    PR_Sleep(PR_MillisecondsToInterval(mSecs));
+    return NS_ERROR_UNEXPECTED; // ignored by Dispatch
+  }
+};
+
+nsresult test_proxy_Wait(nsIThread* const target)
+{
+  nsresult rv = NS_OK;
+  if (target) {
+    nsRefPtr<Blocker> blocker = new Blocker(200);
+    target->Dispatch(blocker, NS_DISPATCH_NORMAL);
+
+    nsRefPtr<RunnableFunctor<int> >
+      rf1 = functor(&one).proxy(target),
+      rf2 = functor(&plus_two).bind(rf1->Wait()).proxy(target);
+
+    rv |= is(rf2->Wait(), 3);
+    rv |= is(rf1->Wait(), 1);
+  }
+  return rv;
+}
+
+nsresult test_proxy_with_bind_result(nsIThread* const target,
+                                     Location<int> loc)
+{
+  nsresult rv = NS_OK;
+  loc = 0;
+  nsRefPtr<Blocker> blocker = new Blocker(200);
+  rv |= target->Dispatch(blocker, NS_DISPATCH_NORMAL);
+  nsRefPtr<RunnableFunctor<void> > rf =
+    functor(&one).bind_result(loc).proxy(target);
+  rv |= is(int(loc), 0);
+  rf->Wait();
+  rv |= is(int(loc), 1);
+  return rv;
+}
+
+nsresult test_proxy_Run_method(nsIThread* const target)
+{
+  nsRefPtr<RunnableFunctor<void*> > rf = // Just because I can:
+    functor(&operator new).bind(sizeof(Blocker)).proxy(target);
+  nsRefPtr<Blocker> blocker = new(rf->Wait()) Blocker(200); // placement new
+  return is(functor(&Blocker::Run).bind(blocker).proxy(target)->Wait(),
+            (nsresult)NS_ERROR_UNEXPECTED);
+}
+
+nsresult test()
+{
+  nsresult rv = NS_OK;
+  nsIThread* thread1 = 0,
+           * thread2 = 0;
+  if (NS_SUCCEEDED(rv = NS_NewThread(&thread1)) &&
+      NS_SUCCEEDED(rv = NS_NewThread(&thread2)))
+  {
+    rv |= ok(thread1 && thread2);
+    rv |= test_proxy_Wait(thread1);
+    rv |= functor(&test_proxy_Wait).bind(thread2).proxy(thread1)->Wait();
+    rv |= functor(&test_proxy_Wait).bind(thread1).proxy(thread2)->Wait();
+
+    Location<int> loc;
+    rv |= functor(&test_proxy_with_bind_result)
+            .bind(thread2)
+            .bind(loc)
+            .proxy(thread1)->Wait();
+    rv |= is(int(loc), 1);
+
+    rv |= test_proxy_Run_method(thread2);
+  }
+
+  return rv;
+}
+
+int main() {
+  ScopedXPCOM xpcom("RunnableFunctorTests");
+  if (xpcom.failed())
+    return NS_ERROR_FAILURE;
+
+  nsresult rv = NS_OK;
+  RUN_TEST(test());
+  return rv;
+}
