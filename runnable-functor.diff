diff --git a/xpcom/glue/Functor.h b/xpcom/glue/Functor.h
--- a/xpcom/glue/Functor.h
+++ b/xpcom/glue/Functor.h
@@ -38,16 +38,17 @@
 
 #ifndef Functor_h__
 #define Functor_h__
 
 #include "nsISupports.h"
 #include "nsIRunnable.h"
 #include "nsAutoPtr.h"
 #include "TList.h"
+#include "RunnableFunctor.h"
 
 /**
  * For an overview of Functor usage, see bug 486440.
  *
  * This implementation was inspired by Andrei Alexandrescu's book
  *
  *   Modern C++ Design: Generic Programming and Design Patterns Applied,
  *
@@ -204,16 +205,20 @@ public:
 
   EXTRACT_TYPEDEFS(Params)
 
 public:
   Functor(const Functor& f) : mImpl(f.mImpl) {}
   Functor(ImplType* impl)   : mImpl(impl) {}
  ~Functor() {}
 
+  nsRefPtr<RunnableFunctor<Result, Functor> >
+  proxy(nsIThread* target,
+        PRUint32 flags = NS_DISPATCH_SYNC);
+
   template <typename Callable>
   static Functor callable(Callable c) {
     return Functor(new CallableHandler<Functor, Callable>(c));
   }
 
   template <typename Method>
   static Functor method(Method m) {
     return Functor(new MethodHandler<Functor, Method>(m));
@@ -639,9 +644,27 @@ template <typename R, typename P0, typen
 Functor<R, TLIST9(P0, P1, P2, P3, P4, P5, P6, P7, P8)>
 functor(R (*f)(P0, P1, P2, P3, P4, P5, P6, P7, P8)) {
   return Functor<R, TLIST9(P0, P1, P2, P3, P4, P5, P6, P7, P8)>::callable(f);
 }
 
 // [[[end]]]
 
 
+template <typename Result, class Params>
+nsRefPtr<RunnableFunctor<Result, Functor<Result, Params> > >
+Functor<Result, Params>::proxy(nsIThread* target, PRUint32 flags)
+{
+  static nsIThread* mainThread = nsnull;
+  if (!target && (mainThread || NS_SUCCEEDED(NS_GetMainThread(&mainThread))))
+      target = mainThread;
+
+  typedef RunnableFunctor<Result, Functor> Event;
+  nsRefPtr<Event> event(new Event(*this));
+
+  PRBool dispatched = target && NS_SUCCEEDED(target->Dispatch(event, flags));
+  NS_ASSERTION(dispatched, "Failed to dispatch event to thread.");
+
+  return event; // event->Wait() will block forever if Dispatch failed
+}
+
+
 #endif
diff --git a/xpcom/glue/Makefile.in b/xpcom/glue/Makefile.in
--- a/xpcom/glue/Makefile.in
+++ b/xpcom/glue/Makefile.in
@@ -120,16 +120,17 @@ SDK_HEADERS = \
 		nsDeque.h \
 		$(NULL)
 
 EXPORTS = \
 		nsThreadUtils.h \
 		nsProxyRelease.h \
 		nsXPTCUtils.h \
 		TList.h \
+		RunnableFunctor.h \
 		Functor.h \
 		Bind.h \
 		$(NULL)
 
 SDK_LIBRARY     =                        \
 		$(LIB_PREFIX)xpcomglue_s.$(LIB_SUFFIX) \
 		$(NULL)
 
diff --git a/xpcom/glue/RunnableFunctor.h b/xpcom/glue/RunnableFunctor.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/RunnableFunctor.h
@@ -0,0 +1,88 @@
+#ifndef RunnableFunctor_h__
+#define RunnableFunctor_h__
+
+#include "nsISupports.h"
+#include "nsAutoPtr.h"
+#include "nsAutoLock.h"
+#include "nsIEventTarget.h"
+#include "nsThreadUtils.h"
+#include "nsProxyRelease.h"
+
+class RunnableSupports : public nsIRunnable {
+  NS_DECL_ISUPPORTS
+protected:
+  virtual ~RunnableSupports() {}
+};
+inline NS_IMPL_THREADSAFE_ADDREF(RunnableSupports)
+inline NS_IMPL_THREADSAFE_RELEASE(RunnableSupports)
+inline NS_IMPL_THREADSAFE_QUERY_INTERFACE1(RunnableSupports, nsIRunnable)
+
+class AbstractRunnableFunctor
+  : public RunnableSupports
+{
+  PRMonitor* const mMon;
+  PRBool mRun;
+public:
+  AbstractRunnableFunctor()
+    : mMon(nsAutoMonitor::NewMonitor("AbstractRunnableFunctor"))
+    , mRun(PR_FALSE)
+  {}
+  void Wait()
+  {
+    nsAutoMonitor mon(mMon);
+    if (!mRun)
+      mon.Wait();
+  }
+protected:
+  ~AbstractRunnableFunctor()
+  {
+    nsAutoMonitor::DestroyMonitor(mMon);
+  }
+  nsresult AfterRun()
+  {
+    nsAutoMonitor mon(mMon);
+    mRun = PR_TRUE;
+    mon.NotifyAll();
+    return NS_OK;
+  }
+};
+
+template <typename Result, typename Functor>
+class RunnableFunctor
+  : public AbstractRunnableFunctor
+{
+  Result mResult;
+  Functor mFunctor;
+public:
+  RunnableFunctor(Functor functor)
+    : mFunctor(functor)
+  {}
+  Result& Wait()
+  {
+    AbstractRunnableFunctor::Wait();
+    return mResult;
+  }
+  NS_IMETHOD Run()
+  {
+    mResult = mFunctor();
+    return AfterRun();
+  }
+};
+
+template <typename Functor>
+class RunnableFunctor<void, Functor>
+  : public AbstractRunnableFunctor
+{
+  Functor mFunctor;
+public:
+  RunnableFunctor(Functor functor)
+    : mFunctor(functor)
+  {}
+  NS_IMETHOD Run()
+  {
+    mFunctor();
+    return AfterRun();
+  }
+};
+
+#endif
diff --git a/xpcom/tests/Makefile.in b/xpcom/tests/Makefile.in
--- a/xpcom/tests/Makefile.in
+++ b/xpcom/tests/Makefile.in
@@ -69,16 +69,17 @@ CPPSRCS		= \
 		TestRegistrationOrder.cpp \
 		TestThreadPoolListener.cpp \
 		TestTimers.cpp \
 		TestOOM.cpp \
 		TestBlockingProcess.cpp \
 		TestQuickReturn.cpp \
 		TestArguments.cpp \
 		TestFunctor.cpp \
+		TestRunnableFunctor.cpp \
 		$(NULL)
 
 ifndef MOZ_ENABLE_LIBXUL
 CPPSRCS += \
 		TestAtoms.cpp \
 		TestPermanentAtoms.cpp \
 		$(NULL)
 endif
diff --git a/xpcom/tests/TestRunnableFunctor.cpp b/xpcom/tests/TestRunnableFunctor.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/TestRunnableFunctor.cpp
@@ -0,0 +1,37 @@
+#include <iostream>
+#include "nsAutoPtr.h"
+#include "Bind.h"
+#include "RunnableFunctor.h"
+
+int one() { return 1; }
+int plus_two(int x) { return x + 2; }
+
+void is(int x, int y) {
+  std::cout << (x == y ? "OK: " : "FAIL: ")
+            << x << " = " << y << std::endl;
+}
+
+void test() {
+  typedef Functor<int, TLIST0()> ftype;
+  typedef RunnableFunctor<int, ftype> rftype;
+
+  ftype f1 = functor(&one);
+  ftype f5 = BIND1(&plus_two, 3);
+
+  is((f5.proxy(nsnull)->Wait() -
+      f1.proxy(nsnull)->Wait()),
+     4);
+
+  nsRefPtr<rftype> rf1(new rftype(f1));
+  nsRefPtr<rftype> rf5(new rftype(f5));
+
+  rf1->Run();
+  rf5->Run();
+
+  is(rf1->Wait() + rf5->Wait(), 6);
+}
+
+int main() {
+  test();
+  return 0;
+}
