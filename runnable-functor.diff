diff --git a/xpcom/glue/Functor.h b/xpcom/glue/Functor.h
--- a/xpcom/glue/Functor.h
+++ b/xpcom/glue/Functor.h
@@ -1,16 +1,17 @@
 #ifndef Functor_h__
 #define Functor_h__
 
 #include "nsISupports.h"
 #include "nsIRunnable.h"
 #include "nsAutoPtr.h"
 #include "TList.h"
 #include "Join.h"
+#include "nsRunnableFunctor.h"
 
 class FunctorSupports : public nsISupports {
 public:
   // nsISupports implementation must be inlined so that this file can be
   // included across modules.  Because NS_IMPL_ISUPPORTS0 appears inline,
   // the method prototypes for AddRef, Release, and QueryInterface provided by
   // NS_DECL_ISUPPORTS are not needed, but the nsAutoRefCnt and
   // NS_DECL_OWNINGTHREAD members (also provided by NS_DECL_ISUPPORTS)
@@ -74,16 +75,20 @@ public:
   typedef P1  first_argument_type;
   typedef P2 second_argument_type;
   typedef Result      result_type;
 
 public:
   Functor(const Functor& f) : mImpl(f.mImpl) {}
   Functor(ImplType* impl)   : mImpl(impl) {}
  ~Functor() {}
+
+  nsRefPtr<nsRunnableFunctor<Result, Functor> >
+  proxy(nsIThread* target,
+        PRUint32 flags = NS_DISPATCH_SYNC);
 
   template <typename Callable>
   static Functor callable(Callable c) {
     return Functor(new CallableHandler<Functor, Callable>(c));
   }
 
   template <typename Method>
   static Functor method(Method m) {
@@ -283,9 +288,35 @@ JOIN16(DGFA,EMPTY)
 #undef DECL_GLOBAL_FUNCTION_ADAPTERS
 #undef DECL_GLOBAL_METHOD_ADAPTER
 #undef DGMA
 #undef DGFA
 #undef ctnP
 #undef P
 #undef cP
 
+template <typename Result, class Params>
+nsRefPtr<nsRunnableFunctor<Result, Functor<Result, Params> > >
+Functor<Result, Params>::proxy(nsIThread* target, PRUint32 flags)
+{
+  static nsIThread* mainThread = nsnull;
+  if (!target && (mainThread || NS_SUCCEEDED(NS_GetMainThread(&mainThread))))
+      target = mainThread;
+
+  typedef nsRunnableFunctor<Result, Functor> Event;
+  nsRefPtr<Event> event(new Event(*this));
+
+#if DEBUG
+  nsIThread* currentThread = nsnull;
+  NS_GetCurrentThread(&currentThread);
+  if (currentThread == target) {
+    NS_ERROR("OYEZ Proxying to same thread!!");
+    NS_ABORT();
+  }
 #endif
+
+  PRBool dispatched = target && NS_SUCCEEDED(target->Dispatch(event, flags));
+  NS_ASSERTION(dispatched, "Failed to dispatch event to thread.");
+
+  return event; // event->Wait() will block forever if Dispatch failed
+}
+
+#endif
diff --git a/xpcom/glue/Makefile.in b/xpcom/glue/Makefile.in
--- a/xpcom/glue/Makefile.in
+++ b/xpcom/glue/Makefile.in
@@ -124,16 +124,17 @@ EXPORTS = \
 EXPORTS = \
 		nsThreadUtils.h \
 		nsProxyRelease.h \
 		nsXPTCUtils.h \
 		Join.h \
 		TList.h \
 		Functor.h \
 		Bind.h \
+		nsRunnableFunctor.h \
 		$(NULL)
 
 SDK_LIBRARY     =                        \
 		$(LIB_PREFIX)xpcomglue_s.$(LIB_SUFFIX) \
 		$(NULL)
 
 # we don't want the shared lib, but we want to force the creation of a static lib.
 FORCE_STATIC_LIB = 1
diff --git a/xpcom/glue/nsRunnableFunctor.h b/xpcom/glue/nsRunnableFunctor.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/nsRunnableFunctor.h
@@ -0,0 +1,99 @@
+#ifndef nsRunnableFunctor_h__
+#define nsRunnableFunctor_h__
+
+#include "nsISupports.h"
+#include "nsAutoPtr.h"
+#include "nsAutoLock.h"
+#include "nsIEventTarget.h"
+#include "nsThreadUtils.h"
+#include "nsProxyRelease.h"
+
+class ThreadSafeRunnable
+  : public nsIRunnable
+{
+  nsAutoRefCnt mRefCnt;
+public:
+  NS_IMPL_THREADSAFE_ISUPPORTS1(ThreadSafeRunnable, nsIRunnable)
+protected:
+  virtual ~ThreadSafeRunnable() {}
+};
+
+class nsARunnableFunctor
+  : public ThreadSafeRunnable
+{
+  PRMonitor* const mMon;
+  PRBool mRun;
+public:
+  nsARunnableFunctor()
+    : mMon(nsAutoMonitor::NewMonitor("nsARunnableFunctor"))
+    , mRun(PR_FALSE)
+  {}
+  void Wait()
+  {
+    nsAutoMonitor mon(mMon);
+    if (!mRun)
+      mon.Wait();
+  }
+  nsrefcnt Release()
+  {
+    if (NS_IsMainThread())
+      return ThreadSafeRunnable::Release();
+    nsIThread* mainThread = nsnull;
+    NS_GetMainThread(&mainThread);
+    if (mainThread)
+      NS_ProxyRelease(mainThread, this);
+    return 1;
+  }
+protected:
+  ~nsARunnableFunctor()
+  {
+    nsAutoMonitor::DestroyMonitor(mMon);
+  }
+  nsresult AfterRun()
+  {
+    nsAutoMonitor mon(mMon);
+    mRun = PR_TRUE;
+    mon.NotifyAll();
+    return NS_OK;
+  }
+};
+
+template <typename Result, typename Functor>
+class nsRunnableFunctor
+  : public nsARunnableFunctor
+{
+  Result mResult;
+  Functor mFunctor;
+public:
+  nsRunnableFunctor(Functor functor)
+    : mFunctor(functor)
+  {}
+  Result& Wait()
+  {
+    nsARunnableFunctor::Wait();
+    return mResult;
+  }
+  nsresult Run()
+  {
+    mResult = mFunctor();
+    return AfterRun();
+  }
+};
+
+template <typename Functor>
+class nsRunnableFunctor<void, Functor>
+  : public nsARunnableFunctor
+{
+  Functor mFunctor;
+public:
+  nsRunnableFunctor(Functor functor)
+    : mFunctor(functor)
+  {}
+  nsresult Run()
+  {
+    mFunctor();
+    return AfterRun();
+  }
+};
+
+#endif
