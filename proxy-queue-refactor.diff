diff --git a/parser/htmlparser/src/nsParser.cpp b/parser/htmlparser/src/nsParser.cpp
--- a/parser/htmlparser/src/nsParser.cpp
+++ b/parser/htmlparser/src/nsParser.cpp
@@ -1469,17 +1469,17 @@ FindSuitableDTD(CParserContext& aParserC
   NS_ASSERTION(aParserContext.mDocType == eXML, "What are you trying to send me, here?");
   aParserContext.mDTD = new nsExpatDriver();
   return aParserContext.mDTD ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 }
 
 NS_IMETHODIMP
 nsParser::CancelParsingEvents()
 {
-  ENQUEUE_PARSER_MSG(*mQueue, CancelParsingEvents, ());
+  ENQUEUE_PARSER_MSG(CancelParsingEvents, ());
 }
 
 nsresult
 nsParser::HandleCancelParsingEvents()
 {
   if (mFlags & NS_PARSER_FLAG_PENDING_CONTINUE_EVENT) {
     NS_ASSERTION(mContinueEvent, "mContinueEvent is null");
     // Revoke the pending continue parsing event
@@ -1652,17 +1652,17 @@ nsParser::GetRootContextKey()
  *  Call this when you want to *force* the parser to terminate the
  *  parsing process altogether. This is binary -- so once you terminate
  *  you can't resume without restarting altogether.
  */
 NS_IMETHODIMP
 nsParser::Terminate()
 {
   // TODO somehow force the parser thread to activate?
-  ENQUEUE_PARSER_MSG(*mQueue, Terminate, ());
+  ENQUEUE_PARSER_MSG(Terminate, ());
 }
 
 nsresult
 nsParser::HandleTerminate()
 {
   // We should only call DidBuildModel once, so don't do anything if this is
   // the second time that Terminate has been called.
   if (mInternalState == NS_ERROR_HTMLPARSER_STOPPARSING) {
@@ -1710,17 +1710,17 @@ nsParser::HandleTerminate()
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsParser::ContinueParsing()
 {
-  ENQUEUE_PARSER_MSG(*mQueue, ContinueParsing, ());
+  ENQUEUE_PARSER_MSG(ContinueParsing, ());
 }
 
 nsresult
 nsParser::HandleContinueParsing()
 {
   if (mFlags & NS_PARSER_FLAG_PARSER_ENABLED) {
     NS_WARNING("Trying to continue parsing on a unblocked parser.");
     return NS_OK;
@@ -1729,17 +1729,17 @@ nsParser::HandleContinueParsing()
   mFlags |= NS_PARSER_FLAG_PARSER_ENABLED;
 
   return HandleContinueInterruptedParsing();
 }
 
 NS_IMETHODIMP
 nsParser::ContinueInterruptedParsing()
 {
-  ENQUEUE_PARSER_MSG(*mQueue, ContinueInterruptedParsing, ());
+  ENQUEUE_PARSER_MSG(ContinueInterruptedParsing, ());
 }
 
 nsresult
 nsParser::HandleContinueInterruptedParsing()
 {
   // If there are scripts executing, then the content sink is jumping the gun
   // (probably due to a synchronous XMLHttpRequest) and will re-enable us
   // later, see bug 460706.
@@ -1781,17 +1781,17 @@ nsParser::HandleContinueInterruptedParsi
 
 /**
  *  Stops parsing temporarily. That's it will prevent the
  *  parser from building up content model.
  */
 NS_IMETHODIMP_(void)
 nsParser::BlockParser()
 {
-  VOID_ENQUEUE_PARSER_MSG(*mQueue, BlockParser, ());
+  VOID_ENQUEUE_PARSER_MSG(BlockParser, ());
 }
 
 nsresult
 nsParser::HandleBlockParser()
 {
   mFlags &= ~NS_PARSER_FLAG_PARSER_ENABLED;
   MOZ_TIMER_DEBUGLOG(("Stop: Parse Time: nsParser::BlockParser(), this=%p\n", this));
   MOZ_TIMER_STOP(mParseTime);
@@ -1802,17 +1802,17 @@ nsParser::HandleBlockParser()
  *  Open up the parser for tokenization, building up content
  *  model..etc. However, this method does not resume parsing
  *  automatically. It's the callers' responsibility to restart
  *  the parsing engine.
  */
 NS_IMETHODIMP_(void)
 nsParser::UnblockParser()
 {
-  VOID_ENQUEUE_PARSER_MSG(*mQueue, UnblockParser, ());
+  VOID_ENQUEUE_PARSER_MSG(UnblockParser, ());
   PostContinueEvent();
 }
 
 nsresult
 nsParser::HandleUnblockParser()
 {
   if (!(mFlags & NS_PARSER_FLAG_PARSER_ENABLED)) {
     mFlags |= NS_PARSER_FLAG_PARSER_ENABLED;
@@ -1853,17 +1853,17 @@ void nsParser::HandleParserContinueEvent
 
   NS_ASSERTION(mScriptsExecuting == 0, "Interrupted in the middle of a script?");
 
   mQueue->Flush();
 
   HandleContinueInterruptedParsing();
 }
 
-void nsParser::FlushQueue(const nsRunnable*)
+void nsParser::FlushQueue()
 {
   if (mQueue)
     mQueue->Flush();
 }
 
 void
 nsParser::ScriptExecuting()
 {
@@ -1931,17 +1931,17 @@ nsParser::SetCanInterrupt(PRBool aCanInt
  */
 NS_IMETHODIMP // result never checked as far as I can tell
 nsParser::Parse(nsIURI* aURL,
                 nsIRequestObserver* aListener,
                 void* aKey,
                 nsDTDMode aMode)
 {
   NS_PRECONDITION(aURL, "Error: Null URL given");
-  ENQUEUE_PARSER_MSG(*mQueue, ParseUrl,
+  ENQUEUE_PARSER_MSG(ParseUrl,
     (aURL, aListener, aKey, aMode));
 }
 
 // TODO audit all the handlers!!
 // TODO move as much fallible code as possible into the ::Init methods!?
 // XXXX handlers must be atomic from the first actual parser operation (read, write) to the last
 // XXXX but it may be possible to reorder things...
 // TODO nsURI not threadsafe?
@@ -1992,17 +1992,17 @@ nsParser::HandleParseUrl(const nsACStrin
  */
 NS_IMETHODIMP
 nsParser::Parse(const nsAString& aSourceBuffer,
                 void* aKey,
                 const nsACString& aMimeType,
                 PRBool aLastCall,
                 nsDTDMode aMode)
 {
-  ENQUEUE_PARSER_MSG_AND_WAIT(*mQueue, ParseBuffer,
+  ENQUEUE_PARSER_MSG_AND_WAIT(ParseBuffer,
     (aSourceBuffer, aKey, aMimeType, aLastCall, aMode));
 }
 
 nsresult
 nsParser::HandleParseBuffer(const nsAString& aSourceBuffer,
                             void* aKey,
                             const nsACString& aMimeType,
                             PRBool aLastCall,
@@ -2135,17 +2135,17 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsParser::ParseFragment(const nsAString& aSourceBuffer,
                         void* aKey,
                         nsTArray<nsString>& aTagStack,
                         PRBool aXMLMode,
                         const nsACString& aMimeType,
                         nsDTDMode aMode)
 {
-  ENQUEUE_PARSER_MSG(*mQueue, ParseFragment,
+  ENQUEUE_PARSER_MSG_AND_WAIT(ParseFragment,
     (aSourceBuffer, aKey, aTagStack, aXMLMode, aMimeType, aMode));
 }
 
 NS_IMETHODIMP
 nsParser::HandleParseFragment(const nsAString& aSourceBuffer,
                               void* aKey,
                               const nsTArray<nsString>& aTagStack,
                               PRBool aXMLMode,
@@ -2172,17 +2172,17 @@ nsParser::HandleParseFragment(const nsAS
     // Ensure that the buffer is not empty. Because none of the DTDs care
     // about leading whitespace, this doesn't change the result.
     theContext.AssignLiteral(" ");
   }
 
   // First, parse the context to build up the DTD's tag stack. Note that we
   // pass PR_FALSE for the aLastCall parameter.
 
-  IMMEDIATELY_INVOKE_PARSER_MSG(ParseBuffer, result,
+  IMMEDIATELY_DELIVER_PARSER_MSG(ParseBuffer, result,
     (theContext, (void*)&theContext, aMimeType, PR_FALSE, aMode));
 
   if (NS_FAILED(result)) {
     mFlags |= NS_PARSER_FLAG_OBSERVERS_ENABLED;
     return result;
   }
 
   if (!mSink) {
@@ -2233,23 +2233,23 @@ nsParser::HandleParseFragment(const nsAS
   }
 
   fragSink->WillBuildContent();
   // Now, parse the actual content. Note that this is the last call
   // for HTML content, but for XML, we will want to build and parse
   // the end tags.  However, if tagStack is empty, it's the last call
   // for XML as well.
   if (!aXMLMode || (theCount == 0)) {
-    IMMEDIATELY_INVOKE_PARSER_MSG(ParseBuffer, result,
+    IMMEDIATELY_DELIVER_PARSER_MSG(ParseBuffer, result,
       (aSourceBuffer, &theContext, aMimeType, PR_TRUE, aMode));
     fragSink->DidBuildContent();
   } else {
     // Add an end tag chunk, so expat will read the whole source buffer,
     // and not worry about ']]' etc.
-    IMMEDIATELY_INVOKE_PARSER_MSG(ParseBuffer, result,
+    IMMEDIATELY_DELIVER_PARSER_MSG(ParseBuffer, result,
       (aSourceBuffer + NS_LITERAL_STRING("</"),
        &theContext, aMimeType, PR_FALSE, aMode));
 
     fragSink->DidBuildContent();
 
     if (NS_SUCCEEDED(result)) {
       nsAutoString endContext;       
       for (theIndex = 0; theIndex < theCount; theIndex++) {
@@ -2265,17 +2265,17 @@ nsParser::HandleParseFragment(const nsAS
           endContext.Append(thisTag);
         } else {
           endContext.Append(Substring(thisTag,0,endOfTag));
         }
 
         endContext.AppendLiteral(">");
       }
 
-      IMMEDIATELY_INVOKE_PARSER_MSG(ParseBuffer, result,
+      IMMEDIATELY_DELIVER_PARSER_MSG(ParseBuffer, result,
         (endContext, &theContext, aMimeType, PR_TRUE, aMode));
     }
   }
 
   mFlags |= NS_PARSER_FLAG_OBSERVERS_ENABLED;
 
   return result;
 }
@@ -2480,17 +2480,17 @@ nsParser::BuildModel()
 
 /*******************************************************************
   These methods are used to talk to the netlib system...
  *******************************************************************/
 
 nsresult
 nsParser::OnStartRequest(nsIRequest *request, nsISupports* aContext)
 {
-  ENQUEUE_PARSER_MSG(*mQueue, StartRequest, (request, aContext));
+  ENQUEUE_PARSER_MSG(StartRequest, (request, aContext));
 }
 
 nsresult
 nsParser::HandleStartRequest(nsIRequest* request, nsISupports* aContext)
 {
   NS_PRECONDITION(eNone == mParserContext->mStreamListenerState,
                   "Parser's nsIStreamListener API was not setup "
                   "correctly in constructor.");
@@ -2909,17 +2909,17 @@ CheckCharset(const char* aBytes,
 
 nsresult
 nsParser::OnDataAvailable(nsIRequest *request, nsISupports*,
                           nsIInputStream *pIStream, PRUint32 sourceOffset,
                           PRUint32 aLength)
 {
   NS_PRECONDITION(NS_InputStreamIsBuffered(pIStream),
                   "Must have a buffered input stream");
-  ENQUEUE_PARSER_MSG(*mQueue, DataAvailable,
+  ENQUEUE_PARSER_MSG(DataAvailable,
     (request, pIStream, sourceOffset, aLength));
 }
 
 nsresult
 nsParser::HandleDataAvailable(nsIRequest* aRequest,
                               char* aBytes,
                               PRUint32 aNumBytes,
                               PRUint32 aSourceOffset)
@@ -2978,17 +2978,17 @@ nsParser::HandleDataAvailable(nsIRequest
 /**
  *  This is called by the networking library once the last block of data
  *  has been collected from the net.
  */
 NS_IMETHODIMP
 nsParser::OnStopRequest(nsIRequest *request, nsISupports* aContext,
                         nsresult status)
 {
-  ENQUEUE_PARSER_MSG_AND_WAIT(*mQueue, StopRequest, (request, aContext, status));
+  ENQUEUE_PARSER_MSG_AND_WAIT(StopRequest, (request, aContext, status));
 }
 
 nsresult
 nsParser::HandleStopRequest(nsIRequest *request,
                             nsISupports* aContext,
                             nsresult status)
 {
   nsresult rv = NS_OK;
diff --git a/parser/htmlparser/src/nsParser.h b/parser/htmlparser/src/nsParser.h
--- a/parser/htmlparser/src/nsParser.h
+++ b/parser/htmlparser/src/nsParser.h
@@ -456,17 +456,17 @@ class nsParser : public nsIParser,
      * @update	gess5/11/98
      * @return  TRUE if all went well, otherwise FALSE
      */
     virtual nsresult ResumeParse(PRBool allowIteration = PR_TRUE,
                                  PRBool aIsFinalChunk = PR_FALSE,
                                  PRBool aCanInterrupt = PR_TRUE);
 
     nsParserQueue* mQueue;
-    void FlushQueue(const nsRunnable*);
+    void FlushQueue();
 
     DECL_PARSER_MSG_HANDLER(CancelParsingEvents, ())
     DECL_PARSER_MSG_HANDLER(StartRequest, (nsIRequest*, nsISupports*))
     DECL_PARSER_MSG_HANDLER(DataAvailable, (nsIRequest*, char*, PRUint32, PRUint32))
     DECL_PARSER_MSG_HANDLER(StopRequest, (nsIRequest*, nsISupports*, nsresult))
 
 private:
 
diff --git a/parser/htmlparser/src/nsParserQueue.cpp b/parser/htmlparser/src/nsParserQueue.cpp
--- a/parser/htmlparser/src/nsParserQueue.cpp
+++ b/parser/htmlparser/src/nsParserQueue.cpp
@@ -1,146 +1,98 @@
-
 #include "nsParserQueue.h"
 #include "nsThreadUtils.h"
 
-NS_IMPL_ISUPPORTS0(nsParserQueue::Msg)
+#define QPMT(EVENT) QUALIFIED_PROXY_MSG_TYPENAME(Parser, EVENT)
+#define IMPL_INIT(EVENT) QPMT(EVENT)::Init
 
 nsresult
-nsParserQueue::Flush(PRBool breakOnFailure)
-{
-  nsresult rv = NS_OK;
-
-  nsDeque q;
-  {
-    nsAutoLock synchronized(mLock);
-    while (GetSize())
-      q.Push(Pop());
-  }
-
-  PRBool safeToRelease = NS_IsMainThread();
-  while ((!breakOnFailure || NS_SUCCEEDED(rv)) &&
-         q.GetSize())
-  {
-    Msg* msg = static_cast<Msg*>(q.Pop());
-    rv = msg->Deliver();
-    if (NS_SUCCEEDED(rv))
-      rv = Flush(breakOnFailure);
-
-    msg->Notify(); // wake up waiting threads
-
-    if (safeToRelease) {
-      msg->Release();
-    } else {
-      NS_DispatchToMainThread(
-        new nsRunnableMethod<Msg>(msg, &Msg::VoidRelease));
-    }
-  }
-
-  // XXX what about document.write?
-  if (q.GetSize()) {
-    nsAutoLock synchronized(mLock);
-    while (q.GetSize())
-      // note: PushFront does not AddRef
-      nsDeque::PushFront(q.PopFront());
-  }
-
-  return rv;
-}
-
-nsresult
-nsParserQueue::ParseUrlMsg
-             ::Init(nsIURI* aURL,
+IMPL_INIT(ParseUrl)(nsIURI* aURL,
                     nsIRequestObserver* aListener,
                     void* aKey,
                     nsDTDMode aMode)
 {
   NS_ENSURE_ARG_POINTER(aURL);
   nsresult rv = aURL->GetSpec(mSpec);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mListener = aListener;
   mKey = aKey;
   mMode = aMode;
   return NS_OK;
 }
 
 nsresult
-nsParserQueue::ParseBufferMsg
-             ::Init(const nsAString& aSourceBuffer,
-                    void* aKey,
-                    const nsACString& aMimeType,
-                    PRBool aLastCall,
-                    nsDTDMode aMode)
+IMPL_INIT(ParseBuffer)(const nsAString& aSourceBuffer,
+                       void* aKey,
+                       const nsACString& aMimeType,
+                       PRBool aLastCall,
+                       nsDTDMode aMode)
 {
   mSourceBuffer = aSourceBuffer;
   mKey = aKey;
   mMimeType = aMimeType;
   mLastCall = aLastCall;
   mMode = aMode;
   return NS_OK;
 }
 
 nsresult
-nsParserQueue::StartRequestMsg
-             ::Init(nsIRequest* aRequest,
-                    nsISupports* aContext)
+IMPL_INIT(StartRequest)(nsIRequest* aRequest,
+                        nsISupports* aContext)
 {
   mRequest = aRequest;
   mContext = aContext;
   return NS_OK;
 }
 
-nsParserQueue::DataAvailableMsg::~DataAvailableMsg()
+QPMT(DataAvailable)::~PROXY_MSG_TYPENAME(DataAvailable)()
 {
   if (mBytes) {
     delete[] mBytes;
     mBytes = nsnull;
   }
 }
 
 nsresult
-nsParserQueue::DataAvailableMsg
-             ::Init(nsIRequest* aRequest,
-                    nsIInputStream* pIStream,
-                    PRUint32 aSourceOffset,
-                    PRUint32 aLength)
+IMPL_INIT(DataAvailable)(nsIRequest* aRequest,
+                         nsIInputStream* pIStream,
+                         PRUint32 aSourceOffset,
+                         PRUint32 aLength)
 {
   mRequest = aRequest;
   mSourceOffset = aSourceOffset;
   mBytes = new char[aLength + 1];
   nsresult rv = pIStream->Read(mBytes, aLength, &mNumBytes);
   if (NS_FAILED(rv)) {
     Release();
     return rv;
   }
   mBytes[mNumBytes] = 0;
   return NS_OK;
 }
 
 nsresult
-nsParserQueue::StopRequestMsg
-             ::Init(nsIRequest* aRequest,
-                    nsISupports* aContext,
-                    nsresult aStatus)
+IMPL_INIT(StopRequest)(nsIRequest* aRequest,
+                       nsISupports* aContext,
+                       nsresult aStatus)
 {
   mRequest = aRequest;
   mContext = aContext;
   mStatus = aStatus;
   return NS_OK;
 }
 
 nsresult
-nsParserQueue::ParseFragmentMsg
-             ::Init(const nsAString& aSourceBuffer,
-                    void* aKey,
-                    const nsTArray<nsString>& aTagStack,
-                    PRBool aXMLMode,
-                    const nsACString& aMimeType,
-                    nsDTDMode aMode)
+IMPL_INIT(ParseFragment)(const nsAString& aSourceBuffer,
+                         void* aKey,
+                         const nsTArray<nsString>& aTagStack,
+                         PRBool aXMLMode,
+                         const nsACString& aMimeType,
+                         nsDTDMode aMode)
 {
   mSourceBuffer = aSourceBuffer;
   mKey = aKey;
   mTagStack = aTagStack;
   mXMLMode = aXMLMode;
   mMimeType = aMimeType;
   mMode = aMode;
   return NS_OK;
diff --git a/parser/htmlparser/src/nsParserQueue.h b/parser/htmlparser/src/nsParserQueue.h
--- a/parser/htmlparser/src/nsParserQueue.h
+++ b/parser/htmlparser/src/nsParserQueue.h
@@ -1,327 +1,166 @@
 #ifndef __ns_parser_queue__
 #define __ns_parser_queue__
 
-#include "nsISupports.h"
+#include "nsProxyQueue.h"
 #include "nsParser.h"
 #include "nsIInputStream.h"
-#include "nsDeque.h"
-#include "nsAutoLock.h"
+
+// These wrapper macros will be #undef'd at the end of this file:
+#define PARSER_HANDLER_TYPEDEF(PARAMS)       PROXY_HANDLER_TYPEDEF(Parser, PARAMS)
+#define DECL_PARSER_INIT_AND_HANDLER(PARAMS) DECL_PROXY_INIT_AND_HANDLER(Parser, PARAMS)
+#define INLINE_PARSER_MSG_CTOR(EVENT)        INLINE_PROXY_MSG_CTOR(Parser, EVENT)
+#define TRIVIAL_PARSER_MSG(EVENT)            TRIVIAL_PROXY_MSG(Parser, EVENT)
 
 /**
-** "Private" #defines
-** All private #defines SHOULD be undefined when possible
+** nsParserQueue
 */
 
-#define SCHEDULE_FLUSH                                                        \
-  PR_BEGIN_MACRO                                                              \
-    if (NS_FAILED(NS_DispatchToCurrentThread(                                 \
-                    new nsParserContinueEvent(                                \
-                      this, &nsParser::FlushQueue))))                         \
-      NS_ASSERTION(PR_FALSE,                                                  \
-        "Failed to schedule FlushQueue event!");                              \
-  PR_END_MACRO
-
-// toggle to control flush method
-// #undef SCHEDULE_FLUSH
-
-// stupid, uninteresting, reliable flush method
-#ifndef SCHEDULE_FLUSH
-#define SCHEDULE_FLUSH                                                        \
-  PR_BEGIN_MACRO                                                              \
-    FlushQueue(0);                                                            \
-  PR_END_MACRO
-#endif
-
-#define PRIVATE_ENQUEUE_PARSER_MSG(Q, EVENT, INIT_ARGS)                       \
-  NS_ASSERTION(NS_IsMainThread(),                                             \
-    "Enqueueing off main thread");                                            \
-  nsParserQueue::EVENT##Msg* msg =                                            \
-    new nsParserQueue::EVENT##Msg(this, &nsParser::Handle##EVENT);            \
-  nsresult rv = msg                                                           \
-    ? msg->Init INIT_ARGS                                                     \
-    : NS_ERROR_OUT_OF_MEMORY;                                                 \
-  if (NS_SUCCEEDED(rv)) {                                                     \
-    nsAutoLock synchronized(Q);                                               \
-    (Q).Push(msg);                                                            \
-  } else delete msg;                                                          \
-  SCHEDULE_FLUSH;
-
-// Can't undefine unless used exclusively by inline functions:
-// #undef SCHEDULE_FLUSH
-
-#define HANDLER_TYPEDEF(PARAMS)                                               \
-  typedef nsresult (nsParser::*HandlerType)PARAMS;                            \
-  HandlerType mHandler;
-
-#define DECL_INIT_AND_TYPEDEF_HANDLER(PARAMS)                                 \
-public:                                                                       \
-  nsresult Init PARAMS;                                                       \
-private:                                                                      \
-  HANDLER_TYPEDEF(PARAMS)
-
-#define INLINE_MSG_CTOR(TYPE)                                                 \
-public:                                                                       \
-  TYPE##Msg(nsParser* aParser, HandlerType aHandler)                          \
-    : Msg(aParser), mHandler(aHandler) {}
-
-#define INLINE_MSG_DELIVER(PARAMS)                                            \
-public:                                                                       \
-  nsresult Deliver() {                                                        \
-    return (mParser->*mHandler)PARAMS;                                        \
-  }
-
-#define TRIVIAL_MSG(TYPE)                                                     \
-  class TYPE##Msg : public Msg {                                              \
-    HANDLER_TYPEDEF(())                                                       \
-  public:                                                                     \
-    INLINE_MSG_CTOR(TYPE)                                                     \
-    INLINE_MSG_DELIVER(())                                                    \
-    nsresult Init() { return NS_OK; }                                         \
-  };
-
-/**
-** "Public" #defines
-*/
-
-#define IMMEDIATELY_INVOKE_PARSER_MSG(EVENT, RV, INIT_ARGS)                   \
-  PR_BEGIN_MACRO                                                              \
-    nsParserQueue::EVENT##Msg msg(this, &nsParser::Handle##EVENT);            \
-    RV = msg.Init INIT_ARGS;                                                  \
-    if (NS_SUCCEEDED(RV))                                                     \
-      RV = msg.Deliver();                                                     \
-  PR_END_MACRO
-
-#define ENQUEUE_PARSER_MSG(Q, EVENT, INIT_ARGS)                               \
-  PR_BEGIN_MACRO                                                              \
-    PRIVATE_ENQUEUE_PARSER_MSG(Q, EVENT, INIT_ARGS)                           \
-    return rv;                                                                \
-  PR_END_MACRO
-
-#define VOID_ENQUEUE_PARSER_MSG(Q, EVENT, INIT_ARGS)                          \
-  PR_BEGIN_MACRO                                                              \
-    PRIVATE_ENQUEUE_PARSER_MSG(Q, EVENT, INIT_ARGS)                           \
-  PR_END_MACRO
-
-#define PARSER_SYNC_OPERATION(Q) msg->Wait()
-// TODO switch back to this version once the notifier and waiter are on different threads
-#undef  PARSER_SYNC_OPERATION
-
-#ifndef PARSER_SYNC_OPERATION
-#define PARSER_SYNC_OPERATION(Q) (Q).Flush()
-#endif
-
-#define ENQUEUE_PARSER_MSG_AND_WAIT(Q, EVENT, INIT_ARGS)                      \
-  PR_BEGIN_MACRO                                                              \
-    PRIVATE_ENQUEUE_PARSER_MSG(Q, EVENT, INIT_ARGS);                          \
-    return PARSER_SYNC_OPERATION(Q);                                          \
-  PR_END_MACRO
-
-// Can't undefine unless used exclusively by inline functions:
-// #undef PRIVATE_ENQUEUE_PARSER_MSG
-
-class nsParserQueue : private nsDeque {
-  PRLock* const mLock;
+class nsParserQueue : public nsProxyQueue<nsParser>
+{
 public:
-
-  /**
-  ** Queue-specific operations
-  */
-
-  nsParserQueue() : mLock(nsAutoLock::NewLock("nsParserQueue::mLock")) {}
-
-  virtual ~nsParserQueue() {
-    NS_ASSERTION(!GetSize(), "Expect leaks because you did "
-      "not Flush(PR_FALSE) before deleting nsParserQueue!");
-    nsAutoLock::DestroyLock(mLock);
-  }
-
-  operator PRLock*() { return mLock; }
-
-  nsresult Flush(PRBool breakOnFailure=PR_TRUE);
-
-  // Type-safe interface to private nsDeque base:
-
-  class Msg;
-
-  void Push(Msg* msg) {
-    if (msg) {
-      nsDeque::Push(msg);
-      // Released by nsParserQueue::Flush
-      NS_ADDREF(msg);
-    }
-  }
-
-  Msg* Pop() {
-    return (Msg*)nsDeque::Pop();
-  }
-
-  PRUint32 GetSize() const {
-    return nsDeque::GetSize();
-  }
-
-  /**
-  ** Common interface from which all the *Msg classes inherit
-  */
-
-  class Msg : public nsISupports {
-    NS_DECL_ISUPPORTS
-  public:
-    // TODO avoid this instantiation if not waiting?
-    // TODO determine a more specific type name?
-    Msg(nsParser* aParser)
-      : mParser(aParser)
-      , mMon(nsAutoMonitor::NewMonitor("nsParserQueue::Msg")) {}
-
-    virtual ~Msg() { nsAutoMonitor::DestroyMonitor(mMon); }
-
-    nsresult Wait(PRIntervalTime interval=PR_INTERVAL_NO_TIMEOUT) {
-      nsAutoMonitor mon(mMon);
-      return mon.Wait(interval);
-    }
-
-    nsresult Notify() {
-      nsAutoMonitor mon(mMon);
-      return mon.Notify();
-    }
-
-    void VoidRelease() {
-      if (NS_FAILED(Release())) {
-        NS_WARNING("Ignoring nsParserQueue::Msg::Release failure");
-      }
-    }
-
-    virtual nsresult Deliver() = 0;
-
-  protected:
-    nsRefPtr<nsParser> mParser;
-    PRMonitor* const mMon;
-  };
-
-  /**
-  ** nsIParser interface method-specific message classes
-  */
-
-  class ParseUrlMsg : public Msg
+  DECL_PROXY_MSG_SUBCLASS(ParseUrl)
   {
-    HANDLER_TYPEDEF((const nsACString &spec,
-                     nsIRequestObserver* aListener,
-                     void* aKey,
-                     nsDTDMode aMode))
+    PARSER_HANDLER_TYPEDEF((
+      const nsACString &spec,
+      nsIRequestObserver* aListener,
+      void* aKey,
+      nsDTDMode aMode))
 
     nsCString mSpec;
     nsCOMPtr<nsIRequestObserver> mListener;
     void* mKey;
     nsDTDMode mMode;
 
   public:
-    INLINE_MSG_CTOR(ParseUrl)
-    INLINE_MSG_DELIVER((mSpec, mListener, mKey, mMode))
+    INLINE_PARSER_MSG_CTOR(ParseUrl)
+    INLINE_PROXY_MSG_DELIVER((mSpec, mListener, mKey, mMode))
 
     nsresult Init(nsIURI* aURL,
                   nsIRequestObserver* aListener,
                   void* aKey,
                   nsDTDMode aMode);
   };
 
-  class ParseBufferMsg : public Msg
+  DECL_PROXY_MSG_SUBCLASS(ParseBuffer)
   {
-    DECL_INIT_AND_TYPEDEF_HANDLER((const nsAString& aSourceBuffer,
-                                   void* aKey,
-                                   const nsACString& aMimeType,
-                                   PRBool aLastCall,
-                                   nsDTDMode aMode))
+    DECL_PARSER_INIT_AND_HANDLER((
+      const nsAString& aSourceBuffer,
+      void* aKey,
+      const nsACString& aMimeType,
+      PRBool aLastCall,
+      nsDTDMode aMode))
+
     nsString mSourceBuffer;
     void* mKey;
     nsCString mMimeType;
     PRBool mLastCall;
     nsDTDMode mMode;
 
   public:
-    INLINE_MSG_CTOR(ParseBuffer)
-    INLINE_MSG_DELIVER((mSourceBuffer, mKey, mMimeType, mLastCall, mMode))
+    INLINE_PARSER_MSG_CTOR(ParseBuffer)
+    INLINE_PROXY_MSG_DELIVER((mSourceBuffer, mKey, mMimeType, mLastCall, mMode))
   };
 
-  class StartRequestMsg : public Msg
+  DECL_PROXY_MSG_SUBCLASS(StartRequest)
   {
-    DECL_INIT_AND_TYPEDEF_HANDLER((nsIRequest* aRequest,
-                                   nsISupports* aContext))
+    DECL_PARSER_INIT_AND_HANDLER((
+      nsIRequest* aRequest,
+      nsISupports* aContext))
+
     nsCOMPtr<nsIRequest> mRequest;
     nsCOMPtr<nsISupports> mContext;
 
   public:
-    INLINE_MSG_CTOR(StartRequest)
-    INLINE_MSG_DELIVER((mRequest, mContext))
+    INLINE_PARSER_MSG_CTOR(StartRequest)
+    INLINE_PROXY_MSG_DELIVER((mRequest, mContext))
   };
 
-  class DataAvailableMsg : public Msg
+  DECL_PROXY_MSG_SUBCLASS(DataAvailable)
   {
-    HANDLER_TYPEDEF((nsIRequest*, char*, PRUint32, PRUint32))
+    PARSER_HANDLER_TYPEDEF((nsIRequest*, char*, PRUint32, PRUint32))
 
     nsCOMPtr<nsIRequest> mRequest;
     char* mBytes;
     PRUint32 mNumBytes, mSourceOffset;
 
   public:
-    INLINE_MSG_CTOR(DataAvailable)
-    ~DataAvailableMsg();
-    INLINE_MSG_DELIVER((mRequest, mBytes, mNumBytes, mSourceOffset))
+    INLINE_PARSER_MSG_CTOR(DataAvailable)
+   ~PROXY_MSG_TYPENAME(DataAvailable)();
+    INLINE_PROXY_MSG_DELIVER((mRequest, mBytes, mNumBytes, mSourceOffset))
 
     nsresult Init(nsIRequest* aRequest,
                   nsIInputStream* pIStream,
                   PRUint32 aSourceOffset,
                   PRUint32 aLength);
   };
 
-  class StopRequestMsg : public Msg
+  DECL_PROXY_MSG_SUBCLASS(StopRequest)
   {
-    DECL_INIT_AND_TYPEDEF_HANDLER((nsIRequest* aRequest,
-                                   nsISupports* aContext,
-                                   nsresult aStatus))
+    DECL_PARSER_INIT_AND_HANDLER((
+      nsIRequest* aRequest,
+      nsISupports* aContext,
+      nsresult aStatus))
+
     nsCOMPtr<nsIRequest> mRequest;
     nsCOMPtr<nsISupports> mContext;
     nsresult mStatus;
 
   public:
-    INLINE_MSG_CTOR(StopRequest)
-    INLINE_MSG_DELIVER((mRequest, mContext, mStatus))
+    INLINE_PARSER_MSG_CTOR(StopRequest)
+    INLINE_PROXY_MSG_DELIVER((mRequest, mContext, mStatus))
   };
 
-  class ParseFragmentMsg : public Msg
+  DECL_PROXY_MSG_SUBCLASS(ParseFragment)
   {
-    DECL_INIT_AND_TYPEDEF_HANDLER((
+    DECL_PARSER_INIT_AND_HANDLER((
       const nsAString& aSourceBuffer,
       void* aKey,
       const nsTArray<nsString>& aTagStack,
       PRBool aXMLMode,
       const nsACString& aMimeType,
       nsDTDMode aMode))
 
     nsString mSourceBuffer;
     void* mKey;
     nsTArray<nsString> mTagStack;
     PRBool mXMLMode;
     nsCString mMimeType;
     nsDTDMode mMode;
 
   public:
-    INLINE_MSG_CTOR(ParseFragment)
-    INLINE_MSG_DELIVER((mSourceBuffer, mKey, mTagStack, mXMLMode, mMimeType, mMode))
+    INLINE_PARSER_MSG_CTOR(ParseFragment)
+    INLINE_PROXY_MSG_DELIVER((mSourceBuffer, mKey, mTagStack, mXMLMode, mMimeType, mMode))
   };
 
-  TRIVIAL_MSG(Terminate)
-  TRIVIAL_MSG(BlockParser)
-  TRIVIAL_MSG(UnblockParser)
-  TRIVIAL_MSG(ContinueInterruptedParsing)
-  TRIVIAL_MSG(ContinueParsing)
-  TRIVIAL_MSG(CancelParsingEvents)
+  TRIVIAL_PARSER_MSG(Terminate)
+  TRIVIAL_PARSER_MSG(BlockParser)
+  TRIVIAL_PARSER_MSG(UnblockParser)
+  TRIVIAL_PARSER_MSG(ContinueInterruptedParsing)
+  TRIVIAL_PARSER_MSG(ContinueParsing)
+  TRIVIAL_PARSER_MSG(CancelParsingEvents)
 
 };
 
 // Sayonara, macro scum!
-#undef HANDLER_TYPEDEF
-#undef DECL_INIT_AND_TYPEDEF_HANDLER
-#undef INLINE_MSG_CTOR
-#undef INLINE_MSG_DELIVER
-#undef TRIVIAL_MSG
+#undef PARSER_HANDLER_TYPEDEF
+#undef DECL_PARSER_INIT_AND_HANDLER
+#undef INLINE_PARSER_MSG_CTOR
+#undef TRIVIAL_PARSER_MSG
+
+/**
+** "Public" #defines
+*/
+
+#define IMMEDIATELY_DELIVER_PARSER_MSG(EVENT, RV, INIT_ARGS)                  \
+  IMMEDIATELY_DELIVER_PROXY_MSG(Parser, EVENT, RV, INIT_ARGS)
+
+#define ENQUEUE_PARSER_MSG(EVENT, INIT_ARGS)                                  \
+  ENQUEUE_PROXY_MSG(Parser, mQueue, EVENT, INIT_ARGS)
+
+#define VOID_ENQUEUE_PARSER_MSG(EVENT, INIT_ARGS)                             \
+  VOID_ENQUEUE_PROXY_MSG(Parser, mQueue, EVENT, INIT_ARGS)
+
+#define ENQUEUE_PARSER_MSG_AND_WAIT(EVENT, INIT_ARGS)                         \
+  ENQUEUE_PROXY_MSG_AND_WAIT(Parser, mQueue, EVENT, INIT_ARGS)
 
 #endif
diff --git a/parser/htmlparser/src/nsProxyQueue.cpp b/parser/htmlparser/src/nsProxyQueue.cpp
new file mode 100644
--- /dev/null
+++ b/parser/htmlparser/src/nsProxyQueue.cpp
@@ -0,0 +1,55 @@
+template <class T>
+NS_IMPL_ADDREF(nsProxyQueue<T>::Msg)
+
+template <class T>
+NS_IMPL_RELEASE(nsProxyQueue<T>::Msg)
+
+// YOU SEE THIS? THIS FUCKING BULLSHIT? SHIT IS BULLSHIT!
+// NS_IMPL_QUERY_INTERFACE0(nsProxyQueue<T>::Msg)
+template <class T>
+NS_INTERFACE_TABLE_HEAD(nsProxyQueue<T>::Msg)
+NS_INTERFACE_TABLE0(typename nsProxyQueue<T>::Msg)
+NS_INTERFACE_TABLE_TAIL
+
+template <class T>
+nsresult
+nsProxyQueue<T>::Flush(PRBool breakOnFailure)
+{
+  nsresult rv = NS_OK;
+
+  nsDeque q;
+  {
+    nsAutoLock synchronized(mLock);
+    while (GetSize())
+      q.Push(Pop());
+  }
+
+  PRBool safeToRelease = NS_IsMainThread();
+  while ((!breakOnFailure || NS_SUCCEEDED(rv)) &&
+         q.GetSize())
+  {
+    Msg* msg = static_cast<Msg*>(q.Pop());
+    rv = msg->Deliver();
+    if (NS_SUCCEEDED(rv))
+      rv = Flush(breakOnFailure);
+
+    msg->Notify(); // wake up waiting threads
+
+    if (safeToRelease) {
+      msg->Release();
+    } else {
+      NS_DispatchToMainThread(
+        new nsRunnableMethod<Msg>(msg, &Msg::VoidRelease));
+    }
+  }
+
+  // XXX what about document.write?
+  if (q.GetSize()) {
+    nsAutoLock synchronized(mLock);
+    while (q.GetSize())
+      // note: PushFront does not AddRef
+      nsDeque::PushFront(q.PopFront());
+  }
+
+  return rv;
+}
diff --git a/parser/htmlparser/src/nsProxyQueue.h b/parser/htmlparser/src/nsProxyQueue.h
new file mode 100644
--- /dev/null
+++ b/parser/htmlparser/src/nsProxyQueue.h
@@ -0,0 +1,244 @@
+#ifndef __ns_proxy_queue__
+#define __ns_proxy_queue__
+
+#include "nsDeque.h"
+#include "nsISupports.h"
+#include "nsAutoPtr.h"
+#include "nsAutoLock.h"
+#include "nsThreadUtils.h"
+
+template <class T>
+class nsProxyQueue : private nsDeque
+{
+  PRLock* const mLock;
+
+public:
+  typedef nsProxyQueue<T> QueueType;
+
+  /**
+  ** Queue-specific operations
+  */
+
+  nsProxyQueue() : mLock(nsAutoLock::NewLock("nsProxyQueue::mLock")) {}
+
+  virtual ~nsProxyQueue() {
+    NS_ASSERTION(!GetSize(), "Expect leaks because you did "
+      "not Flush(PR_FALSE) before deleting nsProxyQueue!");
+    nsAutoLock::DestroyLock(mLock);
+  }
+
+  operator PRLock*() { return mLock; }
+
+  nsresult Flush(PRBool breakOnFailure=PR_TRUE);
+
+  // Type-safe interface to private nsDeque base:
+
+  class Msg;
+
+  void Push(Msg* msg) {
+    if (msg) {
+      nsDeque::Push(msg);
+      // Released by nsProxyQueue::Flush
+      NS_ADDREF(msg);
+    }
+  }
+
+  Msg* Pop() {
+    return (Msg*)nsDeque::Pop();
+  }
+
+  PRUint32 GetSize() const {
+    return nsDeque::GetSize();
+  }
+
+  /**
+  ** Common interface from which all the *Msg classes inherit
+  */
+
+  class Msg : public nsISupports
+  {
+    NS_DECL_ISUPPORTS
+
+  public:
+    // TODO avoid this instantiation if not waiting?
+    // TODO determine a more specific type name?
+    Msg(T* aReceiver)
+      : mReceiver(aReceiver)
+      , mMon(nsAutoMonitor::NewMonitor("nsProxyQueue::Msg::mMon")) {}
+
+    virtual ~Msg() { nsAutoMonitor::DestroyMonitor(mMon); }
+
+    nsresult Wait(PRIntervalTime interval=PR_INTERVAL_NO_TIMEOUT) {
+      nsAutoMonitor mon(mMon);
+      return mon.Wait(interval);
+    }
+
+    nsresult Notify() {
+      nsAutoMonitor mon(mMon);
+      return mon.Notify();
+    }
+
+    void VoidRelease() {
+      if (NS_FAILED(Release())) {
+        NS_WARNING("Ignoring nsProxyQueue::Msg::Release failure");
+      }
+    }
+
+    virtual nsresult Deliver() = 0;
+
+  protected:
+    nsRefPtr<T> mReceiver;
+    PRMonitor* const mMon;
+  };
+
+};
+
+#include "nsProxyQueue.cpp"
+
+/**
+** nsProxyQueue convenience macros
+* ================================
+* These macros save typing and enforce a number of invariants.  They are
+* meant to be wrapped by macros with simpler signatures wherever subclasses
+* of nsProxyQueue are defined (e.g., in nsParserQueue.h).
+*
+* By convention,
+*
+*   - CLASS is the subclass-specific part of the subclass name.  For example,
+*     if the signature of a subclass is
+*
+*       class nsParserQueue : public nsProxyQueue<nsParser>
+*
+*     then CLASS is expected to be Parser, so that the macro expansions
+*     ns##CLASS##Queue and ns##CLASS correctly identify nsParserQueue and
+*     T = nsParser.
+*
+*   - Q is a pointer to the queue.  The expression substituted for Q is
+*     evaluated only once.
+*
+*   - EVENT is the kind of message being enqueued or invoked.  The EVENT
+*     macro argument constrains the name of the message type and the name of
+*     the handler method: ns##CLASS##Queue::EVENT##Msg must expand to the
+*     message type and ns##CLASS::Handle##EVENT must expand to the name of the
+*     method invoked by ns##CLASS##Queue::EVENT##Msg::Deliver.
+*
+*   - INIT_ARGS is a parentheses-enclosed list of arguments to be passed to
+*     the ns##CLASS##Queue::EVENT##Msg::Init method.
+*/
+
+/**
+** Naming convention enforcement macros
+*/
+
+// These two macros define the relationship between Msg subclass names and
+// the names of the handler methods called by Deliver:
+#define PROXY_MSG_TYPENAME(EVENT)        EVENT##Msg
+#define PROXY_HANDLER_METHOD_NAME(EVENT) Handle##EVENT
+
+#define DECL_PROXY_MSG_SUBCLASS(EVENT)                                        \
+  class PROXY_MSG_TYPENAME(EVENT) : public Msg
+
+// These two macros define the naming convention for subclasses of
+// nsProxyQueue<PROXY_T_TYPENAME(CLASS)>:
+#define PROXY_T_TYPENAME(CLASS)          ns##CLASS
+#define PROXY_SUBCLASS_NAME(CLASS)       PROXY_T_TYPENAME(CLASS##Queue)
+
+#define QUALIFIED_PROXY_MSG_TYPENAME(CLASS, EVENT)                            \
+  PROXY_SUBCLASS_NAME(CLASS)::PROXY_MSG_TYPENAME(EVENT)
+
+/**
+** Msg-implementation convenience macros
+*/
+
+#define PROXY_HANDLER_TYPEDEF(CLASS, PARAMS)                                  \
+private:                                                                      \
+  typedef nsresult (PROXY_T_TYPENAME(CLASS)::*HandlerType)PARAMS;             \
+  HandlerType mHandler;
+
+#define DECL_PROXY_INIT_AND_HANDLER(CLASS, PARAMS)                            \
+public:                                                                       \
+  nsresult Init PARAMS;                                                       \
+  PROXY_HANDLER_TYPEDEF(CLASS, PARAMS)
+
+#define INLINE_PROXY_MSG_DELIVER(PARAMS)                                      \
+public:                                                                       \
+  nsresult Deliver() {                                                        \
+    return (mReceiver->*mHandler)PARAMS;                                      \
+  }
+
+#define INLINE_PROXY_MSG_CTOR(CLASS, EVENT)                                   \
+public:                                                                       \
+  PROXY_MSG_TYPENAME(EVENT)(PROXY_T_TYPENAME(CLASS)* aReceiver,               \
+                            HandlerType aHandler)                             \
+    : nsProxyQueue<PROXY_T_TYPENAME(CLASS)>::Msg(aReceiver)                   \
+    , mHandler(aHandler) {}
+
+#define TRIVIAL_PROXY_MSG(CLASS, EVENT)                                       \
+  DECL_PROXY_MSG_SUBCLASS(EVENT) {                                            \
+    PROXY_HANDLER_TYPEDEF(CLASS, ())                                          \
+  public:                                                                     \
+    INLINE_PROXY_MSG_CTOR(CLASS, EVENT)                                       \
+    INLINE_PROXY_MSG_DELIVER(())                                              \
+    nsresult Init() { return NS_OK; }                                         \
+  };
+
+/**
+** Queue manipulation convenience macros
+*/
+
+#define ALLOC_NEW_PROXY_MSG(VAR, CLASS, EVENT)                                \
+  QUALIFIED_PROXY_MSG_TYPENAME(CLASS, EVENT)* VAR =                           \
+    new QUALIFIED_PROXY_MSG_TYPENAME(CLASS, EVENT)(this,                      \
+      &PROXY_T_TYPENAME(CLASS)::PROXY_HANDLER_METHOD_NAME(EVENT))
+
+#define PRIVATE_ENQUEUE_PROXY_MSG(CLASS, Q, EVENT, INIT_ARGS)                 \
+  NS_ASSERTION(NS_IsMainThread(), "Enqueueing off main thread");              \
+  PROXY_SUBCLASS_NAME(CLASS)* const q = Q;                                    \
+  ALLOC_NEW_PROXY_MSG(msg, CLASS, EVENT);                                     \
+  nsresult rv = msg ? msg->Init INIT_ARGS                                     \
+                    : NS_ERROR_OUT_OF_MEMORY;                                 \
+  if (NS_SUCCEEDED(rv)) {                                                     \
+    nsAutoLock synchronized(*q);                                              \
+    q->Push(msg);                                                             \
+  } else delete msg;                                                          \
+  if (msg && NS_FAILED(NS_DispatchToCurrentThread(                            \
+               NS_NEW_RUNNABLE_METHOD(PROXY_T_TYPENAME(CLASS),                \
+                                      this, FlushQueue)))) {                  \
+    NS_ASSERTION(PR_FALSE, "Failed to schedule Flush event");                 \
+  }
+
+#define ENQUEUE_PROXY_MSG(CLASS, Q, EVENT, INIT_ARGS)                         \
+  PR_BEGIN_MACRO                                                              \
+    PRIVATE_ENQUEUE_PROXY_MSG(CLASS, Q, EVENT, INIT_ARGS)                     \
+    return rv;                                                                \
+  PR_END_MACRO
+
+#define VOID_ENQUEUE_PROXY_MSG(CLASS, Q, EVENT, INIT_ARGS)                    \
+  PR_BEGIN_MACRO                                                              \
+    PRIVATE_ENQUEUE_PROXY_MSG(CLASS, Q, EVENT, INIT_ARGS)                     \
+  PR_END_MACRO
+
+#define PROXY_SYNC_OPERATION(IGNORED) msg->Wait()
+// TODO switch back to this version once the notifier and waiter are on different threads
+#undef  PROXY_SYNC_OPERATION
+
+#ifndef PROXY_SYNC_OPERATION
+#define PROXY_SYNC_OPERATION(Q) (Q)->Flush()
+#endif
+
+#define ENQUEUE_PROXY_MSG_AND_WAIT(CLASS, Q, EVENT, INIT_ARGS)                \
+  PR_BEGIN_MACRO                                                              \
+    PRIVATE_ENQUEUE_PROXY_MSG(CLASS, Q, EVENT, INIT_ARGS);                    \
+    return PROXY_SYNC_OPERATION(q);                                           \
+  PR_END_MACRO
+
+#define IMMEDIATELY_DELIVER_PROXY_MSG(CLASS, EVENT, RV, INIT_ARGS)            \
+  PR_BEGIN_MACRO                                                              \
+    QUALIFIED_PROXY_MSG_TYPENAME(CLASS, EVENT)                                \
+      msg(this, &PROXY_T_TYPENAME(CLASS)::PROXY_HANDLER_METHOD_NAME(EVENT));  \
+    RV = msg.Init INIT_ARGS;                                                  \
+    if (NS_SUCCEEDED(RV))                                                     \
+      RV = msg.Deliver();                                                     \
+  PR_END_MACRO
+
+#endif
