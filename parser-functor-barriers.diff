* * *

diff --git a/content/html/document/src/nsHTMLContentSink.cpp b/content/html/document/src/nsHTMLContentSink.cpp
--- a/content/html/document/src/nsHTMLContentSink.cpp
+++ b/content/html/document/src/nsHTMLContentSink.cpp
@@ -118,16 +118,20 @@
 #include "nsIDocShellTreeItem.h"
 
 #include "nsEscape.h"
 #include "nsIElementObserver.h"
 #include "nsNodeInfoManager.h"
 #include "nsContentCreatorFunctions.h"
 #include "mozAutoDocUpdate.h"
 
+#include "Bind.h"
+#include "nsRunnableFunctor.h"
+#include "nsThreadUtils.h"
+
 #ifdef NS_DEBUG
 static PRLogModuleInfo* gSinkLogModuleInfo;
 
 #define SINK_TRACE_NODE(_bit, _msg, _tag, _sp, _obj) \
   _obj->SinkTraceNode(_bit, _msg, _tag, _sp, this)
 
 #else
 #define SINK_TRACE_NODE(_bit, _msg, _tag, _sp, _obj)
@@ -149,16 +153,34 @@ NS_NewHTMLNOTUSEDElement(nsINodeInfo *aN
 static const contentCreatorCallback sContentCreatorCallbacks[] = {
   NS_NewHTMLUnknownElement,
 #include "nsHTMLTagList.h"
 #undef HTML_TAG
 #undef HTML_OTHER
   NS_NewHTMLUnknownElement
 };
 
+#define PROXY_SYNC(BOUND)                                                     \
+  PR_BEGIN_MACRO                                                              \
+    nsIThread* thread = nsnull;                                               \
+    NS_GetCurrentThread(&thread);                                             \
+    if (mSinkThread.get() != thread)                                          \
+      return (BOUND).proxy(mSinkThread, NS_DISPATCH_SYNC)->Wait();            \
+  PR_END_MACRO
+
+#define TRIVIAL_PROXY_SYNC(METHOD)                                            \
+  PROXY_SYNC(BIND1(&HTMLContentSink::METHOD,                                  \
+                   nsRefPtr<HTMLContentSink>                                  \
+                           (const_cast<HTMLContentSink*>(this))))
+
+#define PARSER_NODE_PROXY_SYNC(METHOD, NODE)                                  \
+  PROXY_SYNC(BIND2(&HTMLContentSink::METHOD,                                  \
+                   nsRefPtr<HTMLContentSink>(this),                           \
+                   ref(NODE)))
+
 class SinkContext;
 class HTMLContentSink;
 
 static void MaybeSetForm(nsGenericHTMLElement*, nsHTMLTag, HTMLContentSink*);
 
 class HTMLContentSink : public nsContentSink,
 #ifdef DEBUG
                         public nsIDebugDumpContent,
@@ -230,16 +252,18 @@ protected:
 #ifdef NS_DEBUG
   void SinkTraceNode(PRUint32 aBit,
                      const char* aMsg,
                      const nsHTMLTag aTag,
                      PRInt32 aStackPos,
                      void* aThis);
 #endif
 
+  nsRefPtr<nsIThread> mSinkThread;
+
   nsIHTMLDocument* mHTMLDocument;
 
   // The maximum length of a text run
   PRInt32 mMaxTextRun;
 
   nsGenericHTMLElement* mRoot;
   nsGenericHTMLElement* mBody;
   nsRefPtr<nsGenericHTMLElement> mFrameset;
@@ -1628,16 +1652,17 @@ IsScriptEnabled(nsIDocument *aDoc, nsIDo
 nsresult
 HTMLContentSink::Init(nsIDocument* aDoc,
                       nsIURI* aURI,
                       nsISupports* aContainer,
                       nsIChannel* aChannel)
 {
   NS_ENSURE_TRUE(aContainer, NS_ERROR_NULL_POINTER);
 
+  NS_GetMainThread(getter_AddRefs(mSinkThread));
 
   MOZ_TIMER_DEBUGLOG(("Reset and start: nsHTMLContentSink::Init(), this=%p\n",
                       this));
   MOZ_TIMER_RESET(mWatch);
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = nsContentSink::Init(aDoc, aURI, aContainer, aChannel);
   if (NS_FAILED(rv)) {
@@ -1739,22 +1764,25 @@ HTMLContentSink::Init(nsIDocument* aDoc,
   MOZ_TIMER_STOP(mWatch);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::WillParse(void)
 {
+  TRIVIAL_PROXY_SYNC(WillParse);
   return WillParseImpl();
 }
 
 NS_IMETHODIMP
 HTMLContentSink::WillBuildModel(nsDTDMode aDTDMode)
 {
+  TRIVIAL_PROXY_SYNC(WillBuildModel);
+
   WillBuildModelImpl();
 
   if (mHTMLDocument) {
     nsCompatibility mode = eCompatibility_NavQuirks;
     switch (aDTDMode) {
       case eDTDMode_full_standards:
         mode = eCompatibility_FullStandards;
         break;
@@ -1771,16 +1799,18 @@ HTMLContentSink::WillBuildModel(nsDTDMod
   mDocument->BeginLoad();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::DidBuildModel(void)
 {
+  TRIVIAL_PROXY_SYNC(DidBuildModel);
+
   // NRA Dump stopwatch stop info here
 #ifdef MOZ_PERF_METRICS
   MOZ_TIMER_DEBUGLOG(("Stop: nsHTMLContentSink::DidBuildModel(), this=%p\n",
                       this));
   MOZ_TIMER_STOP(mWatch);
   MOZ_TIMER_LOG(("Content creation time (this=%p): ", this));
   MOZ_TIMER_PRINT(mWatch);
 #endif
@@ -1835,30 +1865,39 @@ PRBool
 HTMLContentSink::ReadyToCallDidBuildModel(PRBool aTerminated)
 {
   return ReadyToCallDidBuildModelImpl(aTerminated);
 }
 
 NS_IMETHODIMP
 HTMLContentSink::SetParser(nsIParser* aParser)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::SetParser,
+                   nsRefPtr<HTMLContentSink>(this),
+                   nsRefPtr<nsIParser>(aParser)));
+
   NS_PRECONDITION(aParser, "Should have a parser here!");
   mParser = aParser;
   return NS_OK;
 }
 
 NS_IMETHODIMP_(PRBool)
 HTMLContentSink::IsFormOnStack()
 {
+  TRIVIAL_PROXY_SYNC(IsFormOnStack);
   return mFormOnStack;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::BeginContext(PRInt32 aPosition)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::BeginContext,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aPosition));
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::BeginContext()\n"));
   MOZ_TIMER_START(mWatch);
   NS_PRECONDITION(aPosition > -1, "out of bounds");
 
   // Create new context
   SinkContext* sc = new SinkContext(this);
   if (!sc) {
     MOZ_TIMER_DEBUGLOG(("Stop: nsHTMLContentSink::BeginContext()\n"));
@@ -1907,16 +1946,20 @@ HTMLContentSink::BeginContext(PRInt32 aP
   MOZ_TIMER_STOP(mWatch);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::EndContext(PRInt32 aPosition)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::EndContext,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aPosition));
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::EndContext()\n"));
   MOZ_TIMER_START(mWatch);
   NS_PRECONDITION(mCurrentContext && aPosition > -1, "non-existing context");
 
   PRUint32 n = mContextStack.Length() - 1;
   SinkContext* sc = mContextStack.ElementAt(n);
 
   const SinkContext::Node &bottom = mCurrentContext->mStack[0];
@@ -1997,16 +2040,18 @@ HTMLContentSink::CloseHTML()
   MOZ_TIMER_STOP(mWatch);
 
   return NS_OK;
 }
 
 nsresult
 HTMLContentSink::OpenHead()
 {
+  TRIVIAL_PROXY_SYNC(OpenHead);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::OpenHead()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = OpenHeadContext();
 
   MOZ_TIMER_DEBUGLOG(("Stop: nsHTMLContentSink::OpenHead()\n"));
   MOZ_TIMER_STOP(mWatch);
 
@@ -2289,32 +2334,39 @@ HTMLContentSink::CloseFrameset()
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::IsEnabled(PRInt32 aTag, PRBool* aReturn)
 {
+  PROXY_SYNC(BIND3(&HTMLContentSink::IsEnabled,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aTag,
+                   aReturn));
+
   nsHTMLTag theHTMLTag = nsHTMLTag(aTag);
 
   if (theHTMLTag == eHTMLTag_script) {
     *aReturn = mScriptEnabled;
   } else if (theHTMLTag == eHTMLTag_frameset) {
     *aReturn = mFramesEnabled;
   } else {
     *aReturn = PR_FALSE;
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::OpenContainer(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(OpenContainer, aNode);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::OpenContainer()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = NS_OK;
 
   switch (aNode.GetNodeType()) {
     case eHTMLTag_frameset:
       rv = OpenFrameset(aNode);
@@ -2352,16 +2404,20 @@ HTMLContentSink::OpenContainer(const nsI
   MOZ_TIMER_STOP(mWatch);
 
   return rv;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::CloseContainer(const eHTMLTags aTag)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::CloseContainer,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aTag));
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::CloseContainer()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = NS_OK;
 
   switch (aTag) {
     case eHTMLTag_frameset:
       rv = CloseFrameset();
@@ -2393,16 +2449,18 @@ NS_IMETHODIMP
 HTMLContentSink::CloseMalformedContainer(const eHTMLTags aTag)
 {
   return mCurrentContext->CloseContainer(aTag, PR_TRUE);
 }
 
 NS_IMETHODIMP
 HTMLContentSink::AddLeaf(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(AddLeaf, aNode);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::AddLeaf()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv;
 
   nsHTMLTag nodeType = nsHTMLTag(aNode.GetNodeType());
   switch (nodeType) {
   case eHTMLTag_link:
@@ -2426,16 +2484,18 @@ HTMLContentSink::AddLeaf(const nsIParser
  * This gets called by the parsing system when we find a comment
  * @update	gess11/9/98
  * @param   aNode contains a comment token
  * @return  error code
  */
 nsresult
 HTMLContentSink::AddComment(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(AddComment, aNode);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::AddComment()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = mCurrentContext->AddComment(aNode);
 
   MOZ_TIMER_DEBUGLOG(("Stop: nsHTMLContentSink::AddComment()\n"));
   MOZ_TIMER_STOP(mWatch);
 
@@ -2446,16 +2506,18 @@ HTMLContentSink::AddComment(const nsIPar
  * This gets called by the parsing system when we find a PI
  * @update	gess11/9/98
  * @param   aNode contains a comment token
  * @return  error code
  */
 nsresult
 HTMLContentSink::AddProcessingInstruction(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(AddProcessingInstruction, aNode);
+
   nsresult result = NS_OK;
 
   MOZ_TIMER_START(mWatch);
   // Implementation of AddProcessingInstruction() should start here
 
   MOZ_TIMER_STOP(mWatch);
 
   return result;
@@ -2464,16 +2526,18 @@ HTMLContentSink::AddProcessingInstructio
 /**
  *  This gets called by the parser when it encounters
  *  a DOCTYPE declaration in the HTML document.
  */
 
 NS_IMETHODIMP
 HTMLContentSink::AddDocTypeDecl(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(AddDocTypeDecl, aNode);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::AddDocTypeDecl()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsAutoString docTypeStr(aNode.GetText());
   nsresult rv = NS_OK;
 
   PRInt32 publicStart = docTypeStr.Find("PUBLIC", PR_TRUE);
   PRInt32 systemStart = docTypeStr.Find("SYSTEM", PR_TRUE);
@@ -2708,34 +2772,41 @@ NS_IMETHODIMP
 HTMLContentSink::WillProcessAToken(void)
 {
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::DidProcessAToken(void)
 {
+  TRIVIAL_PROXY_SYNC(DidProcessAToken);
   return DidProcessATokenImpl();
 }
 
 NS_IMETHODIMP
 HTMLContentSink::WillInterrupt()
 {
+  TRIVIAL_PROXY_SYNC(WillInterrupt);
   return WillInterruptImpl();
 }
 
 NS_IMETHODIMP
 HTMLContentSink::WillResume()
 {
+  TRIVIAL_PROXY_SYNC(WillResume);
   return WillResumeImpl();
 }
 
 NS_IMETHODIMP
 HTMLContentSink::NotifyTagObservers(nsIParserNode* aNode)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::NotifyTagObservers,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aNode));
+
   // Bug 125317
   // Inform observers that we're handling a document.write().
   // This information is necessary for the charset observer, atleast,
   // to make a decision whether a new charset loading is required or not.
 
   if (!mObservers) {
     return NS_OK;
   }
@@ -3179,16 +3250,20 @@ HTMLContentSink::ProcessSTYLEEndTag(nsGe
   }
 
   return rv;
 }
 
 void
 HTMLContentSink::FlushPendingNotifications(mozFlushType aType)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::FlushPendingNotifications,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aType));
+
   // Only flush tags if we're not doing the notification ourselves
   // (since we aren't reentrant)
   if (!mInNotification) {
     if (aType >= Flush_ContentAndNotify) {
       FlushTags();
     }
     else if (mCurrentContext) {
       mCurrentContext->FlushText();
@@ -3210,16 +3285,20 @@ HTMLContentSink::FlushTags()
   }
   
   return mCurrentContext ? mCurrentContext->FlushTags() : NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::SetDocumentCharset(nsACString& aCharset)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::SetDocumentCharset,
+                   nsRefPtr<HTMLContentSink>(this),
+                   nsCString(aCharset)));
+
   if (mDocShell) {
     // the following logic to get muCV is copied from
     // nsHTMLDocument::StartDocumentLoad
     // We need to call muCV->SetPrevDocCharacterSet here in case
     // the charset is detected by parser DetectMetaTag
     nsCOMPtr<nsIMarkupDocumentViewer> muCV;
     nsCOMPtr<nsIContentViewer> cv;
     mDocShell->GetContentViewer(getter_AddRefs(cv));
@@ -3258,16 +3337,17 @@ HTMLContentSink::SetDocumentCharset(nsAC
   }
 
   return NS_OK;
 }
 
 nsISupports *
 HTMLContentSink::GetTarget()
 {
+  TRIVIAL_PROXY_SYNC(GetTarget);
   return mDocument;
 }
 
 PRBool
 HTMLContentSink::IsScriptExecuting()
 {
   return IsScriptExecutingImpl();
 }
diff --git a/content/xul/document/src/nsXULContentSink.cpp b/content/xul/document/src/nsXULContentSink.cpp
--- a/content/xul/document/src/nsXULContentSink.cpp
+++ b/content/xul/document/src/nsXULContentSink.cpp
@@ -88,16 +88,18 @@
 #include "nsUnicharUtils.h"
 #include "nsGkAtoms.h"
 #include "nsContentUtils.h"
 #include "nsAttrName.h"
 #include "nsXMLContentSink.h"
 #include "nsIConsoleService.h"
 #include "nsIScriptError.h"
 
+#include "Bind.h"
+
 #ifdef PR_LOGGING
 static PRLogModuleInfo* gLog;
 #endif
 
 //----------------------------------------------------------------------
 
 XULContentSinkImpl::ContextStack::ContextStack()
     : mTop(nsnull), mDepth(0)
@@ -268,16 +270,20 @@ XULContentSinkImpl::WillBuildModel(nsDTD
 #endif
 
     return NS_OK;
 }
 
 NS_IMETHODIMP 
 XULContentSinkImpl::DidBuildModel(void)
 {
+    if (!NS_IsMainThread())
+        return BIND1(&XULContentSinkImpl::DidBuildModel,
+                     this).proxy(nsnull, NS_DISPATCH_SYNC)->Wait();
+
     nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocument);
     if (doc) {
         doc->EndLoad();
         mDocument = nsnull;
     }
 
     // Drop our reference to the parser to get rid of a circular
     // reference.
@@ -448,16 +454,22 @@ XULContentSinkImpl::FlushText(PRBool aCr
 }
 
 //----------------------------------------------------------------------
 
 nsresult
 XULContentSinkImpl::NormalizeAttributeString(const PRUnichar *aExpatName,
                                              nsAttrName &aName)
 {
+    if (!NS_IsMainThread())
+        return BIND3(&XULContentSinkImpl::NormalizeAttributeString,
+                     nsRefPtr<XULContentSinkImpl>(this),
+                     aExpatName,
+                     aName).proxy(nsnull, NS_DISPATCH_SYNC)->Wait();
+
     PRInt32 nameSpaceID;
     nsCOMPtr<nsIAtom> prefix, localName;
     nsContentUtils::SplitExpatName(aExpatName, getter_AddRefs(prefix),
                                    getter_AddRefs(localName), &nameSpaceID);
 
     if (nameSpaceID == kNameSpaceID_None) {
         aName.SetTo(localName);
 
@@ -492,17 +504,26 @@ XULContentSinkImpl::CreateElement(nsINod
 
 
 NS_IMETHODIMP 
 XULContentSinkImpl::HandleStartElement(const PRUnichar *aName, 
                                        const PRUnichar **aAtts,
                                        PRUint32 aAttsCount, 
                                        PRInt32 aIndex, 
                                        PRUint32 aLineNumber)
-{ 
+{
+  if (!NS_IsMainThread())
+    return BIND6(&XULContentSinkImpl::HandleStartElement,
+                 this,
+                 aName,
+                 aAtts,
+                 aAttsCount,
+                 aIndex,
+                 aLineNumber).proxy(nsnull, NS_DISPATCH_SYNC)->Wait();
+
   // XXX Hopefully the parser will flag this before we get here. If
   // we're in the epilog, there should be no new elements
   NS_PRECONDITION(mState != eInEpilog, "tag in XUL doc epilog");
   NS_PRECONDITION(aIndex >= -1, "Bogus aIndex");
   NS_PRECONDITION(aAttsCount % 2 == 0, "incorrect aAttsCount");
   // Adjust aAttsCount so it's the actual number of attributes
   aAttsCount /= 2;
   
diff --git a/parser/htmlparser/src/nsExpatDriver.cpp b/parser/htmlparser/src/nsExpatDriver.cpp
--- a/parser/htmlparser/src/nsExpatDriver.cpp
+++ b/parser/htmlparser/src/nsExpatDriver.cpp
@@ -56,16 +56,19 @@
 #include "nsIConsoleService.h"
 #include "nsIScriptError.h"
 #include "nsIContentPolicy.h"
 #include "nsContentPolicyUtils.h"
 #include "nsContentErrors.h"
 #include "nsXPCOMCIDInternal.h"
 #include "nsUnicharInputStream.h"
 
+#include "nsThreadUtils.h"
+#include "Bind.h"
+
 #define kExpatSeparatorChar 0xFFFF
 
 static const PRUnichar kUTF16[] = { 'U', 'T', 'F', '-', '1', '6', '\0' };
 
 #ifdef PR_LOGGING
 static PRLogModuleInfo *gExpatDriverLog = PR_NewLogModule("expatdriver");
 #endif
 
@@ -406,79 +409,94 @@ nsExpatDriver::nsExpatDriver()
 
 nsExpatDriver::~nsExpatDriver()
 {
   if (mExpatParser) {
     XML_ParserFree(mExpatParser);
   }
 }
 
+#define PROXY_SYNC(BOUND)                                                     \
+  PR_BEGIN_MACRO                                                              \
+    if (!NS_IsMainThread())                                                   \
+      return (BOUND).proxy(nsnull, NS_DISPATCH_SYNC)->Wait();                 \
+  PR_END_MACRO
+
 nsresult
 nsExpatDriver::HandleStartElement(const PRUnichar *aValue,
                                   const PRUnichar **aAtts)
 {
+  PROXY_SYNC(BIND3(&nsExpatDriver::HandleStartElement,
+                   this, aValue, aAtts));
+
   NS_ASSERTION(mSink, "content sink not found!");
 
   // Calculate the total number of elements in aAtts.
   // XML_GetSpecifiedAttributeCount will only give us the number of specified
   // attrs (twice that number, actually), so we have to check for default attrs
   // ourselves.
   PRUint32 attrArrayLength;
   for (attrArrayLength = XML_GetSpecifiedAttributeCount(mExpatParser);
        aAtts[attrArrayLength];
        attrArrayLength += 2) {
     // Just looping till we find out what the length is
   }
 
   if (mSink) {
-    nsresult rv = mSink->
-      HandleStartElement(aValue, aAtts, attrArrayLength,
-                         XML_GetIdAttributeIndex(mExpatParser),
-                         XML_GetCurrentLineNumber(mExpatParser));
+    PRUint32 attrIndex = XML_GetIdAttributeIndex(mExpatParser),
+            lineNumber = XML_GetCurrentLineNumber(mExpatParser);
+    nsresult rv = mSink->HandleStartElement(aValue, aAtts, attrArrayLength,
+                                            attrIndex, lineNumber);
     MaybeStopParser(rv);
   }
 
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleEndElement(const PRUnichar *aValue)
 {
+  PROXY_SYNC(BIND2(&nsExpatDriver::HandleEndElement,
+                   this, aValue));
   NS_ASSERTION(mSink, "content sink not found!");
   NS_ASSERTION(mInternalState != NS_ERROR_HTMLPARSER_BLOCK,
                "Shouldn't block from HandleStartElement.");
 
   if (mSink && mInternalState != NS_ERROR_HTMLPARSER_STOPPARSING) {
     nsresult rv = mSink->HandleEndElement(aValue);
     MaybeStopParser(rv);
   }
 
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleCharacterData(const PRUnichar *aValue,
                                    const PRUint32 aLength)
 {
+  PROXY_SYNC(BIND3(&nsExpatDriver::HandleCharacterData,
+                   this, aValue, aLength));
   NS_ASSERTION(mSink, "content sink not found!");
 
   if (mInCData) {
     mCDataText.Append(aValue, aLength);
   }
   else if (mSink) {
     nsresult rv = mSink->HandleCharacterData(aValue, aLength);
     MaybeStopParser(rv);
   }
 
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleComment(const PRUnichar *aValue)
 {
+  PROXY_SYNC(BIND2(&nsExpatDriver::HandleComment,
+                   this, aValue));
   NS_ASSERTION(mSink, "content sink not found!");
 
   if (mInExternalDTD) {
     // Ignore comments from external DTDs
     return NS_OK;
   }
 
   if (mInInternalSubset) {
@@ -493,16 +511,18 @@ nsExpatDriver::HandleComment(const PRUni
 
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleProcessingInstruction(const PRUnichar *aTarget,
                                            const PRUnichar *aData)
 {
+  PROXY_SYNC(BIND3(&nsExpatDriver::HandleProcessingInstruction,
+                   this, aTarget, aData));
   NS_ASSERTION(mSink, "content sink not found!");
 
   if (mInExternalDTD) {
     // Ignore PIs in external DTDs for now.  Eventually we want to
     // pass them to the sink in a way that doesn't put them in the DOM
     return NS_OK;
   }
 
@@ -521,28 +541,32 @@ nsExpatDriver::HandleProcessingInstructi
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleXMLDeclaration(const PRUnichar *aVersion,
                                     const PRUnichar *aEncoding,
                                     PRInt32 aStandalone)
 {
+  PROXY_SYNC(BIND4(&nsExpatDriver::HandleXMLDeclaration,
+                   this, aVersion, aEncoding, aStandalone));
   if (mSink) {
     nsresult rv = mSink->HandleXMLDeclaration(aVersion, aEncoding, aStandalone);
     MaybeStopParser(rv);
   }
 
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleDefault(const PRUnichar *aValue,
                              const PRUint32 aLength)
 {
+  PROXY_SYNC(BIND3(&nsExpatDriver::HandleDefault,
+                   this, aValue, aLength));
   NS_ASSERTION(mSink, "content sink not found!");
 
   if (mInExternalDTD) {
     // Ignore newlines in external DTDs
     return NS_OK;
   }
 
   if (mInInternalSubset) {
@@ -560,24 +584,26 @@ nsExpatDriver::HandleDefault(const PRUni
   }
 
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleStartCdataSection()
 {
+  PROXY_SYNC(BIND1(&nsExpatDriver::HandleStartCdataSection, this));
   mInCData = PR_TRUE;
 
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleEndCdataSection()
 {
+  PROXY_SYNC(BIND1(&nsExpatDriver::HandleEndCdataSection, this));
   NS_ASSERTION(mSink, "content sink not found!");
 
   mInCData = PR_FALSE;
   if (mSink) {
     nsresult rv = mSink->HandleCDataSection(mCDataText.get(),
                                             mCDataText.Length());
     MaybeStopParser(rv);
   }
@@ -585,70 +611,81 @@ nsExpatDriver::HandleEndCdataSection()
 
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleStartNamespaceDecl(const PRUnichar* aPrefix,
                                         const PRUnichar* aUri)
 {
+  PROXY_SYNC(BIND3(&nsExpatDriver::HandleStartNamespaceDecl,
+                   this, aPrefix, aUri));
   if (mExtendedSink) {
     nsresult rv = mExtendedSink->HandleStartNamespaceDecl(aPrefix, aUri);
     MaybeStopParser(rv);
   }
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleEndNamespaceDecl(const PRUnichar* aPrefix)
 {
+  PROXY_SYNC(BIND2(&nsExpatDriver::HandleEndNamespaceDecl,
+                   this, aPrefix));
   if (mExtendedSink && mInternalState != NS_ERROR_HTMLPARSER_STOPPARSING) {
     nsresult rv = mExtendedSink->HandleEndNamespaceDecl(aPrefix);
     MaybeStopParser(rv);
   }
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleNotationDecl(const PRUnichar* aNotationName,
                                   const PRUnichar* aBase,
                                   const PRUnichar* aSysid,
                                   const PRUnichar* aPubid)
 {
+  PROXY_SYNC(BIND5(&nsExpatDriver::HandleNotationDecl,
+                   this, aNotationName, aBase, aSysid, aPubid));
   if (mExtendedSink) {
     nsresult rv = mExtendedSink->HandleNotationDecl(aNotationName, aSysid,
                                                     aPubid);
     MaybeStopParser(rv);
   }
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleUnparsedEntityDecl(const PRUnichar* aEntityName,
                                         const PRUnichar* aBase,
                                         const PRUnichar* aSysid,
                                         const PRUnichar* aPubid,
                                         const PRUnichar* aNotationName)
 {
+  PROXY_SYNC(BIND6(&nsExpatDriver::HandleUnparsedEntityDecl,
+                   this, aEntityName, aBase, aSysid, aPubid, aNotationName));
   if (mExtendedSink) {
     nsresult rv = mExtendedSink->HandleUnparsedEntityDecl(aEntityName,
                                                           aSysid,
                                                           aPubid,
                                                           aNotationName);
     MaybeStopParser(rv);
   }
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleStartDoctypeDecl(const PRUnichar* aDoctypeName,
                                       const PRUnichar* aSysid,
                                       const PRUnichar* aPubid,
                                       PRBool aHasInternalSubset)
 {
+  PROXY_SYNC(BIND5(&nsExpatDriver::HandleStartDoctypeDecl,
+                   this, aDoctypeName, aSysid, aPubid, aHasInternalSubset));
+
   mDoctypeName = aDoctypeName;
   mSystemID = aSysid;
   mPublicID = aPubid;
 
   if (mExtendedSink) {
     nsresult rv = mExtendedSink->HandleStartDTD(aDoctypeName, aSysid, aPubid);
     MaybeStopParser(rv);
   }
@@ -665,16 +702,18 @@ nsExpatDriver::HandleStartDoctypeDecl(co
   }
 
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleEndDoctypeDecl()
 {
+  PROXY_SYNC(BIND1(&nsExpatDriver::HandleEndDoctypeDecl, this));
+
   NS_ASSERTION(mSink, "content sink not found!");
 
   mInInternalSubset = PR_FALSE;
 
   if (mSink) {
     // let the sink know any additional knowledge that we have about the
     // document (currently, from bug 124570, we only expect to pass additional
     // agent sheets needed to layout the XML vocabulary of the document)
@@ -716,16 +755,19 @@ ExternalDTDStreamReaderFunc(nsIUnicharIn
 }
 
 int
 nsExpatDriver::HandleExternalEntityRef(const PRUnichar *openEntityNames,
                                        const PRUnichar *base,
                                        const PRUnichar *systemId,
                                        const PRUnichar *publicId)
 {
+  PROXY_SYNC(BIND5(&nsExpatDriver::HandleExternalEntityRef,
+             this, openEntityNames, base, systemId, publicId));
+
   if (mInInternalSubset && !mInExternalDTD && openEntityNames) {
     mInternalSubset.Append(PRUnichar('%'));
     mInternalSubset.Append(nsDependentString(openEntityNames));
     mInternalSubset.Append(PRUnichar(';'));
   }
 
   // Load the external entity into a buffer.
   nsCOMPtr<nsIInputStream> in;
@@ -767,16 +809,19 @@ nsExpatDriver::HandleExternalEntityRef(c
 
 nsresult
 nsExpatDriver::OpenInputStreamFromExternalDTD(const PRUnichar* aFPIStr,
                                               const PRUnichar* aURLStr,
                                               const PRUnichar* aBaseURL,
                                               nsIInputStream** aStream,
                                               nsAString& aAbsURL)
 {
+  PROXY_SYNC(BIND6(&nsExpatDriver::OpenInputStreamFromExternalDTD,
+                   this, aFPIStr, aURLStr, aBaseURL, aStream, nsString(aAbsURL)));
+  
   nsCOMPtr<nsIURI> baseURI;
   nsresult rv = NS_NewURI(getter_AddRefs(baseURI),
                           NS_ConvertUTF16toUTF8(aBaseURL));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIURI> uri;
   rv = NS_NewURI(getter_AddRefs(uri), NS_ConvertUTF16toUTF8(aURLStr), nsnull,
                  baseURI);
@@ -887,16 +932,18 @@ AppendErrorPointer(const PRInt32 aColNum
   aSourceString.Append(PRUnichar('^'));
 
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleError()
 {
+  PROXY_SYNC(BIND1(&nsExpatDriver::HandleError, this));
+
   PRInt32 code = XML_GetErrorCode(mExpatParser);
   NS_ASSERTION(code > XML_ERROR_NONE, "unexpected XML error code");
 
   // Map Expat error code to an error string
   // XXX Deal with error returns.
   nsAutoString description;
   nsParserMsgUtils::GetLocalizedStringByID(XMLPARSER_PROPERTIES, code,
                                            description);
@@ -999,16 +1046,19 @@ nsExpatDriver::HandleError()
 }
 
 void
 nsExpatDriver::ParseBuffer(const PRUnichar *aBuffer,
                            PRUint32 aLength,
                            PRBool aIsFinal,
                            PRUint32 *aConsumed)
 {
+  PROXY_SYNC(BIND5(&nsExpatDriver::ParseBuffer, this,
+                   aBuffer, aLength, aIsFinal, aConsumed));
+
   NS_ASSERTION((aBuffer && aLength != 0) || (!aBuffer && aLength == 0), "?");
   NS_ASSERTION(mInternalState != NS_OK || aIsFinal || aBuffer,
                "Useless call, we won't call Expat");
   NS_PRECONDITION(!BlockedOrInterrupted() || !aBuffer,
                   "Non-null buffer when resuming");
   NS_PRECONDITION(XML_GetCurrentByteIndex(mExpatParser) % sizeof(PRUnichar) == 0,
                   "Consumed part of a PRUnichar?");
 
@@ -1050,16 +1100,19 @@ nsExpatDriver::ParseBuffer(const PRUnich
   else {
     *aConsumed = 0;
   }
 }
 
 NS_IMETHODIMP
 nsExpatDriver::ConsumeToken(nsScanner& aScanner, PRBool& aFlushTokens)
 {
+  PROXY_SYNC(BIND3(&nsExpatDriver::ConsumeToken, this,
+                   ref(aScanner),
+                   ref(aFlushTokens)));
   // We keep the scanner pointing to the position where Expat will start
   // parsing.
   nsScannerIterator currentExpatPosition;
   aScanner.CurrentPosition(currentExpatPosition);
 
   // This is the start of the first buffer that we need to pass to Expat.
   nsScannerIterator start = currentExpatPosition;
   start.advance(mExpatBuffered);
@@ -1220,16 +1273,20 @@ nsExpatDriver::ConsumeToken(nsScanner& a
   return NS_SUCCEEDED(mInternalState) ? kEOF : NS_OK;
 }
 
 NS_IMETHODIMP
 nsExpatDriver::WillBuildModel(const CParserContext& aParserContext,
                               nsITokenizer* aTokenizer,
                               nsIContentSink* aSink)
 {
+  PROXY_SYNC(BIND4(&nsExpatDriver::WillBuildModel, this,
+                   ref(aParserContext),
+                   aTokenizer, aSink));
+
   mSink = do_QueryInterface(aSink);
   if (!mSink) {
     NS_ERROR("nsExpatDriver didn't get an nsIExpatSink");
     // Make sure future calls to us bail out as needed
     mInternalState = NS_ERROR_UNEXPECTED;
     return mInternalState;
   }
 
@@ -1307,39 +1364,43 @@ nsExpatDriver::BuildModel(nsITokenizer* 
                           const nsCString*)// aCharsetPtr)
 {
   return mInternalState;
 }
 
 NS_IMETHODIMP
 nsExpatDriver::DidBuildModel(nsresult anErrorCode)
 {
+  PROXY_SYNC(BIND2(&nsExpatDriver::DidBuildModel, this, anErrorCode));
   mOriginalSink = nsnull;
   mSink = nsnull;
   mExtendedSink = nsnull;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsExpatDriver::WillTokenize(PRBool aIsFinalChunk,
                             nsTokenAllocator* aTokenAllocator)
 {
+  PROXY_SYNC(BIND3(&nsExpatDriver::WillTokenize, this,
+                   aIsFinalChunk, aTokenAllocator));
   mIsFinalChunk = aIsFinalChunk;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsExpatDriver::DidTokenize(PRBool aIsFinalChunk)
 {
   return NS_OK;
 }
 
 NS_IMETHODIMP_(void)
 nsExpatDriver::Terminate()
 {
+  PROXY_SYNC(BIND1(&nsExpatDriver::Terminate, this));
   // XXX - not sure what happens to the unparsed data.
   if (mExpatParser) {
     XML_StopParser(mExpatParser, XML_FALSE);
   }
   mInternalState = NS_ERROR_HTMLPARSER_STOPPARSING;
 }
 
 NS_IMETHODIMP_(PRInt32)
@@ -1425,16 +1486,18 @@ NS_IMETHODIMP_(PRBool)
 nsExpatDriver::CanContain(PRInt32 aParent,PRInt32 aChild) const
 {
   return PR_TRUE;
 }
 
 void
 nsExpatDriver::MaybeStopParser(nsresult aState)
 {
+  PROXY_SYNC(BIND2(&nsExpatDriver::MaybeStopParser, this, aState));
+
   if (NS_FAILED(aState)) {
     // If we had a failure we want to override NS_ERROR_HTMLPARSER_INTERRUPTED
     // and we want to override NS_ERROR_HTMLPARSER_BLOCK but not with
     // NS_ERROR_HTMLPARSER_INTERRUPTED.
     if (NS_SUCCEEDED(mInternalState) ||
         mInternalState == NS_ERROR_HTMLPARSER_INTERRUPTED ||
         (mInternalState == NS_ERROR_HTMLPARSER_BLOCK &&
          aState != NS_ERROR_HTMLPARSER_INTERRUPTED)) {
diff --git a/parser/htmlparser/src/nsParser.cpp b/parser/htmlparser/src/nsParser.cpp
--- a/parser/htmlparser/src/nsParser.cpp
+++ b/parser/htmlparser/src/nsParser.cpp
@@ -74,27 +74,43 @@
 #include "nsICSSStyleSheet.h"
 #include "nsICSSLoaderObserver.h"
 #include "nsICSSLoader.h"
 
 #ifdef MOZ_VIEW_SOURCE
 #include "nsViewSourceHTML.h"
 #endif
 
+#include "Bind.h"
+
 #define NS_PARSER_FLAG_PARSER_ENABLED         0x00000002
 #define NS_PARSER_FLAG_OBSERVERS_ENABLED      0x00000004
 #define NS_PARSER_FLAG_PENDING_CONTINUE_EVENT 0x00000008
 #define NS_PARSER_FLAG_CAN_INTERRUPT          0x00000010
 #define NS_PARSER_FLAG_FLUSH_TOKENS           0x00000020
 #define NS_PARSER_FLAG_CAN_TOKENIZE           0x00000040
 
 static NS_DEFINE_IID(kISupportsIID, NS_ISUPPORTS_IID);
 static NS_DEFINE_CID(kCParserCID, NS_PARSER_CID);
 static NS_DEFINE_IID(kIParserIID, NS_IPARSER_IID);
 
+#define PROXY_SYNC_EXPR(TARGET, BOUND)                                        \
+  (BOUND).proxy((TARGET), NS_DISPATCH_SYNC)->Wait()
+
+#define PROXY_SYNC(BOUND)                                                     \
+  PR_BEGIN_MACRO                                                              \
+    if (NS_GetCurrentThread() != mParserThread.get())                         \
+      return PROXY_SYNC_EXPR(mParserThread, BOUND);                           \
+  PR_END_MACRO
+
+#define TRIVIAL_PROXY_SYNC(METHOD)                                            \
+  PROXY_SYNC(BIND1(&nsParser::METHOD,                                         \
+                   nsRefPtr<nsParser>(const_cast<nsParser*>(this))))
+
+
 //-------------------------------------------------------------------
 
 nsCOMArray<nsIUnicharStreamListener> *nsParser::sParserDataListeners;
 
 //-------------- Begin ParseContinue Event Definition ------------------------
 /*
 The parser can be explicitly interrupted by passing a return value of
 NS_ERROR_HTMLPARSER_INTERRUPTED from BuildModel on the DTD. This will cause
@@ -813,16 +829,18 @@ nsParser::Initialize(PRBool aConstructor
   mCharset.AssignLiteral("ISO-8859-1");
   mInternalState = NS_OK;
   mStreamStatus = 0;
   mCommand = eViewNormal;
   mFlags = NS_PARSER_FLAG_OBSERVERS_ENABLED |
            NS_PARSER_FLAG_PARSER_ENABLED |
            NS_PARSER_FLAG_CAN_TOKENIZE;
 
+  NS_GetCurrentThread(getter_AddRefs(mParserThread));
+
   MOZ_TIMER_DEBUGLOG(("Reset: Parse Time: nsParser::nsParser(), this=%p\n", this));
   MOZ_TIMER_RESET(mParseTime);
   MOZ_TIMER_RESET(mDTDTime);
   MOZ_TIMER_RESET(mTokenizeTime);
 }
 
 void
 nsParser::Cleanup()
@@ -914,16 +932,19 @@ nsParser::PostContinueEvent()
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP_(void)
 nsParser::SetParserFilter(nsIParserFilter * aFilter)
 {
+  PROXY_SYNC(BIND2(&nsParser::SetParserFilter,
+                   nsRefPtr<nsParser>(this),
+                   nsRefPtr<nsIParserFilter>(aFilter)));
   mParserFilter = aFilter;
 }
 
 NS_IMETHODIMP_(void)
 nsParser::GetCommand(nsCString& aCommand)
 {
   aCommand = mCommandStr;
 }
@@ -933,16 +954,22 @@ nsParser::GetCommand(nsCString& aCommand
  *  about the command which caused the parser to be constructed. For example,
  *  this allows us to select a DTD which can do, say, view-source.
  *
  *  @param   aCommand the command string to set
  */
 NS_IMETHODIMP_(void)
 nsParser::SetCommand(const char* aCommand)
 {
+  // TODO is aCommand safe? stick with SYNC?
+  typedef void (nsParser::*SetCommandPtr)(const char*);
+  PROXY_SYNC(BIND2(static_cast<SetCommandPtr>(&nsParser::SetCommand),
+                   nsRefPtr<nsParser>(this),
+                   aCommand));
+
   mCommandStr.Assign(aCommand);
   if (mCommandStr.Equals(kViewSourceCommand)) {
     mCommand = eViewSource;
   } else if (mCommandStr.Equals(kViewFragmentCommand)) {
     mCommand = eViewFragment;
   } else {
     mCommand = eViewNormal;
   }
@@ -953,29 +980,39 @@ nsParser::SetCommand(const char* aComman
  *  about the command which caused the parser to be constructed. For example,
  *  this allows us to select a DTD which can do, say, view-source.
  *
  *  @param   aParserCommand the command to set
  */
 NS_IMETHODIMP_(void)
 nsParser::SetCommand(eParserCommands aParserCommand)
 {
+  typedef void (nsParser::*SetCommandPtr)(eParserCommands);
+  PROXY_SYNC(BIND2(static_cast<SetCommandPtr>(&nsParser::SetCommand),
+                   nsRefPtr<nsParser>(this),
+                   aParserCommand));
+
   mCommand = aParserCommand;
 }
 
 /**
  *  Call this method once you've created a parser, and want to instruct it
  *  about what charset to load
  *
  *  @param   aCharset- the charset of a document
  *  @param   aCharsetSource- the source of the charset
  */
 NS_IMETHODIMP_(void)
 nsParser::SetDocumentCharset(const nsACString& aCharset, PRInt32 aCharsetSource)
 {
+  PROXY_SYNC(BIND3(&nsParser::SetDocumentCharset,
+                   nsRefPtr<nsParser>(this),
+                   nsCString(aCharset),
+                   aCharsetSource));
+
   mCharset = aCharset;
   mCharsetSource = aCharsetSource;
   if (mParserContext && mParserContext->mScanner) {
      mParserContext->mScanner->SetDocumentCharset(aCharset, aCharsetSource);
   }
 }
 
 void
@@ -990,31 +1027,35 @@ nsParser::SetSinkCharset(nsACString& aCh
  *  This method gets called in order to set the content
  *  sink for this parser to dump nodes to.
  *
  *  @param   nsIContentSink interface for node receiver
  */
 NS_IMETHODIMP_(void)
 nsParser::SetContentSink(nsIContentSink* aSink)
 {
+  PROXY_SYNC(BIND2(&nsParser::SetContentSink,
+                   nsRefPtr<nsParser>(this),
+                   aSink));
   NS_PRECONDITION(aSink, "sink cannot be null!");
   mSink = aSink;
 
   if (mSink) {
     mSink->SetParser(this);
   }
 }
 
 /**
  * retrieve the sink set into the parser
  * @return  current sink
  */
 NS_IMETHODIMP_(nsIContentSink*)
 nsParser::GetContentSink()
 {
+  TRIVIAL_PROXY_SYNC(GetContentSink);
   return mSink;
 }
 
 /**
  * Determine what DTD mode (and thus what layout nsCompatibility mode)
  * to use for this document based on the first chunk of data received
  * from the network (each parsercontext can have its own mode).  (No,
  * this is not an optimal solution -- we really don't need to know until
@@ -1617,16 +1658,18 @@ void
 nsParser::SetUnusedInput(nsString& aBuffer)
 {
   mUnusedInput = aBuffer;
 }
 
 NS_IMETHODIMP_(void *)
 nsParser::GetRootContextKey()
 {
+  TRIVIAL_PROXY_SYNC(GetRootContextKey);
+
   CParserContext* pc = mParserContext;
   if (!pc) {
     return nsnull;
   }
 
   while (pc->mPrevContext) {
     pc = pc->mPrevContext;
   }
@@ -1637,16 +1680,18 @@ nsParser::GetRootContextKey()
 /**
  *  Call this when you want to *force* the parser to terminate the
  *  parsing process altogether. This is binary -- so once you terminate
  *  you can't resume without restarting altogether.
  */
 NS_IMETHODIMP
 nsParser::Terminate(void)
 {
+  TRIVIAL_PROXY_SYNC(Terminate);
+
   // We should only call DidBuildModel once, so don't do anything if this is
   // the second time that Terminate has been called.
   if (mInternalState == NS_ERROR_HTMLPARSER_STOPPARSING) {
     return NS_OK;
   }
 
   nsresult result = NS_OK;
   // XXX - [ until we figure out a way to break parser-sink circularity ]
@@ -1859,33 +1904,55 @@ nsParser::SetCanInterrupt(PRBool aCanInt
  *  of this method.
  */
 NS_IMETHODIMP
 nsParser::Parse(nsIURI* aURL,
                 nsIRequestObserver* aListener,
                 void* aKey,
                 nsDTDMode aMode)
 {
+  nsresult result = kBadURL;
 
   NS_PRECONDITION(aURL, "Error: Null URL given");
+  NS_ENSURE_TRUE(aURL, result);
+
+  nsCAutoString spec;
+  result = aURL->GetSpec(spec);
+  nsString* utf16p = NS_SUCCEEDED(result)
+    ? new NS_ConvertUTF8toUTF16(spec)
+    : nsnull;
+
+  Functor<nsresult, TLIST0()> handle =
+    BIND5(&nsParser::HandleParseBuffer,
+          nsRefPtr<nsParser>(this),
+          utf16p,
+          nsRefPtr<nsIRequestObserver>(aListener),
+          aKey,
+          aMode);
+
+  PROXY_SYNC(handle);
+
+  return handle();
+}
+
+nsresult
+nsParser::HandleParseBuffer(nsString* theName,
+                            nsIRequestObserver* aListener,
+                            void* aKey,
+                            nsDTDMode aMode)
+{
   NS_ASSERTION(!mSpeculativeScriptThread, "Can't reuse a parser like this");
 
   nsresult result=kBadURL;
   mObserver = aListener;
 
-  if (aURL) {
-    nsCAutoString spec;
-    nsresult rv = aURL->GetSpec(spec);
-    if (rv != NS_OK) {
-      return rv;
-    }
-    NS_ConvertUTF8toUTF16 theName(spec);
-
-    nsScanner* theScanner = new nsScanner(theName, PR_FALSE, mCharset,
+  if (theName) {
+    nsScanner* theScanner = new nsScanner(*theName, PR_FALSE, mCharset,
                                           mCharsetSource);
+    delete theName;
     CParserContext* pc = new CParserContext(mParserContext, theScanner, aKey,
                                             mCommand, aListener);
     if (pc && theScanner) {
       pc->mMultipart = PR_TRUE;
       pc->mContextType = CParserContext::eCTURL;
       pc->mDTDMode = aMode;
       PushContext(*pc);
 
@@ -1906,23 +1973,40 @@ nsParser::Parse(nsIURI* aURL,
 /**
  * Call this method if all you want to do is parse 1 string full of HTML text.
  * In particular, this method should be called by the DOM when it has an HTML
  * string to feed to the parser in real-time.
  *
  * @param   aSourceBuffer contains a string-full of real content
  * @param   aMimeType tells us what type of content to expect in the given string
  */
+
+#define PARSE_BUFFER_PARAMS                                                   \
+ (const nsAString& aSourceBuffer,                                             \
+  void* aKey,                                                                 \
+  const nsACString& aMimeType,                                                \
+  PRBool aLastCall,                                                           \
+  nsDTDMode aMode)
+
 NS_IMETHODIMP
-nsParser::Parse(const nsAString& aSourceBuffer,
-                void* aKey,
-                const nsACString& aMimeType,
-                PRBool aLastCall,
-                nsDTDMode aMode)
+nsParser::Parse PARSE_BUFFER_PARAMS
 {
+  // necessary because nsParser::Parse is overloaded:
+  typedef nsresult (nsParser::*ParseBufferPtr) PARSE_BUFFER_PARAMS;
+  PROXY_SYNC(BIND6(static_cast<ParseBufferPtr>(&nsParser::Parse),
+                   nsRefPtr<nsParser>(this),
+                   nsString(aSourceBuffer),
+                   aKey,
+                   nsCString(aMimeType),
+                   aLastCall,
+                   aMode));
+
+// sayonara, macro scum!
+#undef PARSE_BUFFER_PARAMS
+
   nsresult result = NS_OK;
 
   // Don't bother if we're never going to parse this.
   if (mInternalState == NS_ERROR_HTMLPARSER_STOPPARSING) {
     return result;
   }
 
   if (!aLastCall && aSourceBuffer.IsEmpty()) {
@@ -2040,16 +2124,25 @@ nsParser::Parse(const nsAString& aSource
 NS_IMETHODIMP
 nsParser::ParseFragment(const nsAString& aSourceBuffer,
                         void* aKey,
                         nsTArray<nsString>& aTagStack,
                         PRBool aXMLMode,
                         const nsACString& aMimeType,
                         nsDTDMode aMode)
 {
+  PROXY_SYNC(BIND7(&nsParser::ParseFragment,
+                   nsRefPtr<nsParser>(this),
+                   nsString(aSourceBuffer),
+                   aKey,
+                   nsTArray<nsString>(aTagStack),
+                   aXMLMode,
+                   nsCString(aMimeType),
+                   aMode));
+
   nsresult result = NS_OK;
   nsAutoString  theContext;
   PRUint32 theCount = aTagStack.Length();
   PRUint32 theIndex = 0;
 
   // Disable observers for fragments
   mFlags &= ~NS_PARSER_FLAG_OBSERVERS_ENABLED;
 
@@ -2359,16 +2452,21 @@ nsParser::BuildModel()
 
 /*******************************************************************
   These methods are used to talk to the netlib system...
  *******************************************************************/
 
 nsresult
 nsParser::OnStartRequest(nsIRequest *request, nsISupports* aContext)
 {
+  PROXY_SYNC(BIND3(&nsParser::OnStartRequest,
+                   nsRefPtr<nsParser>(this),
+                   nsRefPtr<nsIRequest>(request),
+                   nsRefPtr<nsISupports>(aContext)));
+
   NS_PRECONDITION(eNone == mParserContext->mStreamListenerState,
                   "Parser's nsIStreamListener API was not setup "
                   "correctly in constructor.");
   if (mObserver) {
     mObserver->OnStartRequest(request, aContext);
   }
   mParserContext->mStreamListenerState = eOnStart;
   mParserContext->mAutoDetectStatus = eUnknownDetect;
@@ -2784,33 +2882,51 @@ CheckCharset(const char* aBytes,
   }
 }
 
 nsresult
 nsParser::OnDataAvailable(nsIRequest *request, nsISupports* aContext,
                           nsIInputStream *pIStream, PRUint32 sourceOffset,
                           PRUint32 aLength)
 {
-  NS_PRECONDITION((eOnStart == mParserContext->mStreamListenerState ||
-                   eOnDataAvail == mParserContext->mStreamListenerState),
-            "Error: OnStartRequest() must be called before OnDataAvailable()");
   NS_PRECONDITION(NS_InputStreamIsBuffered(pIStream),
                   "Must have a buffered input stream");
 
-  nsresult rv = NS_OK;
-
   char *data = new char[aLength + 1];
   PRUint32 totalRead;
-  rv = pIStream->Read(data, aLength, &totalRead);
+  nsresult rv = pIStream->Read(data, aLength, &totalRead);
   if (NS_FAILED(rv)) {
     delete[] data;
     return rv;
   }
   data[aLength] = 0;
 
+  Functor<nsresult, TLIST0()> handle =
+    BIND5(&nsParser::HandleDataAvailable,
+          nsRefPtr<nsParser>(this),
+          nsRefPtr<nsIRequest>(request),
+          data, totalRead, sourceOffset);
+
+  PROXY_SYNC(handle);
+
+  return handle();
+}
+
+nsresult
+nsParser::HandleDataAvailable(nsIRequest* request,
+                              char* data,
+                              PRUint32 totalRead,
+                              PRUint32 sourceOffset)
+{
+  NS_PRECONDITION((eOnStart == mParserContext->mStreamListenerState ||
+                   eOnDataAvail == mParserContext->mStreamListenerState),
+            "Error: OnStartRequest() must be called before OnDataAvailable()");
+
+  nsresult rv = NS_OK;
+
   CParserContext *theContext = mParserContext;
 
   while (theContext && theContext->mRequest != request) {
     theContext = theContext->mPrevContext;
   }
 
   if (theContext) {
     theContext->mStreamListenerState = eOnDataAvail;
@@ -2856,16 +2972,22 @@ nsParser::OnDataAvailable(nsIRequest *re
 /**
  *  This is called by the networking library once the last block of data
  *  has been collected from the net.
  */
 nsresult
 nsParser::OnStopRequest(nsIRequest *request, nsISupports* aContext,
                         nsresult status)
 {
+  PROXY_SYNC(BIND4(&nsParser::OnStopRequest,
+                   nsRefPtr<nsParser>(this),
+                   nsRefPtr<nsIRequest>(request),
+                   nsRefPtr<nsISupports>(aContext),
+                   status));
+
   nsresult rv = NS_OK;
 
   if (mSpeculativeScriptThread) {
     mSpeculativeScriptThread->StopParsing(PR_FALSE);
   }
 
   CParserContext *pc = mParserContext;
   while (pc) {
diff --git a/parser/htmlparser/src/nsParser.h b/parser/htmlparser/src/nsParser.h
--- a/parser/htmlparser/src/nsParser.h
+++ b/parser/htmlparser/src/nsParser.h
@@ -403,16 +403,30 @@ class nsParser : public nsIParser,
      * @update	gess5/18/98
      * @param 
      * @return
      */
     nsresult DidBuildModel(nsresult anErrorCode);
 
     void SpeculativelyParse();
 
+    nsresult
+    HandleParseBuffer(
+      nsString* theName,
+      nsIRequestObserver* aListener,
+      void* aKey,
+      nsDTDMode aMode);
+
+    nsresult
+    HandleDataAvailable(
+      nsIRequest* request,
+      char* data,
+      PRUint32 totalRead,
+      PRUint32 sourceOffset);
+
 private:
 
     /*******************************************
       These are the tokenization methods...
      *******************************************/
 
     /**
      *  Part of the code sandwich, this gets called right before
@@ -446,18 +460,19 @@ private:
      *  @return  TRUE if all went well
      */
     PRBool DidTokenize(PRBool aIsFinalChunk = PR_FALSE);
 
 protected:
     //*********************************************
     // And now, some data members...
     //*********************************************
-    
-      
+
+    nsRefPtr<nsIThread> mParserThread;
+
     CParserContext*              mParserContext;
     nsCOMPtr<nsIDTD>             mDTD;
     nsCOMPtr<nsIRequestObserver> mObserver;
     nsCOMPtr<nsIContentSink>     mSink;
     nsIRunnable*                 mContinueEvent;  // weak ref
     nsRefPtr<nsSpeculativeScriptThread> mSpeculativeScriptThread;
    
     nsCOMPtr<nsIParserFilter> mParserFilter;
