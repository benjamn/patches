* * *

diff --git a/content/html/document/src/nsHTMLContentSink.cpp b/content/html/document/src/nsHTMLContentSink.cpp
--- a/content/html/document/src/nsHTMLContentSink.cpp
+++ b/content/html/document/src/nsHTMLContentSink.cpp
@@ -119,16 +119,20 @@
 #include "nsIDocShellTreeItem.h"
 
 #include "nsEscape.h"
 #include "nsIElementObserver.h"
 #include "nsNodeInfoManager.h"
 #include "nsContentCreatorFunctions.h"
 #include "mozAutoDocUpdate.h"
 
+#include "Bind.h"
+#include "nsRunnableFunctor.h"
+#include "nsThreadUtils.h"
+
 #ifdef NS_DEBUG
 static PRLogModuleInfo* gSinkLogModuleInfo;
 
 #define SINK_TRACE_NODE(_bit, _msg, _tag, _sp, _obj) \
   _obj->SinkTraceNode(_bit, _msg, _tag, _sp, this)
 
 #else
 #define SINK_TRACE_NODE(_bit, _msg, _tag, _sp, _obj)
@@ -149,16 +153,49 @@ NS_NewHTMLNOTUSEDElement(nsINodeInfo *aN
 #define HTML_OTHER(_tag) NS_NewHTMLNOTUSEDElement,
 static const contentCreatorCallback sContentCreatorCallbacks[] = {
   NS_NewHTMLUnknownElement,
 #include "nsHTMLTagList.h"
 #undef HTML_TAG
 #undef HTML_OTHER
   NS_NewHTMLUnknownElement
 };
+
+#define PROXY_SYNC(BOUND)                                                     \
+  PR_BEGIN_MACRO                                                              \
+    nsIThread* thread = nsnull;                                               \
+    NS_GetCurrentThread(&thread);                                             \
+    if (mSinkThread.get() != thread)                                          \
+      return (BOUND).proxy(mSinkThread, NS_DISPATCH_SYNC)->Wait();            \
+  PR_END_MACRO
+
+#define TRIVIAL_PROXY_SYNC(METHOD)                                            \
+  PROXY_SYNC(BIND1(&HTMLContentSink::METHOD,                                  \
+                   nsRefPtr<HTMLContentSink>                                  \
+                           (const_cast<HTMLContentSink*>(this))))
+
+template <typename T>
+class AutoDerefHolder {
+  T* mPtr;
+public:
+  AutoDerefHolder(T& t) : mPtr(&t) {}
+  operator T&() { return *mPtr; }
+  operator T*() { return mPtr; }
+};
+
+template <typename T>
+static AutoDerefHolder<T>
+make_adf(T& t) {
+  return AutoDerefHolder<T>(t);
+}
+
+#define PARSER_NODE_PROXY_SYNC(METHOD, NODE)                                  \
+  PROXY_SYNC(BIND2(&HTMLContentSink::METHOD,                                  \
+                   nsRefPtr<HTMLContentSink>(this),                           \
+                   make_adf(NODE)))
 
 class SinkContext;
 class HTMLContentSink;
 
 static void MaybeSetForm(nsGenericHTMLElement*, nsHTMLTag, HTMLContentSink*);
 
 class HTMLContentSink : public nsContentSink,
 #ifdef DEBUG
@@ -229,16 +266,18 @@ protected:
 
 #ifdef NS_DEBUG
   void SinkTraceNode(PRUint32 aBit,
                      const char* aMsg,
                      const nsHTMLTag aTag,
                      PRInt32 aStackPos,
                      void* aThis);
 #endif
+
+  nsRefPtr<nsIThread> mSinkThread;
 
   nsIHTMLDocument* mHTMLDocument;
 
   // The maximum length of a text run
   PRInt32 mMaxTextRun;
 
   nsGenericHTMLElement* mRoot;
   nsGenericHTMLElement* mBody;
@@ -1628,16 +1667,17 @@ nsresult
 nsresult
 HTMLContentSink::Init(nsIDocument* aDoc,
                       nsIURI* aURI,
                       nsISupports* aContainer,
                       nsIChannel* aChannel)
 {
   NS_ENSURE_TRUE(aContainer, NS_ERROR_NULL_POINTER);
 
+  NS_GetCurrentThread(getter_AddRefs(mSinkThread));
 
   MOZ_TIMER_DEBUGLOG(("Reset and start: nsHTMLContentSink::Init(), this=%p\n",
                       this));
   MOZ_TIMER_RESET(mWatch);
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = nsContentSink::Init(aDoc, aURI, aContainer, aChannel);
   if (NS_FAILED(rv)) {
@@ -1739,22 +1779,25 @@ HTMLContentSink::Init(nsIDocument* aDoc,
   MOZ_TIMER_STOP(mWatch);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::WillParse(void)
 {
+  TRIVIAL_PROXY_SYNC(WillParse);
   return WillParseImpl();
 }
 
 NS_IMETHODIMP
 HTMLContentSink::WillBuildModel(void)
 {
+  TRIVIAL_PROXY_SYNC(WillBuildModel);
+
   WillBuildModelImpl();
   if (mHTMLDocument) {
     NS_ASSERTION(mParser, "no parser");
     nsCompatibility mode = eCompatibility_NavQuirks;
     if (mParser) {
       nsDTDMode dtdMode = mParser->GetParseMode();
       switch (dtdMode) {
         case eDTDMode_full_standards:
@@ -1778,16 +1821,18 @@ HTMLContentSink::WillBuildModel(void)
   mDocument->BeginLoad();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::DidBuildModel(void)
 {
+  TRIVIAL_PROXY_SYNC(DidBuildModel);
+
   // NRA Dump stopwatch stop info here
 #ifdef MOZ_PERF_METRICS
   MOZ_TIMER_DEBUGLOG(("Stop: nsHTMLContentSink::DidBuildModel(), this=%p\n",
                       this));
   MOZ_TIMER_STOP(mWatch);
   MOZ_TIMER_LOG(("Content creation time (this=%p): ", this));
   MOZ_TIMER_PRINT(mWatch);
 #endif
@@ -1842,30 +1887,39 @@ HTMLContentSink::ReadyToCallDidBuildMode
 HTMLContentSink::ReadyToCallDidBuildModel(PRBool aTerminated)
 {
   return ReadyToCallDidBuildModelImpl(aTerminated);
 }
 
 NS_IMETHODIMP
 HTMLContentSink::SetParser(nsIParser* aParser)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::SetParser,
+                   nsRefPtr<HTMLContentSink>(this),
+                   nsRefPtr<nsIParser>(aParser)));
+
   NS_PRECONDITION(aParser, "Should have a parser here!");
   mParser = aParser;
   return NS_OK;
 }
 
 NS_IMETHODIMP_(PRBool)
 HTMLContentSink::IsFormOnStack()
 {
+  TRIVIAL_PROXY_SYNC(IsFormOnStack);
   return mFormOnStack;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::BeginContext(PRInt32 aPosition)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::BeginContext,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aPosition));
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::BeginContext()\n"));
   MOZ_TIMER_START(mWatch);
   NS_PRECONDITION(aPosition > -1, "out of bounds");
 
   // Create new context
   SinkContext* sc = new SinkContext(this);
   if (!sc) {
     MOZ_TIMER_DEBUGLOG(("Stop: nsHTMLContentSink::BeginContext()\n"));
@@ -1914,16 +1968,20 @@ HTMLContentSink::BeginContext(PRInt32 aP
   MOZ_TIMER_STOP(mWatch);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::EndContext(PRInt32 aPosition)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::EndContext,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aPosition));
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::EndContext()\n"));
   MOZ_TIMER_START(mWatch);
   NS_PRECONDITION(mCurrentContext && aPosition > -1, "non-existing context");
 
   PRInt32 n = mContextStack.Count() - 1;
   SinkContext* sc = (SinkContext*) mContextStack.ElementAt(n);
 
   const SinkContext::Node &bottom = mCurrentContext->mStack[0];
@@ -2004,16 +2062,18 @@ HTMLContentSink::CloseHTML()
   MOZ_TIMER_STOP(mWatch);
 
   return NS_OK;
 }
 
 nsresult
 HTMLContentSink::OpenHead()
 {
+  TRIVIAL_PROXY_SYNC(OpenHead);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::OpenHead()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = OpenHeadContext();
 
   MOZ_TIMER_DEBUGLOG(("Stop: nsHTMLContentSink::OpenHead()\n"));
   MOZ_TIMER_STOP(mWatch);
 
@@ -2296,32 +2356,39 @@ HTMLContentSink::CloseFrameset()
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::IsEnabled(PRInt32 aTag, PRBool* aReturn)
 {
+  PROXY_SYNC(BIND3(&HTMLContentSink::IsEnabled,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aTag,
+                   aReturn));
+
   nsHTMLTag theHTMLTag = nsHTMLTag(aTag);
 
   if (theHTMLTag == eHTMLTag_script) {
     *aReturn = mScriptEnabled;
   } else if (theHTMLTag == eHTMLTag_frameset) {
     *aReturn = mFramesEnabled;
   } else {
     *aReturn = PR_FALSE;
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::OpenContainer(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(OpenContainer, aNode);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::OpenContainer()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = NS_OK;
 
   switch (aNode.GetNodeType()) {
     case eHTMLTag_frameset:
       rv = OpenFrameset(aNode);
@@ -2359,16 +2426,20 @@ HTMLContentSink::OpenContainer(const nsI
   MOZ_TIMER_STOP(mWatch);
 
   return rv;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::CloseContainer(const eHTMLTags aTag)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::CloseContainer,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aTag));
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::CloseContainer()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = NS_OK;
 
   switch (aTag) {
     case eHTMLTag_frameset:
       rv = CloseFrameset();
@@ -2400,16 +2471,18 @@ HTMLContentSink::CloseMalformedContainer
 HTMLContentSink::CloseMalformedContainer(const eHTMLTags aTag)
 {
   return mCurrentContext->CloseContainer(aTag, PR_TRUE);
 }
 
 NS_IMETHODIMP
 HTMLContentSink::AddLeaf(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(AddLeaf, aNode);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::AddLeaf()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv;
 
   nsHTMLTag nodeType = nsHTMLTag(aNode.GetNodeType());
   switch (nodeType) {
   case eHTMLTag_link:
@@ -2433,16 +2506,18 @@ HTMLContentSink::AddLeaf(const nsIParser
  * This gets called by the parsing system when we find a comment
  * @update	gess11/9/98
  * @param   aNode contains a comment token
  * @return  error code
  */
 nsresult
 HTMLContentSink::AddComment(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(AddComment, aNode);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::AddComment()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = mCurrentContext->AddComment(aNode);
 
   MOZ_TIMER_DEBUGLOG(("Stop: nsHTMLContentSink::AddComment()\n"));
   MOZ_TIMER_STOP(mWatch);
 
@@ -2453,16 +2528,18 @@ HTMLContentSink::AddComment(const nsIPar
  * This gets called by the parsing system when we find a PI
  * @update	gess11/9/98
  * @param   aNode contains a comment token
  * @return  error code
  */
 nsresult
 HTMLContentSink::AddProcessingInstruction(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(AddProcessingInstruction, aNode);
+
   nsresult result = NS_OK;
 
   MOZ_TIMER_START(mWatch);
   // Implementation of AddProcessingInstruction() should start here
 
   MOZ_TIMER_STOP(mWatch);
 
   return result;
@@ -2471,16 +2548,18 @@ HTMLContentSink::AddProcessingInstructio
 /**
  *  This gets called by the parser when it encounters
  *  a DOCTYPE declaration in the HTML document.
  */
 
 NS_IMETHODIMP
 HTMLContentSink::AddDocTypeDecl(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(AddDocTypeDecl, aNode);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::AddDocTypeDecl()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsAutoString docTypeStr(aNode.GetText());
   nsresult rv = NS_OK;
 
   PRInt32 publicStart = docTypeStr.Find("PUBLIC", PR_TRUE);
   PRInt32 systemStart = docTypeStr.Find("SYSTEM", PR_TRUE);
@@ -2715,34 +2794,39 @@ HTMLContentSink::WillProcessAToken(void)
 HTMLContentSink::WillProcessAToken(void)
 {
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::DidProcessAToken(void)
 {
+  TRIVIAL_PROXY_SYNC(DidProcessAToken);
   return DidProcessATokenImpl();
 }
 
 NS_IMETHODIMP
 HTMLContentSink::WillInterrupt()
 {
+  TRIVIAL_PROXY_SYNC(WillInterrupt);
   return WillInterruptImpl();
 }
 
 NS_IMETHODIMP
 HTMLContentSink::WillResume()
 {
+  TRIVIAL_PROXY_SYNC(WillResume);
   return WillResumeImpl();
 }
 
 NS_IMETHODIMP
 HTMLContentSink::NotifyTagObservers(nsIParserNode* aNode)
 {
+  PARSER_NODE_PROXY_SYNC(NotifyTagObservers, *aNode);
+
   // Bug 125317
   // Inform observers that we're handling a document.write().
   // This information is necessary for the charset observer, atleast,
   // to make a decision whether a new charset loading is required or not.
 
   if (!mObservers) {
     return NS_OK;
   }
@@ -3184,16 +3268,20 @@ HTMLContentSink::ProcessSTYLEEndTag(nsGe
   }
 
   return rv;
 }
 
 void
 HTMLContentSink::FlushPendingNotifications(mozFlushType aType)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::FlushPendingNotifications,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aType));
+
   // Only flush tags if we're not doing the notification ourselves
   // (since we aren't reentrant)
   if (!mInNotification) {
     if (aType >= Flush_ContentAndNotify) {
       FlushTags();
     }
     else if (mCurrentContext) {
       mCurrentContext->FlushText();
@@ -3215,16 +3303,20 @@ HTMLContentSink::FlushTags()
   }
   
   return mCurrentContext ? mCurrentContext->FlushTags() : NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::SetDocumentCharset(nsACString& aCharset)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::SetDocumentCharset,
+                   nsRefPtr<HTMLContentSink>(this),
+                   nsCString(aCharset)));
+
   if (mDocShell) {
     // the following logic to get muCV is copied from
     // nsHTMLDocument::StartDocumentLoad
     // We need to call muCV->SetPrevDocCharacterSet here in case
     // the charset is detected by parser DetectMetaTag
     nsCOMPtr<nsIMarkupDocumentViewer> muCV;
     nsCOMPtr<nsIContentViewer> cv;
     mDocShell->GetContentViewer(getter_AddRefs(cv));
@@ -3263,16 +3355,17 @@ HTMLContentSink::SetDocumentCharset(nsAC
   }
 
   return NS_OK;
 }
 
 nsISupports *
 HTMLContentSink::GetTarget()
 {
+  TRIVIAL_PROXY_SYNC(GetTarget);
   return mDocument;
 }
 
 #ifdef DEBUG
 /**
  *  This will dump content model into the output file.
  *
  *  @update  harishd 05/25/00
diff --git a/content/xul/document/src/nsXULContentSink.cpp b/content/xul/document/src/nsXULContentSink.cpp
--- a/content/xul/document/src/nsXULContentSink.cpp
+++ b/content/xul/document/src/nsXULContentSink.cpp
@@ -88,16 +88,18 @@
 #include "nsUnicharUtils.h"
 #include "nsGkAtoms.h"
 #include "nsContentUtils.h"
 #include "nsAttrName.h"
 #include "nsXMLContentSink.h"
 #include "nsIConsoleService.h"
 #include "nsIScriptError.h"
 
+#include "Bind.h"
+
 #ifdef PR_LOGGING
 static PRLogModuleInfo* gLog;
 #endif
 
 //----------------------------------------------------------------------
 
 XULContentSinkImpl::ContextStack::ContextStack()
     : mTop(nsnull), mDepth(0)
@@ -268,16 +270,20 @@ XULContentSinkImpl::WillBuildModel(void)
 #endif
 
     return NS_OK;
 }
 
 NS_IMETHODIMP 
 XULContentSinkImpl::DidBuildModel(void)
 {
+    if (!NS_IsMainThread())
+        return BIND1(&XULContentSinkImpl::DidBuildModel,
+                     this).proxy(nsnull, NS_DISPATCH_SYNC)->Wait();
+
     nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocument);
     if (doc) {
         doc->EndLoad();
         mDocument = nsnull;
     }
 
     // Drop our reference to the parser to get rid of a circular
     // reference.
@@ -448,16 +454,22 @@ XULContentSinkImpl::FlushText(PRBool aCr
 }
 
 //----------------------------------------------------------------------
 
 nsresult
 XULContentSinkImpl::NormalizeAttributeString(const PRUnichar *aExpatName,
                                              nsAttrName &aName)
 {
+    if (!NS_IsMainThread())
+        return BIND3(&XULContentSinkImpl::NormalizeAttributeString,
+                     nsRefPtr<XULContentSinkImpl>(this),
+                     aExpatName,
+                     aName).proxy(nsnull, NS_DISPATCH_SYNC)->Wait();
+
     PRInt32 nameSpaceID;
     nsCOMPtr<nsIAtom> prefix, localName;
     nsContentUtils::SplitExpatName(aExpatName, getter_AddRefs(prefix),
                                    getter_AddRefs(localName), &nameSpaceID);
 
     if (nameSpaceID == kNameSpaceID_None) {
         aName.SetTo(localName);
 
@@ -492,17 +504,26 @@ XULContentSinkImpl::CreateElement(nsINod
 
 
 NS_IMETHODIMP 
 XULContentSinkImpl::HandleStartElement(const PRUnichar *aName, 
                                        const PRUnichar **aAtts,
                                        PRUint32 aAttsCount, 
                                        PRInt32 aIndex, 
                                        PRUint32 aLineNumber)
-{ 
+{
+  if (!NS_IsMainThread())
+    return BIND6(&XULContentSinkImpl::HandleStartElement,
+                 this,
+                 aName,
+                 aAtts,
+                 aAttsCount,
+                 aIndex,
+                 aLineNumber).proxy(nsnull, NS_DISPATCH_SYNC)->Wait();
+
   // XXX Hopefully the parser will flag this before we get here. If
   // we're in the epilog, there should be no new elements
   NS_PRECONDITION(mState != eInEpilog, "tag in XUL doc epilog");
   NS_PRECONDITION(aIndex >= -1, "Bogus aIndex");
   NS_PRECONDITION(aAttsCount % 2 == 0, "incorrect aAttsCount");
   // Adjust aAttsCount so it's the actual number of attributes
   aAttsCount /= 2;
   
diff --git a/parser/htmlparser/src/nsExpatDriver.cpp b/parser/htmlparser/src/nsExpatDriver.cpp
--- a/parser/htmlparser/src/nsExpatDriver.cpp
+++ b/parser/htmlparser/src/nsExpatDriver.cpp
@@ -56,16 +56,19 @@
 #include "nsCRT.h"
 #include "nsIConsoleService.h"
 #include "nsIScriptError.h"
 #include "nsIContentPolicy.h"
 #include "nsContentPolicyUtils.h"
 #include "nsContentErrors.h"
 #include "nsXPCOMCIDInternal.h"
 #include "nsUnicharInputStream.h"
+
+#include "nsThreadUtils.h"
+#include "Bind.h"
 
 #define kExpatSeparatorChar 0xFFFF
 
 static const PRUnichar kUTF16[] = { 'U', 'T', 'F', '-', '1', '6', '\0' };
 
 #ifdef PR_LOGGING
 static PRLogModuleInfo *gExpatDriverLog = PR_NewLogModule("expatdriver");
 #endif
@@ -424,20 +427,25 @@ nsExpatDriver::HandleStartElement(const 
   PRUint32 attrArrayLength;
   for (attrArrayLength = XML_GetSpecifiedAttributeCount(mExpatParser);
        aAtts[attrArrayLength];
        attrArrayLength += 2) {
     // Just looping till we find out what the length is
   }
 
   if (mSink) {
-    nsresult rv = mSink->
-      HandleStartElement(aValue, aAtts, attrArrayLength,
-                         XML_GetIdAttributeIndex(mExpatParser),
-                         XML_GetCurrentLineNumber(mExpatParser));
+    PRUint32 attrIndex = XML_GetIdAttributeIndex(mExpatParser),
+            lineNumber = XML_GetCurrentLineNumber(mExpatParser);
+    nsresult rv = NS_IsMainThread()
+      ? mSink->HandleStartElement(aValue, aAtts, attrArrayLength,
+                                  attrIndex, lineNumber)
+      : BIND6(&nsIExpatSink::HandleStartElement,
+              mSink,
+              aValue, aAtts, attrArrayLength,
+              attrIndex, lineNumber).proxy(nsnull, NS_DISPATCH_SYNC)->Wait();
     MaybeStopParser(rv);
   }
 
   return NS_OK;
 }
 
 nsresult
 nsExpatDriver::HandleEndElement(const PRUnichar *aValue)
@@ -716,16 +724,24 @@ ExternalDTDStreamReaderFunc(nsIUnicharIn
 }
 
 int
 nsExpatDriver::HandleExternalEntityRef(const PRUnichar *openEntityNames,
                                        const PRUnichar *base,
                                        const PRUnichar *systemId,
                                        const PRUnichar *publicId)
 {
+  if (!NS_IsMainThread())
+    return BIND5(&nsExpatDriver::HandleExternalEntityRef,
+                 this,
+                 openEntityNames,
+                 base,
+                 systemId,
+                 publicId).proxy(nsnull, NS_DISPATCH_SYNC)->Wait();
+  
   if (mInInternalSubset && !mInExternalDTD && openEntityNames) {
     mInternalSubset.Append(PRUnichar('%'));
     mInternalSubset.Append(nsDependentString(openEntityNames));
     mInternalSubset.Append(PRUnichar(';'));
   }
 
   // Load the external entity into a buffer.
   nsCOMPtr<nsIInputStream> in;
diff --git a/parser/htmlparser/src/nsParser.cpp b/parser/htmlparser/src/nsParser.cpp
--- a/parser/htmlparser/src/nsParser.cpp
+++ b/parser/htmlparser/src/nsParser.cpp
@@ -67,30 +67,46 @@
 #include "nsHTMLTokenizer.h"
 #include "nsIDocument.h"
 #include "nsNetUtil.h"
 #include "nsScriptLoader.h"
 #include "nsDataHashtable.h"
 #include "nsIThreadPool.h"
 #include "nsXPCOMCIDInternal.h"
 
+#include "Bind.h"
+#include "nsRunnableFunctor.h"
+
 #ifdef MOZ_VIEW_SOURCE
 #include "nsViewSourceHTML.h"
 #endif
 
 #define NS_PARSER_FLAG_PARSER_ENABLED         0x00000002
 #define NS_PARSER_FLAG_OBSERVERS_ENABLED      0x00000004
 #define NS_PARSER_FLAG_PENDING_CONTINUE_EVENT 0x00000008
 #define NS_PARSER_FLAG_CAN_INTERRUPT          0x00000010
 #define NS_PARSER_FLAG_FLUSH_TOKENS           0x00000020
 #define NS_PARSER_FLAG_CAN_TOKENIZE           0x00000040
 
 static NS_DEFINE_IID(kISupportsIID, NS_ISUPPORTS_IID);
 static NS_DEFINE_CID(kCParserCID, NS_PARSER_CID);
 static NS_DEFINE_IID(kIParserIID, NS_IPARSER_IID);
+
+#define PROXY_SYNC_EXPR(TARGET, BOUND)                                        \
+  (BOUND).proxy((TARGET), NS_DISPATCH_SYNC)->Wait()
+
+#define PROXY_SYNC(BOUND)                                                     \
+  PR_BEGIN_MACRO                                                              \
+    if (NS_GetCurrentThread() != mParserThread.get())                         \
+      return PROXY_SYNC_EXPR(mParserThread, BOUND);                           \
+  PR_END_MACRO
+
+#define TRIVIAL_PROXY_SYNC(METHOD)                                            \
+  PROXY_SYNC(BIND1(&nsParser::METHOD,                                         \
+                   nsRefPtr<nsParser>(const_cast<nsParser*>(this))))
 
 //-------------------------------------------------------------------
 
 nsCOMArray<nsIUnicharStreamListener> *nsParser::sParserDataListeners;
 
 //-------------- Begin ParseContinue Event Definition ------------------------
 /*
 The parser can be explicitly interrupted by passing a return value of
@@ -806,16 +822,18 @@ nsParser::Initialize(PRBool aConstructor
   mInternalState = NS_OK;
   mStreamStatus = 0;
   mCommand = eViewNormal;
   mFlags = NS_PARSER_FLAG_OBSERVERS_ENABLED |
            NS_PARSER_FLAG_PARSER_ENABLED |
            NS_PARSER_FLAG_CAN_TOKENIZE;
   mScriptsExecuting = 0;
 
+  NS_GetCurrentThread(getter_AddRefs(mParserThread));
+
   MOZ_TIMER_DEBUGLOG(("Reset: Parse Time: nsParser::nsParser(), this=%p\n", this));
   MOZ_TIMER_RESET(mParseTime);
   MOZ_TIMER_RESET(mDTDTime);
   MOZ_TIMER_RESET(mTokenizeTime);
 }
 
 void
 nsParser::Cleanup()
@@ -906,16 +924,19 @@ nsParser::PostContinueEvent()
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP_(void)
 nsParser::SetParserFilter(nsIParserFilter * aFilter)
 {
+  PROXY_SYNC(BIND2(&nsParser::SetParserFilter,
+                   nsRefPtr<nsParser>(this),
+                   nsRefPtr<nsIParserFilter>(aFilter)));
   mParserFilter = aFilter;
 }
 
 NS_IMETHODIMP_(void)
 nsParser::GetCommand(nsCString& aCommand)
 {
   aCommand = mCommandStr;
 }
@@ -925,16 +946,22 @@ nsParser::GetCommand(nsCString& aCommand
  *  about the command which caused the parser to be constructed. For example,
  *  this allows us to select a DTD which can do, say, view-source.
  *
  *  @param   aCommand the command string to set
  */
 NS_IMETHODIMP_(void)
 nsParser::SetCommand(const char* aCommand)
 {
+  // TODO is aCommand safe? stick with SYNC?
+  typedef void (nsParser::*SetCommandPtr)(const char*);
+  PROXY_SYNC(BIND2(static_cast<SetCommandPtr>(&nsParser::SetCommand),
+                   nsRefPtr<nsParser>(this),
+                   aCommand));
+
   mCommandStr.Assign(aCommand);
   if (mCommandStr.Equals(kViewSourceCommand)) {
     mCommand = eViewSource;
   } else if (mCommandStr.Equals(kViewFragmentCommand)) {
     mCommand = eViewFragment;
   } else {
     mCommand = eViewNormal;
   }
@@ -945,29 +972,39 @@ nsParser::SetCommand(const char* aComman
  *  about the command which caused the parser to be constructed. For example,
  *  this allows us to select a DTD which can do, say, view-source.
  *
  *  @param   aParserCommand the command to set
  */
 NS_IMETHODIMP_(void)
 nsParser::SetCommand(eParserCommands aParserCommand)
 {
+  typedef void (nsParser::*SetCommandPtr)(eParserCommands);
+  PROXY_SYNC(BIND2(static_cast<SetCommandPtr>(&nsParser::SetCommand),
+                   nsRefPtr<nsParser>(this),
+                   aParserCommand));
+
   mCommand = aParserCommand;
 }
 
 /**
  *  Call this method once you've created a parser, and want to instruct it
  *  about what charset to load
  *
  *  @param   aCharset- the charset of a document
  *  @param   aCharsetSource- the source of the charset
  */
 NS_IMETHODIMP_(void)
 nsParser::SetDocumentCharset(const nsACString& aCharset, PRInt32 aCharsetSource)
 {
+  PROXY_SYNC(BIND3(&nsParser::SetDocumentCharset,
+                   nsRefPtr<nsParser>(this),
+                   nsCString(aCharset),
+                   aCharsetSource));
+
   mCharset = aCharset;
   mCharsetSource = aCharsetSource;
   if (mParserContext && mParserContext->mScanner) {
      mParserContext->mScanner->SetDocumentCharset(aCharset, aCharsetSource);
   }
 }
 
 void
@@ -983,30 +1020,36 @@ nsParser::SetSinkCharset(nsACString& aCh
  *  sink for this parser to dump nodes to.
  *
  *  @param   nsIContentSink interface for node receiver
  */
 NS_IMETHODIMP_(void)
 nsParser::SetContentSink(nsIContentSink* aSink)
 {
   NS_PRECONDITION(aSink, "sink cannot be null!");
+
+  PROXY_SYNC(BIND2(&nsParser::SetContentSink,
+                   nsRefPtr<nsParser>(this),
+                   nsRefPtr<nsIContentSink>(aSink)));
+
   mSink = aSink;
 
   if (mSink) {
     mSink->SetParser(this);
   }
 }
 
 /**
  * retrieve the sink set into the parser
  * @return  current sink
  */
 NS_IMETHODIMP_(nsIContentSink*)
 nsParser::GetContentSink() const
 {
+  TRIVIAL_PROXY_SYNC(GetContentSink);
   return mSink;
 }
 
 /**
  *  Retrieve parsemode from topmost parser context
  *
  *  @return  parsemode
  */
@@ -1621,16 +1664,18 @@ nsParser::SetUnusedInput(nsString& aBuff
 nsParser::SetUnusedInput(nsString& aBuffer)
 {
   mUnusedInput = aBuffer;
 }
 
 NS_IMETHODIMP_(void *)
 nsParser::GetRootContextKey()
 {
+  TRIVIAL_PROXY_SYNC(GetRootContextKey);
+
   CParserContext* pc = mParserContext;
   if (!pc) {
     return nsnull;
   }
 
   while (pc->mPrevContext) {
     pc = pc->mPrevContext;
   }
@@ -1641,16 +1686,18 @@ nsParser::GetRootContextKey()
 /**
  *  Call this when you want to *force* the parser to terminate the
  *  parsing process altogether. This is binary -- so once you terminate
  *  you can't resume without restarting altogether.
  */
 NS_IMETHODIMP
 nsParser::Terminate(void)
 {
+  TRIVIAL_PROXY_SYNC(Terminate);
+
   // We should only call DidBuildModel once, so don't do anything if this is
   // the second time that Terminate has been called.
   if (mInternalState == NS_ERROR_HTMLPARSER_STOPPARSING) {
     return NS_OK;
   }
 
   nsresult result = NS_OK;
   // XXX - [ until we figure out a way to break parser-sink circularity ]
@@ -1878,33 +1925,55 @@ nsParser::SetCanInterrupt(PRBool aCanInt
  *  of this method.
  */
 NS_IMETHODIMP
 nsParser::Parse(nsIURI* aURL,
                 nsIRequestObserver* aListener,
                 void* aKey,
                 nsDTDMode aMode)
 {
+  nsresult result = kBadURL;
 
   NS_PRECONDITION(aURL, "Error: Null URL given");
+  NS_ENSURE_TRUE(aURL, result);
+
+  nsCAutoString spec;
+  result = aURL->GetSpec(spec);
+  nsString* utf16p = NS_SUCCEEDED(result)
+    ? new NS_ConvertUTF8toUTF16(spec)
+    : nsnull;
+
+  Functor<nsresult, TLIST0()> handle =
+    BIND5(&nsParser::HandleParseBuffer,
+          nsRefPtr<nsParser>(this),
+          utf16p,
+          nsRefPtr<nsIRequestObserver>(aListener),
+          aKey,
+          aMode);
+
+  PROXY_SYNC(handle);
+
+  return handle();
+}
+
+nsresult
+nsParser::HandleParseBuffer(nsString* theName,
+                            nsIRequestObserver* aListener,
+                            void* aKey,
+                            nsDTDMode aMode)
+{
   NS_ASSERTION(!mSpeculativeScriptThread, "Can't reuse a parser like this");
 
   nsresult result=kBadURL;
   mObserver = aListener;
 
-  if (aURL) {
-    nsCAutoString spec;
-    nsresult rv = aURL->GetSpec(spec);
-    if (rv != NS_OK) {
-      return rv;
-    }
-    NS_ConvertUTF8toUTF16 theName(spec);
-
-    nsScanner* theScanner = new nsScanner(theName, PR_FALSE, mCharset,
+  if (theName) {
+    nsScanner* theScanner = new nsScanner(*theName, PR_FALSE, mCharset,
                                           mCharsetSource);
+    delete theName;
     CParserContext* pc = new CParserContext(theScanner, aKey, mCommand,
                                             aListener);
     if (pc && theScanner) {
       pc->mMultipart = PR_TRUE;
       pc->mContextType = CParserContext::eCTURL;
       pc->mDTDMode = aMode;
       PushContext(*pc);
 
@@ -1925,23 +1994,40 @@ nsParser::Parse(nsIURI* aURL,
 /**
  * Call this method if all you want to do is parse 1 string full of HTML text.
  * In particular, this method should be called by the DOM when it has an HTML
  * string to feed to the parser in real-time.
  *
  * @param   aSourceBuffer contains a string-full of real content
  * @param   aMimeType tells us what type of content to expect in the given string
  */
+
+#define PARSE_BUFFER_PARAMS                                                   \
+ (const nsAString& aSourceBuffer,                                             \
+  void* aKey,                                                                 \
+  const nsACString& aMimeType,                                                \
+  PRBool aLastCall,                                                           \
+  nsDTDMode aMode)
+
 NS_IMETHODIMP
-nsParser::Parse(const nsAString& aSourceBuffer,
-                void* aKey,
-                const nsACString& aMimeType,
-                PRBool aLastCall,
-                nsDTDMode aMode)
+nsParser::Parse PARSE_BUFFER_PARAMS
 {
+  // necessary because nsParser::Parse is overloaded:
+  typedef nsresult (nsParser::*ParseBufferPtr) PARSE_BUFFER_PARAMS;
+  PROXY_SYNC(BIND6(static_cast<ParseBufferPtr>(&nsParser::Parse),
+                   nsRefPtr<nsParser>(this),
+                   nsString(aSourceBuffer),
+                   aKey,
+                   nsCString(aMimeType),
+                   aLastCall,
+                   aMode));
+
+// sayonara, macro scum!
+#undef PARSE_BUFFER_PARAMS
+
   nsresult result = NS_OK;
 
   // Don't bother if we're never going to parse this.
   if (mInternalState == NS_ERROR_HTMLPARSER_STOPPARSING) {
     return result;
   }
 
   if (!aLastCall && aSourceBuffer.IsEmpty()) {
@@ -2064,16 +2150,25 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsParser::ParseFragment(const nsAString& aSourceBuffer,
                         void* aKey,
                         nsTArray<nsString>& aTagStack,
                         PRBool aXMLMode,
                         const nsACString& aMimeType,
                         nsDTDMode aMode)
 {
+  PROXY_SYNC(BIND7(&nsParser::ParseFragment,
+                   nsRefPtr<nsParser>(this),
+                   nsString(aSourceBuffer),
+                   aKey,
+                   nsTArray<nsString>(aTagStack),
+                   aXMLMode,
+                   nsCString(aMimeType),
+                   aMode));
+
   nsresult result = NS_OK;
   nsAutoString  theContext;
   PRUint32 theCount = aTagStack.Length();
   PRUint32 theIndex = 0;
 
   // Disable observers for fragments
   mFlags &= ~NS_PARSER_FLAG_OBSERVERS_ENABLED;
 
@@ -2392,16 +2487,21 @@ nsParser::BuildModel()
 
 /*******************************************************************
   These methods are used to talk to the netlib system...
  *******************************************************************/
 
 nsresult
 nsParser::OnStartRequest(nsIRequest *request, nsISupports* aContext)
 {
+  PROXY_SYNC(BIND3(&nsParser::OnStartRequest,
+                   nsRefPtr<nsParser>(this),
+                   nsRefPtr<nsIRequest>(request),
+                   nsRefPtr<nsISupports>(aContext)));
+
   NS_PRECONDITION(eNone == mParserContext->mStreamListenerState,
                   "Parser's nsIStreamListener API was not setup "
                   "correctly in constructor.");
   if (mObserver) {
     mObserver->OnStartRequest(request, aContext);
   }
   mParserContext->mStreamListenerState = eOnStart;
   mParserContext->mAutoDetectStatus = eUnknownDetect;
@@ -2814,32 +2914,50 @@ CheckCharset(const char* aBytes,
   }
 }
 
 nsresult
 nsParser::OnDataAvailable(nsIRequest *request, nsISupports* aContext,
                           nsIInputStream *pIStream, PRUint32 sourceOffset,
                           PRUint32 aLength)
 {
-  NS_PRECONDITION((eOnStart == mParserContext->mStreamListenerState ||
-                   eOnDataAvail == mParserContext->mStreamListenerState),
-            "Error: OnStartRequest() must be called before OnDataAvailable()");
   NS_PRECONDITION(NS_InputStreamIsBuffered(pIStream),
                   "Must have a buffered input stream");
 
-  nsresult rv = NS_OK;
-
   char *data = new char[aLength + 1];
   PRUint32 totalRead;
-  rv = pIStream->Read(data, aLength, &totalRead);
+  nsresult rv = pIStream->Read(data, aLength, &totalRead);
   if (NS_FAILED(rv)) {
     delete[] data;
     return rv;
   }
   data[aLength] = 0;
+
+  Functor<nsresult, TLIST0()> handle =
+    BIND5(&nsParser::HandleDataAvailable,
+          nsRefPtr<nsParser>(this),
+          nsRefPtr<nsIRequest>(request),
+          data, totalRead, sourceOffset);
+
+  PROXY_SYNC(handle);
+
+  return handle();
+}
+
+nsresult
+nsParser::HandleDataAvailable(nsIRequest* request,
+                              char* data,
+                              PRUint32 totalRead,
+                              PRUint32 sourceOffset)
+{
+  NS_PRECONDITION((eOnStart == mParserContext->mStreamListenerState ||
+                   eOnDataAvail == mParserContext->mStreamListenerState),
+            "Error: OnStartRequest() must be called before OnDataAvailable()");
+
+  nsresult rv = NS_OK;
 
   CParserContext *theContext = mParserContext;
 
   while (theContext && theContext->mRequest != request) {
     theContext = theContext->mPrevContext;
   }
 
   if (theContext) {
@@ -2886,16 +3004,22 @@ nsParser::OnDataAvailable(nsIRequest *re
 /**
  *  This is called by the networking library once the last block of data
  *  has been collected from the net.
  */
 nsresult
 nsParser::OnStopRequest(nsIRequest *request, nsISupports* aContext,
                         nsresult status)
 {
+  PROXY_SYNC(BIND4(&nsParser::OnStopRequest,
+                   nsRefPtr<nsParser>(this),
+                   nsRefPtr<nsIRequest>(request),
+                   nsRefPtr<nsISupports>(aContext),
+                   status));
+
   nsresult rv = NS_OK;
 
   if (mSpeculativeScriptThread) {
     mSpeculativeScriptThread->StopParsing(PR_FALSE);
   }
 
   CParserContext *pc = mParserContext;
   while (pc) {
diff --git a/parser/htmlparser/src/nsParser.h b/parser/htmlparser/src/nsParser.h
--- a/parser/htmlparser/src/nsParser.h
+++ b/parser/htmlparser/src/nsParser.h
@@ -422,16 +422,30 @@ class nsParser : public nsIParser,
      * @update	gess5/18/98
      * @param 
      * @return
      */
     nsresult DidBuildModel(nsresult anErrorCode);
 
     void SpeculativelyParse();
 
+    nsresult
+    HandleParseBuffer(
+      nsString* theName,
+      nsIRequestObserver* aListener,
+      void* aKey,
+      nsDTDMode aMode);
+
+    nsresult
+    HandleDataAvailable(
+      nsIRequest* request,
+      char* data,
+      PRUint32 totalRead,
+      PRUint32 sourceOffset);
+
 private:
 
     /*******************************************
       These are the tokenization methods...
      *******************************************/
 
     /**
      *  Part of the code sandwich, this gets called right before
@@ -465,18 +479,19 @@ private:
      *  @return  TRUE if all went well
      */
     PRBool DidTokenize(PRBool aIsFinalChunk = PR_FALSE);
 
 protected:
     //*********************************************
     // And now, some data members...
     //*********************************************
-    
-      
+
+    nsRefPtr<nsIThread> mParserThread;
+
     CParserContext*              mParserContext;
     nsCOMPtr<nsIRequestObserver> mObserver;
     nsCOMPtr<nsIContentSink>     mSink;
     nsIRunnable*                 mContinueEvent;  // weak ref
     nsRefPtr<nsSpeculativeScriptThread> mSpeculativeScriptThread;
    
     nsCOMPtr<nsIParserFilter> mParserFilter;
     nsTokenAllocator          mTokenAllocator;
