Copying network data using nsIInputStream::Read rather than ReadSegments.

diff --git a/parser/htmlparser/src/nsParser.cpp b/parser/htmlparser/src/nsParser.cpp
--- a/parser/htmlparser/src/nsParser.cpp
+++ b/parser/htmlparser/src/nsParser.cpp
@@ -69,16 +69,18 @@
 #include "nsNetUtil.h"
 #include "nsScriptLoader.h"
 #include "nsDataHashtable.h"
 #include "nsIThreadPool.h"
 #include "nsXPCOMCIDInternal.h"
 #include "nsICSSStyleSheet.h"
 #include "nsICSSLoaderObserver.h"
 #include "nsICSSLoader.h"
+#include "EventStats.h"
+#include "mozilla/TimeStamp.h"
 
 #ifdef MOZ_VIEW_SOURCE
 #include "nsViewSourceHTML.h"
 #endif
 
 #define NS_PARSER_FLAG_PARSER_ENABLED         0x00000002
 #define NS_PARSER_FLAG_OBSERVERS_ENABLED      0x00000004
 #define NS_PARSER_FLAG_PENDING_CONTINUE_EVENT 0x00000008
@@ -2769,22 +2771,74 @@ nsParser::DetectMetaTag(const char* aByt
 typedef struct {
   PRBool mNeedCharsetCheck;
   nsParser* mParser;
   nsIParserFilter* mParserFilter;
   nsScanner* mScanner;
   nsIRequest* mRequest;
 } ParserWriteStruct;
 
+static inline void
+CheckCharset(const char* aBytes,
+             const PRUint32 aByteCount,
+             nsIRequest* aRequest,
+             nsParser* aParser)
+{
+  PRInt32 guessSource;
+  nsCAutoString guess;
+  nsCAutoString preferred;
+
+  if (aParser->DetectMetaTag(aBytes, aByteCount, guess, guessSource) ||
+      ((aByteCount >= 4) &&
+       DetectByteOrderMark((const unsigned char*)aBytes,
+                           aByteCount, guess, guessSource))) {
+    nsCOMPtr<nsICharsetAlias> alias(do_GetService(NS_CHARSETALIAS_CONTRACTID));
+    // Only continue if it's a recognized charset and not
+    // one of a designated set that we ignore.
+    if (NS_SUCCEEDED(alias->GetPreferred(guess, preferred)) &&
+        ((kCharsetFromByteOrderMark == guessSource) ||
+         (!preferred.EqualsLiteral("UTF-16") &&
+          !preferred.EqualsLiteral("UTF-16BE") &&
+          !preferred.EqualsLiteral("UTF-16LE") &&
+          !preferred.EqualsLiteral("UTF-32") &&
+          !preferred.EqualsLiteral("UTF-32BE") &&
+          !preferred.EqualsLiteral("UTF-32LE")))) {
+      guess = preferred;
+      aParser->SetDocumentCharset(guess, guessSource);
+      aParser->SetSinkCharset(preferred);
+      nsCOMPtr<nsICachingChannel> channel(do_QueryInterface(aRequest));
+      if (channel) {
+        nsCOMPtr<nsISupports> cacheToken;
+        channel->GetCacheToken(getter_AddRefs(cacheToken));
+        if (cacheToken) {
+          nsCOMPtr<nsICacheEntryDescriptor> cacheDescriptor(do_QueryInterface(cacheToken));
+          if (cacheDescriptor) {
+#ifdef DEBUG
+            nsresult rv =
+#endif
+              cacheDescriptor->SetMetaDataElement("charset",
+                                                  guess.get());
+            NS_ASSERTION(NS_SUCCEEDED(rv),"cannot SetMetaDataElement");
+          }
+        }
+      }
+    }
+  }
+}
+
+#define ON_DATA_AVAILABLE__READ_SEGMENTS
+#define MEASURE_DATA_COPY_OVERHEAD
+
 /*
  * This function is invoked as a result of a call to a stream's
  * ReadSegments() method. It is called for each contiguous buffer
  * of data in the underlying stream or pipe. Using ReadSegments
  * allows us to avoid copying data to read out of the stream.
  */
+#ifdef ON_DATA_AVAILABLE__READ_SEGMENTS
 static NS_METHOD
 ParserWriteFunc(nsIInputStream* in,
                 void* closure,
                 const char* fromRawSegment,
                 PRUint32 toOffset,
                 PRUint32 count,
                 PRUint32 *writeCount)
 {
@@ -2793,82 +2847,61 @@ ParserWriteFunc(nsIInputStream* in,
   const char* buf = fromRawSegment;
   PRUint32 theNumRead = count;
 
   if (!pws) {
     return NS_ERROR_FAILURE;
   }
 
   if (pws->mNeedCharsetCheck) {
-    PRInt32 guessSource;
-    nsCAutoString guess;
-    nsCAutoString preferred;
-
+    CheckCharset(buf, theNumRead, pws->mRequest, pws->mParser);
     pws->mNeedCharsetCheck = PR_FALSE;
-    if (pws->mParser->DetectMetaTag(buf, theNumRead, guess, guessSource) ||
-        ((count >= 4) &&
-         DetectByteOrderMark((const unsigned char*)buf,
-                             theNumRead, guess, guessSource))) {
-      nsCOMPtr<nsICharsetAlias> alias(do_GetService(NS_CHARSETALIAS_CONTRACTID));
-      result = alias->GetPreferred(guess, preferred);
-      // Only continue if it's a recognized charset and not
-      // one of a designated set that we ignore.
-      if (NS_SUCCEEDED(result) &&
-          ((kCharsetFromByteOrderMark == guessSource) ||
-           (!preferred.EqualsLiteral("UTF-16") &&
-            !preferred.EqualsLiteral("UTF-16BE") &&
-            !preferred.EqualsLiteral("UTF-16LE") &&
-            !preferred.EqualsLiteral("UTF-32") &&
-            !preferred.EqualsLiteral("UTF-32BE") &&
-            !preferred.EqualsLiteral("UTF-32LE")))) {
-        guess = preferred;
-        pws->mParser->SetDocumentCharset(guess, guessSource);
-        pws->mParser->SetSinkCharset(preferred);
-        nsCOMPtr<nsICachingChannel> channel(do_QueryInterface(pws->mRequest));
-        if (channel) {
-          nsCOMPtr<nsISupports> cacheToken;
-          channel->GetCacheToken(getter_AddRefs(cacheToken));
-          if (cacheToken) {
-            nsCOMPtr<nsICacheEntryDescriptor> cacheDescriptor(do_QueryInterface(cacheToken));
-            if (cacheDescriptor) {
-#ifdef DEBUG
-              nsresult rv =
-#endif
-                cacheDescriptor->SetMetaDataElement("charset",
-                                                    guess.get());
-              NS_ASSERTION(NS_SUCCEEDED(rv),"cannot SetMetaDataElement");
-            }
-          }
-        }
-      }
-    }
   }
 
   if (pws->mParserFilter)
     pws->mParserFilter->RawBuffer(buf, &theNumRead);
 
   result = pws->mScanner->Append(buf, theNumRead, pws->mRequest);
   if (NS_SUCCEEDED(result)) {
     *writeCount = count;
   }
 
   return result;
 }
+#endif
 
 nsresult
 nsParser::OnDataAvailable(nsIRequest *request, nsISupports* aContext,
                           nsIInputStream *pIStream, PRUint32 sourceOffset,
                           PRUint32 aLength)
 {
   NS_PRECONDITION((eOnStart == mParserContext->mStreamListenerState ||
                    eOnDataAvail == mParserContext->mStreamListenerState),
             "Error: OnStartRequest() must be called before OnDataAvailable()");
   NS_PRECONDITION(NS_InputStreamIsBuffered(pIStream),
                   "Must have a buffered input stream");
 
+#ifdef MEASURE_DATA_COPY_OVERHEAD
+  static mozilla::TimeStamp firstODA = mozilla::TimeStamp::Now();
+  printf("+—————\n");
+#endif
+
+  {
+    nsIThread* thread = 0;
+    NS_GetCurrentThread(&thread);
+    if (thread) {
+      RunningStats<double>* rs = 0;
+      thread->Note();
+      thread->GetStats(&rs);
+      if (rs)
+        printf("| last: %g  \tcount: %d  \tmean: %g  \tstdev: %g  \tmax: %g  \tmin: %g\n",
+               rs->last(), rs->count(), rs->mean(), rs->stdev(), rs->max(), rs->min());
+    }
+  }
+
   nsresult rv = NS_OK;
 
   CParserContext *theContext = mParserContext;
 
   while (theContext && theContext->mRequest != request) {
     theContext = theContext->mPrevContext;
   }
 
@@ -2884,28 +2917,62 @@ nsParser::OnDataAvailable(nsIRequest *re
       if (theContext->mScanner) {
         nsScannerIterator iter;
         theContext->mScanner->EndReading(iter);
         theContext->mScanner->SetPosition(iter, PR_TRUE);
       }
     }
 
     PRUint32 totalRead;
+
+#ifdef MEASURE_DATA_COPY_OVERHEAD
+    static mozilla::TimeDuration total = 0;
+    static int trials = 0;
+    mozilla::TimeStamp start = mozilla::TimeStamp::Now();
+#endif
+
+#ifdef ON_DATA_AVAILABLE__READ_SEGMENTS
     ParserWriteStruct pws;
     pws.mNeedCharsetCheck =
       (0 == sourceOffset) && (mCharsetSource < kCharsetFromMetaTag);
     pws.mParser = this;
     pws.mParserFilter = mParserFilter;
     pws.mScanner = theContext->mScanner;
     pws.mRequest = request;
 
     rv = pIStream->ReadSegments(ParserWriteFunc, &pws, aLength, &totalRead);
     if (NS_FAILED(rv)) {
       return rv;
     }
+#else
+    char *data = new char[aLength + 1];
+    rv = pIStream->Read(data, aLength, &totalRead);
+    if (NS_FAILED(rv)) {
+      delete[] data;
+      return rv;
+    }
+    data[aLength] = 0;
+    if (0 == sourceOffset && mCharsetSource < kCharsetFromMetaTag)
+      CheckCharset(data, totalRead, request, this);
+    if (mParserFilter)
+      mParserFilter->RawBuffer(data, &totalRead);
+    rv = theContext->mScanner->Append(data, totalRead, request);
+    delete[] data;
+    NS_ENSURE_SUCCESS(rv, rv);
+#endif
+
+#ifdef MEASURE_DATA_COPY_OVERHEAD
+    mozilla::TimeDuration time = mozilla::TimeStamp::Now() - start;
+    total += time;
+    trials += 1;
+    printf("| time: %gs  \taverage time: %gs  \ttotal: %gs\n",
+           time.ToSeconds(),
+           total.ToSeconds() / (double) trials,
+           total.ToSeconds());
+#endif
 
     // Don't bother to start parsing until we've seen some
     // non-whitespace data
     if (!IsScriptExecuting() &&
         theContext->mScanner->FirstNonWhitespacePosition() >= 0) {
       if (mSink) {
         mSink->WillParse();
       }
diff --git a/xpcom/threads/EventStats.h b/xpcom/threads/EventStats.h
new file mode 100644
--- /dev/null
+++ b/xpcom/threads/EventStats.h
@@ -0,0 +1,135 @@
+#ifndef EventStats_h__
+#define EventStats_h__
+
+#include "nsCOMPtr.h"
+#include "nsIRunnable.h"
+#include "mozilla/TimeStamp.h"
+#include "nsThreadUtils.h"
+#include <math.h>
+
+template <typename UnitType>
+class RunningStats {
+  PRUint32 mCount; // current sample size
+  UnitType mSoSD,  // sum of squared deviations
+           mMean,  // sample mean
+           mMax,   // sample maximum
+           mMin,   // sample minimum
+           mLast;  // most recent value
+public:
+  RunningStats()
+    : mCount(0)
+    , mSoSD(0)
+    , mMean(0)
+    , mMax(0)
+    , mMin(0)
+    , mLast(0)
+  {}
+
+  UnitType mean()  const { return mMean; }
+  UnitType var()   const { return mCount > 0 ? mSoSD / mCount : 0; }
+  UnitType stdev() const { return UnitType(sqrt(var())); }
+  UnitType max()   const { return mMax; }
+  UnitType min()   const { return mMin; }
+  UnitType last()  const { return mLast; }
+  PRUint32 count() const { return mCount; }
+
+  RunningStats* update(UnitType x) {
+    UnitType mean((mMean * mCount + x) / (mCount + 1)),
+             xDev(x - mean), mInc(mean - mMean);
+
+    mSoSD +=
+      // squared deviation of x:
+      (xDev * xDev) +
+      // increase in mSoSD due to new sample mean:
+      (mInc * mInc) * mCount;
+
+    if (mCount++ > 0) {
+      if (x < mMin) mMin = x;
+      if (x > mMax) mMax = x;
+    } else mMin = mMax = x;
+
+    mMean = mean;
+    mLast = x;
+
+    return this;
+  }
+};
+
+// // Inlining would hide this from the debugger:
+// const RunningStats<double>* Stats() const;
+// static nsThread* GetCurrent();
+// static const RunningStats<double>* NoteCurrentEvent();
+
+class EventStatsWrapper;
+
+class EventStatsObserver {
+public:
+  EventStatsObserver() : mESW(0) {}
+
+  virtual EventStatsWrapper*
+  SetESW(EventStatsWrapper* esw) {
+    EventStatsWrapper* old = mESW;
+    mESW = esw;
+    return old;
+  }
+
+  virtual EventStatsWrapper*
+  GetESW() { return mESW; }
+
+private:
+  EventStatsWrapper* mESW;
+};
+
+class EventStatsWrapper : public nsRunnable {
+
+  const mozilla::TimeStamp  mCreationTime;
+  mozilla::TimeStamp        mRunTime;
+  nsCOMPtr<nsIRunnable>     mEvent;
+  EventStatsObserver* const mObserver;
+  PRBool                    mNoted;
+
+  typedef RunningStats<double> RVType;
+  RVType* const mRunningStats;
+
+public:
+
+  EventStatsWrapper(nsIRunnable* event,
+                    RVType* rvp,
+                    EventStatsObserver* obs)
+    : mCreationTime(mozilla::TimeStamp::Now())
+    , mEvent(event)
+    , mObserver(obs)
+    , mNoted(PR_FALSE)
+    , mRunningStats(rvp)
+  {}
+
+  ~EventStatsWrapper() {}
+
+  NS_IMETHOD Run() {
+    NS_ASSERTION(mRunTime.IsNull(),
+                 "Calling EventStatsWrapper::Run more than once?");
+    mRunTime = mozilla::TimeStamp::Now();
+    EventStatsWrapper* const old = mObserver->SetESW(this);
+    if (mNoted) {
+      mNoted = PR_FALSE;
+      Note();
+    }
+    nsresult rv = mEvent->Run();
+    if (mObserver->SetESW(old) != this) {
+      NS_WARNING("EventStatsWrapper changed during mEvent execution?");
+    }
+    return rv;
+  }
+
+  const RVType* Note() {
+    if (!mNoted) {
+      mNoted = PR_TRUE;
+      if (mRunningStats && !mRunTime.IsNull())
+        mRunningStats->update((mRunTime - mCreationTime).ToSeconds());
+    }
+    return mRunningStats;
+  }
+
+};
+
+#endif
diff --git a/xpcom/threads/Makefile.in b/xpcom/threads/Makefile.in
--- a/xpcom/threads/Makefile.in
+++ b/xpcom/threads/Makefile.in
@@ -65,16 +65,17 @@ CPPSRCS		= \
 		nsTimerImpl.cpp \
 		TimerThread.cpp \
 		$(NULL)
 
 EXPORTS		= \
 		nsProcess.h \
 		nsEventQueue.h \
 		nsThreadUtilsInternal.h \
+		EventStats.h \
 		$(NULL)
 
 XPIDLSRCS	= \
 		nsIEventTarget.idl \
 		nsIThread.idl \
 		nsIThreadInternal.idl \
 		nsIThreadManager.idl \
 		nsIThreadPool.idl \
diff --git a/xpcom/threads/nsIThread.idl b/xpcom/threads/nsIThread.idl
--- a/xpcom/threads/nsIThread.idl
+++ b/xpcom/threads/nsIThread.idl
@@ -33,17 +33,24 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsIEventTarget.idl"
 
+%{C++
+template <typename T> class RunningStats;
+typedef RunningStats<double> Stats;
+
+%}
+
 [ptr] native PRThread(PRThread);
+[ptr] native Stats(Stats);
 
 /**
  * This interface provides a high-level abstraction for an operating system
  * thread.
  *
  * Threads have a built-in event queue, and a thread is an event target that
  * can receive nsIRunnable objects (events) to be processed on the thread.
  *
@@ -53,16 +60,19 @@
 interface nsIThread : nsIEventTarget
 {
   /**
    * @returns
    *   The NSPR thread object corresponding to this nsIThread.
    */
   [noscript] readonly attribute PRThread PRThread;
 
+  [noscript] readonly attribute Stats Stats;
+  [noscript] void note();
+
   /**
    * Shutdown the thread.  This method prevents further dispatch of events to
    * the thread, and it causes any pending events to run to completion before
    * the thread joins (see PR_JoinThread) with the current thread.  During this
    * method call, events for the current thread may be processed.
    *
    * This method MAY NOT be executed from the thread itself.  Instead, it is
    * meant to be executed from another thread (usually the thread that created
diff --git a/xpcom/threads/nsThread.cpp b/xpcom/threads/nsThread.cpp
--- a/xpcom/threads/nsThread.cpp
+++ b/xpcom/threads/nsThread.cpp
@@ -369,16 +369,38 @@ nsThread::PutEvent(nsIRunnable *event)
 
   return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 // nsIEventTarget
 
 NS_IMETHODIMP
+nsThread::GetStats(RunningStats<double>** rsp)
+{
+#ifdef MEASURE_TIME_SPENT_IN_THREAD_EVENT_QUEUE
+  if (rsp)
+    *rsp = &mRunningStats;
+  return NS_OK;
+#else
+  return NS_ERROR_NOT_IMPLEMENTED;
+#endif
+}
+
+NS_IMETHODIMP
+nsThread::Note()
+{
+#ifdef MEASURE_TIME_SPENT_IN_THREAD_EVENT_QUEUE
+  if (GetESW())
+    GetESW()->Note();
+#endif
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsThread::Dispatch(nsIRunnable *event, PRUint32 flags)
 {
   LOG(("THRD(%p) Dispatch [%p %x]\n", this, event, flags));
 
   NS_ENSURE_ARG_POINTER(event);
 
   if (flags & DISPATCH_SYNC) {
     nsThread *thread = nsThreadManager::get()->GetCurrentThread();
@@ -398,17 +420,22 @@ nsThread::Dispatch(nsIRunnable *event, P
       return rv;
 
     while (wrapper->IsPending())
       NS_ProcessNextEvent(thread);
     return rv;
   }
 
   NS_ASSERTION(flags == NS_DISPATCH_NORMAL, "unexpected dispatch flags");
-  return PutEvent(event);
+  return PutEvent(
+#ifdef MEASURE_TIME_SPENT_IN_THREAD_EVENT_QUEUE
+                  new EventStatsWrapper(event, &mRunningStats, this));
+#else
+                  event);
+#endif
 }
 
 NS_IMETHODIMP
 nsThread::IsOnCurrentThread(PRBool *result)
 {
   *result = (PR_GetCurrentThread() == mThread);
   return NS_OK;
 }
diff --git a/xpcom/threads/nsThread.h b/xpcom/threads/nsThread.h
--- a/xpcom/threads/nsThread.h
+++ b/xpcom/threads/nsThread.h
@@ -41,19 +41,24 @@
 
 #include "nsIThreadInternal.h"
 #include "nsISupportsPriority.h"
 #include "nsEventQueue.h"
 #include "nsThreadUtils.h"
 #include "nsString.h"
 #include "nsAutoLock.h"
 #include "nsAutoPtr.h"
+#include "EventStats.h"
+
+#define MEASURE_TIME_SPENT_IN_THREAD_EVENT_QUEUE
 
 // A native thread
-class nsThread : public nsIThreadInternal, public nsISupportsPriority
+class nsThread : public nsIThreadInternal
+               , public nsISupportsPriority
+               , public EventStatsObserver
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIEVENTTARGET
   NS_DECL_NSITHREAD
   NS_DECL_NSITHREADINTERNAL
   NS_DECL_NSISUPPORTSPRIORITY
 
@@ -141,16 +146,21 @@ private:
   PRUint32  mRunningEvent;  // counter
 
   struct nsThreadShutdownContext *mShutdownContext;
 
   PRPackedBool mShutdownRequired;
   PRPackedBool mShutdownPending;
   // Set to true when events posted to this thread will never run.
   PRPackedBool mEventsAreDoomed;
+
+#ifdef MEASURE_TIME_SPENT_IN_THREAD_EVENT_QUEUE
+  RunningStats<double> mRunningStats;
+#endif
+
 };
 
 //-----------------------------------------------------------------------------
 
 class nsThreadSyncDispatch : public nsRunnable {
 public:
   nsThreadSyncDispatch(nsIThread *origin, nsIRunnable *task)
     : mOrigin(origin), mSyncTask(task) {
