[HTML5] Remove unneeded parser/html/java/translator directory (bug 518224). r=hsivonen

diff --git a/parser/html/java/translator/Makefile b/parser/html/java/translator/Makefile
deleted file mode 100644
--- a/parser/html/java/translator/Makefile
+++ /dev/null
@@ -1,58 +0,0 @@
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Makefile.
-#
-# The Initial Developer of the Original Code is
-#   Mozilla Corporation.
-#
-# Portions created by the Initial Developer are Copyright (C) 2009
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   Ben Newman <b{enjam,newma}n@mozilla.com>
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-SVN_BASE=https://whattf.svn.cvsdude.com/htmlparser/trunk
-
-libs:: \
-; mkdir -p bin && \
-  find src -name "*.java" | \
-    xargs javac -cp ../javaparser.jar -g -d bin && \
-  jar cfm translator.jar manifest.txt -C bin .
-
-sync:: \
-; ../sync-src.sh $(SVN_BASE)/translator-src && \
-  ../sync-files.sh $(SVN_BASE) LICENSE.txt README.txt
-
-named_characters:: libs \
-; java -cp translator.jar \
-    nu.validator.htmlparser.generator.GenerateNamedCharactersCpp \
-      named-character-references.html \
-      ../..
-
-clean:: \
-; rm -rf bin translator.jar
diff --git a/parser/html/java/translator/manifest.txt b/parser/html/java/translator/manifest.txt
deleted file mode 100644
--- a/parser/html/java/translator/manifest.txt
+++ /dev/null
@@ -1,2 +0,0 @@
-Main-Class: nu.validator.htmlparser.cpptranslate.Main
-Class-Path: javaparser.jar
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/AnnotationHelperVisitor.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/AnnotationHelperVisitor.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/AnnotationHelperVisitor.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2009
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.cpptranslate;
-
-import java.util.List;
-
-import japa.parser.ast.expr.AnnotationExpr;
-import japa.parser.ast.expr.MarkerAnnotationExpr;
-import japa.parser.ast.type.ReferenceType;
-import japa.parser.ast.visitor.VoidVisitorAdapter;
-
-public class AnnotationHelperVisitor<T> extends VoidVisitorAdapter<T> {
-
-    protected List<AnnotationExpr> currentAnnotations;
-
-    protected boolean nsUri() {
-        return hasAnnotation("NsUri");
-    }
-
-    protected boolean prefix() {
-        return hasAnnotation("Prefix");
-    }
-
-    protected boolean local() {
-        return hasAnnotation("Local");
-    }
-
-    protected boolean literal() {
-        return hasAnnotation("Literal");
-    }
-
-    protected boolean inline() {
-        return hasAnnotation("Inline");
-    }
-
-    protected boolean noLength() {
-        return hasAnnotation("NoLength");
-    }
-
-    protected boolean virtual() {
-        return hasAnnotation("Virtual");
-    }
-
-    private boolean hasAnnotation(String anno) {
-        if (currentAnnotations == null) {
-            return false;
-        }
-        for (AnnotationExpr ann : currentAnnotations) {
-            if (ann instanceof MarkerAnnotationExpr) {
-                MarkerAnnotationExpr marker = (MarkerAnnotationExpr) ann;
-                if (marker.getName().getName().equals(anno)) {
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    protected Type convertType(japa.parser.ast.type.Type type, int modifiers) {
-        if (type instanceof ReferenceType) {
-            ReferenceType referenceType = (ReferenceType) type;
-            return new Type(convertTypeName(referenceType.getType().toString()), referenceType.getArrayCount(), noLength(), modifiers);
-        } else {
-            return new Type(convertTypeName(type.toString()), 0, false, modifiers);
-        }
-    }
-
-    private String convertTypeName(String name) {
-        if ("String".equals(name)) {
-            if (local()) {
-                return "@Local";
-            }
-            if (nsUri()) {
-                return "@NsUri";
-            }
-            if (prefix()) {
-                return "@Prefix";
-            }
-            if (literal()) {
-                return "@Literal";
-            }
-        }
-        return name;
-    }
-
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/CppTypes.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/CppTypes.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/CppTypes.java
+++ /dev/null
@@ -1,310 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2008-2009
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.cpptranslate;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
-public class CppTypes {
-
-    private static Set<String> reservedWords = new HashSet<String>();
-
-    static {
-        reservedWords.add("small");
-        reservedWords.add("for");
-        reservedWords.add("false");
-        reservedWords.add("true");
-        reservedWords.add("default");
-        reservedWords.add("class");
-        reservedWords.add("switch");
-        reservedWords.add("union");
-        reservedWords.add("template");
-        reservedWords.add("int");
-        reservedWords.add("char");
-        reservedWords.add("operator");
-        reservedWords.add("or");
-        reservedWords.add("and");
-        reservedWords.add("not");
-        reservedWords.add("xor");
-        reservedWords.add("unicode");
-    }
-
-    private static final String[] TREE_BUILDER_INCLUDES = { "prtypes",
-            "nsIAtom", "nsITimer", "nsString", "nsINameSpaceManager", "nsIContent",
-            "nsIDocument", "nsTraceRefcnt", "jArray", "nsHtml5DocumentMode",
-            "nsHtml5ArrayCopy", "nsHtml5NamedCharacters", "nsHtml5Parser",
-            "nsHtml5Atoms", "nsHtml5ByteReadable", "nsHtml5TreeOperation",
-            "nsHtml5PendingNotification", "nsHtml5StateSnapshot", "nsHtml5StackNode", 
-            "nsHtml5TreeOpExecutor", "nsHtml5StreamParser" };
-
-    private static final String[] INCLUDES = { "prtypes", "nsIAtom",
-            "nsString", "nsINameSpaceManager", "nsIContent", "nsIDocument",
-            "nsTraceRefcnt", "jArray", "nsHtml5DocumentMode",
-            "nsHtml5ArrayCopy", "nsHtml5NamedCharacters",
-            "nsHtml5Atoms", "nsHtml5ByteReadable", "nsIUnicodeDecoder", };
-
-    private static final String[] OTHER_DECLATIONS = {};
-
-    private static final String[] TREE_BUILDER_OTHER_DECLATIONS = { };
-
-    private static final String[] NAMED_CHARACTERS_INCLUDES = { "prtypes",
-            "jArray", "nscore" };
-
-    private static final String[] FORWARD_DECLARATIONS = { "nsHtml5StreamParser", };
-    
-    private static final String[] CLASSES_THAT_NEED_SUPPLEMENT = {
-        "MetaScanner",
-        "StackNode",
-        "TreeBuilder",
-        "UTF16Buffer",
-    };
-    
-    private final Map<String, String> atomMap = new HashMap<String, String>();
-
-    private final Writer atomWriter;
-
-    public CppTypes(File atomList) {
-        if (atomList == null) {
-            atomWriter = null;
-        } else {
-            try {
-                atomWriter = new OutputStreamWriter(new FileOutputStream(
-                        atomList), "utf-8");
-            } catch (IOException e) {
-                throw new RuntimeException(e);
-            }
-        }
-    }
-
-    public void finished() {
-        try {
-            if (atomWriter != null) {
-                atomWriter.flush();
-                atomWriter.close();
-            }
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    public String classPrefix() {
-        return "nsHtml5";
-    }
-
-    public String booleanType() {
-        return "PRBool";
-    }
-
-    public String charType() {
-        return "PRUnichar";
-    }
-
-    public String intType() {
-        return "PRInt32";
-    }
-
-    public String stringType() {
-        return "nsString*";
-    }
-
-    public String localType() {
-        return "nsIAtom*";
-    }
-
-    public String prefixType() {
-        return "nsIAtom*";
-    }
-
-    public String nsUriType() {
-        return "PRInt32";
-    }
-
-    public String falseLiteral() {
-        return "PR_FALSE";
-    }
-
-    public String trueLiteral() {
-        return "PR_TRUE";
-    }
-
-    public String nullLiteral() {
-        return "nsnull";
-    }
-
-    public String encodingDeclarationHandlerType() {
-        return "nsHtml5StreamParser*";
-    }
-
-    public String nodeType() {
-        return "nsIContent*";
-    }
-
-    public String xhtmlNamespaceLiteral() {
-        return "kNameSpaceID_XHTML";
-    }
-
-    public String svgNamespaceLiteral() {
-        return "kNameSpaceID_SVG";
-    }
-
-    public String xmlnsNamespaceLiteral() {
-        return "kNameSpaceID_XMLNS";
-    }
-
-    public String xmlNamespaceLiteral() {
-        return "kNameSpaceID_XML";
-    }
-
-    public String noNamespaceLiteral() {
-        return "kNameSpaceID_None";
-    }
-
-    public String xlinkNamespaceLiteral() {
-        return "kNameSpaceID_XLink";
-    }
-
-    public String mathmlNamespaceLiteral() {
-        return "kNameSpaceID_MathML";
-    }
-
-    public String arrayTemplate() {
-        return "jArray";
-    }
-
-    public String localForLiteral(String literal) {
-        String atom = atomMap.get(literal);
-        if (atom == null) {
-            atom = createAtomName(literal);
-            atomMap.put(literal, atom);
-            if (atomWriter != null) {
-                try {
-                    atomWriter.write("HTML5_ATOM(" + atom + ", \"" + literal
-                            + "\")\n");
-                } catch (IOException e) {
-                    throw new RuntimeException(e);
-                }
-            }
-        }
-        return "nsHtml5Atoms::" + atom;
-    }
-
-    private String createAtomName(String literal) {
-        String candidate = literal.replaceAll("[^a-zA-Z0-9_]", "_");
-        if ("".equals(candidate)) {
-            candidate = "emptystring";
-        }
-        while (atomMap.values().contains(candidate)
-                || reservedWords.contains(candidate)) {
-            candidate = candidate + '_';
-        }
-        return candidate;
-    }
-
-    public String stringForLiteral(String literal) {
-        return '"' + literal + '"';
-    }
-
-    public String staticArrayMacro() {
-        return "J_ARRAY_STATIC";
-    }
-
-    public String[] boilerplateIncludes(String javaClass) {
-        if ("TreeBuilder".equals(javaClass)) {
-            return TREE_BUILDER_INCLUDES;
-        } else {
-            return INCLUDES;
-        }
-    }
-    
-    public String[] boilerplateDeclarations(String javaClass) {
-        if ("TreeBuilder".equals(javaClass)) {
-            return TREE_BUILDER_OTHER_DECLATIONS;
-        } else {
-            return OTHER_DECLATIONS;
-        }
-    }
-
-    public String[] namedCharactersIncludes() {
-        return NAMED_CHARACTERS_INCLUDES;
-    }
-
-    public String[] boilerplateForwardDeclarations() {
-        return FORWARD_DECLARATIONS;
-    }
-
-    public String documentModeHandlerType() {
-        return "nsHtml5TreeBuilder*";
-    }
-
-    public String documentModeType() {
-        return "nsHtml5DocumentMode";
-    }
-
-    public String arrayCopy() {
-        return "nsHtml5ArrayCopy::arraycopy";
-    }
-
-    public String maxInteger() {
-        return "PR_INT32_MAX";
-    }
-
-    public String constructorBoilerplate(String className) {
-        return "MOZ_COUNT_CTOR(" + className + ");";
-    }
-
-    public String destructorBoilderplate(String className) {
-        return "MOZ_COUNT_DTOR(" + className + ");";
-    }
-
-    public String literalType() {
-        return "const char*";
-    }
-    
-    public boolean hasSupplement(String javaClass) {
-        return Arrays.binarySearch(CLASSES_THAT_NEED_SUPPLEMENT, javaClass) > -1;
-    }
-
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/CppVisitor.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/CppVisitor.java
deleted file mode 100755
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/CppVisitor.java
+++ /dev/null
@@ -1,2090 +0,0 @@
-/*
- * Copyright (C) 2007 Júlio Vilmar Gesser.
- * Copyright (C) 2008 Mozilla Foundation
- * 
- * This file is part of HTML Parser C++ Translator. It was derived from DumpVisitor
- * which was part of Java 1.5 parser and Abstract Syntax Tree and came with the following notice:
- *
- * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
- */
-/*
- * Created on 05/10/2006
- */
-package nu.validator.htmlparser.cpptranslate;
-
-import japa.parser.ast.BlockComment;
-import japa.parser.ast.CompilationUnit;
-import japa.parser.ast.ImportDeclaration;
-import japa.parser.ast.LineComment;
-import japa.parser.ast.Node;
-import japa.parser.ast.PackageDeclaration;
-import japa.parser.ast.TypeParameter;
-import japa.parser.ast.body.AnnotationDeclaration;
-import japa.parser.ast.body.AnnotationMemberDeclaration;
-import japa.parser.ast.body.BodyDeclaration;
-import japa.parser.ast.body.ClassOrInterfaceDeclaration;
-import japa.parser.ast.body.ConstructorDeclaration;
-import japa.parser.ast.body.EmptyMemberDeclaration;
-import japa.parser.ast.body.EmptyTypeDeclaration;
-import japa.parser.ast.body.EnumConstantDeclaration;
-import japa.parser.ast.body.EnumDeclaration;
-import japa.parser.ast.body.FieldDeclaration;
-import japa.parser.ast.body.InitializerDeclaration;
-import japa.parser.ast.body.JavadocComment;
-import japa.parser.ast.body.MethodDeclaration;
-import japa.parser.ast.body.ModifierSet;
-import japa.parser.ast.body.Parameter;
-import japa.parser.ast.body.TypeDeclaration;
-import japa.parser.ast.body.VariableDeclarator;
-import japa.parser.ast.body.VariableDeclaratorId;
-import japa.parser.ast.expr.ArrayAccessExpr;
-import japa.parser.ast.expr.ArrayCreationExpr;
-import japa.parser.ast.expr.ArrayInitializerExpr;
-import japa.parser.ast.expr.AssignExpr;
-import japa.parser.ast.expr.BinaryExpr;
-import japa.parser.ast.expr.BooleanLiteralExpr;
-import japa.parser.ast.expr.CastExpr;
-import japa.parser.ast.expr.CharLiteralExpr;
-import japa.parser.ast.expr.ClassExpr;
-import japa.parser.ast.expr.ConditionalExpr;
-import japa.parser.ast.expr.DoubleLiteralExpr;
-import japa.parser.ast.expr.EnclosedExpr;
-import japa.parser.ast.expr.Expression;
-import japa.parser.ast.expr.FieldAccessExpr;
-import japa.parser.ast.expr.InstanceOfExpr;
-import japa.parser.ast.expr.IntegerLiteralExpr;
-import japa.parser.ast.expr.IntegerLiteralMinValueExpr;
-import japa.parser.ast.expr.LongLiteralExpr;
-import japa.parser.ast.expr.LongLiteralMinValueExpr;
-import japa.parser.ast.expr.MarkerAnnotationExpr;
-import japa.parser.ast.expr.MemberValuePair;
-import japa.parser.ast.expr.MethodCallExpr;
-import japa.parser.ast.expr.NameExpr;
-import japa.parser.ast.expr.NormalAnnotationExpr;
-import japa.parser.ast.expr.NullLiteralExpr;
-import japa.parser.ast.expr.ObjectCreationExpr;
-import japa.parser.ast.expr.QualifiedNameExpr;
-import japa.parser.ast.expr.SingleMemberAnnotationExpr;
-import japa.parser.ast.expr.StringLiteralExpr;
-import japa.parser.ast.expr.SuperExpr;
-import japa.parser.ast.expr.ThisExpr;
-import japa.parser.ast.expr.UnaryExpr;
-import japa.parser.ast.expr.VariableDeclarationExpr;
-import japa.parser.ast.stmt.AssertStmt;
-import japa.parser.ast.stmt.BlockStmt;
-import japa.parser.ast.stmt.BreakStmt;
-import japa.parser.ast.stmt.CatchClause;
-import japa.parser.ast.stmt.ContinueStmt;
-import japa.parser.ast.stmt.DoStmt;
-import japa.parser.ast.stmt.EmptyStmt;
-import japa.parser.ast.stmt.ExplicitConstructorInvocationStmt;
-import japa.parser.ast.stmt.ExpressionStmt;
-import japa.parser.ast.stmt.ForStmt;
-import japa.parser.ast.stmt.ForeachStmt;
-import japa.parser.ast.stmt.IfStmt;
-import japa.parser.ast.stmt.LabeledStmt;
-import japa.parser.ast.stmt.ReturnStmt;
-import japa.parser.ast.stmt.Statement;
-import japa.parser.ast.stmt.SwitchEntryStmt;
-import japa.parser.ast.stmt.SwitchStmt;
-import japa.parser.ast.stmt.SynchronizedStmt;
-import japa.parser.ast.stmt.ThrowStmt;
-import japa.parser.ast.stmt.TryStmt;
-import japa.parser.ast.stmt.TypeDeclarationStmt;
-import japa.parser.ast.stmt.WhileStmt;
-import japa.parser.ast.type.ClassOrInterfaceType;
-import japa.parser.ast.type.PrimitiveType;
-import japa.parser.ast.type.ReferenceType;
-import japa.parser.ast.type.Type;
-import japa.parser.ast.type.VoidType;
-import japa.parser.ast.type.WildcardType;
-
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-
-/**
- * @author Julio Vilmar Gesser
- * @author Henri Sivonen
- */
-
-public class CppVisitor extends AnnotationHelperVisitor<LocalSymbolTable> {
-
-    private static final String[] CLASS_NAMES = { "AttributeName",
-            "ElementName", "HtmlAttributes", "LocatorImpl", "MetaScanner",
-            "NamedCharacters", "Portability", "StackNode", "Tokenizer",
-            "TreeBuilder", "UTF16Buffer" };
-
-    public class SourcePrinter {
-
-        private int level = 0;
-
-        private boolean indented = false;
-
-        private final StringBuilder buf = new StringBuilder();
-
-        public void indent() {
-            level++;
-        }
-
-        public void unindent() {
-            level--;
-        }
-
-        private void makeIndent() {
-            for (int i = 0; i < level; i++) {
-                buf.append("  ");
-            }
-        }
-
-        public void print(String arg) {
-            if (!indented) {
-                makeIndent();
-                indented = true;
-            }
-            buf.append(arg);
-        }
-
-        public void printLn(String arg) {
-            print(arg);
-            printLn();
-        }
-
-        public void printLn() {
-            buf.append("\n");
-            indented = false;
-        }
-
-        public String getSource() {
-            return buf.toString();
-        }
-
-        @Override public String toString() {
-            return getSource();
-        }
-    }
-
-    protected SourcePrinter printer = new SourcePrinter();
-
-    private SourcePrinter staticInitializerPrinter = new SourcePrinter();
-
-    private SourcePrinter tempPrinterHolder;
-
-    protected final CppTypes cppTypes;
-
-    protected String className = "";
-
-    protected int currentArrayCount;
-
-    protected Set<String> forLoopsWithCondition = new HashSet<String>();
-
-    protected boolean inPrimitiveNoLengthFieldDeclarator = false;
-
-    protected final SymbolTable symbolTable;
-
-    protected String definePrefix;
-
-    protected String javaClassName;
-
-    protected boolean suppressPointer = false;
-
-    private final List<String> staticReleases = new LinkedList<String>();
-
-    private boolean inConstructorBody = false;
-
-    private String currentMethod = null;
-
-    private Set<String> labels = null;
-
-    private boolean destructor;
-
-    /**
-     * @param cppTypes
-     */
-    public CppVisitor(CppTypes cppTypes, SymbolTable symbolTable) {
-        this.cppTypes = cppTypes;
-        this.symbolTable = symbolTable;
-        staticInitializerPrinter.indent();
-    }
-
-    public String getSource() {
-        return printer.getSource();
-    }
-
-    private String classNameFromExpression(Expression e) {
-        if (e instanceof NameExpr) {
-            NameExpr nameExpr = (NameExpr) e;
-            String name = nameExpr.getName();
-            if (Arrays.binarySearch(CLASS_NAMES, name) > -1) {
-                return name;
-            }
-        }
-        return null;
-    }
-
-    protected void printModifiers(int modifiers) {
-    }
-
-    private void printMembers(List<BodyDeclaration> members, LocalSymbolTable arg) {
-        for (BodyDeclaration member : members) {
-            member.accept(this, arg);
-        }
-    }
-
-    private void printTypeArgs(List<Type> args, LocalSymbolTable arg) {
-        // if (args != null) {
-        // printer.print("<");
-        // for (Iterator<Type> i = args.iterator(); i.hasNext();) {
-        // Type t = i.next();
-        // t.accept(this, arg);
-        // if (i.hasNext()) {
-        // printer.print(", ");
-        // }
-        // }
-        // printer.print(">");
-        // }
-    }
-
-    private void printTypeParameters(List<TypeParameter> args, LocalSymbolTable arg) {
-        // if (args != null) {
-        // printer.print("<");
-        // for (Iterator<TypeParameter> i = args.iterator(); i.hasNext();) {
-        // TypeParameter t = i.next();
-        // t.accept(this, arg);
-        // if (i.hasNext()) {
-        // printer.print(", ");
-        // }
-        // }
-        // printer.print(">");
-        // }
-    }
-
-    public void visit(Node n, LocalSymbolTable arg) {
-        throw new IllegalStateException(n.getClass().getName());
-    }
-
-    public void visit(CompilationUnit n, LocalSymbolTable arg) {
-        if (n.getTypes() != null) {
-            for (Iterator<TypeDeclaration> i = n.getTypes().iterator(); i.hasNext();) {
-                i.next().accept(this, arg);
-                printer.printLn();
-                if (i.hasNext()) {
-                    printer.printLn();
-                }
-            }
-        }
-    }
-
-    public void visit(PackageDeclaration n, LocalSymbolTable arg) {
-        throw new IllegalStateException(n.getClass().getName());
-    }
-
-    public void visit(NameExpr n, LocalSymbolTable arg) {
-        if ("mappingLangToXmlLang".equals(n.getName())) {
-            printer.print("0");
-        } else if ("LANG_NS".equals(n.getName())) {
-            printer.print("ALL_NO_NS");
-        } else if ("LANG_PREFIX".equals(n.getName())) {
-            printer.print("ALL_NO_PREFIX");
-        } else if ("HTML_LOCAL".equals(n.getName())) {
-            printer.print(cppTypes.localForLiteral("html"));
-        } else if ("documentModeHandler".equals(n.getName())) {
-            printer.print("this");
-        } else {
-            String prefixedName = javaClassName + "." + n.getName();
-            String constant = symbolTable.cppDefinesByJavaNames.get(prefixedName);
-            if (constant != null) {
-                printer.print(constant);
-            } else {
-                printer.print(n.getName());
-            }
-        }
-    }
-
-    public void visit(QualifiedNameExpr n, LocalSymbolTable arg) {
-        n.getQualifier().accept(this, arg);
-        printer.print(".");
-        printer.print(n.getName());
-    }
-
-    public void visit(ImportDeclaration n, LocalSymbolTable arg) {
-        throw new IllegalStateException(n.getClass().getName());
-    }
-
-    public void visit(ClassOrInterfaceDeclaration n, LocalSymbolTable arg) {
-        javaClassName = n.getName();
-        className = cppTypes.classPrefix() + javaClassName;
-        definePrefix = makeDefinePrefix(className);
-
-        startClassDeclaration();
-
-        if (n.getMembers() != null) {
-            printMembers(n.getMembers(), arg);
-        }
-
-        endClassDeclaration();
-    }
-
-    private String makeDefinePrefix(String name) {
-        StringBuilder sb = new StringBuilder();
-        boolean prevWasLowerCase = true;
-        for (int i = 0; i < name.length(); i++) {
-            char c = name.charAt(i);
-            if (c >= 'a' && c <= 'z') {
-                sb.append((char) (c - 0x20));
-                prevWasLowerCase = true;
-            } else if (c >= 'A' && c <= 'Z') {
-                if (prevWasLowerCase) {
-                    sb.append('_');
-                }
-                sb.append(c);
-                prevWasLowerCase = false;
-            } else if (c >= '0' && c <= '9') {
-                sb.append(c);
-                prevWasLowerCase = false;
-            }
-        }
-        sb.append('_');
-        return sb.toString();
-    }
-
-    protected void endClassDeclaration() {
-        printer.printLn("void");
-        printer.print(className);
-        printer.printLn("::initializeStatics()");
-        printer.printLn("{");
-        printer.print(staticInitializerPrinter.getSource());
-        printer.printLn("}");
-        printer.printLn();
-
-        printer.printLn("void");
-        printer.print(className);
-        printer.printLn("::releaseStatics()");
-        printer.printLn("{");
-        printer.indent();
-        for (String del : staticReleases) {
-            printer.print(del);
-            printer.printLn(";");
-        }
-        printer.unindent();
-        printer.printLn("}");
-        printer.printLn();
-
-        if (cppTypes.hasSupplement(javaClassName)) {
-            printer.printLn();
-            printer.print("#include \"");
-            printer.print(className);
-            printer.printLn("CppSupplement.h\"");
-        }
-    }
-
-    protected void startClassDeclaration() {
-        printer.print("#define ");
-        printer.print(className);
-        printer.printLn("_cpp__");
-        printer.printLn();
-
-        String[] incs = cppTypes.boilerplateIncludes(javaClassName);
-        for (int i = 0; i < incs.length; i++) {
-            String inc = incs[i];
-            printer.print("#include \"");
-            printer.print(inc);
-            printer.printLn(".h\"");
-        }
-
-        printer.printLn();
-
-        for (int i = 0; i < Main.H_LIST.length; i++) {
-            String klazz = Main.H_LIST[i];
-            if (!klazz.equals(javaClassName)) {
-                printer.print("#include \"");
-                printer.print(cppTypes.classPrefix());
-                printer.print(klazz);
-                printer.printLn(".h\"");
-            }
-        }
-
-        printer.printLn();
-        printer.print("#include \"");
-        printer.print(className);
-        printer.printLn(".h\"");
-        if ("AttributeName".equals(javaClassName)
-                || "ElementName".equals(javaClassName)) {
-            printer.print("#include \"");
-            printer.print(cppTypes.classPrefix());
-            printer.print("Releasable");
-            printer.print(javaClassName);
-            printer.printLn(".h\"");
-        }
-        printer.printLn();
-    }
-
-    public void visit(EmptyTypeDeclaration n, LocalSymbolTable arg) {
-        if (n.getJavaDoc() != null) {
-            n.getJavaDoc().accept(this, arg);
-        }
-        printer.print(";");
-    }
-
-    public void visit(JavadocComment n, LocalSymbolTable arg) {
-        printer.print("/**");
-        printer.print(n.getContent());
-        printer.printLn("*/");
-    }
-
-    public void visit(ClassOrInterfaceType n, LocalSymbolTable arg) {
-        if (n.getScope() != null) {
-            n.getScope().accept(this, arg);
-            printer.print(".");
-            throw new IllegalStateException("Can't translate nested classes.");
-        }
-        String name = n.getName();
-        if ("String".equals(name)) {
-            if (local()) {
-                name = cppTypes.localType();
-            } else if (prefix()) {
-                name = cppTypes.prefixType();
-            } else if (nsUri()) {
-                name = cppTypes.nsUriType();
-            } else if (literal()) {
-                name = cppTypes.literalType();
-            } else {
-                name = cppTypes.stringType();
-            }
-        } else if ("T".equals(name) || "Object".equals(name)) {
-            name = cppTypes.nodeType();
-        } else if ("TokenHandler".equals(name)) {
-            name = cppTypes.classPrefix() + "TreeBuilder*";
-        } else if ("EncodingDeclarationHandler".equals(name)) {
-            name = cppTypes.encodingDeclarationHandlerType();
-        } else if ("DocumentModeHandler".equals(name)) {
-            name = cppTypes.documentModeHandlerType();
-        } else if ("DocumentMode".equals(name)) {
-            name = cppTypes.documentModeType();
-        } else {
-            name = cppTypes.classPrefix() + name + (suppressPointer ? "" : "*");
-        }
-        printer.print(name);
-        printTypeArgs(n.getTypeArgs(), arg);
-    }
-
-    protected boolean inHeader() {
-        return false;
-    }
-
-    public void visit(TypeParameter n, LocalSymbolTable arg) {
-        printer.print(n.getName());
-        if (n.getTypeBound() != null) {
-            printer.print(" extends ");
-            for (Iterator<ClassOrInterfaceType> i = n.getTypeBound().iterator(); i.hasNext();) {
-                ClassOrInterfaceType c = i.next();
-                c.accept(this, arg);
-                if (i.hasNext()) {
-                    printer.print(" & ");
-                }
-            }
-        }
-    }
-
-    public void visit(PrimitiveType n, LocalSymbolTable arg) {
-        switch (n.getType()) {
-            case Boolean:
-                printer.print(cppTypes.booleanType());
-                break;
-            case Byte:
-                throw new IllegalStateException("Unsupported primitive.");
-            case Char:
-                printer.print(cppTypes.charType());
-                break;
-            case Double:
-                throw new IllegalStateException("Unsupported primitive.");
-            case Float:
-                throw new IllegalStateException("Unsupported primitive.");
-            case Int:
-                printer.print(cppTypes.intType());
-                break;
-            case Long:
-                throw new IllegalStateException("Unsupported primitive.");
-            case Short:
-                throw new IllegalStateException("Unsupported primitive.");
-        }
-    }
-
-    public void visit(ReferenceType n, LocalSymbolTable arg) {
-        if (noLength()) {
-            n.getType().accept(this, arg);
-            for (int i = 0; i < n.getArrayCount(); i++) {
-                if (!inPrimitiveNoLengthFieldDeclarator) {
-                    printer.print("*");
-                }
-            }
-        } else {
-            for (int i = 0; i < n.getArrayCount(); i++) {
-                printer.print(cppTypes.arrayTemplate());
-                printer.print("<");
-            }
-            n.getType().accept(this, arg);
-            for (int i = 0; i < n.getArrayCount(); i++) {
-                printer.print(",");
-                printer.print(cppTypes.intType());
-                printer.print(">");
-            }
-        }
-    }
-
-    public void visit(WildcardType n, LocalSymbolTable arg) {
-        printer.print("?");
-        if (n.getExtends() != null) {
-            printer.print(" extends ");
-            n.getExtends().accept(this, arg);
-        }
-        if (n.getSuper() != null) {
-            printer.print(" super ");
-            n.getSuper().accept(this, arg);
-        }
-    }
-
-    public void visit(FieldDeclaration n, LocalSymbolTable arg) {
-        currentAnnotations = n.getAnnotations();
-        fieldDeclaration(n, arg);
-        currentAnnotations = null;
-    }
-
-    protected boolean isNonToCharArrayMethodCall(Expression exp) {
-        if (exp instanceof MethodCallExpr) {
-            MethodCallExpr mce = (MethodCallExpr) exp;
-            return !"toCharArray".equals(mce.getName());
-        } else {
-            return false;
-        }
-    }
-
-    protected void fieldDeclaration(FieldDeclaration n, LocalSymbolTable arg) {
-        tempPrinterHolder = printer;
-        printer = staticInitializerPrinter;
-        int modifiers = n.getModifiers();
-        List<VariableDeclarator> variables = n.getVariables();
-        VariableDeclarator declarator = variables.get(0);
-        if (ModifierSet.isStatic(modifiers) && ModifierSet.isFinal(modifiers)
-                && !(n.getType() instanceof PrimitiveType)
-                && declarator.getInit() != null) {
-            if (n.getType() instanceof ReferenceType) {
-                ReferenceType rt = (ReferenceType) n.getType();
-                currentArrayCount = rt.getArrayCount();
-                if (currentArrayCount > 0) {
-                    if (currentArrayCount != 1) {
-                        throw new IllegalStateException(
-                                "Multidimensional arrays not supported. " + n);
-                    }
-                    if (noLength()) {
-                        if (rt.getType() instanceof PrimitiveType) {
-                            // do nothing
-                        } else {
-                            staticReleases.add("delete[] "
-                                    + declarator.getId().getName());
-
-                            ArrayInitializerExpr aie = (ArrayInitializerExpr) declarator.getInit();
-
-                            declarator.getId().accept(this, arg);
-                            printer.print(" = new ");
-                            // suppressPointer = true;
-                            rt.getType().accept(this, arg);
-                            // suppressPointer = false;
-                            printer.print("[");
-                            printer.print("" + aie.getValues().size());
-                            printer.printLn("];");
-
-                            printArrayInit(declarator.getId(), aie.getValues(),
-                                    arg);
-                        }
-                    } else if (isNonToCharArrayMethodCall(declarator.getInit())
-                            || !(rt.getType() instanceof PrimitiveType)) {
-                        staticReleases.add(declarator.getId().getName()
-                                + ".release()");
-                        declarator.getId().accept(this, arg);
-                        printer.print(" = ");
-                        if (declarator.getInit() instanceof ArrayInitializerExpr) {
-
-                            ArrayInitializerExpr aie = (ArrayInitializerExpr) declarator.getInit();
-                            printer.print(cppTypes.arrayTemplate());
-                            printer.print("<");
-                            suppressPointer = true;
-                            rt.getType().accept(this, arg);
-                            suppressPointer = false;
-                            printer.print(",");
-                            printer.print(cppTypes.intType());
-                            printer.print(">(");
-                            printer.print("" + aie.getValues().size());
-                            printer.printLn(");");
-                            printArrayInit(declarator.getId(), aie.getValues(),
-                                    arg);
-                        } else {
-                            declarator.getInit().accept(this, arg);
-                            printer.printLn(";");
-                        }
-                    } else if ((rt.getType() instanceof PrimitiveType)) {
-                        printer = tempPrinterHolder;
-                        printer.print("static ");
-                        rt.getType().accept(this, arg);
-                        printer.print(" const ");
-                        declarator.getId().accept(this, arg);
-                        printer.print("_DATA[] = ");
-                        declarator.getInit().accept(this, arg);
-                        printer.printLn(";");
-                        printer = staticInitializerPrinter;
-
-                        declarator.getId().accept(this, arg);
-                        printer.print(" = ");
-                        printer.print(cppTypes.arrayTemplate());
-                        printer.print("<");
-                        rt.getType().accept(this, arg);
-                        printer.print(",");
-                        printer.print(cppTypes.intType());
-                        printer.print(">((");
-                        rt.getType().accept(this, arg);
-                        printer.print("*)");
-                        declarator.getId().accept(this, arg);
-                        printer.print("_DATA, ");
-                        printer.print(Integer.toString(((ArrayInitializerExpr) declarator.getInit()).getValues().size()));
-                        printer.printLn(");");
-                    }
-                } else {
-
-                    if ("AttributeName".equals(n.getType().toString())) {
-                        printer.print("ATTR_");
-                        staticReleases.add("delete ATTR_"
-                                + declarator.getId().getName());
-                    } else if ("ElementName".equals(n.getType().toString())) {
-                        printer.print("ELT_");
-                        staticReleases.add("delete ELT_"
-                                + declarator.getId().getName());
-                    } else {
-                        staticReleases.add("delete "
-                                + declarator.getId().getName());
-                    }
-                    declarator.accept(this, arg);
-                    printer.printLn(";");
-                }
-            } else {
-                throw new IllegalStateException(
-                        "Non-reference, non-primitive fields not supported.");
-            }
-        }
-        currentArrayCount = 0;
-        printer = tempPrinterHolder;
-    }
-
-    private void printArrayInit(VariableDeclaratorId variableDeclaratorId,
-            List<Expression> values, LocalSymbolTable arg) {
-        for (int i = 0; i < values.size(); i++) {
-            Expression exp = values.get(i);
-            variableDeclaratorId.accept(this, arg);
-            printer.print("[");
-            printer.print("" + i);
-            printer.print("] = ");
-            if (exp instanceof NameExpr) {
-                if ("AttributeName".equals(javaClassName)) {
-                    printer.print("ATTR_");
-                } else if ("ElementName".equals(javaClassName)) {
-                    printer.print("ELT_");
-                }
-            }
-            exp.accept(this, arg);
-            printer.printLn(";");
-        }
-    }
-
-    public void visit(VariableDeclarator n, LocalSymbolTable arg) {
-        n.getId().accept(this, arg);
-
-        if (n.getInit() != null) {
-            printer.print(" = ");
-            n.getInit().accept(this, arg);
-        }
-    }
-
-    public void visit(VariableDeclaratorId n, LocalSymbolTable arg) {
-        printer.print(n.getName());
-        if (noLength()) {
-            for (int i = 0; i < currentArrayCount; i++) {
-                if (inPrimitiveNoLengthFieldDeclarator) {
-                    printer.print("[]");
-                }
-            }
-        }
-        for (int i = 0; i < n.getArrayCount(); i++) {
-            printer.print("[]");
-        }
-    }
-
-    public void visit(ArrayInitializerExpr n, LocalSymbolTable arg) {
-        printer.print("{");
-        if (n.getValues() != null) {
-            printer.print(" ");
-            for (Iterator<Expression> i = n.getValues().iterator(); i.hasNext();) {
-                Expression expr = i.next();
-                expr.accept(this, arg);
-                if (i.hasNext()) {
-                    printer.print(", ");
-                }
-            }
-            printer.print(" ");
-        }
-        printer.print("}");
-    }
-
-    public void visit(VoidType n, LocalSymbolTable arg) {
-        printer.print("void");
-    }
-
-    public void visit(ArrayAccessExpr n, LocalSymbolTable arg) {
-        n.getName().accept(this, arg);
-        printer.print("[");
-        n.getIndex().accept(this, arg);
-        printer.print("]");
-    }
-
-    public void visit(ArrayCreationExpr n, LocalSymbolTable arg) {
-        // printer.print("new ");
-        // n.getType().accept(this, arg);
-        // printTypeArgs(n.getTypeArgs(), arg);
-
-        if (n.getDimensions() != null) {
-            if (noLength()) {
-                for (Expression dim : n.getDimensions()) {
-                    printer.print("new ");
-                    n.getType().accept(this, arg);
-                    printer.print("[");
-                    dim.accept(this, arg);
-                    printer.print("]");
-                }
-            } else {
-                for (Expression dim : n.getDimensions()) {
-                    printer.print(cppTypes.arrayTemplate());
-                    printer.print("<");
-                    n.getType().accept(this, arg);
-                    printer.print(",");
-                    printer.print(cppTypes.intType());
-                    printer.print(">(");
-                    dim.accept(this, arg);
-                    printer.print(")");
-                }
-            }
-            if (n.getArrayCount() > 0) {
-                throw new IllegalStateException(
-                        "Nested array allocation not supported. "
-                                + n.toString());
-            }
-        } else {
-            throw new IllegalStateException(
-                    "Array initializer as part of array creation not supported. "
-                            + n.toString());
-        }
-    }
-
-    public void visit(AssignExpr n, LocalSymbolTable arg) {
-        if (inConstructorBody) {
-            n.getTarget().accept(this, arg);
-            printer.print("(");
-            n.getValue().accept(this, arg);
-            printer.print(")");
-        } else {
-            n.getTarget().accept(this, arg);
-            printer.print(" ");
-            switch (n.getOperator()) {
-                case assign:
-                    printer.print("=");
-                    break;
-                case and:
-                    printer.print("&=");
-                    break;
-                case or:
-                    printer.print("|=");
-                    break;
-                case xor:
-                    printer.print("^=");
-                    break;
-                case plus:
-                    printer.print("+=");
-                    break;
-                case minus:
-                    printer.print("-=");
-                    break;
-                case rem:
-                    printer.print("%=");
-                    break;
-                case slash:
-                    printer.print("/=");
-                    break;
-                case star:
-                    printer.print("*=");
-                    break;
-                case lShift:
-                    printer.print("<<=");
-                    break;
-                case rSignedShift:
-                    printer.print(">>=");
-                    break;
-                case rUnsignedShift:
-                    printer.print(">>>=");
-                    break;
-            }
-            printer.print(" ");
-            n.getValue().accept(this, arg);
-        }
-    }
-
-    public void visit(BinaryExpr n, LocalSymbolTable arg) {
-        Expression right = n.getRight();
-        switch (n.getOperator()) {
-            case notEquals:
-                if (right instanceof NullLiteralExpr) {
-                    printer.print("!!");
-                    n.getLeft().accept(this, arg);
-                    return;
-                } else if (right instanceof IntegerLiteralExpr) {
-                    IntegerLiteralExpr ile = (IntegerLiteralExpr) right;
-                    if ("0".equals(ile.getValue())) {
-                        n.getLeft().accept(this, arg);
-                        return;
-                    }
-                }
-            case equals:
-                if (right instanceof NullLiteralExpr) {
-                    printer.print("!");
-                    n.getLeft().accept(this, arg);
-                    return;
-                } else if (right instanceof IntegerLiteralExpr) {
-                    IntegerLiteralExpr ile = (IntegerLiteralExpr) right;
-                    if ("0".equals(ile.getValue())) {
-                        printer.print("!");
-                        n.getLeft().accept(this, arg);
-                        return;
-                    }
-                }
-            default:
-                // fall thru
-        }
-
-        n.getLeft().accept(this, arg);
-        printer.print(" ");
-        switch (n.getOperator()) {
-            case or:
-                printer.print("||");
-                break;
-            case and:
-                printer.print("&&");
-                break;
-            case binOr:
-                printer.print("|");
-                break;
-            case binAnd:
-                printer.print("&");
-                break;
-            case xor:
-                printer.print("^");
-                break;
-            case equals:
-                printer.print("==");
-                break;
-            case notEquals:
-                printer.print("!=");
-                break;
-            case less:
-                printer.print("<");
-                break;
-            case greater:
-                printer.print(">");
-                break;
-            case lessEquals:
-                printer.print("<=");
-                break;
-            case greaterEquals:
-                printer.print(">=");
-                break;
-            case lShift:
-                printer.print("<<");
-                break;
-            case rSignedShift:
-                printer.print(">>");
-                break;
-            case rUnsignedShift:
-                printer.print(">>>");
-                break;
-            case plus:
-                printer.print("+");
-                break;
-            case minus:
-                printer.print("-");
-                break;
-            case times:
-                printer.print("*");
-                break;
-            case divide:
-                printer.print("/");
-                break;
-            case remainder:
-                printer.print("%");
-                break;
-        }
-        printer.print(" ");
-        n.getRight().accept(this, arg);
-    }
-
-    public void visit(CastExpr n, LocalSymbolTable arg) {
-        printer.print("(");
-        n.getType().accept(this, arg);
-        printer.print(") ");
-        n.getExpr().accept(this, arg);
-    }
-
-    public void visit(ClassExpr n, LocalSymbolTable arg) {
-        n.getType().accept(this, arg);
-        printer.print(".class");
-    }
-
-    public void visit(ConditionalExpr n, LocalSymbolTable arg) {
-        n.getCondition().accept(this, arg);
-        printer.print(" ? ");
-        n.getThenExpr().accept(this, arg);
-        printer.print(" : ");
-        n.getElseExpr().accept(this, arg);
-    }
-
-    public void visit(EnclosedExpr n, LocalSymbolTable arg) {
-        printer.print("(");
-        n.getInner().accept(this, arg);
-        printer.print(")");
-    }
-
-    public void visit(FieldAccessExpr n, LocalSymbolTable arg) {
-        Expression scope = n.getScope();
-        String field = n.getField();
-        if (inConstructorBody && (scope instanceof ThisExpr)) {
-            printer.print(field);
-        } else if ("length".equals(field) && !(scope instanceof ThisExpr)) {
-            scope.accept(this, arg);
-            printer.print(".length");
-        } else if ("MAX_VALUE".equals(field)
-                && "Integer".equals(scope.toString())) {
-            printer.print(cppTypes.maxInteger());
-        } else {
-            String clazzName = classNameFromExpression(scope);
-            if (clazzName == null) {
-                if ("DocumentMode".equals(scope.toString())) {
-                    // printer.print(cppTypes.documentModeType());
-                    // printer.print(".");
-                } else {
-                    scope.accept(this, arg);
-                    printer.print("->");
-                }
-            } else {
-                String prefixedName = clazzName + "." + field;
-                String constant = symbolTable.cppDefinesByJavaNames.get(prefixedName);
-                if (constant != null) {
-                    printer.print(constant);
-                    return;
-                } else {
-                    printer.print(cppTypes.classPrefix());
-                    printer.print(clazzName);
-                    printer.print("::");
-                    if (symbolTable.isNotAnAttributeOrElementName(field)) {
-                        if ("AttributeName".equals(clazzName)) {
-                            printer.print("ATTR_");
-                        } else if ("ElementName".equals(clazzName)) {
-                            printer.print("ELT_");
-                        }
-                    }
-                }
-            }
-            printer.print(field);
-        }
-    }
-
-    public void visit(InstanceOfExpr n, LocalSymbolTable arg) {
-        n.getExpr().accept(this, arg);
-        printer.print(" instanceof ");
-        n.getType().accept(this, arg);
-    }
-
-    public void visit(CharLiteralExpr n, LocalSymbolTable arg) {
-        printCharLiteral(n.getValue());
-    }
-
-    private void printCharLiteral(String val) {
-        if (val.length() != 1) {
-            printer.print("'");
-            printer.print(val);
-            printer.print("'");
-            return;
-        }
-        char c = val.charAt(0);
-        switch (c) {
-            case 0:
-                printer.print("'\\0'");
-                break;
-            case '\n':
-                printer.print("'\\n'");
-                break;
-            case '\t':
-                printer.print("'\\t'");
-                break;
-            case 0xB:
-                printer.print("'\\v'");
-                break;
-            case '\b':
-                printer.print("'\\b'");
-                break;
-            case '\r':
-                printer.print("'\\r'");
-                break;
-            case 0xC:
-                printer.print("'\\f'");
-                break;
-            case 0x7:
-                printer.print("'\\a'");
-                break;
-            case '\\':
-                printer.print("'\\\\'");
-                break;
-            case '?':
-                printer.print("'\\?'");
-                break;
-            case '\'':
-                printer.print("'\\''");
-                break;
-            case '"':
-                printer.print("'\\\"'");
-                break;
-            default:
-                if (c >= 0x20 && c <= 0x7F) {
-                    printer.print("'" + c);
-                    printer.print("'");
-                } else {
-                    printer.print("0x");
-                    printer.print(Integer.toHexString(c));
-                }
-                break;
-        }
-    }
-
-    public void visit(DoubleLiteralExpr n, LocalSymbolTable arg) {
-        printer.print(n.getValue());
-    }
-
-    public void visit(IntegerLiteralExpr n, LocalSymbolTable arg) {
-        printer.print(n.getValue());
-    }
-
-    public void visit(LongLiteralExpr n, LocalSymbolTable arg) {
-        printer.print(n.getValue());
-    }
-
-    public void visit(IntegerLiteralMinValueExpr n, LocalSymbolTable arg) {
-        printer.print(n.getValue());
-    }
-
-    public void visit(LongLiteralMinValueExpr n, LocalSymbolTable arg) {
-        printer.print(n.getValue());
-    }
-
-    public void visit(StringLiteralExpr n, LocalSymbolTable arg) {
-        String val = n.getValue();
-        if ("http://www.w3.org/1999/xhtml".equals(val)) {
-            printer.print(cppTypes.xhtmlNamespaceLiteral());
-        } else if ("http://www.w3.org/2000/svg".equals(val)) {
-            printer.print(cppTypes.svgNamespaceLiteral());
-        } else if ("http://www.w3.org/2000/xmlns/".equals(val)) {
-            printer.print(cppTypes.xmlnsNamespaceLiteral());
-        } else if ("http://www.w3.org/XML/1998/namespace".equals(val)) {
-            printer.print(cppTypes.xmlNamespaceLiteral());
-        } else if ("http://www.w3.org/1999/xlink".equals(val)) {
-            printer.print(cppTypes.xlinkNamespaceLiteral());
-        } else if ("http://www.w3.org/1998/Math/MathML".equals(val)) {
-            printer.print(cppTypes.mathmlNamespaceLiteral());
-        } else if ("".equals(val) && "AttributeName".equals(javaClassName)) {
-            printer.print(cppTypes.noNamespaceLiteral());
-        } else if (val.startsWith("-/") || val.startsWith("+//")
-                || val.startsWith("http://") || val.startsWith("XSLT")) {
-            printer.print(cppTypes.stringForLiteral(val));
-        } else if (("hidden".equals(val) || "isindex".equals(val))
-                && "TreeBuilder".equals(javaClassName)) {
-            printer.print(cppTypes.stringForLiteral(val));
-        } else if ("isQuirky".equals(currentMethod) && "html".equals(val)) {
-            printer.print(cppTypes.stringForLiteral(val));
-        } else {
-            printer.print(cppTypes.localForLiteral(val));
-        }
-    }
-
-    public void visit(BooleanLiteralExpr n, LocalSymbolTable arg) {
-        if (n.getValue()) {
-            printer.print(cppTypes.trueLiteral());
-        } else {
-            printer.print(cppTypes.falseLiteral());
-        }
-    }
-
-    public void visit(NullLiteralExpr n, LocalSymbolTable arg) {
-        printer.print(cppTypes.nullLiteral());
-    }
-
-    public void visit(ThisExpr n, LocalSymbolTable arg) {
-        if (n.getClassExpr() != null) {
-            n.getClassExpr().accept(this, arg);
-            printer.print(".");
-        }
-        printer.print("this");
-    }
-
-    public void visit(SuperExpr n, LocalSymbolTable arg) {
-        if (n.getClassExpr() != null) {
-            n.getClassExpr().accept(this, arg);
-            printer.print(".");
-        }
-        printer.print("super");
-    }
-
-    public void visit(MethodCallExpr n, LocalSymbolTable arg) {
-        if ("releaseArray".equals(n.getName())
-                && "Portability".equals(n.getScope().toString())) {
-            n.getArgs().get(0).accept(this, arg);
-            printer.print(".release()");
-        } else if ("deleteArray".equals(n.getName())
-                && "Portability".equals(n.getScope().toString())) {
-            printer.print("delete[] ");
-            n.getArgs().get(0).accept(this, arg);
-        } else if ("delete".equals(n.getName())
-                && "Portability".equals(n.getScope().toString())) {
-            printer.print("delete ");
-            n.getArgs().get(0).accept(this, arg);
-        } else if ("arraycopy".equals(n.getName())
-                && "System".equals(n.getScope().toString())) {
-            printer.print(cppTypes.arrayCopy());
-            printer.print("(");
-            if (n.getArgs().get(0).toString().equals(
-                    n.getArgs().get(2).toString())) {
-                n.getArgs().get(0).accept(this, arg);
-                printer.print(", ");
-                n.getArgs().get(1).accept(this, arg);
-                printer.print(", ");
-                n.getArgs().get(3).accept(this, arg);
-                printer.print(", ");
-                n.getArgs().get(4).accept(this, arg);
-            } else if (n.getArgs().get(1).toString().equals("0")
-                    && n.getArgs().get(3).toString().equals("0")) {
-                n.getArgs().get(0).accept(this, arg);
-                printer.print(", ");
-                n.getArgs().get(2).accept(this, arg);
-                printer.print(", ");
-                n.getArgs().get(4).accept(this, arg);
-            } else {
-                for (Iterator<Expression> i = n.getArgs().iterator(); i.hasNext();) {
-                    Expression e = i.next();
-                    e.accept(this, arg);
-                    if (i.hasNext()) {
-                        printer.print(", ");
-                    }
-                }
-            }
-            printer.print(")");
-        } else if ("binarySearch".equals(n.getName())
-                && "Arrays".equals(n.getScope().toString())) {
-            n.getArgs().get(0).accept(this, arg);
-            printer.print(".binarySearch(");
-            n.getArgs().get(1).accept(this, arg);
-            printer.print(")");
-        } else {
-            Expression scope = n.getScope();
-            if (scope != null) {
-                if (scope instanceof StringLiteralExpr) {
-                    StringLiteralExpr strLit = (StringLiteralExpr) scope;
-                    String str = strLit.getValue();
-                    if (!"toCharArray".equals(n.getName())) {
-                        throw new IllegalStateException(
-                                "Unsupported method call on string literal: "
-                                        + n.getName());
-                    }
-                    printer.print("{ ");
-                    for (int i = 0; i < str.length(); i++) {
-                        char c = str.charAt(i);
-                        if (i != 0) {
-                            printer.print(", ");
-                        }
-                        printCharLiteral("" + c);
-                    }
-                    printer.print(" }");
-                    return;
-                } else {
-                    String clazzName = classNameFromExpression(scope);
-                    if (clazzName == null) {
-                        scope.accept(this, arg);
-                        printer.print("->");
-                    } else {
-                        printer.print(cppTypes.classPrefix());
-                        printer.print(clazzName);
-                        printer.print("::");
-                    }
-                }
-            }
-            printTypeArgs(n.getTypeArgs(), arg);
-            printer.print(n.getName());
-            printer.print("(");
-            if (n.getArgs() != null) {
-                for (Iterator<Expression> i = n.getArgs().iterator(); i.hasNext();) {
-                    Expression e = i.next();
-                    e.accept(this, arg);
-                    if (i.hasNext()) {
-                        printer.print(", ");
-                    }
-                }
-            }
-            printer.print(")");
-        }
-    }
-
-    public void visit(ObjectCreationExpr n, LocalSymbolTable arg) {
-        if (n.getScope() != null) {
-            n.getScope().accept(this, arg);
-            printer.print(".");
-        }
-
-        printer.print("new ");
-
-        suppressPointer = true;
-        printTypeArgs(n.getTypeArgs(), arg);
-        if ("createAttributeName".equals(currentMethod)
-                || "elementNameByBuffer".equals(currentMethod)) {
-            printer.print(cppTypes.classPrefix());
-            printer.print("Releasable");
-            printer.print(n.getType().getName());
-        } else {
-            n.getType().accept(this, arg);
-        }
-        suppressPointer = false;
-
-        if ("AttributeName".equals(n.getType().getName())) {
-            List<Expression> args = n.getArgs();
-            while (args.size() > 3) {
-                args.remove(3);
-            }
-        }
-
-        printer.print("(");
-        if (n.getArgs() != null) {
-            for (Iterator<Expression> i = n.getArgs().iterator(); i.hasNext();) {
-                Expression e = i.next();
-                e.accept(this, arg);
-                if (i.hasNext()) {
-                    printer.print(", ");
-                }
-            }
-        }
-        printer.print(")");
-
-        if (n.getAnonymousClassBody() != null) {
-            printer.printLn(" {");
-            printer.indent();
-            printMembers(n.getAnonymousClassBody(), arg);
-            printer.unindent();
-            printer.print("}");
-        }
-    }
-
-    public void visit(UnaryExpr n, LocalSymbolTable arg) {
-        switch (n.getOperator()) {
-            case positive:
-                printer.print("+");
-                break;
-            case negative:
-                printer.print("-");
-                break;
-            case inverse:
-                printer.print("~");
-                break;
-            case not:
-                printer.print("!");
-                break;
-            case preIncrement:
-                printer.print("++");
-                break;
-            case preDecrement:
-                printer.print("--");
-                break;
-        }
-
-        n.getExpr().accept(this, arg);
-
-        switch (n.getOperator()) {
-            case posIncrement:
-                printer.print("++");
-                break;
-            case posDecrement:
-                printer.print("--");
-                break;
-        }
-    }
-
-    public void visit(ConstructorDeclaration n, LocalSymbolTable arg) {
-        if ("TreeBuilder".equals(javaClassName)
-                || "MetaScanner".equals(javaClassName)) {
-            return;
-        }
-
-        arg = new LocalSymbolTable(javaClassName, symbolTable);
-        
-        // if (n.getJavaDoc() != null) {
-        // n.getJavaDoc().accept(this, arg);
-        // }
-        currentAnnotations = n.getAnnotations();
-
-        printModifiers(n.getModifiers());
-
-        printMethodNamespace();
-        printer.print(className);
-        currentAnnotations = null;
-
-        printer.print("(");
-        if (n.getParameters() != null) {
-            for (Iterator<Parameter> i = n.getParameters().iterator(); i.hasNext();) {
-                Parameter p = i.next();
-                p.accept(this, arg);
-                if (i.hasNext()) {
-                    printer.print(", ");
-                }
-            }
-        }
-        printer.print(")");
-
-        printConstructorBody(n.getBlock(), arg);
-    }
-
-    protected void printConstructorBody(BlockStmt block, LocalSymbolTable arg) {
-        inConstructorBody = true;
-        List<Statement> statements = block.getStmts();
-        List<Statement> nonAssigns = new LinkedList<Statement>();
-        int i = 0;
-        boolean needOutdent = false;
-        for (Statement statement : statements) {
-            if (statement instanceof ExpressionStmt
-                    && ((ExpressionStmt) statement).getExpression() instanceof AssignExpr) {
-                if (i == 0) {
-                    printer.printLn();
-                    printer.indent();
-                    printer.print(": ");
-                    needOutdent = true;
-                } else {
-                    printer.print(",");
-                    printer.printLn();
-                    printer.print("  ");
-                }
-                statement.accept(this, arg);
-                i++;
-            } else {
-                nonAssigns.add(statement);
-            }
-        }
-        if (needOutdent) {
-            printer.unindent();
-        }
-        inConstructorBody = false;
-        printer.printLn();
-        printer.printLn("{");
-        printer.indent();
-        String boilerplate = cppTypes.constructorBoilerplate(className);
-        if (boilerplate != null) {
-            printer.printLn(boilerplate);
-        }
-        for (Statement statement : nonAssigns) {
-            statement.accept(this, arg);
-            printer.printLn();
-        }
-        printer.unindent();
-        printer.printLn("}");
-        printer.printLn();
-    }
-
-    public void visit(MethodDeclaration n, LocalSymbolTable arg) {
-        arg = new LocalSymbolTable(javaClassName, symbolTable);
-        if (isPrintableMethod(n.getModifiers())
-                && !(n.getName().equals("endCoalescing") || n.getName().equals(
-                        "startCoalescing"))) {
-            printMethodDeclaration(n, arg);
-        }
-    }
-
-    private boolean isPrintableMethod(int modifiers) {
-        return !(ModifierSet.isAbstract(modifiers) || (ModifierSet.isProtected(modifiers) && !(ModifierSet.isFinal(modifiers) || "Tokenizer".equals(javaClassName))));
-    }
-
-    protected void printMethodDeclaration(MethodDeclaration n, LocalSymbolTable arg) {
-        if (n.getName().startsWith("fatal") || n.getName().startsWith("err")
-                || n.getName().startsWith("warn")
-                || n.getName().startsWith("maybeErr")
-                || n.getName().startsWith("maybeWarn")
-                || "releaseArray".equals(n.getName())
-                || "deleteArray".equals(n.getName())
-                || "delete".equals(n.getName())) {
-            return;
-        }
-
-        currentMethod = n.getName();
-
-        destructor = "destructor".equals(n.getName());
-
-        // if (n.getJavaDoc() != null) {
-        // n.getJavaDoc().accept(this, arg);
-        // }
-        currentAnnotations = n.getAnnotations();
-        boolean isInline = inline();
-        if (isInline && !inHeader()) {
-            return;
-        }
-
-        if (destructor) {
-            printModifiers(ModifierSet.PUBLIC);
-        } else {
-            printModifiers(n.getModifiers());
-        }
-
-        printTypeParameters(n.getTypeParameters(), arg);
-        if (n.getTypeParameters() != null) {
-            printer.print(" ");
-        }
-        if (!destructor) {
-            n.getType().accept(this, arg);
-            printer.print(" ");
-        }
-        printMethodNamespace();
-        if (destructor) {
-            printer.print("~");
-            printer.print(className);
-        } else {
-            printer.print(n.getName());
-        }
-
-        currentAnnotations = null;
-        printer.print("(");
-        if (n.getParameters() != null) {
-            for (Iterator<Parameter> i = n.getParameters().iterator(); i.hasNext();) {
-                Parameter p = i.next();
-                p.accept(this, arg);
-                if (i.hasNext()) {
-                    printer.print(", ");
-                }
-            }
-        }
-        printer.print(")");
-
-        for (int i = 0; i < n.getArrayCount(); i++) {
-            printer.print("[]");
-        }
-
-        if (inHeader() == isInline) {
-            printMethodBody(n.getBody(), arg);
-        } else {
-            printer.printLn(";");
-        }
-    }
-
-    private void printMethodBody(BlockStmt n, LocalSymbolTable arg) {
-        if (n == null) {
-            printer.print(";");
-        } else {
-            printer.printLn();
-            printer.printLn("{");
-            printer.indent();
-            if (destructor) {
-                String boilerplate = cppTypes.destructorBoilderplate(className);
-                if (boilerplate != null) {
-                    printer.printLn(boilerplate);
-                }
-            }
-            if (n.getStmts() != null) {
-                for (Statement s : n.getStmts()) {
-                    s.accept(this, arg);
-                    printer.printLn();
-                }
-            }
-            printer.unindent();
-            printer.print("}");
-        }
-        printer.printLn();
-        printer.printLn();
-    }
-
-    protected void printMethodNamespace() {
-        printer.printLn();
-        printer.print(className);
-        printer.print("::");
-    }
-
-    public void visit(Parameter n, LocalSymbolTable arg) {
-        currentAnnotations = n.getAnnotations();
-
-        arg.putLocalType(n.getId().getName(), convertType(n.getType(), n.getModifiers()));
-        
-        n.getType().accept(this, arg);
-        if (n.isVarArgs()) {
-            printer.print("...");
-        }
-        printer.print(" ");
-        n.getId().accept(this, arg);
-        currentAnnotations = null;
-    }
-
-    public void visit(ExplicitConstructorInvocationStmt n, LocalSymbolTable arg) {
-        if (n.isThis()) {
-            printTypeArgs(n.getTypeArgs(), arg);
-            printer.print("this");
-        } else {
-            if (n.getExpr() != null) {
-                n.getExpr().accept(this, arg);
-                printer.print(".");
-            }
-            printTypeArgs(n.getTypeArgs(), arg);
-            printer.print("super");
-        }
-        printer.print("(");
-        if (n.getArgs() != null) {
-            for (Iterator<Expression> i = n.getArgs().iterator(); i.hasNext();) {
-                Expression e = i.next();
-                e.accept(this, arg);
-                if (i.hasNext()) {
-                    printer.print(", ");
-                }
-            }
-        }
-        printer.print(");");
-    }
-
-    public void visit(VariableDeclarationExpr n, LocalSymbolTable arg) {
-        currentAnnotations = n.getAnnotations();
-
-        arg.putLocalType(n.getVars().get(0).toString(), convertType(n.getType(), n.getModifiers()));
-        
-        n.getType().accept(this, arg);
-        printer.print(" ");
-
-        for (Iterator<VariableDeclarator> i = n.getVars().iterator(); i.hasNext();) {
-            VariableDeclarator v = i.next();
-            v.accept(this, arg);
-            if (i.hasNext()) {
-                printer.print(", ");
-            }
-        }
-        currentAnnotations = null;
-    }
-
-    public void visit(TypeDeclarationStmt n, LocalSymbolTable arg) {
-        n.getTypeDeclaration().accept(this, arg);
-    }
-
-    public void visit(AssertStmt n, LocalSymbolTable arg) {
-    }
-
-    public void visit(BlockStmt n, LocalSymbolTable arg) {
-        printer.printLn("{");
-        if (n.getStmts() != null) {
-            printer.indent();
-            for (Statement s : n.getStmts()) {
-                s.accept(this, arg);
-                printer.printLn();
-            }
-            printer.unindent();
-        }
-        printer.print("}");
-
-    }
-
-    public void visit(LabeledStmt n, LocalSymbolTable arg) {
-        // Only conditionless for loops are needed and supported
-        // Not implementing general Java continue semantics in order
-        // to keep the generated C++ more readable.
-        Statement stmt = n.getStmt();
-        if (stmt instanceof ForStmt) {
-            ForStmt forLoop = (ForStmt) stmt;
-            if (!(forLoop.getInit() == null && forLoop.getCompare() == null && forLoop.getUpdate() == null)) {
-                forLoopsWithCondition.add(n.getLabel());
-            }
-        } else {
-            throw new IllegalStateException(
-                    "Only for loop supported as labeled statement. Line: "
-                            + n.getBeginLine());
-        }
-        String label = n.getLabel();
-        if (labels.contains(label)) {
-            printer.print(label);
-            printer.print(": ");
-        }
-        stmt.accept(this, arg);
-        printer.printLn();
-        label += "_end";
-        if (labels.contains(label)) {
-            printer.print(label);
-            printer.print(": ;");
-        }
-    }
-
-    public void visit(EmptyStmt n, LocalSymbolTable arg) {
-        printer.print(";");
-    }
-
-    public void visit(ExpressionStmt n, LocalSymbolTable arg) {
-        Expression e = n.getExpression();
-        if (isDroppedExpression(e)) {
-            return;
-        }
-        e.accept(this, arg);
-        if (!inConstructorBody) {
-            printer.print(";");
-        }
-    }
-
-    private boolean isDroppedExpression(Expression e) {
-        if (e instanceof MethodCallExpr) {
-            MethodCallExpr methodCallExpr = (MethodCallExpr) e;
-            String name = methodCallExpr.getName();
-            if (name.startsWith("fatal") || name.startsWith("err")
-                    || name.startsWith("warn") || name.startsWith("maybeErr")
-                    || name.startsWith("maybeWarn")) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    public void visit(SwitchStmt n, LocalSymbolTable arg) {
-        printer.print("switch(");
-        n.getSelector().accept(this, arg);
-        printer.printLn(") {");
-        if (n.getEntries() != null) {
-            printer.indent();
-            for (SwitchEntryStmt e : n.getEntries()) {
-                e.accept(this, arg);
-            }
-            printer.unindent();
-        }
-        printer.print("}");
-
-    }
-
-    public void visit(SwitchEntryStmt n, LocalSymbolTable arg) {
-        if (n.getLabel() != null) {
-            printer.print("case ");
-            n.getLabel().accept(this, arg);
-            printer.print(":");
-        } else {
-            printer.print("default:");
-        }
-        if (isNoStatement(n.getStmts())) {
-            printer.printLn();
-            printer.indent();
-            if (n.getLabel() == null) {
-                printer.printLn("; // fall through");
-            }
-            printer.unindent();
-        } else {
-            printer.printLn(" {");
-            printer.indent();
-            for (Statement s : n.getStmts()) {
-                s.accept(this, arg);
-                printer.printLn();
-            }
-            printer.unindent();
-            printer.printLn("}");
-        }
-    }
-
-    private boolean isNoStatement(List<Statement> stmts) {
-        if (stmts == null) {
-            return true;
-        }
-        for (Statement statement : stmts) {
-            if (!isDroppableStatement(statement)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    private boolean isDroppableStatement(Statement statement) {
-        if (statement instanceof AssertStmt) {
-            return true;
-        } else if (statement instanceof ExpressionStmt) {
-            ExpressionStmt es = (ExpressionStmt) statement;
-            if (isDroppedExpression(es.getExpression())) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    public void visit(BreakStmt n, LocalSymbolTable arg) {
-        if (n.getId() != null) {
-            printer.print("goto ");
-            printer.print(n.getId());
-            printer.print("_end");
-        } else {
-            printer.print("break");
-        }
-        printer.print(";");
-    }
-
-    public void visit(ReturnStmt n, LocalSymbolTable arg) {
-        printer.print("return");
-        if (n.getExpr() != null) {
-            printer.print(" ");
-            n.getExpr().accept(this, arg);
-        }
-        printer.print(";");
-    }
-
-    public void visit(EnumDeclaration n, LocalSymbolTable arg) {
-        if (n.getJavaDoc() != null) {
-            n.getJavaDoc().accept(this, arg);
-        }
-        currentAnnotations = n.getAnnotations();
-        // if (annotations != null) {
-        // for (AnnotationExpr a : annotations) {
-        // a.accept(this, arg);
-        // printer.printLn();
-        // }
-        // }
-        printModifiers(n.getModifiers());
-
-        printer.print("enum ");
-        printer.print(n.getName());
-
-        currentAnnotations = null;
-
-        if (n.getImplements() != null) {
-            printer.print(" implements ");
-            for (Iterator<ClassOrInterfaceType> i = n.getImplements().iterator(); i.hasNext();) {
-                ClassOrInterfaceType c = i.next();
-                c.accept(this, arg);
-                if (i.hasNext()) {
-                    printer.print(", ");
-                }
-            }
-        }
-
-        printer.printLn(" {");
-        printer.indent();
-        if (n.getEntries() != null) {
-            printer.printLn();
-            for (Iterator<EnumConstantDeclaration> i = n.getEntries().iterator(); i.hasNext();) {
-                EnumConstantDeclaration e = i.next();
-                e.accept(this, arg);
-                if (i.hasNext()) {
-                    printer.print(", ");
-                }
-            }
-        }
-        if (n.getMembers() != null) {
-            printer.printLn(";");
-            printMembers(n.getMembers(), arg);
-        } else {
-            if (n.getEntries() != null) {
-                printer.printLn();
-            }
-        }
-        printer.unindent();
-        printer.print("}");
-    }
-
-    public void visit(EnumConstantDeclaration n, LocalSymbolTable arg) {
-        if (n.getJavaDoc() != null) {
-            n.getJavaDoc().accept(this, arg);
-        }
-        currentAnnotations = n.getAnnotations();
-        // if (annotations != null) {
-        // for (AnnotationExpr a : annotations) {
-        // a.accept(this, arg);
-        // printer.printLn();
-        // }
-        // }
-        printer.print(n.getName());
-
-        currentAnnotations = null;
-
-        if (n.getArgs() != null) {
-            printer.print("(");
-            for (Iterator<Expression> i = n.getArgs().iterator(); i.hasNext();) {
-                Expression e = i.next();
-                e.accept(this, arg);
-                if (i.hasNext()) {
-                    printer.print(", ");
-                }
-            }
-            printer.print(")");
-        }
-
-        if (n.getClassBody() != null) {
-            printer.printLn(" {");
-            printer.indent();
-            printMembers(n.getClassBody(), arg);
-            printer.unindent();
-            printer.printLn("}");
-        }
-    }
-
-    public void visit(EmptyMemberDeclaration n, LocalSymbolTable arg) {
-        if (n.getJavaDoc() != null) {
-            n.getJavaDoc().accept(this, arg);
-        }
-        printer.print(";");
-    }
-
-    public void visit(InitializerDeclaration n, LocalSymbolTable arg) {
-        if (n.getJavaDoc() != null) {
-            n.getJavaDoc().accept(this, arg);
-        }
-        if (n.isStatic()) {
-            printer.print("static ");
-        }
-        n.getBlock().accept(this, arg);
-    }
-
-    public void visit(IfStmt n, LocalSymbolTable arg) {
-        if (!isErrorHandlerIf(n.getCondition())) {
-            printer.print("if (");
-            n.getCondition().accept(this, arg);
-            printer.print(") ");
-            n.getThenStmt().accept(this, arg);
-            if (n.getElseStmt() != null) {
-                printer.print(" else ");
-                n.getElseStmt().accept(this, arg);
-            }
-        }
-    }
-
-    private boolean isErrorHandlerIf(Expression condition) {
-        if (condition instanceof BinaryExpr) {
-            BinaryExpr be = (BinaryExpr) condition;
-            return be.getLeft().toString().equals("errorHandler");
-        }
-        return false;
-    }
-
-    public void visit(WhileStmt n, LocalSymbolTable arg) {
-        printer.print("while (");
-        n.getCondition().accept(this, arg);
-        printer.print(") ");
-        n.getBody().accept(this, arg);
-    }
-
-    public void visit(ContinueStmt n, LocalSymbolTable arg) {
-        // Not supporting the general Java continue semantics.
-        // Instead, making the generated code more readable for the
-        // case at hand.
-        if (n.getId() != null) {
-            printer.print("goto ");
-            printer.print(n.getId());
-            if (forLoopsWithCondition.contains(n.getId())) {
-                throw new IllegalStateException(
-                        "Continue attempted with a loop that has a condition. "
-                                + className + " " + n.getId());
-            }
-        } else {
-            printer.print("continue");
-        }
-        printer.print(";");
-    }
-
-    public void visit(DoStmt n, LocalSymbolTable arg) {
-        printer.print("do ");
-        n.getBody().accept(this, arg);
-        printer.print(" while (");
-        n.getCondition().accept(this, arg);
-        printer.print(");");
-    }
-
-    public void visit(ForeachStmt n, LocalSymbolTable arg) {
-        printer.print("for (");
-        n.getVariable().accept(this, arg);
-        printer.print(" : ");
-        n.getIterable().accept(this, arg);
-        printer.print(") ");
-        n.getBody().accept(this, arg);
-    }
-
-    public void visit(ForStmt n, LocalSymbolTable arg) {
-        printer.print("for (");
-        if (n.getInit() != null) {
-            for (Iterator<Expression> i = n.getInit().iterator(); i.hasNext();) {
-                Expression e = i.next();
-                e.accept(this, arg);
-                if (i.hasNext()) {
-                    printer.print(", ");
-                }
-            }
-        }
-        printer.print("; ");
-        if (n.getCompare() != null) {
-            n.getCompare().accept(this, arg);
-        }
-        printer.print("; ");
-        if (n.getUpdate() != null) {
-            for (Iterator<Expression> i = n.getUpdate().iterator(); i.hasNext();) {
-                Expression e = i.next();
-                e.accept(this, arg);
-                if (i.hasNext()) {
-                    printer.print(", ");
-                }
-            }
-        }
-        printer.print(") ");
-        n.getBody().accept(this, arg);
-    }
-
-    public void visit(ThrowStmt n, LocalSymbolTable arg) {
-        printer.print("throw ");
-        n.getExpr().accept(this, arg);
-        printer.print(";");
-    }
-
-    public void visit(SynchronizedStmt n, LocalSymbolTable arg) {
-        printer.print("synchronized (");
-        n.getExpr().accept(this, arg);
-        printer.print(") ");
-        n.getBlock().accept(this, arg);
-    }
-
-    public void visit(TryStmt n, LocalSymbolTable arg) {
-        printer.print("try ");
-        n.getTryBlock().accept(this, arg);
-        if (n.getCatchs() != null) {
-            for (CatchClause c : n.getCatchs()) {
-                c.accept(this, arg);
-            }
-        }
-        if (n.getFinallyBlock() != null) {
-            printer.print(" finally ");
-            n.getFinallyBlock().accept(this, arg);
-        }
-    }
-
-    public void visit(CatchClause n, LocalSymbolTable arg) {
-        printer.print(" catch (");
-        n.getExcept().accept(this, arg);
-        printer.print(") ");
-        n.getCatchBlock().accept(this, arg);
-
-    }
-
-    public void visit(AnnotationDeclaration n, LocalSymbolTable arg) {
-        if (n.getJavaDoc() != null) {
-            n.getJavaDoc().accept(this, arg);
-        }
-        currentAnnotations = n.getAnnotations();
-        // if (annotations != null) {
-        // for (AnnotationExpr a : annotations) {
-        // a.accept(this, arg);
-        // printer.printLn();
-        // }
-        // }
-        printModifiers(n.getModifiers());
-
-        printer.print("@interface ");
-        printer.print(n.getName());
-        currentAnnotations = null;
-        printer.printLn(" {");
-        printer.indent();
-        if (n.getMembers() != null) {
-            printMembers(n.getMembers(), arg);
-        }
-        printer.unindent();
-        printer.print("}");
-    }
-
-    public void visit(AnnotationMemberDeclaration n, LocalSymbolTable arg) {
-        if (n.getJavaDoc() != null) {
-            n.getJavaDoc().accept(this, arg);
-        }
-        currentAnnotations = n.getAnnotations();
-        // if (annotations != null) {
-        // for (AnnotationExpr a : annotations) {
-        // a.accept(this, arg);
-        // printer.printLn();
-        // }
-        // }
-        printModifiers(n.getModifiers());
-
-        n.getType().accept(this, arg);
-        printer.print(" ");
-        printer.print(n.getName());
-        currentAnnotations = null;
-        printer.print("()");
-        if (n.getDefaultValue() != null) {
-            printer.print(" default ");
-            n.getDefaultValue().accept(this, arg);
-        }
-        printer.print(";");
-    }
-
-    public void visit(MarkerAnnotationExpr n, LocalSymbolTable arg) {
-        printer.print("@");
-        n.getName().accept(this, arg);
-    }
-
-    public void visit(SingleMemberAnnotationExpr n, LocalSymbolTable arg) {
-        printer.print("@");
-        n.getName().accept(this, arg);
-        printer.print("(");
-        n.getMemberValue().accept(this, arg);
-        printer.print(")");
-    }
-
-    public void visit(NormalAnnotationExpr n, LocalSymbolTable arg) {
-        printer.print("@");
-        n.getName().accept(this, arg);
-        printer.print("(");
-        if (n.getPairs() != null) {
-            for (Iterator<MemberValuePair> i = n.getPairs().iterator(); i.hasNext();) {
-                MemberValuePair m = i.next();
-                m.accept(this, arg);
-                if (i.hasNext()) {
-                    printer.print(", ");
-                }
-            }
-        }
-        printer.print(")");
-    }
-
-    public void visit(MemberValuePair n, LocalSymbolTable arg) {
-        printer.print(n.getName());
-        printer.print(" = ");
-        n.getValue().accept(this, arg);
-    }
-
-    public void visit(LineComment n, LocalSymbolTable arg) {
-        printer.print("//");
-        printer.printLn(n.getContent());
-    }
-
-    public void visit(BlockComment n, LocalSymbolTable arg) {
-        printer.print("/*");
-        printer.print(n.getContent());
-        printer.printLn("*/");
-    }
-
-    public void setLabels(Set<String> labels) {
-        this.labels = labels;
-    }
-
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/GkAtomParser.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/GkAtomParser.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/GkAtomParser.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2008
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.cpptranslate;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.Reader;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-public class GkAtomParser {
-
-    private static final Pattern ATOM = Pattern.compile("^GK_ATOM\\(([^,]+),\\s*\"([^\"]*)\"\\).*$");
-    
-    private final BufferedReader reader;
-    
-    public GkAtomParser(Reader reader) {
-        this.reader = new BufferedReader(reader);
-    }
-    
-    public Map<String, String> parse() throws IOException {
-        Map<String, String> map = new HashMap<String, String>();
-        String line;
-        while((line = reader.readLine()) != null) {
-            Matcher m = ATOM.matcher(line);
-            if (m.matches()) {
-                map.put(m.group(2), m.group(1));
-            }
-        }
-        return map;
-    }
-    
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/HVisitor.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/HVisitor.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/HVisitor.java
+++ /dev/null
@@ -1,352 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2008
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.cpptranslate;
-
-import java.util.LinkedList;
-import java.util.List;
-
-import japa.parser.ast.body.FieldDeclaration;
-import japa.parser.ast.body.MethodDeclaration;
-import japa.parser.ast.body.ModifierSet;
-import japa.parser.ast.body.VariableDeclarator;
-import japa.parser.ast.expr.IntegerLiteralExpr;
-import japa.parser.ast.expr.MethodCallExpr;
-import japa.parser.ast.stmt.BlockStmt;
-import japa.parser.ast.type.PrimitiveType;
-import japa.parser.ast.type.ReferenceType;
-import japa.parser.ast.type.Type;
-
-public class HVisitor extends CppVisitor {
-
-    private enum Visibility {
-        NONE, PRIVATE, PUBLIC, PROTECTED,
-    }
-
-    private Visibility previousVisibility = Visibility.NONE;
-
-    private List<String> defines = new LinkedList<String>();
-
-    private SourcePrinter arrayInitPrinter = new SourcePrinter();
-    private SourcePrinter mainPrinterHolder;
-
-    /**
-     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#printMethodNamespace()
-     */
-    @Override protected void printMethodNamespace() {
-    }
-
-    public HVisitor(CppTypes cppTypes, SymbolTable symbolTable) {
-        super(cppTypes, symbolTable);
-    }
-
-    /**
-     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#startClassDeclaration()
-     */
-    @Override protected void startClassDeclaration() {
-        printer.print("#ifndef ");        
-        printer.print(className);
-        printer.printLn("_h__");
-        printer.print("#define ");        
-        printer.print(className);
-        printer.printLn("_h__");
-        
-        printer.printLn();
-        
-        String[] incs = cppTypes.boilerplateIncludes(javaClassName);
-        for (int i = 0; i < incs.length; i++) {
-            String inc = incs[i];
-            if (className.equals(inc)) {
-                continue;
-            }
-            printer.print("#include \"");
-            printer.print(inc);
-            printer.printLn(".h\"");
-        }
-
-        printer.printLn();
-
-        String[] forwDecls = cppTypes.boilerplateForwardDeclarations();
-        for (int i = 0; i < forwDecls.length; i++) {
-            String decl = forwDecls[i];
-            printer.print("class ");
-            printer.print(decl);
-            printer.printLn(";");            
-        }
-        
-        printer.printLn();
-
-        for (int i = 0; i < Main.H_LIST.length; i++) {
-            String klazz = Main.H_LIST[i];
-            if (!(klazz.equals(javaClassName) || klazz.equals("StackNode"))) {
-                printer.print("class ");
-                printer.print(cppTypes.classPrefix());
-                printer.print(klazz);
-                printer.printLn(";");
-            }
-        }
-        
-        printer.printLn();
-        
-        String[] otherDecls = cppTypes.boilerplateDeclarations(javaClassName);
-        for (int i = 0; i < otherDecls.length; i++) {
-            String decl = otherDecls[i];
-            printer.printLn(decl);
-        }
-        
-        printer.printLn();
-
-        printer.print("class ");
-        printer.printLn(className);
-        printer.printLn("{");
-        printer.indent();
-        printer.indent();
-    }
-
-    /**
-     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#endClassDeclaration()
-     */
-    @Override protected void endClassDeclaration() {
-        printModifiers(ModifierSet.PUBLIC | ModifierSet.STATIC);
-        printer.printLn("void initializeStatics();");        
-        printModifiers(ModifierSet.PUBLIC | ModifierSet.STATIC);
-        printer.printLn("void releaseStatics();");        
-        
-        printer.unindent();
-        printer.unindent();
-        
-        if (cppTypes.hasSupplement(javaClassName)) {
-            printer.printLn();
-            printer.print("#include \"");
-            printer.print(className);
-            printer.printLn("HSupplement.h\"");
-        }
-        
-        printer.printLn("};");
-        printer.printLn();
-
-        // This stuff should probably go into the .cpp anyway. sigh.
-        printer.print("#ifdef ");
-        printer.print(className);
-        printer.printLn("_cpp__");
-        printer.print(arrayInitPrinter.getSource());
-        printer.printLn("#endif");
-        printer.printLn();
-        
-        for (String define : defines) {
-            printer.printLn(define);
-        }
-        
-        printer.printLn();
-        printer.printLn();
-        printer.printLn("#endif");
-    }
-
-    /**
-     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#printModifiers(int)
-     */
-    @Override protected void printModifiers(int modifiers) {
-        if (ModifierSet.isPrivate(modifiers)) {
-            if (previousVisibility != Visibility.PRIVATE) {
-                printer.unindent();
-                printer.printLn("private:");
-                printer.indent();
-                previousVisibility = Visibility.PRIVATE;
-            }
-        } else if (ModifierSet.isProtected(modifiers)) {
-            if (previousVisibility != Visibility.PROTECTED) {
-                printer.unindent();
-                printer.printLn("protected:");
-                printer.indent();
-                previousVisibility = Visibility.PROTECTED;
-            }
-        } else {
-            if (previousVisibility != Visibility.PUBLIC) {
-                printer.unindent();
-                printer.printLn("public:");
-                printer.indent();
-                previousVisibility = Visibility.PUBLIC;
-            }
-        }
-        if (inline()) {
-            printer.print("inline ");            
-        }
-        if (virtual()) {
-            printer.print("virtual ");            
-        }
-        if (ModifierSet.isStatic(modifiers)) {
-            printer.print("static ");
-        }
-    }
-
-    /**
-     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#fieldDeclaration(japa.parser.ast.body.FieldDeclaration, java.lang.LocalSymbolTable)
-     */
-    @Override protected void fieldDeclaration(FieldDeclaration n, LocalSymbolTable arg) {
-        int modifiers = n.getModifiers();
-        List<VariableDeclarator> variables = n.getVariables();
-        VariableDeclarator declarator = variables.get(0);
-        if (ModifierSet.isStatic(modifiers) && ModifierSet.isFinal(modifiers)
-                && n.getType() instanceof PrimitiveType) {
-            PrimitiveType type = (PrimitiveType) n.getType();
-            if (type.getType() != PrimitiveType.Primitive.Int) {
-                throw new IllegalStateException(
-                        "Only int constant #defines supported.");
-            }
-            if (variables.size() != 1) {
-                throw new IllegalStateException(
-                        "More than one variable declared by one declarator.");
-            }
-            String name = javaClassName + "." + declarator.getId().getName();
-            String value = declarator.getInit().toString();
-            if ("Integer.MAX_VALUE".equals(value)) {
-                value = cppTypes.maxInteger();
-            }
-            String longName = definePrefix + declarator.getId().getName();
-            if (symbolTable.cppDefinesByJavaNames.containsKey(name)) {
-                throw new IllegalStateException(
-                        "Duplicate #define constant local name: " + name);
-            }
-            symbolTable.cppDefinesByJavaNames.put(name, longName);
-            defines.add("#define " + longName + " " + value);
-        } else {
-            if (n.getType() instanceof ReferenceType) {
-                ReferenceType rt = (ReferenceType) n.getType();
-                currentArrayCount = rt.getArrayCount();
-                if (currentArrayCount > 0
-                        && (rt.getType() instanceof PrimitiveType) && declarator.getInit() != null) {
-                    if (!ModifierSet.isStatic(modifiers)) {
-                        throw new IllegalStateException(
-                                "Non-static array case not supported here." + declarator);
-                    }
-                    if (noLength()) {
-                        inPrimitiveNoLengthFieldDeclarator = true;
-                        
-                        mainPrinterHolder = printer;
-                        printer = arrayInitPrinter;
-                        n.getType().accept(this, arg);
-                        printer.print(" ");
-                        printer.print(className);
-                        printer.print("::");
-                        declarator.getId().accept(this, arg);
-
-                        printer.print(" = ");                    
-                        
-                        declarator.getInit().accept(this, arg);
-                       
-                        printer.printLn(";");                    
-                        printer = mainPrinterHolder;                        
-                    } else if (!isNonToCharArrayMethodCall(declarator.getInit())) {
-                        mainPrinterHolder = printer;
-                        printer = arrayInitPrinter;
-                        
-                        printer.print(cppTypes.arrayTemplate());
-                        printer.print("<");
-                        suppressPointer = true;
-                        rt.getType().accept(this, arg);
-                        suppressPointer = false;
-                        printer.print(",");
-                        printer.print(cppTypes.intType());
-                        printer.print("> ");
-                        printer.print(className);
-                        printer.print("::");
-                        declarator.getId().accept(this, arg);
-                        printer.printLn(" = 0;");                    
-                        
-                        printer = mainPrinterHolder;    
-                                            }
-                } else if (ModifierSet.isStatic(modifiers)) {
-                    mainPrinterHolder = printer;
-                    printer = arrayInitPrinter;
-
-                    n.getType().accept(this, arg);
-                    printer.print(" ");
-                    printer.print(className);
-                    printer.print("::");
-                    if ("AttributeName".equals(n.getType().toString())) {
-                        printer.print("ATTR_");
-                    } else if ("ElementName".equals(n.getType().toString())) {
-                        printer.print("ELT_");
-                    }
-                    declarator.getId().accept(this, arg);
-                    printer.print(" = ");
-                    printer.print(cppTypes.nullLiteral());
-                    printer.printLn(";");
-                    
-                    printer = mainPrinterHolder;    
-                }
-            }
-            printModifiers(modifiers);
-            n.getType().accept(this, arg);
-            printer.print(" ");
-            if (ModifierSet.isStatic(modifiers)) {
-                if ("AttributeName".equals(n.getType().toString())) {
-                    printer.print("ATTR_");
-                } else if ("ElementName".equals(n.getType().toString())) {
-                    printer.print("ELT_");
-                }
-            }
-            declarator.getId().accept(this, arg);
-            printer.printLn(";");
-            currentArrayCount = 0;
-            inPrimitiveNoLengthFieldDeclarator = false;
-        }
-    }
-
-    /**
-     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#printConstructorBody(japa.parser.ast.stmt.BlockStmt, java.lang.LocalSymbolTable)
-     */
-    @Override protected void printConstructorBody(BlockStmt block, LocalSymbolTable arg) {
-        printer.printLn(";");
-    }
-
-    /**
-     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#visit(japa.parser.ast.body.MethodDeclaration, java.lang.LocalSymbolTable)
-     */
-    @Override public void visit(MethodDeclaration n, LocalSymbolTable arg) {
-        arg = new LocalSymbolTable(javaClassName, symbolTable);
-        printMethodDeclaration(n, arg);
-    }
-
-    /**
-     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#inHeader()
-     */
-    @Override protected boolean inHeader() {
-        return true;
-    }
-
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LabelVisitor.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LabelVisitor.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LabelVisitor.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2008
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.cpptranslate;
-
-import japa.parser.ast.stmt.BreakStmt;
-import japa.parser.ast.stmt.ContinueStmt;
-import japa.parser.ast.visitor.VoidVisitorAdapter;
-
-import java.util.HashSet;
-import java.util.Set;
-
-public class LabelVisitor extends VoidVisitorAdapter<Object> {
-
-    private final Set<String> labels = new HashSet<String>();
-    
-    public LabelVisitor() {
-    }
-
-    /**
-     * @see japa.parser.ast.visitor.VoidVisitorAdapter#visit(japa.parser.ast.stmt.BreakStmt, java.lang.Object)
-     */
-    @Override
-    public void visit(BreakStmt n, Object arg) {
-        String label = n.getId();
-        if (label != null) {
-            labels.add(label + "_end");
-        }
-    }
-
-    /**
-     * @see japa.parser.ast.visitor.VoidVisitorAdapter#visit(japa.parser.ast.stmt.ContinueStmt, java.lang.Object)
-     */
-    @Override
-    public void visit(ContinueStmt n, Object arg) {
-        String label = n.getId();
-        if (label != null) {
-            labels.add(label);
-        }
-    }
-
-    /**
-     * Returns the labels.
-     * 
-     * @return the labels
-     */
-    public Set<String> getLabels() {
-        return labels;
-    }
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LicenseExtractor.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LicenseExtractor.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LicenseExtractor.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2008
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.cpptranslate;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.Reader;
-
-public class LicenseExtractor {
-
-    private final Reader reader;
-    
-    public LicenseExtractor(File file) throws IOException {
-        this.reader = new InputStreamReader(new FileInputStream(file), "utf-8");
-    }
-    
-    public String extract() throws IOException {
-        boolean prevWasAsterisk = false;
-        StringBuilder sb = new StringBuilder();
-        int c;
-        while ((c = reader.read()) != -1) {
-            sb.append((char)c);
-            switch (c) {
-                case '*':
-                    prevWasAsterisk = true;
-                    continue;
-                case '/':
-                    if (prevWasAsterisk) {
-                        return sb.toString();                        
-                    }
-                default:
-                    prevWasAsterisk = false;
-                    continue;
-            }
-        }
-        return "";
-    }
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LocalSymbolTable.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LocalSymbolTable.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LocalSymbolTable.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2009
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.cpptranslate;
-
-import java.util.HashMap;
-import java.util.Map;
-
-public class LocalSymbolTable {
-
-    private final Map<String, Type> locals = new HashMap<String, Type>();
-
-    private final String javaClassName;
-    
-    private final SymbolTable delegate;    
-
-    /**
-     * @param javaClassName
-     * @param delegate
-     */
-    public LocalSymbolTable(String javaClassName, SymbolTable delegate) {
-        this.javaClassName = javaClassName;
-        this.delegate = delegate;
-    }
-
-    public void putLocalType(String name, Type type) {
-        locals.put(name, type);
-    }
-
-    /**
-     * @param klazz
-     * @param variable
-     * @return
-     * @see nu.validator.htmlparser.cpptranslate.SymbolTable#getFieldType(java.lang.String, java.lang.String)
-     */
-    public Type getVariableType(String klazz, String variable) {
-        if (klazz == null) {
-            Type type = locals.get(variable);
-            if (type != null) {
-                return type;
-            }
-        }
-        return delegate.getFieldType(((klazz == null || "this".equals(klazz)) ? javaClassName : klazz), variable);
-    }
-
-    /**
-     * @param klazz may be <code>null</code> or "this"
-     * @param method 
-     * @return
-     * @see nu.validator.htmlparser.cpptranslate.SymbolTable#getMethodReturnType(java.lang.String, java.lang.String)
-     */
-    public Type getMethodReturnType(String klazz, String method) {
-        return delegate.getMethodReturnType(((klazz == null || "this".equals(klazz)) ? javaClassName : klazz), method);
-    }
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/Main.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/Main.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/Main.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2008
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.cpptranslate;
-
-import japa.parser.JavaParser;
-import japa.parser.ParseException;
-import japa.parser.ast.CompilationUnit;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
-import java.io.UnsupportedEncodingException;
-
-public class Main {
-
-    static final String[] H_LIST = {
-        "Tokenizer",
-        "TreeBuilder",
-        "MetaScanner",
-        "AttributeName",
-        "ElementName",
-        "HtmlAttributes",
-        "StackNode",
-        "UTF16Buffer",
-        "StateSnapshot",
-        "Portability",
-    };
-    
-    private static final String[] CPP_LIST = {
-        "Tokenizer",
-        "TreeBuilder",
-        "MetaScanner",
-        "AttributeName",
-        "ElementName",
-        "HtmlAttributes",
-        "StackNode",
-        "UTF16Buffer",
-        "StateSnapshot",
-    };
-    
-    /**
-     * @param args
-     * @throws ParseException 
-     * @throws IOException 
-     */
-    public static void main(String[] args) throws ParseException, IOException {
-        CppTypes cppTypes = new CppTypes(new File(args[2]));
-        SymbolTable symbolTable = new SymbolTable();
-        
-        File javaDirectory = new File(args[0]);
-        File targetDirectory = new File(args[1]);
-        File cppDirectory = targetDirectory;
-        File javaCopyDirectory = new File(targetDirectory, "javasrc");
-        
-        for (int i = 0; i < H_LIST.length; i++) {
-            parseFile(cppTypes, javaDirectory, cppDirectory, H_LIST[i], ".h", new HVisitor(cppTypes, symbolTable));
-//            copyFile(new File(javaDirectory, H_LIST[i] + ".java"), new File(javaCopyDirectory, H_LIST[i] + ".java"));
-        }
-        for (int i = 0; i < CPP_LIST.length; i++) {
-            parseFile(cppTypes, javaDirectory, cppDirectory, CPP_LIST[i], ".cpp", new CppVisitor(cppTypes, symbolTable));
-        }
-        cppTypes.finished();
-    }
-
-    private static void copyFile(File input, File output) throws IOException {
-        if (input.getCanonicalFile().equals(output.getCanonicalFile())) {
-            return; // files are the same!
-        }
-        // This is horribly inefficient, but perf is not really much of a concern here.
-        FileInputStream in = new FileInputStream(input);
-        FileOutputStream out = new FileOutputStream(output);
-        int b;
-        while ((b = in.read()) != -1) {
-            out.write(b);
-        }
-        out.flush();
-        out.close();
-        in.close();
-    }
-    
-    private static void parseFile(CppTypes cppTypes, File javaDirectory, File cppDirectory, String className, String fne, CppVisitor visitor) throws ParseException,
-            FileNotFoundException, UnsupportedEncodingException, IOException {
-        File file = new File(javaDirectory, className + ".java");
-        String license = new LicenseExtractor(file).extract();
-        CompilationUnit cu = JavaParser.parse(new NoCppInputStream(new FileInputStream(file)), "utf-8");
-        LabelVisitor labelVisitor = new LabelVisitor();
-        cu.accept(labelVisitor, null);
-        visitor.setLabels(labelVisitor.getLabels());
-        cu.accept(visitor, null);
-        FileOutputStream out = new FileOutputStream(new File(cppDirectory, cppTypes.classPrefix() + className + fne));
-        OutputStreamWriter w = new OutputStreamWriter(out, "utf-8");
-        w.write(license);
-        w.write("\n\n/*\n * THIS IS A GENERATED FILE. PLEASE DO NOT EDIT.\n * Please edit " + className + ".java instead and regenerate.\n */\n\n");
-        w.write(visitor.getSource());
-        w.close();
-    }
-
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/NoCppInputStream.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/NoCppInputStream.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/NoCppInputStream.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2008
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.cpptranslate;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-public class NoCppInputStream extends InputStream {
-
-    private final static char[] START = "[NOCPP[".toCharArray();
-    
-    private final static char[] END = "]NOCPP]".toCharArray();
-    
-    private int state;
-    
-    private final InputStream delegate;
-    
-    
-    
-    /**
-     * @param delegate
-     */
-    public NoCppInputStream(InputStream delegate) {
-        this.delegate = delegate;
-        this.state = 0;
-    }
-
-    @Override public int read() throws IOException {
-        int c;
-        if (state == START.length) {
-            int endState = 0;
-            while (endState != END.length) {
-                c = delegate.read();
-                if (END[endState] == c) {
-                    endState++;
-                } else {
-                    endState = 0;
-                }
-            }
-            state = 0;
-        }
-        c = delegate.read();
-        if (START[state] == c) {
-            state++;
-        } else {
-            state = 0;
-        }
-        return c;
-    }
-
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/StringLiteralParser.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/StringLiteralParser.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/StringLiteralParser.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2008
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.cpptranslate;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.Reader;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-public class StringLiteralParser {
-
-    private static final Pattern STRING_DECL = Pattern.compile("^.*\\(([^ ]+) = new nsString\\(\\)\\)->Assign\\(NS_LITERAL_STRING\\(\"([^\"]*)\"\\)\\);.*$");
-    
-    private final BufferedReader reader;
-    
-    public StringLiteralParser(Reader reader) {
-        this.reader = new BufferedReader(reader);
-    }
-    
-    public Map<String, String> parse() throws IOException {
-        Map<String, String> map = new HashMap<String, String>();
-        String line;
-        while((line = reader.readLine()) != null) {
-            Matcher m = STRING_DECL.matcher(line);
-            if (m.matches()) {
-                map.put(m.group(2), m.group(1));
-            }
-        }
-        return map;
-    }
-    
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/StringPair.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/StringPair.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/StringPair.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2009
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.cpptranslate;
-
-public class StringPair {
-
-    /**
-     * @param first
-     * @param second
-     */
-    public StringPair(String first, String second) {
-        this.first = first;
-        this.second = second;
-    }
-
-    private final String first;
-
-    private final String second;
-
-    /**
-     * @see java.lang.Object#equals(java.lang.Object)
-     */
-    @Override public boolean equals(Object o) {
-        if (o instanceof StringPair) {
-            StringPair other = (StringPair) o;
-            return first.equals(other.first) && second.equals(other.second);
-        }
-        return false;
-    }
-
-    /**
-     * @see java.lang.Object#hashCode()
-     */
-    @Override public int hashCode() {
-        return first.hashCode() ^ second.hashCode();
-    }
-
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/SymbolTable.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/SymbolTable.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/SymbolTable.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2008
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.cpptranslate;
-
-import java.util.HashMap;
-import java.util.Map;
-
-public class SymbolTable {
-    
-    public final Map<String, String> cppDefinesByJavaNames = new HashMap<String, String>();
-
-    private final Map<StringPair, Type> fields = new HashMap<StringPair, Type>();
-    
-    private final Map<StringPair, Type> methodReturns = new HashMap<StringPair, Type>();
-    
-    /**
-     * This is a sad hack to work around the fact the there's no real symbol
-     * table yet.
-     * 
-     * @param name
-     * @return
-     */
-    public boolean isNotAnAttributeOrElementName(String name) {
-        return !("ATTRIBUTE_HASHES".equals(name)
-                || "ATTRIBUTE_NAMES".equals(name)
-                || "ELEMENT_HASHES".equals(name)
-                || "ELEMENT_NAMES".equals(name) || "ALL_NO_NS".equals(name));
-    }
-    
-    public void putFieldType(String klazz, String field, Type type) {
-        fields.put(new StringPair(klazz, field), type);
-    }
-    
-    public void putMethodReturnType(String klazz, String method, Type type) {
-        methodReturns.put(new StringPair(klazz, method), type);
-    }
-    
-    public Type getFieldType(String klazz, String field) {
-        return fields.get(new StringPair(klazz, field));
-    }
-    
-    public Type getMethodReturnType(String klazz, String method) {
-        return methodReturns.get(new StringPair(klazz, method));
-    }
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/SymbolTableVisitor.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/SymbolTableVisitor.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/SymbolTableVisitor.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2009
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.cpptranslate;
-
-import japa.parser.ast.body.ClassOrInterfaceDeclaration;
-import japa.parser.ast.body.FieldDeclaration;
-import japa.parser.ast.body.MethodDeclaration;
-
-public class SymbolTableVisitor extends AnnotationHelperVisitor<SymbolTable> {
-
-    private String javaClassName;
-    
-    /**
-     * @see japa.parser.ast.visitor.VoidVisitorAdapter#visit(japa.parser.ast.body.FieldDeclaration, java.lang.Object)
-     */
-    @Override public void visit(FieldDeclaration n, SymbolTable arg) {
-        currentAnnotations = n.getAnnotations();
-        arg.putFieldType(javaClassName, n.getVariables().get(0).getId().getName(), convertType(n.getType(), n.getModifiers()));
-    }
-
-    /**
-     * @see japa.parser.ast.visitor.VoidVisitorAdapter#visit(japa.parser.ast.body.MethodDeclaration, java.lang.Object)
-     */
-    @Override public void visit(MethodDeclaration n, SymbolTable arg) {
-        currentAnnotations = n.getAnnotations();
-        arg.putMethodReturnType(javaClassName, n.getName(), convertType(n.getType(), n.getModifiers()));
-    }
-
-    /**
-     * @see japa.parser.ast.visitor.VoidVisitorAdapter#visit(japa.parser.ast.body.ClassOrInterfaceDeclaration, java.lang.Object)
-     */
-    @Override public void visit(ClassOrInterfaceDeclaration n, SymbolTable arg) {
-        javaClassName = n.getName();
-    }
-
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/Type.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/Type.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/Type.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2009
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.cpptranslate;
-
-public class Type {
-
-    /**
-     * @param type
-     * @param arrayCount
-     * @param noLength
-     * @param modifiers
-     */
-    public Type(String type, int arrayCount, boolean noLength, int modifiers) {
-        this.type = type;
-        this.arrayCount = arrayCount;
-        this.noLength = noLength;
-        this.modifiers = modifiers;
-    }
-
-    private final String type;
-    
-    private final int arrayCount;
-    
-    private final boolean noLength;
-    
-    private final int modifiers;
-
-    /**
-     * Returns the type.
-     * 
-     * @return the type
-     */
-    public String getType() {
-        return type;
-    }
-
-    /**
-     * Returns the arrayCount.
-     * 
-     * @return the arrayCount
-     */
-    public int getArrayCount() {
-        return arrayCount;
-    }
-
-    /**
-     * Returns the noLength.
-     * 
-     * @return the noLength
-     */
-    public boolean isNoLength() {
-        return noLength;
-    }
-
-    /**
-     * Returns the modifiers.
-     * 
-     * @return the modifiers
-     */
-    public int getModifiers() {
-        return modifiers;
-    }
-    
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/generator/GenerateNamedCharacters.java b/parser/html/java/translator/src/nu/validator/htmlparser/generator/GenerateNamedCharacters.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/generator/GenerateNamedCharacters.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (c) 2008 Mozilla Foundation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a 
- * copy of this software and associated documentation files (the "Software"), 
- * to deal in the Software without restriction, including without limitation 
- * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
- * and/or sell copies of the Software, and to permit persons to whom the 
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in 
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
- * DEALINGS IN THE SOFTWARE.
- */
-
-package nu.validator.htmlparser.generator;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.Map;
-import java.util.TreeMap;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-public class GenerateNamedCharacters {
-
-    private static final int LEAD_OFFSET = 0xD800 - (0x10000 >> 10);
-    
-    private static final Pattern LINE_PATTERN = Pattern.compile("^\\s*<tr> <td> <code title=\"\">([^<]*)</code> </td> <td> U\\+(\\S*) </td> </tr>.*$");
-    
-    private static String toUString(int c) {
-        String hexString = Integer.toHexString(c);
-        switch (hexString.length()) {
-            case 1:
-                return "\\u000" + hexString;
-            case 2:
-                return "\\u00" + hexString;
-            case 3:
-                return "\\u0" + hexString;
-            case 4:
-                return "\\u" + hexString;
-            default:
-                throw new RuntimeException("Unreachable.");
-        }
-    }
-
-    
-    /**
-     * @param args
-     * @throws IOException 
-     */
-    public static void main(String[] args) throws IOException {
-        TreeMap<String, String> entities = new TreeMap<String, String>();
-        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in, "utf-8"));
-        String line;
-        while ((line = reader.readLine()) != null) {
-            Matcher m = LINE_PATTERN.matcher(line);
-            if (m.matches()) {
-                entities.put(m.group(1), m.group(2));
-            }
-        }
-        System.out.println("static final char[][] NAMES = {");
-        for (Map.Entry<String, String> entity : entities.entrySet()) {
-            String name = entity.getKey();
-            System.out.print("\"");
-            System.out.print(name);
-            System.out.println("\".toCharArray(),");
-        }
-        System.out.println("};");
-
-        System.out.println("static final @NoLength char[][] VALUES = {");
-        for (Map.Entry<String, String> entity : entities.entrySet()) {
-            String value = entity.getValue();
-            int intVal = Integer.parseInt(value, 16);
-            System.out.print("{");
-            if (intVal == '\'') {
-                System.out.print("\'\\\'\'");                
-            } else if (intVal == '\n') {
-                System.out.print("\'\\n\'");                
-            } else if (intVal == '\\') {
-                System.out.print("\'\\\\\'");                
-            } else if (intVal <= 0xFFFF) {
-                System.out.print("\'");                
-                System.out.print(toUString(intVal));                                
-                System.out.print("\'");                
-            } else {
-                int hi = (LEAD_OFFSET + (intVal >> 10));
-                int lo = (0xDC00 + (intVal & 0x3FF));
-                System.out.print("\'");                
-                System.out.print(toUString(hi));                                
-                System.out.print("\', \'");                
-                System.out.print(toUString(lo));                                
-                System.out.print("\'");                
-            }
-            System.out.println("},");
-        }
-        System.out.println("};");
-
-    }
-
-}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/generator/GenerateNamedCharactersCpp.java b/parser/html/java/translator/src/nu/validator/htmlparser/generator/GenerateNamedCharactersCpp.java
deleted file mode 100644
--- a/parser/html/java/translator/src/nu/validator/htmlparser/generator/GenerateNamedCharactersCpp.java
+++ /dev/null
@@ -1,360 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is HTML Parser C++ Translator code.
- *
- * The Initial Developer of the Original Code is
- * Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2008
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Henri Sivonen <hsivonen@iki.fi>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-package nu.validator.htmlparser.generator;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.util.Map;
-import java.util.TreeMap;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import nu.validator.htmlparser.cpptranslate.CppTypes;
-
-public class GenerateNamedCharactersCpp {
-
-    private static final int LEAD_OFFSET = 0xD800 - (0x10000 >> 10);
-
-    private static final Pattern LINE_PATTERN = Pattern.compile("<td> <code title=\"\">([^<]*)</code> </td> <td> U\\+(\\S*) </td>");
-
-    private static String toHexString(int c) {
-        String hexString = Integer.toHexString(c);
-        switch (hexString.length()) {
-            case 1:
-                return "0x000" + hexString;
-            case 2:
-                return "0x00" + hexString;
-            case 3:
-                return "0x0" + hexString;
-            case 4:
-                return "0x" + hexString;
-            default:
-                throw new RuntimeException("Unreachable.");
-        }
-    }
-
-    /**
-     * @param args
-     * @throws IOException
-     */
-    public static void main(String[] args) throws IOException {
-        TreeMap<String, String> entities = new TreeMap<String, String>();
-        BufferedReader reader = new BufferedReader(new InputStreamReader(
-                new FileInputStream(args[0]), "utf-8"));
-        String line;
-        while ((line = reader.readLine()) != null) {
-            Matcher m = LINE_PATTERN.matcher(line);
-            while (m.find()) {
-                entities.put(m.group(1), m.group(2));
-            }
-        }
-
-        CppTypes cppTypes = new CppTypes(null);
-        File targetDirectory = new File(args[1]);
-
-        generateH(targetDirectory, cppTypes, entities);
-        generateInclude(targetDirectory, cppTypes, entities);
-        generateCpp(targetDirectory, cppTypes, entities);
-    }
-
-    private static void generateH(File targetDirectory, CppTypes cppTypes,
-            Map<String, String> entities) throws IOException {
-        File hFile = new File(targetDirectory, cppTypes.classPrefix()
-                + "NamedCharacters.h");
-        Writer out = new OutputStreamWriter(new FileOutputStream(hFile),
-                "utf-8");
-        out.write("#ifndef " + cppTypes.classPrefix() + "NamedCharacters_h__\n");
-        out.write("#define " + cppTypes.classPrefix() + "NamedCharacters_h__\n");
-        out.write('\n');
-
-        String[] includes = cppTypes.namedCharactersIncludes();
-        for (int i = 0; i < includes.length; i++) {
-            String include = includes[i];
-            out.write("#include \"" + include + ".h\"\n");
-        }
-
-        out.write('\n');
-
-        out.write("class " + cppTypes.classPrefix() + "NamedCharacters\n");
-        out.write("{\n");
-        out.write("  public:\n");
-        out.write("    static " + cppTypes.arrayTemplate() + "<"
-                + cppTypes.arrayTemplate() + "<" + cppTypes.charType() + ","
-                + cppTypes.intType() + ">," + cppTypes.intType() + "> NAMES;\n");
-        out.write("    static " + cppTypes.arrayTemplate() + "<"
-                + cppTypes.charType() + "," + cppTypes.intType()
-                + ">* VALUES;\n");
-        out.write("    static " + cppTypes.charType() + "** WINDOWS_1252;\n");
-        out.write("    static void initializeStatics();\n");
-        out.write("    static void releaseStatics();\n");
-        out.write("};\n");
-
-        out.write("\n#endif // " + cppTypes.classPrefix()
-                + "NamedCharacters_h__\n");
-        out.flush();
-        out.close();
-    }
-
-    private static void generateInclude(File targetDirectory, CppTypes cppTypes,
-            Map<String, String> entities)
-        throws IOException
-    {
-        File includeFile = new File(targetDirectory, cppTypes.classPrefix()
-                + "NamedCharactersInclude.h");
-        Writer out = new OutputStreamWriter(new FileOutputStream(includeFile),
-                "utf-8");
-
-        out.write("/* Data generated from the table of named character references found at\n");
-        out.write(" *\n");
-        out.write(" *   http://www.w3.org/TR/html5/named-character-references.html\n");
-        out.write(" *\n");
-        out.write(" * Files that #include this file must #define NAMED_CHARACTER_REFERENCE as a\n");
-        out.write(" * macro of five parameters:\n");
-        out.write(" *\n");
-        out.write(" *   1.  a unique integer N identifying the Nth [0,1,..] macro expansion in this file,\n");
-        out.write(" *   2.  a comma-separated sequence of characters comprising the character name,\n");
-        out.write(" *   3.  the length of this sequence of characters,\n");
-        out.write(" *   4.  a comma-separated sequence of PRUnichar literals (high to low) corresponding\n");
-        out.write(" *       to the code-point of the named character, and\n");
-        out.write(" *   5.  the length of this sequence of literals (either 1 or 2).\n");
-        out.write(" *\n");
-        out.write(" * The macro expansion doesn't have to refer to all or any of these parameters,\n");
-        out.write(" * but common sense dictates that it should involve at least one of them.\n");
-        out.write(" */\n");
-        out.write("\n");
-        out.write("// This #define allows the NAMED_CHARACTER_REFERENCE macro to accept comma-\n");
-        out.write("// separated sequences as single macro arguments.  Using commas directly would\n");
-        out.write("// split the sequence into multiple macro arguments.\n");
-        out.write("#define _ ,\n");
-        out.write("\n");
-
-        int i = 0;
-        for (Map.Entry<String, String> entity : entities.entrySet()) {
-            out.write("NAMED_CHARACTER_REFERENCE(" + i++ + ", ");
-            writeNameInitializer(out, entity, " _ ");
-            out.write(", " + entity.getKey().length() + ", ");
-            writeValueInitializer(out, entity, " _ ");
-            int numBytes = (Integer.parseInt(entity.getValue(), 16) <= 0xFFFF) ? 1 : 2;
-            out.write(", " + numBytes + ")\n");
-        }
-
-        out.write("\n");
-        out.write("#undef _\n");
-
-        out.flush();
-        out.close();
-    }
-
-    private static void writeNameInitializer(Writer out,
-            Map.Entry<String, String> entity,
-            String separator)
-        throws IOException
-    {
-        String name = entity.getKey();
-        for (int i = 0; i < name.length(); i++) {
-            out.write("'" + name.charAt(i) + "'");
-            if (i < name.length() - 1)
-                out.write(separator);
-        }
-    }
-
-    private static void writeValueInitializer(Writer out,
-            Map.Entry<String, String> entity,
-            String separator)
-        throws IOException
-    {
-        int value = Integer.parseInt(entity.getValue(), 16);
-        if (value <= 0xFFFF) {
-            out.write(toHexString(value));
-        } else {
-            int hi = (LEAD_OFFSET + (value >> 10));
-            int lo = (0xDC00 + (value & 0x3FF));
-            out.write(toHexString(hi));
-            out.write(separator);
-            out.write(toHexString(lo));
-        }
-    }
-
-    private static void defineMacroAndInclude(Writer out, String expansion,
-            String includeFile)
-        throws IOException
-    {
-        out.write("\n#define NAMED_CHARACTER_REFERENCE(N, CHARS, LEN, VALUE, SIZE) \\\n" +
-                  expansion + "\n");
-        out.write("#include \"" + includeFile + "\"\n");
-        out.write("#undef NAMED_CHARACTER_REFERENCE\n");
-    }
-
-    private static void writeStaticMemberDeclaration(Writer out,
-            CppTypes cppTypes, String type, String name)
-        throws IOException
-    {
-        out.write(type + " " + cppTypes.classPrefix() + "NamedCharacters::"
-                + name + ";\n");
-    }
-
-    private static void generateCpp(File targetDirectory, CppTypes cppTypes,
-            Map<String, String> entities) throws IOException {
-        File hFile = new File(targetDirectory, cppTypes.classPrefix()
-                + "NamedCharacters.cpp");
-        Writer out = new OutputStreamWriter(new FileOutputStream(hFile),
-                "utf-8");
-
-        out.write("#define " + cppTypes.classPrefix()
-                + "NamedCharacters_cpp__\n");
-
-        String[] includes = cppTypes.namedCharactersIncludes();
-        for (int i = 0; i < includes.length; i++) {
-            String include = includes[i];
-            out.write("#include \"" + include + ".h\"\n");
-        }
-
-        out.write('\n');
-        out.write("#include \"" + cppTypes.classPrefix()
-                + "NamedCharacters.h\"\n");
-        out.write("\n");
-
-        String staticMemberType = cppTypes.arrayTemplate() + "<"
-                + cppTypes.arrayTemplate() + "<" + cppTypes.charType() + ","
-                + cppTypes.intType() + ">," + cppTypes.intType() + ">";
-        writeStaticMemberDeclaration(out, cppTypes, staticMemberType, "NAMES");
-
-        staticMemberType = cppTypes.arrayTemplate() + "<"
-                + cppTypes.charType() + "," + cppTypes.intType() + ">*";
-        writeStaticMemberDeclaration(out, cppTypes, staticMemberType, "VALUES");
-
-        staticMemberType = cppTypes.charType() + "**";
-        writeStaticMemberDeclaration(out, cppTypes, staticMemberType, "WINDOWS_1252");
-
-        out.write("static " + cppTypes.charType() + " const WINDOWS_1252_DATA[] = {\n");
-        out.write("  0x20AC,\n");
-        out.write("  0xFFFD,\n");
-        out.write("  0x201A,\n");
-        out.write("  0x0192,\n");
-        out.write("  0x201E,\n");
-        out.write("  0x2026,\n");
-        out.write("  0x2020,\n");
-        out.write("  0x2021,\n");
-        out.write("  0x02C6,\n");
-        out.write("  0x2030,\n");
-        out.write("  0x0160,\n");
-        out.write("  0x2039,\n");
-        out.write("  0x0152,\n");
-        out.write("  0xFFFD,\n");
-        out.write("  0x017D,\n");
-        out.write("  0xFFFD,\n");
-        out.write("  0xFFFD,\n");
-        out.write("  0x2018,\n");
-        out.write("  0x2019,\n");
-        out.write("  0x201C,\n");
-        out.write("  0x201D,\n");
-        out.write("  0x2022,\n");
-        out.write("  0x2013,\n");
-        out.write("  0x2014,\n");
-        out.write("  0x02DC,\n");
-        out.write("  0x2122,\n");
-        out.write("  0x0161,\n");
-        out.write("  0x203A,\n");
-        out.write("  0x0153,\n");
-        out.write("  0xFFFD,\n");
-        out.write("  0x017E,\n");
-        out.write("  0x0178\n");
-        out.write("};\n");
-
-        String includeFile = cppTypes.classPrefix() + "NamedCharactersInclude.h";
-        defineMacroAndInclude(out,
-                "static PRUnichar const NAME_##N[] = { CHARS };",
-                includeFile);
-        defineMacroAndInclude(out,
-                "static PRUnichar const VALUE_##N[] = { VALUE };",
-                includeFile);
-
-        out.write("\n// XXX bug 501082: for some reason, msvc takes forever to optimize this function\n");
-        out.write("#ifdef _MSC_VER\n");
-        out.write("#pragma optimize(\"\", off)\n");
-        out.write("#endif\n\n");
-        
-        out.write("void\n");
-        out.write(cppTypes.classPrefix()
-                + "NamedCharacters::initializeStatics()\n");
-        out.write("{\n");
-        out.write("  NAMES = " + cppTypes.arrayTemplate() + "<"
-                + cppTypes.arrayTemplate() + "<" + cppTypes.charType() + ","
-                + cppTypes.intType() + ">," + cppTypes.intType() + ">("
-                + entities.size() + ");\n");
-        defineMacroAndInclude(out,
-                "  NAMES[N] = jArray<PRUnichar,PRInt32>((PRUnichar*)NAME_##N, LEN);",
-                includeFile);
-
-        out.write("\n  VALUES = new " + cppTypes.arrayTemplate() + "<"
-                + cppTypes.charType() + "," + cppTypes.intType() + ">["
-                + entities.size() + "];\n");
-        defineMacroAndInclude(out,
-                "  VALUES[N] = jArray<PRUnichar,PRInt32>((PRUnichar*)VALUE_##N, SIZE);",
-                includeFile);
-
-        out.write("\n");
-        out.write("  WINDOWS_1252 = new " + cppTypes.charType() + "*[32];\n");
-        out.write("  for (" + cppTypes.intType() + " i = 0; i < 32; ++i) {\n");
-        out.write("    WINDOWS_1252[i] = (" + cppTypes.charType() + "*)&(WINDOWS_1252_DATA[i]);\n");
-        out.write("  }\n");
-        out.write("}\n");
-        out.write("\n");
-
-        out.write("#ifdef _MSC_VER\n");
-        out.write("#pragma optimize(\"\", on)\n");
-        out.write("#endif\n\n");
-        
-        out.write("void\n");
-        out.write(cppTypes.classPrefix()
-                + "NamedCharacters::releaseStatics()\n");
-        out.write("{\n");
-        out.write("  NAMES.release();\n");
-        out.write("  delete[] VALUES;\n");
-        out.write("  delete[] WINDOWS_1252;\n");
-        out.write("}\n");
-        out.flush();
-        out.close();
-    }
-}
