diff --git a/parser/html/java/Makefile b/parser/html/java/Makefile
new file mode 100644
--- /dev/null
+++ b/parser/html/java/Makefile
@@ -0,0 +1,56 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Makefile.
+#
+# The Initial Developer of the Original Code is
+#   Ben Newman <b{enjam,newma}n@mozilla.com>
+#
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+libs:: clean \
+; cd javaparser && \
+    make libs && mv javaparser.jar ../ && \
+  cd ../translator && \
+    make libs && mv translator.jar ../ && \
+  cd ..
+
+sync:: clean \
+; cd javaparser ; make sync ; cd .. ; \
+  cd translator ; make sync ; cd .. ; \
+  cd htmlparser ; make sync ; cd ..
+
+translate:: \
+; java -jar translator.jar htmlparser/src .. ../nsHtml5AtomList.h
+
+clean:: \
+; cd javaparser ; make clean ; cd .. ; \
+  cd translator ; make clean ; cd .. ; \
+  rm -rf *.jar
diff --git a/parser/html/java/README.txt b/parser/html/java/README.txt
new file mode 100644
--- /dev/null
+++ b/parser/html/java/README.txt
@@ -0,0 +1,13 @@
+If this is your first time building the HTML5 parser, you need to execute the
+following commands (from this directory) to bootstrap the translation:
+
+  make sync      # fetch remote source files and licenses
+  make           # build javaparser.jar and translator.jar
+  make translate # perform the Java-to-C++ translation
+
+If you make changes to the translator or the javaparser, you can rebuild by
+retyping 'make' in this directory.  If you make changes to the HTML5 java
+implementation, you can retranslate the java sources by retyping 'make
+translate' in this directory.
+
+Ben Newman (8 July 2009)
diff --git a/parser/html/java/htmlparser/Makefile b/parser/html/java/htmlparser/Makefile
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/Makefile
@@ -0,0 +1,43 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Makefile.
+#
+# The Initial Developer of the Original Code is
+#   Ben Newman <b{enjam,newma}n@mozilla.com>
+#
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+SVN_BASE=http://svn.versiondude.net/whattf/htmlparser/trunk
+
+sync:: \
+; rm -rf src && \
+  svn co $(SVN_BASE)/src/nu/validator/htmlparser/impl src && \
+  find src -name .svn | xargs rm -rf
diff --git a/parser/html/java/htmlparser/src/AttributeName.java b/parser/html/java/htmlparser/src/AttributeName.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/AttributeName.java
@@ -0,0 +1,2789 @@
+/*
+ * Copyright (c) 2008-2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import java.util.Arrays;
+
+import nu.validator.htmlparser.annotation.IdType;
+import nu.validator.htmlparser.annotation.Local;
+import nu.validator.htmlparser.annotation.NoLength;
+import nu.validator.htmlparser.annotation.NsUri;
+import nu.validator.htmlparser.annotation.Prefix;
+import nu.validator.htmlparser.annotation.QName;
+import nu.validator.htmlparser.annotation.Virtual;
+
+public final class AttributeName
+// Uncomment to regenerate
+//        implements Comparable<AttributeName> 
+{
+
+    private static final @NoLength @NsUri String[] ALL_NO_NS = { "", "", "",
+    // [NOCPP[
+            ""
+    // ]NOCPP]
+    };
+
+    private static final @NoLength @NsUri String[] XMLNS_NS = { "",
+            "http://www.w3.org/2000/xmlns/", "http://www.w3.org/2000/xmlns/",
+            // [NOCPP[
+            ""
+    // ]NOCPP]
+    };
+
+    private static final @NoLength @NsUri String[] XML_NS = { "",
+            "http://www.w3.org/XML/1998/namespace",
+            "http://www.w3.org/XML/1998/namespace",
+            // [NOCPP[
+            ""
+    // ]NOCPP]
+    };
+
+    private static final @NoLength @NsUri String[] XLINK_NS = { "",
+            "http://www.w3.org/1999/xlink", "http://www.w3.org/1999/xlink",
+            // [NOCPP[
+            ""
+    // ]NOCPP]
+    };
+
+    // [NOCPP[
+    private static final @NoLength @NsUri String[] LANG_NS = { "", "", "",
+            "http://www.w3.org/XML/1998/namespace" };
+
+    // ]NOCPP]
+
+    private static final @NoLength @Prefix String[] ALL_NO_PREFIX = { null,
+            null, null,
+            // [NOCPP[
+            null
+    // ]NOCPP]
+    };
+
+    private static final @NoLength @Prefix String[] XMLNS_PREFIX = { null,
+            "xmlns", "xmlns",
+            // [NOCPP[
+            null
+    // ]NOCPP]
+    };
+
+    private static final @NoLength @Prefix String[] XLINK_PREFIX = { null,
+            "xlink", "xlink",
+            // [NOCPP[
+            null
+    // ]NOCPP]
+    };
+
+    private static final @NoLength @Prefix String[] XML_PREFIX = { null, "xml",
+            "xml",
+            // [NOCPP[
+            null
+    // ]NOCPP]
+    };
+
+    // [NOCPP[
+
+    private static final @NoLength @Prefix String[] LANG_PREFIX = { null, null,
+            null, "xml" };
+
+    private static final boolean[] ALL_NCNAME = { true, true, true, true };
+
+    private static final boolean[] ALL_NO_NCNAME = { false, false, false, false };
+
+    private static @QName String[] COMPUTE_QNAME(String[] local, String[] prefix) {
+        @QName String[] arr = new String[4];
+        for (int i = 0; i < arr.length; i++) {
+            if (prefix[i] == null) {
+                arr[i] = local[i];
+            } else {
+                arr[i] = (prefix[i] + ':' + local[i]).intern();
+            }
+        }
+        return arr;
+    }
+
+    // ]NOCPP]
+
+    private static @NoLength @Local String[] SVG_DIFFERENT(@Local String name,
+            @Local String camel) {
+        @NoLength @Local String[] arr = new String[4];
+        arr[0] = name;
+        arr[1] = name;
+        arr[2] = camel;
+        // [NOCPP[
+        arr[3] = name;
+        // ]NOCPP]
+        return arr;
+    }
+
+    private static @NoLength @Local String[] MATH_DIFFERENT(@Local String name,
+            @Local String camel) {
+        @NoLength @Local String[] arr = new String[4];
+        arr[0] = name;
+        arr[1] = camel;
+        arr[2] = name;
+        // [NOCPP[
+        arr[3] = name;
+        // ]NOCPP]
+        return arr;
+    }
+
+    private static @NoLength @Local String[] COLONIFIED_LOCAL(
+            @Local String name, @Local String suffix) {
+        @NoLength @Local String[] arr = new String[4];
+        arr[0] = name;
+        arr[1] = suffix;
+        arr[2] = suffix;
+        // [NOCPP[
+        arr[3] = name;
+        // ]NOCPP]
+        return arr;
+    }
+
+    private static @NoLength @Local String[] SAME_LOCAL(@Local String name) {
+        @NoLength @Local String[] arr = new String[4];
+        arr[0] = name;
+        arr[1] = name;
+        arr[2] = name;
+        // [NOCPP[
+        arr[3] = name;
+        // ]NOCPP]
+        return arr;
+    }
+
+    /**
+     * Returns an attribute name by buffer.
+     * 
+     * <p>
+     * C++ ownership: The return value is either released by the caller if the
+     * attribute is a duplicate or the ownership is transferred to
+     * HtmlAttributes and released upon clearing or destroying that object.
+     * 
+     * @param buf
+     * @param offset
+     * @param length
+     * @param checkNcName
+     * @return
+     */
+    static AttributeName nameByBuffer(@NoLength char[] buf, int offset,
+            int length
+            // [NOCPP[
+            , boolean checkNcName
+    // ]NOCPP]
+    ) {
+        // XXX deal with offset
+        int hash = AttributeName.bufToHash(buf, length);
+        int index = Arrays.binarySearch(AttributeName.ATTRIBUTE_HASHES, hash);
+        if (index < 0) {
+            return AttributeName.createAttributeName(
+                    Portability.newLocalNameFromBuffer(buf, offset, length)
+                    // [NOCPP[
+                    , checkNcName
+            // ]NOCPP]
+            );
+        } else {
+            AttributeName attributeName = AttributeName.ATTRIBUTE_NAMES[index];
+            @Local String name = attributeName.getLocal(AttributeName.HTML);
+            if (!Portability.localEqualsBuffer(name, buf, offset, length)) {
+                return AttributeName.createAttributeName(
+                        Portability.newLocalNameFromBuffer(buf, offset, length)
+                        // [NOCPP[
+                        , checkNcName
+                // ]NOCPP]
+                );
+            }
+            return attributeName;
+        }
+    }
+
+    /**
+     * This method has to return a unique integer for each well-known
+     * lower-cased attribute name.
+     * 
+     * @param buf
+     * @param len
+     * @return
+     */
+    private static int bufToHash(@NoLength char[] buf, int len) {
+        int hash2 = 0;
+        int hash = len;
+        hash <<= 5;
+        hash += buf[0] - 0x60;
+        int j = len;
+        for (int i = 0; i < 4 && j > 0; i++) {
+            j--;
+            hash <<= 5;
+            hash += buf[j] - 0x60;
+            hash2 <<= 6;
+            hash2 += buf[i] - 0x5F;
+        }
+        return hash ^ hash2;
+    }
+
+    public static final int HTML = 0;
+
+    public static final int MATHML = 1;
+
+    public static final int SVG = 2;
+
+    // [NOCPP[
+
+    public static final int HTML_LANG = 3;
+
+    private final @IdType String type;
+
+    // ]NOCPP]
+
+    private final @NsUri @NoLength String[] uri;
+
+    private final @Local @NoLength String[] local;
+
+    private final @Prefix @NoLength String[] prefix;
+
+    // [NOCPP[
+
+    private final @QName @NoLength String[] qName;
+
+    // XXX convert to bitfield
+    private final @NoLength boolean[] ncname;
+
+    private final boolean xmlns;
+
+    /**
+     * @param type
+     * @param uri
+     * @param local
+     * @param name
+     * @param ncname
+     * @param xmlns
+     */
+    private AttributeName(@NsUri @NoLength String[] uri,
+            @Local @NoLength String[] local, @Prefix @NoLength String[] prefix,
+            @NoLength boolean[] ncname, boolean xmlns, @IdType String type) {
+        this.type = type;
+        this.uri = uri;
+        this.local = local;
+        this.prefix = prefix;
+
+        this.qName = COMPUTE_QNAME(local, prefix);
+        this.ncname = ncname;
+        this.xmlns = xmlns;
+    }
+
+    // ]NOCPP]
+
+    protected AttributeName(@NsUri @NoLength String[] uri,
+            @Local @NoLength String[] local, @Prefix @NoLength String[] prefix
+            // [NOCPP[
+            , @NoLength boolean[] ncname, boolean xmlns
+    // ]NOCPP]
+    ) {
+        // [NOCPP[
+        this.type = "CDATA";
+        // ]NOCPP]
+        this.uri = uri;
+        this.local = local;
+        this.prefix = prefix;
+        // [NOCPP[
+        this.qName = COMPUTE_QNAME(local, prefix);
+        this.ncname = ncname;
+        this.xmlns = xmlns;
+        // ]NOCPP]
+    }
+
+    private static AttributeName createAttributeName(@Local String name
+    // [NOCPP[
+            , boolean checkNcName
+    // ]NOCPP]
+    ) {
+        // [NOCPP[
+        boolean ncName = true;
+        boolean xmlns = name.startsWith("xmlns:");
+        if (checkNcName) {
+            if (xmlns) {
+                ncName = false;
+            } else {
+                ncName = NCName.isNCName(name);
+            }
+        }
+        // ]NOCPP]
+        return new AttributeName(AttributeName.ALL_NO_NS,
+                AttributeName.SAME_LOCAL(name), ALL_NO_PREFIX
+                // ]NOCPP]
+                , (ncName ? AttributeName.ALL_NCNAME
+                        : AttributeName.ALL_NO_NCNAME), xmlns
+        // ]NOCPP]
+        );
+    }
+
+    @Virtual void release() {
+        // No-op in Java.
+        // Implement as |delete this;| in subclass.
+    }
+
+    @SuppressWarnings("unused") private void destructor() {
+        Portability.releaseLocal(local[0]); // this must be a no-op for static
+        // locals
+        // for non-static cases the other array slots contain the same pointer
+        // as weak references.
+        Portability.deleteArray(local);
+    }
+
+    // [NOCPP[
+    static AttributeName create(@Local String name) {
+        return new AttributeName(AttributeName.ALL_NO_NS,
+                AttributeName.SAME_LOCAL(name), ALL_NO_PREFIX,
+                AttributeName.ALL_NCNAME, false);
+    }
+
+    public boolean isNcName(int mode) {
+        return ncname[mode];
+    }
+
+    public boolean isXmlns() {
+        return xmlns;
+    }
+
+    boolean isCaseFolded() {
+        return this == AttributeName.ACTIVE || this == AttributeName.ALIGN
+                || this == AttributeName.ASYNC
+                || this == AttributeName.AUTOCOMPLETE
+                || this == AttributeName.AUTOFOCUS
+                || this == AttributeName.AUTOSUBMIT
+                || this == AttributeName.CHECKED || this == AttributeName.CLEAR
+                || this == AttributeName.COMPACT
+                || this == AttributeName.DATAFORMATAS
+                || this == AttributeName.DECLARE
+                || this == AttributeName.DEFAULT || this == AttributeName.DEFER
+                || this == AttributeName.DIR || this == AttributeName.DISABLED
+                || this == AttributeName.ENCTYPE || this == AttributeName.FRAME
+                || this == AttributeName.ISMAP || this == AttributeName.METHOD
+                || this == AttributeName.MULTIPLE
+                || this == AttributeName.NOHREF
+                || this == AttributeName.NORESIZE
+                || this == AttributeName.NOSHADE
+                || this == AttributeName.NOWRAP
+                || this == AttributeName.READONLY
+                || this == AttributeName.REPLACE
+                || this == AttributeName.REQUIRED
+                || this == AttributeName.RULES || this == AttributeName.SCOPE
+                || this == AttributeName.SCROLLING
+                || this == AttributeName.SELECTED
+                || this == AttributeName.SHAPE || this == AttributeName.STEP
+                || this == AttributeName.TYPE || this == AttributeName.VALIGN
+                || this == AttributeName.VALUETYPE;
+    }
+
+    boolean isBoolean() {
+        return this == AttributeName.ACTIVE || this == AttributeName.ASYNC
+                || this == AttributeName.AUTOFOCUS
+                || this == AttributeName.AUTOSUBMIT
+                || this == AttributeName.CHECKED
+                || this == AttributeName.COMPACT
+                || this == AttributeName.DECLARE
+                || this == AttributeName.DEFAULT || this == AttributeName.DEFER
+                || this == AttributeName.DISABLED
+                || this == AttributeName.ISMAP
+                || this == AttributeName.MULTIPLE
+                || this == AttributeName.NOHREF
+                || this == AttributeName.NORESIZE
+                || this == AttributeName.NOSHADE
+                || this == AttributeName.NOWRAP
+                || this == AttributeName.READONLY
+                || this == AttributeName.REQUIRED
+                || this == AttributeName.SELECTED;
+    }
+
+    public @QName String getQName(int mode) {
+        return qName[mode];
+    }
+
+    public @IdType String getType(int mode) {
+        return type;
+    }
+
+    // ]NOCPP]
+
+    public @NsUri String getUri(int mode) {
+        return uri[mode];
+    }
+
+    public @Local String getLocal(int mode) {
+        return local[mode];
+    }
+
+    public @Prefix String getPrefix(int mode) {
+        return prefix[mode];
+    }
+
+    boolean equalsAnother(AttributeName another) {
+        return this.getLocal(AttributeName.HTML) == another.getLocal(AttributeName.HTML);
+    }
+
+    // START CODE ONLY USED FOR GENERATING CODE uncomment to regenerate
+
+//    /**
+//     * @see java.lang.Object#toString()
+//     */
+//    @Override public String toString() {
+//        return "(" + formatNs() + ", " + formatLocal() + ", " + formatPrefix()
+//                + ", " + formatNcname() + ", " + (xmlns ? "true" : "false")
+//                + ("ID" == type ? ", \"ID\"" : "") + ")";
+//    }
+//
+//    public int compareTo(AttributeName other) {
+//        int thisHash = this.hash();
+//        int otherHash = other.hash();
+//        if (thisHash < otherHash) {
+//            return -1;
+//        } else if (thisHash == otherHash) {
+//            return 0;
+//        } else {
+//            return 1;
+//        }
+//    }
+//
+//    private String formatPrefix() {
+//        if (prefix[0] == null && prefix[1] == null && prefix[2] == null
+//                && prefix[3] == null) {
+//            return "ALL_NO_PREFIX";
+//        } else if (prefix[0] == null && prefix[1] == prefix[2]
+//                && prefix[3] == null) {
+//            if ("xmlns".equals(prefix[1])) {
+//                return "XMLNS_PREFIX";
+//            } else if ("xml".equals(prefix[1])) {
+//                return "XML_PREFIX";
+//            } else if ("xlink".equals(prefix[1])) {
+//                return "XLINK_PREFIX";
+//            } else {
+//                throw new IllegalStateException();
+//            }
+//        } else if (prefix[0] == null && prefix[1] == null && prefix[2] == null
+//                && prefix[3] == "xml") {
+//            return "LANG_PREFIX";
+//        } else {
+//            throw new IllegalStateException();
+//        }
+//    }
+//
+//    private String formatLocal() {
+//        if (local[0] == local[1] && local[0] == local[3]
+//                && local[0] != local[2]) {
+//            return "SVG_DIFFERENT(\"" + local[0] + "\", \"" + local[2] + "\")";
+//        }
+//        if (local[0] == local[2] && local[0] == local[3]
+//                && local[0] != local[1]) {
+//            return "MATH_DIFFERENT(\"" + local[0] + "\", \"" + local[1] + "\")";
+//        }
+//        if (local[0] == local[3] && local[1] == local[2]
+//                && local[0] != local[1]) {
+//            return "COLONIFIED_LOCAL(\"" + local[0] + "\", \"" + local[1]
+//                    + "\")";
+//        }
+//        for (int i = 1; i < local.length; i++) {
+//            if (local[0] != local[i]) {
+//                throw new IllegalStateException();
+//            }
+//        }
+//        return "SAME_LOCAL(\"" + local[0] + "\")";
+//    }
+//
+//    private String formatNs() {
+//        if (uri[0] == "" && uri[1] == "" && uri[2] == "" && uri[3] == "") {
+//            return "ALL_NO_NS";
+//        } else if (uri[0] == "" && uri[1] == uri[2] && uri[3] == "") {
+//            if ("http://www.w3.org/2000/xmlns/".equals(uri[1])) {
+//                return "XMLNS_NS";
+//            } else if ("http://www.w3.org/XML/1998/namespace".equals(uri[1])) {
+//                return "XML_NS";
+//            } else if ("http://www.w3.org/1999/xlink".equals(uri[1])) {
+//                return "XLINK_NS";
+//            } else {
+//                throw new IllegalStateException();
+//            }
+//        } else if (uri[0] == "" && uri[1] == "" && uri[2] == ""
+//                && uri[3] == "http://www.w3.org/XML/1998/namespace") {
+//            return "LANG_NS";
+//        } else {
+//            throw new IllegalStateException();
+//        }
+//    }
+//
+//    private String formatNcname() {
+//        for (int i = 0; i < ncname.length; i++) {
+//            if (!ncname[i]) {
+//                return "new boolean[]{" + ncname[0] + ", " + ncname[1] + ", "
+//                        + ncname[2] + ", " + ncname[3] + "}";
+//            }
+//        }
+//        return "ALL_NCNAME";
+//    }
+//
+//    private String constName() {
+//        String name = getLocal(HTML);
+//        char[] buf = new char[name.length()];
+//        for (int i = 0; i < name.length(); i++) {
+//            char c = name.charAt(i);
+//            if (c == '-' || c == ':') {
+//                buf[i] = '_';
+//            } else if (c >= 'a' && c <= 'z') {
+//                buf[i] = (char) (c - 0x20);
+//            } else {
+//                buf[i] = c;
+//            }
+//        }
+//        return new String(buf);
+//    }
+//
+//    private int hash() {
+//        String name = getLocal(HTML);
+//        return bufToHash(name.toCharArray(), name.length());
+//    }
+//
+//    /**
+//     * Regenerate self
+//     * 
+//     * @param args
+//     */
+//    public static void main(String[] args) {
+//        Arrays.sort(ATTRIBUTE_NAMES);
+//        for (int i = 1; i < ATTRIBUTE_NAMES.length; i++) {
+//            if (ATTRIBUTE_NAMES[i].hash() == ATTRIBUTE_NAMES[i - 1].hash()) {
+//                System.err.println("Hash collision: "
+//                        + ATTRIBUTE_NAMES[i].getLocal(HTML) + ", "
+//                        + ATTRIBUTE_NAMES[i - 1].getLocal(HTML));
+//                return;
+//            }
+//        }
+//        for (int i = 0; i < ATTRIBUTE_NAMES.length; i++) {
+//            AttributeName att = ATTRIBUTE_NAMES[i];
+//            System.out.println("public static final AttributeName "
+//                    + att.constName() + " = new AttributeName" + att.toString()
+//                    + ";");
+//        }
+//        System.out.println("private final static @NoLength AttributeName[] ATTRIBUTE_NAMES = {");
+//        for (int i = 0; i < ATTRIBUTE_NAMES.length; i++) {
+//            AttributeName att = ATTRIBUTE_NAMES[i];
+//            System.out.println(att.constName() + ",");
+//        }
+//        System.out.println("};");
+//        System.out.println("private final static int[] ATTRIBUTE_HASHES = {");
+//        for (int i = 0; i < ATTRIBUTE_NAMES.length; i++) {
+//            AttributeName att = ATTRIBUTE_NAMES[i];
+//            System.out.println(Integer.toString(att.hash()) + ",");
+//        }
+//        System.out.println("};");
+//    }
+
+    // START GENERATED CODE
+    public static final AttributeName D = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("d"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName K = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("k"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName R = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("r"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName X = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("x"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName Y = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("y"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName Z = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("z"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("by"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("cx"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("cy"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("dx"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("dy"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName G2 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("g2"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName G1 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("g1"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fx"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fy"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName K4 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("k4"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName K2 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("k2"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName K3 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("k3"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName K1 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("k1"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ID = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("id"), ALL_NO_PREFIX, ALL_NCNAME, false, "ID");
+
+    public static final AttributeName IN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("in"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName U2 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("u2"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName U1 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("u1"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rt"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rx"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ry"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TO = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("to"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName Y2 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("y2"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName Y1 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("y1"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName X1 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("x1"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName X2 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("x2"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ALT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("alt"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DIR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("dir"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DUR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("dur"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName END = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("end"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("for"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName IN2 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("in2"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MAX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("max"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MIN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("min"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LOW = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("low"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REL = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rel"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REV = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rev"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SRC = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("src"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName AXIS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("axis"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ABBR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("abbr"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BBOX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("bbox"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CITE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("cite"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CODE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("code"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BIAS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("bias"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COLS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("cols"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLIP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("clip"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CHAR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("char"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BASE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("base"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName EDGE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("edge"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DATA = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("data"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FILL = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fill"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FROM = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("from"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FORM = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("form"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FACE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("face"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HIGH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("high"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HREF = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("href"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OPEN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("open"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ICON = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("icon"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NAME = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("name"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MODE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("mode"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MASK = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("mask"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LINK = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("link"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LANG = new AttributeName(LANG_NS,
+            SAME_LOCAL("lang"), LANG_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LIST = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("list"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TYPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("type"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName WHEN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("when"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName WRAP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("wrap"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TEXT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("text"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PATH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("path"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ping"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REFX = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("refx", "refX"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REFY = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("refy", "refY"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("size"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SEED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("seed"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ROWS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rows"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SPAN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("span"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STEP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("step"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ROLE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("role"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName XREF = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("xref"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ASYNC = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("async"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ALINK = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("alink"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ALIGN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("align"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLOSE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("close"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COLOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("color"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLASS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("class"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLEAR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("clear"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BEGIN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("begin"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DEPTH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("depth"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DEFER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("defer"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FENCE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fence"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FRAME = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("frame"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ISMAP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ismap"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONEND = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onend"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName INDEX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("index"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ORDER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("order"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OTHER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("other"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONCUT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("oncut"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NARGS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("nargs"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MEDIA = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("media"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LABEL = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("label"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LOCAL = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("local"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName WIDTH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("width"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TITLE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("title"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VLINK = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("vlink"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VALUE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("value"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SLOPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("slope"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SHAPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("shape"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCOPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("scope"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCALE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("scale"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SPEED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("speed"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STYLE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("style"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RULES = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rules"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STEMH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("stemh"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STEMV = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("stemv"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName START = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("start"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName XMLNS = new AttributeName(XMLNS_NS,
+            SAME_LOCAL("xmlns"), ALL_NO_PREFIX, new boolean[] { false, false,
+                    false, false }, true);
+
+    public static final AttributeName ACCEPT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("accept"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ACCENT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("accent"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ASCENT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ascent"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ACTIVE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("active"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ALTIMG = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("altimg"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ACTION = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("action"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BORDER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("border"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CURSOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("cursor"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COORDS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("coords"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FILTER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("filter"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FORMAT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("format"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HIDDEN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("hidden"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HSPACE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("hspace"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HEIGHT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("height"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONMOVE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onmove"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONLOAD = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onload"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDRAG = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ondrag"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ORIGIN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("origin"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONZOOM = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onzoom"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONHELP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onhelp"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONSTOP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onstop"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDROP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ondrop"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONBLUR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onblur"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OBJECT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("object"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OFFSET = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("offset"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ORIENT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("orient"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONCOPY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("oncopy"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NOWRAP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("nowrap"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NOHREF = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("nohref"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MACROS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("macros"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName METHOD = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("method"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LOWSRC = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("lowsrc"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LSPACE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("lspace"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LQUOTE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("lquote"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName USEMAP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("usemap"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName WIDTHS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("widths"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TARGET = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("target"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VALUES = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("values"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VALIGN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("valign"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VSPACE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("vspace"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName POSTER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("poster"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName POINTS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("points"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PROMPT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("prompt"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCOPED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("scoped"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STRING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("string"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCHEME = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("scheme"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STROKE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("stroke"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RADIUS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("radius"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RESULT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("result"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REPEAT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("repeat"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RSPACE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rspace"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ROTATE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rotate"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RQUOTE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rquote"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ALTTEXT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("alttext"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARCHIVE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("archive"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName AZIMUTH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("azimuth"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLOSURE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("closure"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CHECKED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("checked"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLASSID = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("classid"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CHAROFF = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("charoff"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BGCOLOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("bgcolor"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COLSPAN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("colspan"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CHARSET = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("charset"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COMPACT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("compact"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CONTENT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("content"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ENCTYPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("enctype"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DATASRC = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("datasrc"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DATAFLD = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("datafld"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DECLARE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("declare"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DISPLAY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("display"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DIVISOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("divisor"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DEFAULT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("default"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DESCENT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("descent"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName KERNING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("kerning"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HANGING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("hanging"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HEADERS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("headers"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONPASTE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onpaste"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONCLICK = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onclick"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OPTIMUM = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("optimum"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONBEGIN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onbegin"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONKEYUP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onkeyup"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONFOCUS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onfocus"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONERROR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onerror"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONINPUT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("oninput"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONABORT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onabort"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONSTART = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onstart"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONRESET = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onreset"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OPACITY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("opacity"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NOSHADE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("noshade"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MINSIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("minsize"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MAXSIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("maxsize"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LOOPEND = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("loopend"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LARGEOP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("largeop"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName UNICODE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("unicode"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TARGETX = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("targetx", "targetX"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName TARGETY = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("targety", "targetY"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName VIEWBOX = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("viewbox", "viewBox"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName VERSION = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("version"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PATTERN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("pattern"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PROFILE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("profile"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SPACING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("spacing"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RESTART = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("restart"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ROWSPAN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rowspan"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SANDBOX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("sandbox"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SUMMARY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("summary"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STANDBY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("standby"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REPLACE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("replace"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName AUTOPLAY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("autoplay"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ADDITIVE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("additive"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CALCMODE = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("calcmode", "calcMode"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName CODETYPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("codetype"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CODEBASE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("codebase"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CONTROLS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("controls"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BEVELLED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("bevelled"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BASELINE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("baseline"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName EXPONENT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("exponent"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName EDGEMODE = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("edgemode", "edgeMode"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ENCODING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("encoding"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName GLYPHREF = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("glyphref", "glyphRef"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName DATETIME = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("datetime"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DISABLED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("disabled"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONTSIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fontsize"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName KEYTIMES = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("keytimes", "keyTimes"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName PANOSE_1 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("panose-1"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HREFLANG = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("hreflang"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONRESIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onresize"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONCHANGE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onchange"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONBOUNCE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onbounce"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONUNLOAD = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onunload"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONFINISH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onfinish"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONSCROLL = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onscroll"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OPERATOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("operator"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OVERFLOW = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("overflow"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONSUBMIT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onsubmit"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONREPEAT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onrepeat"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONSELECT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onselect"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NOTATION = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("notation"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NORESIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("noresize"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MANIFEST = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("manifest"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MATHSIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("mathsize"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MULTIPLE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("multiple"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LONGDESC = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("longdesc"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LANGUAGE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("language"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TEMPLATE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("template"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TABINDEX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("tabindex"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName READONLY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("readonly"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SELECTED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("selected"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ROWLINES = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rowlines"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SEAMLESS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("seamless"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ROWALIGN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rowalign"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STRETCHY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("stretchy"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REQUIRED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("required"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName XML_BASE = new AttributeName(XML_NS,
+            COLONIFIED_LOCAL("xml:base", "base"), XML_PREFIX, new boolean[] {
+                    false, true, true, false }, false);
+
+    public static final AttributeName XML_LANG = new AttributeName(XML_NS,
+            COLONIFIED_LOCAL("xml:lang", "lang"), XML_PREFIX, new boolean[] {
+                    false, true, true, false }, false);
+
+    public static final AttributeName X_HEIGHT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("x-height"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_OWNS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("aria-owns"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName AUTOFOCUS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("autofocus"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_SORT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("aria-sort"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ACCESSKEY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("accesskey"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_BUSY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("aria-busy"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_GRAB = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("aria-grab"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName AMPLITUDE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("amplitude"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_LIVE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("aria-live"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLIP_RULE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("clip-rule"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLIP_PATH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("clip-path"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName EQUALROWS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("equalrows"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ELEVATION = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("elevation"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DIRECTION = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("direction"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DRAGGABLE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("draggable"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FILTERRES = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("filterres", "filterRes"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FILL_RULE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fill-rule"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONTSTYLE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fontstyle"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONT_SIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("font-size"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName KEYPOINTS = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("keypoints", "keyPoints"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName HIDEFOCUS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("hidefocus"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONMESSAGE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onmessage"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName INTERCEPT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("intercept"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDRAGEND = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ondragend"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONMOVEEND = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onmoveend"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONINVALID = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("oninvalid"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONKEYDOWN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onkeydown"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONFOCUSIN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onfocusin"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONMOUSEUP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onmouseup"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName INPUTMODE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("inputmode"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONROWEXIT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onrowexit"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MATHCOLOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("mathcolor"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MASKUNITS = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("maskunits", "maskUnits"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MAXLENGTH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("maxlength"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LINEBREAK = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("linebreak"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LOOPSTART = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("loopstart"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TRANSFORM = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("transform"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName V_HANGING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("v-hanging"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VALUETYPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("valuetype"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName POINTSATZ = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("pointsatz", "pointsAtZ"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName POINTSATX = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("pointsatx", "pointsAtX"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName POINTSATY = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("pointsaty", "pointsAtY"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName PLAYCOUNT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("playcount"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SYMMETRIC = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("symmetric"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCROLLING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("scrolling"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REPEATDUR = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("repeatdur", "repeatDur"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName SELECTION = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("selection"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SEPARATOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("separator"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName XML_SPACE = new AttributeName(XML_NS,
+            COLONIFIED_LOCAL("xml:space", "space"), XML_PREFIX, new boolean[] {
+                    false, true, true, false }, false);
+
+    public static final AttributeName AUTOSUBMIT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("autosubmit"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ALPHABETIC = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("alphabetic"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ACTIONTYPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("actiontype"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ACCUMULATE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("accumulate"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_LEVEL = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("aria-level"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COLUMNSPAN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("columnspan"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CAP_HEIGHT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("cap-height"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BACKGROUND = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("background"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName GLYPH_NAME = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("glyph-name"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName GROUPALIGN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("groupalign"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONTFAMILY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fontfamily"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONTWEIGHT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fontweight"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONT_STYLE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("font-style"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName KEYSPLINES = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("keysplines", "keySplines"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName HTTP_EQUIV = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("http-equiv"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONACTIVATE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onactivate"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OCCURRENCE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("occurrence"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName IRRELEVANT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("irrelevant"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDBLCLICK = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ondblclick"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDRAGDROP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ondragdrop"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONKEYPRESS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onkeypress"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONROWENTER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onrowenter"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDRAGOVER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ondragover"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONFOCUSOUT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onfocusout"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONMOUSEOUT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onmouseout"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NUMOCTAVES = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("numoctaves", "numOctaves"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName MARKER_MID = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("marker-mid"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MARKER_END = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("marker-end"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TEXTLENGTH = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("textlength", "textLength"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName VISIBILITY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("visibility"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VIEWTARGET = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("viewtarget", "viewTarget"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName VERT_ADV_Y = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("vert-adv-y"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PATHLENGTH = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("pathlength", "pathLength"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName REPEAT_MAX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("repeat-max"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RADIOGROUP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("radiogroup"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STOP_COLOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("stop-color"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SEPARATORS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("separators"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REPEAT_MIN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("repeat-min"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ROWSPACING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rowspacing"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ZOOMANDPAN = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("zoomandpan", "zoomAndPan"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName XLINK_TYPE = new AttributeName(XLINK_NS,
+            COLONIFIED_LOCAL("xlink:type", "type"), XLINK_PREFIX,
+            new boolean[] { false, true, true, false }, false);
+
+    public static final AttributeName XLINK_ROLE = new AttributeName(XLINK_NS,
+            COLONIFIED_LOCAL("xlink:role", "role"), XLINK_PREFIX,
+            new boolean[] { false, true, true, false }, false);
+
+    public static final AttributeName XLINK_HREF = new AttributeName(XLINK_NS,
+            COLONIFIED_LOCAL("xlink:href", "href"), XLINK_PREFIX,
+            new boolean[] { false, true, true, false }, false);
+
+    public static final AttributeName XLINK_SHOW = new AttributeName(XLINK_NS,
+            COLONIFIED_LOCAL("xlink:show", "show"), XLINK_PREFIX,
+            new boolean[] { false, true, true, false }, false);
+
+    public static final AttributeName ACCENTUNDER = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("accentunder"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_SECRET = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-secret"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_ATOMIC = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-atomic"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_HIDDEN = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-hidden"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_FLOWTO = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-flowto"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARABIC_FORM = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("arabic-form"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName CELLPADDING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("cellpadding"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName CELLSPACING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("cellspacing"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName COLUMNWIDTH = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("columnwidth"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName COLUMNALIGN = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("columnalign"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName COLUMNLINES = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("columnlines"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName CONTEXTMENU = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("contextmenu"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName BASEPROFILE = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("baseprofile", "baseProfile"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONT_FAMILY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("font-family"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FRAMEBORDER = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("frameborder"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FILTERUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("filterunits", "filterUnits"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FLOOD_COLOR = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("flood-color"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FONT_WEIGHT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("font-weight"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName HORIZ_ADV_X = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("horiz-adv-x"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONDRAGLEAVE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ondragleave"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONMOUSEMOVE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onmousemove"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ORIENTATION = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("orientation"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONMOUSEDOWN = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onmousedown"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONMOUSEOVER = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onmouseover"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONDRAGENTER = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ondragenter"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName IDEOGRAPHIC = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ideographic"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONBEFORECUT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforecut"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONFORMINPUT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onforminput"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONDRAGSTART = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ondragstart"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONMOVESTART = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onmovestart"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MARKERUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("markerunits", "markerUnits"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MATHVARIANT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("mathvariant"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MARGINWIDTH = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("marginwidth"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MARKERWIDTH = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("markerwidth", "markerWidth"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TEXT_ANCHOR = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("text-anchor"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName TABLEVALUES = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("tablevalues", "tableValues"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCRIPTLEVEL = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("scriptlevel"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName REPEATCOUNT = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("repeatcount", "repeatCount"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STITCHTILES = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("stitchtiles", "stitchTiles"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STARTOFFSET = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("startoffset", "startOffset"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCROLLDELAY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("scrolldelay"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName XMLNS_XLINK = new AttributeName(XMLNS_NS,
+            COLONIFIED_LOCAL("xmlns:xlink", "xlink"), XMLNS_PREFIX,
+            new boolean[] { false, false, false, false }, true);
+
+    public static final AttributeName XLINK_TITLE = new AttributeName(XLINK_NS,
+            COLONIFIED_LOCAL("xlink:title", "title"), XLINK_PREFIX,
+            new boolean[] { false, true, true, false }, false);
+
+    public static final AttributeName ARIA_INVALID = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-invalid"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_PRESSED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-pressed"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_CHECKED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-checked"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName AUTOCOMPLETE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("autocomplete"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_SETSIZE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-setsize"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_CHANNEL = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-channel"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName EQUALCOLUMNS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("equalcolumns"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName DISPLAYSTYLE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("displaystyle"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName DATAFORMATAS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("dataformatas"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FILL_OPACITY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("fill-opacity"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FONT_VARIANT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("font-variant"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FONT_STRETCH = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("font-stretch"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FRAMESPACING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("framespacing"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName KERNELMATRIX = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("kernelmatrix", "kernelMatrix"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDEACTIVATE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ondeactivate"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONROWSDELETE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onrowsdelete"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONMOUSELEAVE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onmouseleave"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONFORMCHANGE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onformchange"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONCELLCHANGE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("oncellchange"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONMOUSEWHEEL = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onmousewheel"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONMOUSEENTER = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onmouseenter"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONAFTERPRINT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onafterprint"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONBEFORECOPY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforecopy"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MARGINHEIGHT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("marginheight"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MARKERHEIGHT = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("markerheight", "markerHeight"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MARKER_START = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("marker-start"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MATHEMATICAL = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("mathematical"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName LENGTHADJUST = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("lengthadjust", "lengthAdjust"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName UNSELECTABLE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("unselectable"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName UNICODE_BIDI = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("unicode-bidi"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName UNITS_PER_EM = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("units-per-em"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName WORD_SPACING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("word-spacing"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName WRITING_MODE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("writing-mode"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName V_ALPHABETIC = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("v-alphabetic"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName PATTERNUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("patternunits", "patternUnits"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SPREADMETHOD = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("spreadmethod", "spreadMethod"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SURFACESCALE = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("surfacescale", "surfaceScale"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STROKE_WIDTH = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stroke-width"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName REPEAT_START = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("repeat-start"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName STDDEVIATION = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("stddeviation", "stdDeviation"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STOP_OPACITY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stop-opacity"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_CONTROLS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-controls"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_HASPOPUP = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-haspopup"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ACCENT_HEIGHT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("accent-height"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_VALUENOW = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-valuenow"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_RELEVANT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-relevant"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_POSINSET = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-posinset"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_VALUEMAX = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-valuemax"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_READONLY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-readonly"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_SELECTED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-selected"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_REQUIRED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-required"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_EXPANDED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-expanded"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_DISABLED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-disabled"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ATTRIBUTETYPE = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("attributetype", "attributeType"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ATTRIBUTENAME = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("attributename", "attributeName"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_DATATYPE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-datatype"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_VALUEMIN = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-valuemin"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName BASEFREQUENCY = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("basefrequency", "baseFrequency"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COLUMNSPACING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("columnspacing"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName COLOR_PROFILE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("color-profile"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName CLIPPATHUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("clippathunits", "clipPathUnits"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DEFINITIONURL = new AttributeName(
+            ALL_NO_NS, MATH_DIFFERENT("definitionurl", "definitionURL"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName GRADIENTUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("gradientunits", "gradientUnits"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FLOOD_OPACITY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("flood-opacity"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONAFTERUPDATE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onafterupdate"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONERRORUPDATE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onerrorupdate"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONBEFOREPASTE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforepaste"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONLOSECAPTURE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onlosecapture"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONCONTEXTMENU = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("oncontextmenu"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONSELECTSTART = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onselectstart"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONBEFOREPRINT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforeprint"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MOVABLELIMITS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("movablelimits"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName LINETHICKNESS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("linethickness"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName UNICODE_RANGE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("unicode-range"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName THINMATHSPACE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("thinmathspace"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName VERT_ORIGIN_X = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("vert-origin-x"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName VERT_ORIGIN_Y = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("vert-origin-y"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName V_IDEOGRAPHIC = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("v-ideographic"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName PRESERVEALPHA = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("preservealpha", "preserveAlpha"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCRIPTMINSIZE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("scriptminsize"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName SPECIFICATION = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("specification"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName XLINK_ACTUATE = new AttributeName(
+            XLINK_NS, COLONIFIED_LOCAL("xlink:actuate", "actuate"),
+            XLINK_PREFIX, new boolean[] { false, true, true, false }, false);
+
+    public static final AttributeName XLINK_ARCROLE = new AttributeName(
+            XLINK_NS, COLONIFIED_LOCAL("xlink:arcrole", "arcrole"),
+            XLINK_PREFIX, new boolean[] { false, true, true, false }, false);
+
+    public static final AttributeName ACCEPT_CHARSET = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("accept-charset"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ALIGNMENTSCOPE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("alignmentscope"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_MULTILINE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-multiline"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName BASELINE_SHIFT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("baseline-shift"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName HORIZ_ORIGIN_X = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("horiz-origin-x"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName HORIZ_ORIGIN_Y = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("horiz-origin-y"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONBEFOREUPDATE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforeupdate"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONFILTERCHANGE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onfilterchange"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONROWSINSERTED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onrowsinserted"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONBEFOREUNLOAD = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforeunload"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MATHBACKGROUND = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("mathbackground"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName LETTER_SPACING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("letter-spacing"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName LIGHTING_COLOR = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("lighting-color"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName THICKMATHSPACE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("thickmathspace"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName TEXT_RENDERING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("text-rendering"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName V_MATHEMATICAL = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("v-mathematical"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName POINTER_EVENTS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("pointer-events"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName PRIMITIVEUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("primitiveunits", "primitiveUnits"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SYSTEMLANGUAGE = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("systemlanguage", "systemLanguage"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STROKE_LINECAP = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stroke-linecap"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName SUBSCRIPTSHIFT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("subscriptshift"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName STROKE_OPACITY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stroke-opacity"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_DROPEFFECT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-dropeffect"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_LABELLEDBY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-labelledby"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_TEMPLATEID = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-templateid"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName COLOR_RENDERING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("color-rendering"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName CONTENTEDITABLE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("contenteditable"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName DIFFUSECONSTANT = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("diffuseconstant", "diffuseConstant"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDATAAVAILABLE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ondataavailable"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ONCONTROLSELECT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("oncontrolselect"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName IMAGE_RENDERING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("image-rendering"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName MEDIUMMATHSPACE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("mediummathspace"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName TEXT_DECORATION = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("text-decoration"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName SHAPE_RENDERING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("shape-rendering"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName STROKE_LINEJOIN = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stroke-linejoin"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName REPEAT_TEMPLATE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("repeat-template"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_DESCRIBEDBY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-describedby"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName CONTENTSTYLETYPE = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("contentstyletype", "contentStyleType"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONT_SIZE_ADJUST = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("font-size-adjust"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName KERNELUNITLENGTH = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("kernelunitlength", "kernelUnitLength"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONBEFOREACTIVATE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforeactivate"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ONPROPERTYCHANGE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onpropertychange"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ONDATASETCHANGED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ondatasetchanged"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName MASKCONTENTUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("maskcontentunits", "maskContentUnits"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PATTERNTRANSFORM = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("patterntransform", "patternTransform"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REQUIREDFEATURES = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("requiredfeatures", "requiredFeatures"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RENDERING_INTENT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("rendering-intent"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName SPECULAREXPONENT = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("specularexponent", "specularExponent"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SPECULARCONSTANT = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("specularconstant", "specularConstant"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SUPERSCRIPTSHIFT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("superscriptshift"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName STROKE_DASHARRAY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stroke-dasharray"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName XCHANNELSELECTOR = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("xchannelselector", "xChannelSelector"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName YCHANNELSELECTOR = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("ychannelselector", "yChannelSelector"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_AUTOCOMPLETE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-autocomplete"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName CONTENTSCRIPTTYPE = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("contentscripttype", "contentScriptType"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ENABLE_BACKGROUND = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("enable-background"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName DOMINANT_BASELINE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("dominant-baseline"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName GRADIENTTRANSFORM = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("gradienttransform", "gradientTransform"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONBEFORDEACTIVATE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbefordeactivate"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ONDATASETCOMPLETE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ondatasetcomplete"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName OVERLINE_POSITION = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("overline-position"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ONBEFOREEDITFOCUS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforeeditfocus"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName LIMITINGCONEANGLE = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("limitingconeangle", "limitingConeAngle"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VERYTHINMATHSPACE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("verythinmathspace"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName STROKE_DASHOFFSET = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stroke-dashoffset"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName STROKE_MITERLIMIT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stroke-miterlimit"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ALIGNMENT_BASELINE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("alignment-baseline"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ONREADYSTATECHANGE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onreadystatechange"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName OVERLINE_THICKNESS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("overline-thickness"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName UNDERLINE_POSITION = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("underline-position"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName VERYTHICKMATHSPACE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("verythickmathspace"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName REQUIREDEXTENSIONS = new AttributeName(
+            ALL_NO_NS,
+            SVG_DIFFERENT("requiredextensions", "requiredExtensions"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COLOR_INTERPOLATION = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("color-interpolation"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName UNDERLINE_THICKNESS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("underline-thickness"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName PRESERVEASPECTRATIO = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("preserveaspectratio",
+                    "preserveAspectRatio"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PATTERNCONTENTUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("patterncontentunits",
+                    "patternContentUnits"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_MULTISELECTABLE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-multiselectable"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName SCRIPTSIZEMULTIPLIER = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("scriptsizemultiplier"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_ACTIVEDESCENDANT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-activedescendant"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName VERYVERYTHINMATHSPACE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("veryverythinmathspace"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName VERYVERYTHICKMATHSPACE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("veryverythickmathspace"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName STRIKETHROUGH_POSITION = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("strikethrough-position"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName STRIKETHROUGH_THICKNESS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("strikethrough-thickness"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName EXTERNALRESOURCESREQUIRED = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("externalresourcesrequired",
+                    "externalResourcesRequired"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName GLYPH_ORIENTATION_VERTICAL = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("glyph-orientation-vertical"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName COLOR_INTERPOLATION_FILTERS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("color-interpolation-filters"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName GLYPH_ORIENTATION_HORIZONTAL = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("glyph-orientation-horizontal"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    private final static @NoLength AttributeName[] ATTRIBUTE_NAMES = { D, K, R,
+            X, Y, Z, BY, CX, CY, DX, DY, G2, G1, FX, FY, K4, K2, K3, K1, ID,
+            IN, U2, U1, RT, RX, RY, TO, Y2, Y1, X1, X2, ALT, DIR, DUR, END,
+            FOR, IN2, MAX, MIN, LOW, REL, REV, SRC, AXIS, ABBR, BBOX, CITE,
+            CODE, BIAS, COLS, CLIP, CHAR, BASE, EDGE, DATA, FILL, FROM, FORM,
+            FACE, HIGH, HREF, OPEN, ICON, NAME, MODE, MASK, LINK, LANG, LIST,
+            TYPE, WHEN, WRAP, TEXT, PATH, PING, REFX, REFY, SIZE, SEED, ROWS,
+            SPAN, STEP, ROLE, XREF, ASYNC, ALINK, ALIGN, CLOSE, COLOR, CLASS,
+            CLEAR, BEGIN, DEPTH, DEFER, FENCE, FRAME, ISMAP, ONEND, INDEX,
+            ORDER, OTHER, ONCUT, NARGS, MEDIA, LABEL, LOCAL, WIDTH, TITLE,
+            VLINK, VALUE, SLOPE, SHAPE, SCOPE, SCALE, SPEED, STYLE, RULES,
+            STEMH, STEMV, START, XMLNS, ACCEPT, ACCENT, ASCENT, ACTIVE, ALTIMG,
+            ACTION, BORDER, CURSOR, COORDS, FILTER, FORMAT, HIDDEN, HSPACE,
+            HEIGHT, ONMOVE, ONLOAD, ONDRAG, ORIGIN, ONZOOM, ONHELP, ONSTOP,
+            ONDROP, ONBLUR, OBJECT, OFFSET, ORIENT, ONCOPY, NOWRAP, NOHREF,
+            MACROS, METHOD, LOWSRC, LSPACE, LQUOTE, USEMAP, WIDTHS, TARGET,
+            VALUES, VALIGN, VSPACE, POSTER, POINTS, PROMPT, SCOPED, STRING,
+            SCHEME, STROKE, RADIUS, RESULT, REPEAT, RSPACE, ROTATE, RQUOTE,
+            ALTTEXT, ARCHIVE, AZIMUTH, CLOSURE, CHECKED, CLASSID, CHAROFF,
+            BGCOLOR, COLSPAN, CHARSET, COMPACT, CONTENT, ENCTYPE, DATASRC,
+            DATAFLD, DECLARE, DISPLAY, DIVISOR, DEFAULT, DESCENT, KERNING,
+            HANGING, HEADERS, ONPASTE, ONCLICK, OPTIMUM, ONBEGIN, ONKEYUP,
+            ONFOCUS, ONERROR, ONINPUT, ONABORT, ONSTART, ONRESET, OPACITY,
+            NOSHADE, MINSIZE, MAXSIZE, LOOPEND, LARGEOP, UNICODE, TARGETX,
+            TARGETY, VIEWBOX, VERSION, PATTERN, PROFILE, SPACING, RESTART,
+            ROWSPAN, SANDBOX, SUMMARY, STANDBY, REPLACE, AUTOPLAY, ADDITIVE,
+            CALCMODE, CODETYPE, CODEBASE, CONTROLS, BEVELLED, BASELINE,
+            EXPONENT, EDGEMODE, ENCODING, GLYPHREF, DATETIME, DISABLED,
+            FONTSIZE, KEYTIMES, PANOSE_1, HREFLANG, ONRESIZE, ONCHANGE,
+            ONBOUNCE, ONUNLOAD, ONFINISH, ONSCROLL, OPERATOR, OVERFLOW,
+            ONSUBMIT, ONREPEAT, ONSELECT, NOTATION, NORESIZE, MANIFEST,
+            MATHSIZE, MULTIPLE, LONGDESC, LANGUAGE, TEMPLATE, TABINDEX,
+            READONLY, SELECTED, ROWLINES, SEAMLESS, ROWALIGN, STRETCHY,
+            REQUIRED, XML_BASE, XML_LANG, X_HEIGHT, ARIA_OWNS, AUTOFOCUS,
+            ARIA_SORT, ACCESSKEY, ARIA_BUSY, ARIA_GRAB, AMPLITUDE, ARIA_LIVE,
+            CLIP_RULE, CLIP_PATH, EQUALROWS, ELEVATION, DIRECTION, DRAGGABLE,
+            FILTERRES, FILL_RULE, FONTSTYLE, FONT_SIZE, KEYPOINTS, HIDEFOCUS,
+            ONMESSAGE, INTERCEPT, ONDRAGEND, ONMOVEEND, ONINVALID, ONKEYDOWN,
+            ONFOCUSIN, ONMOUSEUP, INPUTMODE, ONROWEXIT, MATHCOLOR, MASKUNITS,
+            MAXLENGTH, LINEBREAK, LOOPSTART, TRANSFORM, V_HANGING, VALUETYPE,
+            POINTSATZ, POINTSATX, POINTSATY, PLAYCOUNT, SYMMETRIC, SCROLLING,
+            REPEATDUR, SELECTION, SEPARATOR, XML_SPACE, AUTOSUBMIT, ALPHABETIC,
+            ACTIONTYPE, ACCUMULATE, ARIA_LEVEL, COLUMNSPAN, CAP_HEIGHT,
+            BACKGROUND, GLYPH_NAME, GROUPALIGN, FONTFAMILY, FONTWEIGHT,
+            FONT_STYLE, KEYSPLINES, HTTP_EQUIV, ONACTIVATE, OCCURRENCE,
+            IRRELEVANT, ONDBLCLICK, ONDRAGDROP, ONKEYPRESS, ONROWENTER,
+            ONDRAGOVER, ONFOCUSOUT, ONMOUSEOUT, NUMOCTAVES, MARKER_MID,
+            MARKER_END, TEXTLENGTH, VISIBILITY, VIEWTARGET, VERT_ADV_Y,
+            PATHLENGTH, REPEAT_MAX, RADIOGROUP, STOP_COLOR, SEPARATORS,
+            REPEAT_MIN, ROWSPACING, ZOOMANDPAN, XLINK_TYPE, XLINK_ROLE,
+            XLINK_HREF, XLINK_SHOW, ACCENTUNDER, ARIA_SECRET, ARIA_ATOMIC,
+            ARIA_HIDDEN, ARIA_FLOWTO, ARABIC_FORM, CELLPADDING, CELLSPACING,
+            COLUMNWIDTH, COLUMNALIGN, COLUMNLINES, CONTEXTMENU, BASEPROFILE,
+            FONT_FAMILY, FRAMEBORDER, FILTERUNITS, FLOOD_COLOR, FONT_WEIGHT,
+            HORIZ_ADV_X, ONDRAGLEAVE, ONMOUSEMOVE, ORIENTATION, ONMOUSEDOWN,
+            ONMOUSEOVER, ONDRAGENTER, IDEOGRAPHIC, ONBEFORECUT, ONFORMINPUT,
+            ONDRAGSTART, ONMOVESTART, MARKERUNITS, MATHVARIANT, MARGINWIDTH,
+            MARKERWIDTH, TEXT_ANCHOR, TABLEVALUES, SCRIPTLEVEL, REPEATCOUNT,
+            STITCHTILES, STARTOFFSET, SCROLLDELAY, XMLNS_XLINK, XLINK_TITLE,
+            ARIA_INVALID, ARIA_PRESSED, ARIA_CHECKED, AUTOCOMPLETE,
+            ARIA_SETSIZE, ARIA_CHANNEL, EQUALCOLUMNS, DISPLAYSTYLE,
+            DATAFORMATAS, FILL_OPACITY, FONT_VARIANT, FONT_STRETCH,
+            FRAMESPACING, KERNELMATRIX, ONDEACTIVATE, ONROWSDELETE,
+            ONMOUSELEAVE, ONFORMCHANGE, ONCELLCHANGE, ONMOUSEWHEEL,
+            ONMOUSEENTER, ONAFTERPRINT, ONBEFORECOPY, MARGINHEIGHT,
+            MARKERHEIGHT, MARKER_START, MATHEMATICAL, LENGTHADJUST,
+            UNSELECTABLE, UNICODE_BIDI, UNITS_PER_EM, WORD_SPACING,
+            WRITING_MODE, V_ALPHABETIC, PATTERNUNITS, SPREADMETHOD,
+            SURFACESCALE, STROKE_WIDTH, REPEAT_START, STDDEVIATION,
+            STOP_OPACITY, ARIA_CONTROLS, ARIA_HASPOPUP, ACCENT_HEIGHT,
+            ARIA_VALUENOW, ARIA_RELEVANT, ARIA_POSINSET, ARIA_VALUEMAX,
+            ARIA_READONLY, ARIA_SELECTED, ARIA_REQUIRED, ARIA_EXPANDED,
+            ARIA_DISABLED, ATTRIBUTETYPE, ATTRIBUTENAME, ARIA_DATATYPE,
+            ARIA_VALUEMIN, BASEFREQUENCY, COLUMNSPACING, COLOR_PROFILE,
+            CLIPPATHUNITS, DEFINITIONURL, GRADIENTUNITS, FLOOD_OPACITY,
+            ONAFTERUPDATE, ONERRORUPDATE, ONBEFOREPASTE, ONLOSECAPTURE,
+            ONCONTEXTMENU, ONSELECTSTART, ONBEFOREPRINT, MOVABLELIMITS,
+            LINETHICKNESS, UNICODE_RANGE, THINMATHSPACE, VERT_ORIGIN_X,
+            VERT_ORIGIN_Y, V_IDEOGRAPHIC, PRESERVEALPHA, SCRIPTMINSIZE,
+            SPECIFICATION, XLINK_ACTUATE, XLINK_ARCROLE, ACCEPT_CHARSET,
+            ALIGNMENTSCOPE, ARIA_MULTILINE, BASELINE_SHIFT, HORIZ_ORIGIN_X,
+            HORIZ_ORIGIN_Y, ONBEFOREUPDATE, ONFILTERCHANGE, ONROWSINSERTED,
+            ONBEFOREUNLOAD, MATHBACKGROUND, LETTER_SPACING, LIGHTING_COLOR,
+            THICKMATHSPACE, TEXT_RENDERING, V_MATHEMATICAL, POINTER_EVENTS,
+            PRIMITIVEUNITS, SYSTEMLANGUAGE, STROKE_LINECAP, SUBSCRIPTSHIFT,
+            STROKE_OPACITY, ARIA_DROPEFFECT, ARIA_LABELLEDBY, ARIA_TEMPLATEID,
+            COLOR_RENDERING, CONTENTEDITABLE, DIFFUSECONSTANT, ONDATAAVAILABLE,
+            ONCONTROLSELECT, IMAGE_RENDERING, MEDIUMMATHSPACE, TEXT_DECORATION,
+            SHAPE_RENDERING, STROKE_LINEJOIN, REPEAT_TEMPLATE,
+            ARIA_DESCRIBEDBY, CONTENTSTYLETYPE, FONT_SIZE_ADJUST,
+            KERNELUNITLENGTH, ONBEFOREACTIVATE, ONPROPERTYCHANGE,
+            ONDATASETCHANGED, MASKCONTENTUNITS, PATTERNTRANSFORM,
+            REQUIREDFEATURES, RENDERING_INTENT, SPECULAREXPONENT,
+            SPECULARCONSTANT, SUPERSCRIPTSHIFT, STROKE_DASHARRAY,
+            XCHANNELSELECTOR, YCHANNELSELECTOR, ARIA_AUTOCOMPLETE,
+            CONTENTSCRIPTTYPE, ENABLE_BACKGROUND, DOMINANT_BASELINE,
+            GRADIENTTRANSFORM, ONBEFORDEACTIVATE, ONDATASETCOMPLETE,
+            OVERLINE_POSITION, ONBEFOREEDITFOCUS, LIMITINGCONEANGLE,
+            VERYTHINMATHSPACE, STROKE_DASHOFFSET, STROKE_MITERLIMIT,
+            ALIGNMENT_BASELINE, ONREADYSTATECHANGE, OVERLINE_THICKNESS,
+            UNDERLINE_POSITION, VERYTHICKMATHSPACE, REQUIREDEXTENSIONS,
+            COLOR_INTERPOLATION, UNDERLINE_THICKNESS, PRESERVEASPECTRATIO,
+            PATTERNCONTENTUNITS, ARIA_MULTISELECTABLE, SCRIPTSIZEMULTIPLIER,
+            ARIA_ACTIVEDESCENDANT, VERYVERYTHINMATHSPACE,
+            VERYVERYTHICKMATHSPACE, STRIKETHROUGH_POSITION,
+            STRIKETHROUGH_THICKNESS, EXTERNALRESOURCESREQUIRED,
+            GLYPH_ORIENTATION_VERTICAL, COLOR_INTERPOLATION_FILTERS,
+            GLYPH_ORIENTATION_HORIZONTAL, };
+
+    private final static int[] ATTRIBUTE_HASHES = { 1153, 1383, 1601, 1793,
+            1827, 1857, 68600, 69146, 69177, 70237, 70270, 71572, 71669, 72415,
+            72444, 74846, 74904, 74943, 75001, 75276, 75590, 84742, 84839,
+            85575, 85963, 85992, 87204, 88074, 88171, 89130, 89163, 3207892,
+            3283895, 3284791, 3338752, 3358197, 3369562, 3539124, 3562402,
+            3574260, 3670335, 3696933, 3721879, 135280021, 135346322,
+            136317019, 136475749, 136548517, 136652214, 136884919, 136902418,
+            136942992, 137292068, 139120259, 139785574, 142250603, 142314056,
+            142331176, 142519584, 144752417, 145106895, 146147200, 146765926,
+            148805544, 149655723, 149809441, 150018784, 150445028, 150923321,
+            152528754, 152536216, 152647366, 152962785, 155219321, 155654904,
+            157317483, 157350248, 157437941, 157447478, 157604838, 157685404,
+            157894402, 158315188, 166078431, 169409980, 169700259, 169856932,
+            170007032, 170409695, 170466488, 170513710, 170608367, 173028944,
+            173896963, 176090625, 176129212, 179390001, 179489057, 179627464,
+            179840468, 179849042, 180004216, 181779081, 183027151, 183645319,
+            183698797, 185922012, 185997252, 188312483, 188675799, 190977533,
+            190992569, 191006194, 191033518, 191038774, 191096249, 191166163,
+            191194426, 191522106, 191568039, 200104642, 202506661, 202537381,
+            202602917, 203070590, 203120766, 203389054, 203690071, 203971238,
+            203986524, 209040857, 209125756, 212055489, 212322418, 212746849,
+            213002877, 213055164, 213088023, 213259873, 213273386, 213435118,
+            213437318, 213438231, 213493071, 213532268, 213542834, 213584431,
+            213659891, 215285828, 215880731, 216112976, 216684637, 217369699,
+            217565298, 217576549, 218186795, 219743185, 220082234, 221623802,
+            221986406, 222283890, 223089542, 223138630, 223311265, 224547358,
+            224587256, 224589550, 224655650, 224785518, 224810917, 224813302,
+            225429618, 225432950, 225440869, 236107233, 236709921, 236838947,
+            237117095, 237143271, 237172455, 237209953, 237354143, 237372743,
+            237668065, 237703073, 237714273, 239743521, 240512803, 240522627,
+            240560417, 240656513, 241015715, 241062755, 241065383, 243523041,
+            245865199, 246261793, 246556195, 246774817, 246923491, 246928419,
+            246981667, 247014847, 247058369, 247112833, 247118177, 247119137,
+            247128739, 247316903, 249533729, 250235623, 250269543, 251083937,
+            251402351, 252339047, 253260911, 253293679, 254844367, 255547879,
+            256077281, 256345377, 258124199, 258354465, 258605063, 258744193,
+            258845603, 258856961, 258926689, 269869248, 270174334, 270709417,
+            270778994, 270781796, 271102503, 271478858, 271490090, 272870654,
+            273335275, 273369140, 273924313, 274108530, 274116736, 276818662,
+            277476156, 279156579, 279349675, 280108533, 280128712, 280132869,
+            280162403, 280280292, 280413430, 280506130, 280677397, 280678580,
+            280686710, 280689066, 282736758, 283110901, 283275116, 283823226,
+            283890012, 284479340, 284606461, 286700477, 286798916, 291557706,
+            291665349, 291804100, 292138018, 292166446, 292418738, 292451039,
+            300298041, 300374839, 300597935, 303073389, 303083839, 303266673,
+            303354997, 303430688, 303576261, 303724281, 303819694, 304242723,
+            304382625, 306247792, 307227811, 307468786, 307724489, 309671175,
+            310252031, 310358241, 310373094, 311015256, 313357609, 313683893,
+            313701861, 313706996, 313707317, 313710350, 314027746, 314038181,
+            314091299, 314205627, 314233813, 316741830, 316797986, 317486755,
+            317794164, 318721061, 320076137, 322657125, 322887778, 323506876,
+            323572412, 323605180, 323938869, 325060058, 325320188, 325398738,
+            325541490, 325671619, 333868843, 336806130, 337212108, 337282686,
+            337285434, 337585223, 338036037, 338298087, 338566051, 340943551,
+            341190970, 342995704, 343352124, 343912673, 344585053, 346977248,
+            347218098, 347262163, 347278576, 347438191, 347655959, 347684788,
+            347726430, 347727772, 347776035, 347776629, 349500753, 350880161,
+            350887073, 353384123, 355496998, 355906922, 355979793, 356545959,
+            358637867, 358905016, 359164318, 359247286, 359350571, 359579447,
+            365560330, 367399355, 367420285, 367510727, 368013212, 370234760,
+            370353345, 370710317, 371074566, 371122285, 371194213, 371448425,
+            371448430, 371545055, 371596922, 371758751, 371964792, 372151328,
+            376550136, 376710172, 376795771, 376826271, 376906556, 380514830,
+            380774774, 380775037, 381030322, 381136500, 381281631, 381282269,
+            381285504, 381330595, 381331422, 381335911, 381336484, 383907298,
+            383917408, 384595009, 384595013, 387799894, 387823201, 392581647,
+            392584937, 392742684, 392906485, 393003349, 400644707, 400973830,
+            404428547, 404432113, 404432865, 404469244, 404478897, 404694860,
+            406887479, 408294949, 408789955, 410022510, 410467324, 410586448,
+            410945965, 411845275, 414327152, 414327932, 414329781, 414346257,
+            414346439, 414639928, 414835998, 414894517, 414986533, 417465377,
+            417465381, 417492216, 418259232, 419310946, 420103495, 420242342,
+            420380455, 420658662, 420717432, 423183880, 424539259, 425929170,
+            425972964, 426050649, 426126450, 426142833, 426607922, 437289840,
+            437347469, 437412335, 437423943, 437455540, 437462252, 437597991,
+            437617485, 437986305, 437986507, 437986828, 437987072, 438015591,
+            438034813, 438038966, 438179623, 438347971, 438483573, 438547062,
+            438895551, 441592676, 442032555, 443548979, 447881379, 447881655,
+            447881895, 447887844, 448416189, 448445746, 448449012, 450942191,
+            452816744, 453668677, 454434495, 456610076, 456642844, 456738709,
+            457544600, 459451897, 459680944, 468058810, 468083581, 470964084,
+            471470955, 471567278, 472267822, 481177859, 481210627, 481435874,
+            481455115, 481485378, 481490218, 485105638, 486005878, 486383494,
+            487988916, 488103783, 490661867, 491574090, 491578272, 493041952,
+            493441205, 493582844, 493716979, 504577572, 504740359, 505091638,
+            505592418, 505656212, 509516275, 514998531, 515571132, 515594682,
+            518712698, 521362273, 526592419, 526807354, 527348842, 538294791,
+            539214049, 544689535, 545535009, 548544752, 548563346, 548595116,
+            551679010, 558034099, 560329411, 560356209, 560671018, 560671152,
+            560692590, 560845442, 569212097, 569474241, 572252718, 572768481,
+            575326764, 576174758, 576190819, 582099184, 582099438, 582372519,
+            582558889, 586552164, 591325418, 594231990, 594243961, 605711268,
+            615672071, 616086845, 621792370, 624879850, 627432831, 640040548,
+            654392808, 658675477, 659420283, 672891587, 694768102, 705890982,
+            725543146, 759097578, 761686526, 795383908, 843809551, 878105336,
+            908643300, 945213471, };
+
+}
diff --git a/parser/html/java/htmlparser/src/CoalescingTreeBuilder.java b/parser/html/java/htmlparser/src/CoalescingTreeBuilder.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/CoalescingTreeBuilder.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2008-2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.NoLength;
+
+import org.xml.sax.SAXException;
+
+public abstract class CoalescingTreeBuilder<T> extends TreeBuilder<T> {
+
+    protected final void accumulateCharacters(@NoLength char[] buf, int start,
+            int length) throws SAXException {
+        int newLen = charBufferLen + length;
+        if (newLen > charBuffer.length) {
+            char[] newBuf = new char[newLen];
+            System.arraycopy(charBuffer, 0, newBuf, 0, charBufferLen);
+            Portability.releaseArray(charBuffer);
+            charBuffer = newBuf;
+        }
+        System.arraycopy(buf, start, charBuffer, charBufferLen, length);
+        charBufferLen = newLen;
+    }
+
+    /**
+     * @see nu.validator.htmlparser.impl.TreeBuilder#appendCharacters(java.lang.Object, char[], int, int)
+     */
+    @Override protected final void appendCharacters(T parent, char[] buf, int start,
+            int length) throws SAXException {
+        appendCharacters(parent, new String(buf, start, length));
+    }
+
+    protected abstract void appendCharacters(T parent, String text) throws SAXException;
+
+    /**
+     * @see nu.validator.htmlparser.impl.TreeBuilder#appendComment(java.lang.Object, char[], int, int)
+     */
+    @Override final protected void appendComment(T parent, char[] buf, int start,
+            int length) throws SAXException {
+        appendComment(parent, new String(buf, start, length));
+    }
+
+    protected abstract void appendComment(T parent, String comment) throws SAXException;
+    
+    /**
+     * @see nu.validator.htmlparser.impl.TreeBuilder#appendCommentToDocument(char[], int, int)
+     */
+    @Override protected final void appendCommentToDocument(char[] buf, int start,
+            int length) throws SAXException {
+        // TODO Auto-generated method stub
+        appendCommentToDocument(new String(buf, start, length));
+    }
+
+    protected abstract void appendCommentToDocument(String comment) throws SAXException;
+    
+    /**
+     * @see nu.validator.htmlparser.impl.TreeBuilder#insertFosterParentedCharacters(char[], int, int, java.lang.Object, java.lang.Object)
+     */
+    @Override protected final void insertFosterParentedCharacters(char[] buf, int start,
+            int length, T table, T stackParent) throws SAXException {
+        insertFosterParentedCharacters(new String(buf, start, length), table, stackParent);
+    }
+    
+    protected abstract void insertFosterParentedCharacters(String text, T table, T stackParent) throws SAXException;
+}
diff --git a/parser/html/java/htmlparser/src/ElementName.java b/parser/html/java/htmlparser/src/ElementName.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/ElementName.java
@@ -0,0 +1,1513 @@
+/*
+ * Copyright (c) 2008 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import java.util.Arrays;
+
+import nu.validator.htmlparser.annotation.Local;
+import nu.validator.htmlparser.annotation.NoLength;
+import nu.validator.htmlparser.annotation.Virtual;
+
+public final class ElementName
+// uncomment when regenerating self
+//        implements Comparable<ElementName> 
+{
+
+    public final static ElementName NULL_ELEMENT_NAME = new ElementName(null);
+
+    public final @Local String name;
+
+    public final @Local String camelCaseName;
+    
+    public final int group;
+
+    public final boolean special;
+
+    public final boolean scoping;
+
+    public final boolean fosterParenting;
+
+    // [NOCPP[
+    
+    public final boolean custom;
+
+    // ]NOCPP]
+    
+    static ElementName elementNameByBuffer(char[] buf, int offset, int length) {
+        int hash = ElementName.bufToHash(buf, length);
+        int index = Arrays.binarySearch(ElementName.ELEMENT_HASHES, hash);
+        if (index < 0) {
+            return new ElementName(Portability.newLocalNameFromBuffer(buf, offset, length));
+        } else {
+            ElementName elementName = ElementName.ELEMENT_NAMES[index];
+            @Local String name = elementName.name;
+            if (!Portability.localEqualsBuffer(name, buf, offset, length)) {
+                return new ElementName(Portability.newLocalNameFromBuffer(buf,
+                        offset, length));                
+            }
+            return elementName;
+        }
+    }
+
+    /**
+     * This method has to return a unique integer for each well-known
+     * lower-cased element name.
+     * 
+     * @param buf
+     * @param len
+     * @return
+     */
+    private static int bufToHash(char[] buf, int len) {
+        int hash = len;
+        hash <<= 5;
+        hash += buf[0] - 0x60;
+        int j = len;
+        for (int i = 0; i < 4 && j > 0; i++) {
+            j--;
+            hash <<= 5;
+            hash += buf[j] - 0x60;
+        }
+        return hash;
+    }
+
+    private ElementName(@Local String name, @Local String camelCaseName,
+            int group, boolean special, boolean scoping, boolean fosterParenting) {
+        this.name = name;
+        this.camelCaseName = camelCaseName;
+        this.group = group;
+        this.special = special;
+        this.scoping = scoping;
+        this.fosterParenting = fosterParenting;
+        // [NOCPP[
+        this.custom = false;
+        // ]NOCPP]
+    }
+
+    protected ElementName(@Local String name) {
+        this.name = name;
+        this.camelCaseName = name;
+        this.group = TreeBuilder.OTHER;
+        this.special = false;
+        this.scoping = false;
+        this.fosterParenting = false;
+        // [NOCPP[
+        this.custom = true;
+        // ]NOCPP]
+    }
+    
+    @Virtual void release() {
+        // No-op in Java. 
+        // Implement as delete this in subclass.
+        // Be sure to release the local name
+    }
+    
+    @SuppressWarnings("unused") private void destructor() {
+        Portability.releaseLocal(name); // this must be a no-op for static locals
+        // for non-static cases the camel case contains the same pointer as a weak reference.
+    }
+
+    // START CODE ONLY USED FOR GENERATING CODE uncomment and run to regenerate
+
+//    /**
+//     * @see java.lang.Object#toString()
+//     */
+//    @Override public String toString() {
+//        return "(\"" + name + "\", \"" + camelCaseName + "\", TreeBuilder."
+//                + treeBuilderGroupToName() + ", "
+//                + (special ? "true" : "false") + ", "
+//                + (scoping ? "true" : "false") + ", "
+//                + (fosterParenting ? "true" : "false") + ")";
+//    }
+//
+//    private String constName() {
+//        char[] buf = new char[name.length()];
+//        for (int i = 0; i < name.length(); i++) {
+//            char c = name.charAt(i);
+//            if (c == '-') {
+//                buf[i] = '_';
+//            } else if (c >= '0' && c <= '9') {
+//                buf[i] = c;
+//            } else {
+//                buf[i] = (char) (c - 0x20);
+//            }
+//        }
+//        return new String(buf);
+//    }
+//
+//    private int hash() {
+//        return bufToHash(name.toCharArray(), name.length());
+//    }
+//
+//    public int compareTo(ElementName other) {
+//        int thisHash = this.hash();
+//        int otherHash = other.hash();
+//        if (thisHash < otherHash) {
+//            return -1;
+//        } else if (thisHash == otherHash) {
+//            return 0;
+//        } else {
+//            return 1;
+//        }
+//    }
+//
+//    private String treeBuilderGroupToName() {
+//        switch (group) {
+//            case TreeBuilder.OTHER:
+//                return "OTHER";
+//            case TreeBuilder.A:
+//                return "A";
+//            case TreeBuilder.BASE:
+//                return "BASE";
+//            case TreeBuilder.BODY:
+//                return "BODY";
+//            case TreeBuilder.BR:
+//                return "BR";
+//            case TreeBuilder.BUTTON:
+//                return "BUTTON";
+//            case TreeBuilder.CAPTION:
+//                return "CAPTION";
+//            case TreeBuilder.COL:
+//                return "COL";
+//            case TreeBuilder.COLGROUP:
+//                return "COLGROUP";
+//            case TreeBuilder.FORM:
+//                return "FORM";
+//            case TreeBuilder.FRAME:
+//                return "FRAME";
+//            case TreeBuilder.FRAMESET:
+//                return "FRAMESET";
+//            case TreeBuilder.IMAGE:
+//                return "IMAGE";
+//            case TreeBuilder.INPUT:
+//                return "INPUT";
+//            case TreeBuilder.ISINDEX:
+//                return "ISINDEX";
+//            case TreeBuilder.LI:
+//                return "LI";
+//            case TreeBuilder.LINK:
+//                return "LINK";
+//            case TreeBuilder.MATH:
+//                return "MATH";
+//            case TreeBuilder.META:
+//                return "META";
+//            case TreeBuilder.SVG:
+//                return "SVG";
+//            case TreeBuilder.HEAD:
+//                return "HEAD";
+//            case TreeBuilder.HR:
+//                return "HR";
+//            case TreeBuilder.HTML:
+//                return "HTML";
+//            case TreeBuilder.NOBR:
+//                return "NOBR";
+//            case TreeBuilder.NOFRAMES:
+//                return "NOFRAMES";
+//            case TreeBuilder.NOSCRIPT:
+//                return "NOSCRIPT";
+//            case TreeBuilder.OPTGROUP:
+//                return "OPTGROUP";
+//            case TreeBuilder.OPTION:
+//                return "OPTION";
+//            case TreeBuilder.P:
+//                return "P";
+//            case TreeBuilder.PLAINTEXT:
+//                return "PLAINTEXT";
+//            case TreeBuilder.SCRIPT:
+//                return "SCRIPT";
+//            case TreeBuilder.SELECT:
+//                return "SELECT";
+//            case TreeBuilder.STYLE:
+//                return "STYLE";
+//            case TreeBuilder.TABLE:
+//                return "TABLE";
+//            case TreeBuilder.TEXTAREA:
+//                return "TEXTAREA";
+//            case TreeBuilder.TITLE:
+//                return "TITLE";
+//            case TreeBuilder.TR:
+//                return "TR";
+//            case TreeBuilder.XMP:
+//                return "XMP";
+//            case TreeBuilder.TBODY_OR_THEAD_OR_TFOOT:
+//                return "TBODY_OR_THEAD_OR_TFOOT";
+//            case TreeBuilder.TD_OR_TH:
+//                return "TD_OR_TH";
+//            case TreeBuilder.DD_OR_DT:
+//                return "DD_OR_DT";
+//            case TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6:
+//                return "H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6";
+//            case TreeBuilder.OBJECT_OR_MARQUEE_OR_APPLET:
+//                return "OBJECT_OR_MARQUEE_OR_APPLET";
+//            case TreeBuilder.PRE_OR_LISTING:
+//                return "PRE_OR_LISTING";
+//            case TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U:
+//                return "B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U";
+//            case TreeBuilder.UL_OR_OL_OR_DL:
+//                return "UL_OR_OL_OR_DL";
+//            case TreeBuilder.IFRAME:
+//                return "IFRAME";
+//            case TreeBuilder.NOEMBED:
+//                return "NOEMBED";
+//            case TreeBuilder.EMBED_OR_IMG:
+//                return "EMBED_OR_IMG";
+//            case TreeBuilder.AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR:
+//                return "AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR";
+//            case TreeBuilder.DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU:
+//                return "DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU";
+//            case TreeBuilder.FIELDSET_OR_ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION:
+//                return "FIELDSET_OR_ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION";
+//            case TreeBuilder.CODE_OR_RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR:
+//                return "CODE_OR_RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR";
+//            case TreeBuilder.RT_OR_RP:
+//                return "RT_OR_RP";
+//            case TreeBuilder.COMMAND_OR_EVENT_SOURCE:
+//                return "COMMAND_OR_EVENT_SOURCE";
+//            case TreeBuilder.PARAM_OR_SOURCE:
+//                return "PARAM_OR_SOURCE";
+//            case TreeBuilder.MGLYPH_OR_MALIGNMARK:
+//                return "MGLYPH_OR_MALIGNMARK";
+//            case TreeBuilder.MI_MO_MN_MS_MTEXT:
+//                return "MI_MO_MN_MS_MTEXT";
+//            case TreeBuilder.ANNOTATION_XML:
+//                return "ANNOTATION_XML";
+//            case TreeBuilder.FOREIGNOBJECT_OR_DESC:
+//                return "FOREIGNOBJECT_OR_DESC";
+//        }
+//        return null;
+//    }
+//
+//    /**
+//     * Regenerate self
+//     * 
+//     * @param args
+//     */
+//    public static void main(String[] args) {
+//        Arrays.sort(ELEMENT_NAMES);
+//        for (int i = 1; i < ELEMENT_NAMES.length; i++) {
+//            if (ELEMENT_NAMES[i].hash() == ELEMENT_NAMES[i - 1].hash()) {
+//                System.err.println("Hash collision: " + ELEMENT_NAMES[i].name
+//                        + ", " + ELEMENT_NAMES[i - 1].name);
+//                return;
+//            }
+//        }
+//        for (int i = 0; i < ELEMENT_NAMES.length; i++) {
+//            ElementName el = ELEMENT_NAMES[i];
+//            System.out.println("public static final ElementName "
+//                    + el.constName() + " = new ElementName" + el.toString()
+//                    + ";");
+//        }
+//        System.out.println("private final static @NoLength ElementName[] ELEMENT_NAMES = {");
+//        for (int i = 0; i < ELEMENT_NAMES.length; i++) {
+//            ElementName el = ELEMENT_NAMES[i];
+//            System.out.println(el.constName() + ",");
+//        }
+//        System.out.println("};");
+//        System.out.println("private final static int[] ELEMENT_HASHES = {");
+//        for (int i = 0; i < ELEMENT_NAMES.length; i++) {
+//            ElementName el = ELEMENT_NAMES[i];
+//            System.out.println(Integer.toString(el.hash()) + ",");
+//        }
+//        System.out.println("};");
+//    }
+
+    // START GENERATED CODE
+    public static final ElementName A = new ElementName("a", "a", TreeBuilder.A, false, false, false);
+    public static final ElementName B = new ElementName("b", "b", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName G = new ElementName("g", "g", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName I = new ElementName("i", "i", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName P = new ElementName("p", "p", TreeBuilder.P, true, false, false);
+    public static final ElementName Q = new ElementName("q", "q", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName S = new ElementName("s", "s", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName U = new ElementName("u", "u", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName BR = new ElementName("br", "br", TreeBuilder.BR, true, false, false);
+    public static final ElementName CI = new ElementName("ci", "ci", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CN = new ElementName("cn", "cn", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DD = new ElementName("dd", "dd", TreeBuilder.DD_OR_DT, true, false, false);
+    public static final ElementName DL = new ElementName("dl", "dl", TreeBuilder.UL_OR_OL_OR_DL, true, false, false);
+    public static final ElementName DT = new ElementName("dt", "dt", TreeBuilder.DD_OR_DT, true, false, false);
+    public static final ElementName EM = new ElementName("em", "em", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName EQ = new ElementName("eq", "eq", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FN = new ElementName("fn", "fn", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName H1 = new ElementName("h1", "h1", TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6, true, false, false);
+    public static final ElementName H2 = new ElementName("h2", "h2", TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6, true, false, false);
+    public static final ElementName H3 = new ElementName("h3", "h3", TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6, true, false, false);
+    public static final ElementName H4 = new ElementName("h4", "h4", TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6, true, false, false);
+    public static final ElementName H5 = new ElementName("h5", "h5", TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6, true, false, false);
+    public static final ElementName H6 = new ElementName("h6", "h6", TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6, true, false, false);
+    public static final ElementName GT = new ElementName("gt", "gt", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName HR = new ElementName("hr", "hr", TreeBuilder.HR, true, false, false);
+    public static final ElementName IN = new ElementName("in", "in", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LI = new ElementName("li", "li", TreeBuilder.LI, true, false, false);
+    public static final ElementName LN = new ElementName("ln", "ln", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LT = new ElementName("lt", "lt", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MI = new ElementName("mi", "mi", TreeBuilder.MI_MO_MN_MS_MTEXT, false, false, false);
+    public static final ElementName MN = new ElementName("mn", "mn", TreeBuilder.MI_MO_MN_MS_MTEXT, false, false, false);
+    public static final ElementName MO = new ElementName("mo", "mo", TreeBuilder.MI_MO_MN_MS_MTEXT, false, false, false);
+    public static final ElementName MS = new ElementName("ms", "ms", TreeBuilder.MI_MO_MN_MS_MTEXT, false, false, false);
+    public static final ElementName OL = new ElementName("ol", "ol", TreeBuilder.UL_OR_OL_OR_DL, true, false, false);
+    public static final ElementName OR = new ElementName("or", "or", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PI = new ElementName("pi", "pi", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName RP = new ElementName("rp", "rp", TreeBuilder.RT_OR_RP, false, false, false);
+    public static final ElementName RT = new ElementName("rt", "rt", TreeBuilder.RT_OR_RP, false, false, false);
+    public static final ElementName TD = new ElementName("td", "td", TreeBuilder.TD_OR_TH, false, true, false);
+    public static final ElementName TH = new ElementName("th", "th", TreeBuilder.TD_OR_TH, false, true, false);
+    public static final ElementName TR = new ElementName("tr", "tr", TreeBuilder.TR, true, false, true);
+    public static final ElementName TT = new ElementName("tt", "tt", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName UL = new ElementName("ul", "ul", TreeBuilder.UL_OR_OL_OR_DL, true, false, false);
+    public static final ElementName AND = new ElementName("and", "and", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARG = new ElementName("arg", "arg", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ABS = new ElementName("abs", "abs", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName BIG = new ElementName("big", "big", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName BDO = new ElementName("bdo", "bdo", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CSC = new ElementName("csc", "csc", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName COL = new ElementName("col", "col", TreeBuilder.COL, true, false, false);
+    public static final ElementName COS = new ElementName("cos", "cos", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName COT = new ElementName("cot", "cot", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DEL = new ElementName("del", "del", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DFN = new ElementName("dfn", "dfn", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DIR = new ElementName("dir", "dir", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName DIV = new ElementName("div", "div", TreeBuilder.DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU, true, false, false);
+    public static final ElementName EXP = new ElementName("exp", "exp", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName GCD = new ElementName("gcd", "gcd", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName GEQ = new ElementName("geq", "geq", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName IMG = new ElementName("img", "img", TreeBuilder.EMBED_OR_IMG, true, false, false);
+    public static final ElementName INS = new ElementName("ins", "ins", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName INT = new ElementName("int", "int", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName KBD = new ElementName("kbd", "kbd", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LOG = new ElementName("log", "log", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LCM = new ElementName("lcm", "lcm", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LEQ = new ElementName("leq", "leq", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MTD = new ElementName("mtd", "mtd", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MIN = new ElementName("min", "min", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MAP = new ElementName("map", "map", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MTR = new ElementName("mtr", "mtr", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MAX = new ElementName("max", "max", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NEQ = new ElementName("neq", "neq", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NOT = new ElementName("not", "not", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NAV = new ElementName("nav", "nav", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName PRE = new ElementName("pre", "pre", TreeBuilder.PRE_OR_LISTING, true, false, false);
+    public static final ElementName REM = new ElementName("rem", "rem", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SUB = new ElementName("sub", "sub", TreeBuilder.RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR, false, false, false);
+    public static final ElementName SEC = new ElementName("sec", "sec", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SVG = new ElementName("svg", "svg", TreeBuilder.SVG, false, false, false);
+    public static final ElementName SUM = new ElementName("sum", "sum", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SIN = new ElementName("sin", "sin", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SEP = new ElementName("sep", "sep", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SUP = new ElementName("sup", "sup", TreeBuilder.RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR, false, false, false);
+    public static final ElementName SET = new ElementName("set", "set", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TAN = new ElementName("tan", "tan", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName USE = new ElementName("use", "use", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName VAR = new ElementName("var", "var", TreeBuilder.RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR, false, false, false);
+    public static final ElementName WBR = new ElementName("wbr", "wbr", TreeBuilder.AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR, true, false, false);
+    public static final ElementName XMP = new ElementName("xmp", "xmp", TreeBuilder.XMP, false, false, false);
+    public static final ElementName XOR = new ElementName("xor", "xor", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName AREA = new ElementName("area", "area", TreeBuilder.AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR, true, false, false);
+    public static final ElementName ABBR = new ElementName("abbr", "abbr", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName BASE = new ElementName("base", "base", TreeBuilder.BASE, true, false, false);
+    public static final ElementName BVAR = new ElementName("bvar", "bvar", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName BODY = new ElementName("body", "body", TreeBuilder.BODY, true, false, false);
+    public static final ElementName CARD = new ElementName("card", "card", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CODE = new ElementName("code", "code", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName CITE = new ElementName("cite", "cite", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CSCH = new ElementName("csch", "csch", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName COSH = new ElementName("cosh", "cosh", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName COTH = new ElementName("coth", "coth", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CURL = new ElementName("curl", "curl", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DESC = new ElementName("desc", "desc", TreeBuilder.FOREIGNOBJECT_OR_DESC, false, false, false);
+    public static final ElementName DIFF = new ElementName("diff", "diff", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DEFS = new ElementName("defs", "defs", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FORM = new ElementName("form", "form", TreeBuilder.FORM, true, false, false);
+    public static final ElementName FONT = new ElementName("font", "font", TreeBuilder.FONT, false, false, false);
+    public static final ElementName GRAD = new ElementName("grad", "grad", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName HEAD = new ElementName("head", "head", TreeBuilder.HEAD, true, false, false);
+    public static final ElementName HTML = new ElementName("html", "html", TreeBuilder.HTML, false, true, false);
+    public static final ElementName LINE = new ElementName("line", "line", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LINK = new ElementName("link", "link", TreeBuilder.LINK, true, false, false);
+    public static final ElementName LIST = new ElementName("list", "list", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName META = new ElementName("meta", "meta", TreeBuilder.META, true, false, false);
+    public static final ElementName MSUB = new ElementName("msub", "msub", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MODE = new ElementName("mode", "mode", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MATH = new ElementName("math", "math", TreeBuilder.MATH, false, false, false);
+    public static final ElementName MARK = new ElementName("mark", "mark", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MASK = new ElementName("mask", "mask", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MEAN = new ElementName("mean", "mean", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MSUP = new ElementName("msup", "msup", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MENU = new ElementName("menu", "menu", TreeBuilder.DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU, true, false, false);
+    public static final ElementName MROW = new ElementName("mrow", "mrow", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NONE = new ElementName("none", "none", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NOBR = new ElementName("nobr", "nobr", TreeBuilder.NOBR, false, false, false);
+    public static final ElementName NEST = new ElementName("nest", "nest", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PATH = new ElementName("path", "path", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PLUS = new ElementName("plus", "plus", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName RULE = new ElementName("rule", "rule", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName REAL = new ElementName("real", "real", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName RELN = new ElementName("reln", "reln", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName RECT = new ElementName("rect", "rect", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ROOT = new ElementName("root", "root", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName RUBY = new ElementName("ruby", "ruby", TreeBuilder.RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR, false, false, false);
+    public static final ElementName SECH = new ElementName("sech", "sech", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SINH = new ElementName("sinh", "sinh", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SPAN = new ElementName("span", "span", TreeBuilder.RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR, false, false, false);
+    public static final ElementName SAMP = new ElementName("samp", "samp", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName STOP = new ElementName("stop", "stop", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SDEV = new ElementName("sdev", "sdev", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TIME = new ElementName("time", "time", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TRUE = new ElementName("true", "true", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TREF = new ElementName("tref", "tref", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TANH = new ElementName("tanh", "tanh", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TEXT = new ElementName("text", "text", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName VIEW = new ElementName("view", "view", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ASIDE = new ElementName("aside", "aside", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName AUDIO = new ElementName("audio", "audio", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName APPLY = new ElementName("apply", "apply", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName EMBED = new ElementName("embed", "embed", TreeBuilder.EMBED_OR_IMG, true, false, false);
+    public static final ElementName FRAME = new ElementName("frame", "frame", TreeBuilder.FRAME, true, false, false);
+    public static final ElementName FALSE = new ElementName("false", "false", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FLOOR = new ElementName("floor", "floor", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName GLYPH = new ElementName("glyph", "glyph", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName HKERN = new ElementName("hkern", "hkern", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName IMAGE = new ElementName("image", "image", TreeBuilder.IMAGE, true, false, false);
+    public static final ElementName IDENT = new ElementName("ident", "ident", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName INPUT = new ElementName("input", "input", TreeBuilder.INPUT, true, false, false);
+    public static final ElementName LABEL = new ElementName("label", "label", TreeBuilder.OUTPUT_OR_LABEL, false, false, false);
+    public static final ElementName LIMIT = new ElementName("limit", "limit", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MFRAC = new ElementName("mfrac", "mfrac", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MPATH = new ElementName("mpath", "mpath", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName METER = new ElementName("meter", "meter", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MOVER = new ElementName("mover", "mover", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MINUS = new ElementName("minus", "minus", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MROOT = new ElementName("mroot", "mroot", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MSQRT = new ElementName("msqrt", "msqrt", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MTEXT = new ElementName("mtext", "mtext", TreeBuilder.MI_MO_MN_MS_MTEXT, false, false, false);
+    public static final ElementName NOTIN = new ElementName("notin", "notin", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PIECE = new ElementName("piece", "piece", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PARAM = new ElementName("param", "param", TreeBuilder.PARAM_OR_SOURCE, true, false, false);
+    public static final ElementName POWER = new ElementName("power", "power", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName REALS = new ElementName("reals", "reals", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName STYLE = new ElementName("style", "style", TreeBuilder.STYLE, true, false, false);
+    public static final ElementName SMALL = new ElementName("small", "small", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName THEAD = new ElementName("thead", "thead", TreeBuilder.TBODY_OR_THEAD_OR_TFOOT, true, false, true);
+    public static final ElementName TABLE = new ElementName("table", "table", TreeBuilder.TABLE, false, true, true);
+    public static final ElementName TITLE = new ElementName("title", "title", TreeBuilder.TITLE, true, false, false);
+    public static final ElementName TSPAN = new ElementName("tspan", "tspan", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TIMES = new ElementName("times", "times", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TFOOT = new ElementName("tfoot", "tfoot", TreeBuilder.TBODY_OR_THEAD_OR_TFOOT, true, false, true);
+    public static final ElementName TBODY = new ElementName("tbody", "tbody", TreeBuilder.TBODY_OR_THEAD_OR_TFOOT, true, false, true);
+    public static final ElementName UNION = new ElementName("union", "union", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName VKERN = new ElementName("vkern", "vkern", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName VIDEO = new ElementName("video", "video", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCSEC = new ElementName("arcsec", "arcsec", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCCSC = new ElementName("arccsc", "arccsc", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCTAN = new ElementName("arctan", "arctan", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCSIN = new ElementName("arcsin", "arcsin", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCCOS = new ElementName("arccos", "arccos", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName APPLET = new ElementName("applet", "applet", TreeBuilder.MARQUEE_OR_APPLET, false, true, false);
+    public static final ElementName ARCCOT = new ElementName("arccot", "arccot", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName APPROX = new ElementName("approx", "approx", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName BUTTON = new ElementName("button", "button", TreeBuilder.BUTTON, false, true, false);
+    public static final ElementName CIRCLE = new ElementName("circle", "circle", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CENTER = new ElementName("center", "center", TreeBuilder.DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU, true, false, false);
+    public static final ElementName CURSOR = new ElementName("cursor", "cursor", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CANVAS = new ElementName("canvas", "canvas", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DIVIDE = new ElementName("divide", "divide", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DEGREE = new ElementName("degree", "degree", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DIALOG = new ElementName("dialog", "dialog", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName DOMAIN = new ElementName("domain", "domain", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName EXISTS = new ElementName("exists", "exists", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FETILE = new ElementName("fetile", "feTile", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FIGURE = new ElementName("figure", "figure", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName FORALL = new ElementName("forall", "forall", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FILTER = new ElementName("filter", "filter", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FOOTER = new ElementName("footer", "footer", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName HEADER = new ElementName("header", "header", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName IFRAME = new ElementName("iframe", "iframe", TreeBuilder.IFRAME, true, false, false);
+    public static final ElementName KEYGEN = new ElementName("keygen", "keygen", TreeBuilder.KEYGEN, true, false, false);
+    public static final ElementName LAMBDA = new ElementName("lambda", "lambda", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LEGEND = new ElementName("legend", "legend", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MSPACE = new ElementName("mspace", "mspace", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MTABLE = new ElementName("mtable", "mtable", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MSTYLE = new ElementName("mstyle", "mstyle", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MGLYPH = new ElementName("mglyph", "mglyph", TreeBuilder.MGLYPH_OR_MALIGNMARK, false, false, false);
+    public static final ElementName MEDIAN = new ElementName("median", "median", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MUNDER = new ElementName("munder", "munder", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MARKER = new ElementName("marker", "marker", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MERROR = new ElementName("merror", "merror", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MOMENT = new ElementName("moment", "moment", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MATRIX = new ElementName("matrix", "matrix", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName OPTION = new ElementName("option", "option", TreeBuilder.OPTION, true, false, false);
+    public static final ElementName OBJECT = new ElementName("object", "object", TreeBuilder.OBJECT, false, true, false);
+    public static final ElementName OUTPUT = new ElementName("output", "output", TreeBuilder.OUTPUT_OR_LABEL, false, false, false);
+    public static final ElementName PRIMES = new ElementName("primes", "primes", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SOURCE = new ElementName("source", "source", TreeBuilder.PARAM_OR_SOURCE, false, false, false);
+    public static final ElementName STRIKE = new ElementName("strike", "strike", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName STRONG = new ElementName("strong", "strong", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName SWITCH = new ElementName("switch", "switch", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SYMBOL = new ElementName("symbol", "symbol", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SPACER = new ElementName("spacer", "spacer", TreeBuilder.AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR, true, false, false);
+    public static final ElementName SELECT = new ElementName("select", "select", TreeBuilder.SELECT, true, false, false);
+    public static final ElementName SUBSET = new ElementName("subset", "subset", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SCRIPT = new ElementName("script", "script", TreeBuilder.SCRIPT, true, false, false);
+    public static final ElementName TBREAK = new ElementName("tbreak", "tbreak", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName VECTOR = new ElementName("vector", "vector", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARTICLE = new ElementName("article", "article", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName ANIMATE = new ElementName("animate", "animate", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCSECH = new ElementName("arcsech", "arcsech", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCCSCH = new ElementName("arccsch", "arccsch", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCTANH = new ElementName("arctanh", "arctanh", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCSINH = new ElementName("arcsinh", "arcsinh", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCCOSH = new ElementName("arccosh", "arccosh", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCCOTH = new ElementName("arccoth", "arccoth", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ACRONYM = new ElementName("acronym", "acronym", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ADDRESS = new ElementName("address", "address", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName BGSOUND = new ElementName("bgsound", "bgsound", TreeBuilder.AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR, true, false, false);
+    public static final ElementName COMMAND = new ElementName("command", "command", TreeBuilder.COMMAND_OR_EVENT_SOURCE, true, false, false);
+    public static final ElementName COMPOSE = new ElementName("compose", "compose", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CEILING = new ElementName("ceiling", "ceiling", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CSYMBOL = new ElementName("csymbol", "csymbol", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CAPTION = new ElementName("caption", "caption", TreeBuilder.CAPTION, false, true, false);
+    public static final ElementName DISCARD = new ElementName("discard", "discard", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DECLARE = new ElementName("declare", "declare", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DETAILS = new ElementName("details", "details", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName ELLIPSE = new ElementName("ellipse", "ellipse", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEFUNCA = new ElementName("fefunca", "feFuncA", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEFUNCB = new ElementName("fefuncb", "feFuncB", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEBLEND = new ElementName("feblend", "feBlend", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEFLOOD = new ElementName("feflood", "feFlood", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEIMAGE = new ElementName("feimage", "feImage", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEMERGE = new ElementName("femerge", "feMerge", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEFUNCG = new ElementName("fefuncg", "feFuncG", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEFUNCR = new ElementName("fefuncr", "feFuncR", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName HANDLER = new ElementName("handler", "handler", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName INVERSE = new ElementName("inverse", "inverse", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName IMPLIES = new ElementName("implies", "implies", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ISINDEX = new ElementName("isindex", "isindex", TreeBuilder.ISINDEX, true, false, false);
+    public static final ElementName LOGBASE = new ElementName("logbase", "logbase", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LISTING = new ElementName("listing", "listing", TreeBuilder.PRE_OR_LISTING, true, false, false);
+    public static final ElementName MFENCED = new ElementName("mfenced", "mfenced", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MPADDED = new ElementName("mpadded", "mpadded", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MARQUEE = new ElementName("marquee", "marquee", TreeBuilder.MARQUEE_OR_APPLET, false, true, false);
+    public static final ElementName MACTION = new ElementName("maction", "maction", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MSUBSUP = new ElementName("msubsup", "msubsup", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NOEMBED = new ElementName("noembed", "noembed", TreeBuilder.NOEMBED, true, false, false);
+    public static final ElementName POLYGON = new ElementName("polygon", "polygon", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PATTERN = new ElementName("pattern", "pattern", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PRODUCT = new ElementName("product", "product", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SETDIFF = new ElementName("setdiff", "setdiff", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SECTION = new ElementName("section", "section", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName TENDSTO = new ElementName("tendsto", "tendsto", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName UPLIMIT = new ElementName("uplimit", "uplimit", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ALTGLYPH = new ElementName("altglyph", "altGlyph", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName BASEFONT = new ElementName("basefont", "basefont", TreeBuilder.AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR, true, false, false);
+    public static final ElementName CLIPPATH = new ElementName("clippath", "clipPath", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CODOMAIN = new ElementName("codomain", "codomain", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName COLGROUP = new ElementName("colgroup", "colgroup", TreeBuilder.COLGROUP, true, false, false);
+    public static final ElementName DATAGRID = new ElementName("datagrid", "datagrid", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName EMPTYSET = new ElementName("emptyset", "emptyset", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FACTOROF = new ElementName("factorof", "factorof", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FIELDSET = new ElementName("fieldset", "fieldset", TreeBuilder.FIELDSET, true, false, false);
+    public static final ElementName FRAMESET = new ElementName("frameset", "frameset", TreeBuilder.FRAMESET, true, false, false);
+    public static final ElementName FEOFFSET = new ElementName("feoffset", "feOffset", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName GLYPHREF = new ElementName("glyphref", "glyphRef", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName INTERVAL = new ElementName("interval", "interval", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName INTEGERS = new ElementName("integers", "integers", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName INFINITY = new ElementName("infinity", "infinity", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LISTENER = new ElementName("listener", "listener", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LOWLIMIT = new ElementName("lowlimit", "lowlimit", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName METADATA = new ElementName("metadata", "metadata", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MENCLOSE = new ElementName("menclose", "menclose", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MPHANTOM = new ElementName("mphantom", "mphantom", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NOFRAMES = new ElementName("noframes", "noframes", TreeBuilder.NOFRAMES, true, false, false);
+    public static final ElementName NOSCRIPT = new ElementName("noscript", "noscript", TreeBuilder.NOSCRIPT, true, false, false);
+    public static final ElementName OPTGROUP = new ElementName("optgroup", "optgroup", TreeBuilder.OPTGROUP, true, false, false);
+    public static final ElementName POLYLINE = new ElementName("polyline", "polyline", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PREFETCH = new ElementName("prefetch", "prefetch", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PROGRESS = new ElementName("progress", "progress", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PRSUBSET = new ElementName("prsubset", "prsubset", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName QUOTIENT = new ElementName("quotient", "quotient", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SELECTOR = new ElementName("selector", "selector", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TEXTAREA = new ElementName("textarea", "textarea", TreeBuilder.TEXTAREA, true, false, false);
+    public static final ElementName TEXTPATH = new ElementName("textpath", "textPath", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName VARIANCE = new ElementName("variance", "variance", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ANIMATION = new ElementName("animation", "animation", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CONJUGATE = new ElementName("conjugate", "conjugate", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CONDITION = new ElementName("condition", "condition", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName COMPLEXES = new ElementName("complexes", "complexes", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FONT_FACE = new ElementName("font-face", "font-face", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FACTORIAL = new ElementName("factorial", "factorial", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName INTERSECT = new ElementName("intersect", "intersect", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName IMAGINARY = new ElementName("imaginary", "imaginary", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LAPLACIAN = new ElementName("laplacian", "laplacian", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MATRIXROW = new ElementName("matrixrow", "matrixrow", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NOTSUBSET = new ElementName("notsubset", "notsubset", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName OTHERWISE = new ElementName("otherwise", "otherwise", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PIECEWISE = new ElementName("piecewise", "piecewise", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PLAINTEXT = new ElementName("plaintext", "plaintext", TreeBuilder.PLAINTEXT, true, false, false);
+    public static final ElementName RATIONALS = new ElementName("rationals", "rationals", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SEMANTICS = new ElementName("semantics", "semantics", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TRANSPOSE = new ElementName("transpose", "transpose", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ANNOTATION = new ElementName("annotation", "annotation", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName BLOCKQUOTE = new ElementName("blockquote", "blockquote", TreeBuilder.DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU, true, false, false);
+    public static final ElementName DIVERGENCE = new ElementName("divergence", "divergence", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName EULERGAMMA = new ElementName("eulergamma", "eulergamma", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName EQUIVALENT = new ElementName("equivalent", "equivalent", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName IMAGINARYI = new ElementName("imaginaryi", "imaginaryi", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MALIGNMARK = new ElementName("malignmark", "malignmark", TreeBuilder.MGLYPH_OR_MALIGNMARK, false, false, false);
+    public static final ElementName MUNDEROVER = new ElementName("munderover", "munderover", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MLABELEDTR = new ElementName("mlabeledtr", "mlabeledtr", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NOTANUMBER = new ElementName("notanumber", "notanumber", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SOLIDCOLOR = new ElementName("solidcolor", "solidcolor", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ALTGLYPHDEF = new ElementName("altglyphdef", "altGlyphDef", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DETERMINANT = new ElementName("determinant", "determinant", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName EVENTSOURCE = new ElementName("eventsource", "eventsource", TreeBuilder.COMMAND_OR_EVENT_SOURCE, true, false, false);
+    public static final ElementName FEMERGENODE = new ElementName("femergenode", "feMergeNode", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FECOMPOSITE = new ElementName("fecomposite", "feComposite", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FESPOTLIGHT = new ElementName("fespotlight", "feSpotLight", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MALIGNGROUP = new ElementName("maligngroup", "maligngroup", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MPRESCRIPTS = new ElementName("mprescripts", "mprescripts", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MOMENTABOUT = new ElementName("momentabout", "momentabout", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NOTPRSUBSET = new ElementName("notprsubset", "notprsubset", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PARTIALDIFF = new ElementName("partialdiff", "partialdiff", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ALTGLYPHITEM = new ElementName("altglyphitem", "altGlyphItem", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ANIMATECOLOR = new ElementName("animatecolor", "animateColor", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DATATEMPLATE = new ElementName("datatemplate", "datatemplate", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName EXPONENTIALE = new ElementName("exponentiale", "exponentiale", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FETURBULENCE = new ElementName("feturbulence", "feTurbulence", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEPOINTLIGHT = new ElementName("fepointlight", "fePointLight", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEMORPHOLOGY = new ElementName("femorphology", "feMorphology", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName OUTERPRODUCT = new ElementName("outerproduct", "outerproduct", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ANIMATEMOTION = new ElementName("animatemotion", "animateMotion", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName COLOR_PROFILE = new ElementName("color-profile", "color-profile", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FONT_FACE_SRC = new ElementName("font-face-src", "font-face-src", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FONT_FACE_URI = new ElementName("font-face-uri", "font-face-uri", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FOREIGNOBJECT = new ElementName("foreignobject", "foreignObject", TreeBuilder.FOREIGNOBJECT_OR_DESC, false, false, false);
+    public static final ElementName FECOLORMATRIX = new ElementName("fecolormatrix", "feColorMatrix", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MISSING_GLYPH = new ElementName("missing-glyph", "missing-glyph", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MMULTISCRIPTS = new ElementName("mmultiscripts", "mmultiscripts", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SCALARPRODUCT = new ElementName("scalarproduct", "scalarproduct", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName VECTORPRODUCT = new ElementName("vectorproduct", "vectorproduct", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ANNOTATION_XML = new ElementName("annotation-xml", "annotation-xml", TreeBuilder.ANNOTATION_XML, false, false, false);
+    public static final ElementName DEFINITION_SRC = new ElementName("definition-src", "definition-src", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FONT_FACE_NAME = new ElementName("font-face-name", "font-face-name", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEGAUSSIANBLUR = new ElementName("fegaussianblur", "feGaussianBlur", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEDISTANTLIGHT = new ElementName("fedistantlight", "feDistantLight", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LINEARGRADIENT = new ElementName("lineargradient", "linearGradient", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NATURALNUMBERS = new ElementName("naturalnumbers", "naturalnumbers", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName RADIALGRADIENT = new ElementName("radialgradient", "radialGradient", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ANIMATETRANSFORM = new ElementName("animatetransform", "animateTransform", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CARTESIANPRODUCT = new ElementName("cartesianproduct", "cartesianproduct", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FONT_FACE_FORMAT = new ElementName("font-face-format", "font-face-format", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FECONVOLVEMATRIX = new ElementName("feconvolvematrix", "feConvolveMatrix", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEDIFFUSELIGHTING = new ElementName("fediffuselighting", "feDiffuseLighting", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEDISPLACEMENTMAP = new ElementName("fedisplacementmap", "feDisplacementMap", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FESPECULARLIGHTING = new ElementName("fespecularlighting", "feSpecularLighting", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DOMAINOFAPPLICATION = new ElementName("domainofapplication", "domainofapplication", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FECOMPONENTTRANSFER = new ElementName("fecomponenttransfer", "feComponentTransfer", TreeBuilder.OTHER, false, false, false);
+    private final static @NoLength ElementName[] ELEMENT_NAMES = {
+    A,
+    B,
+    G,
+    I,
+    P,
+    Q,
+    S,
+    U,
+    BR,
+    CI,
+    CN,
+    DD,
+    DL,
+    DT,
+    EM,
+    EQ,
+    FN,
+    H1,
+    H2,
+    H3,
+    H4,
+    H5,
+    H6,
+    GT,
+    HR,
+    IN,
+    LI,
+    LN,
+    LT,
+    MI,
+    MN,
+    MO,
+    MS,
+    OL,
+    OR,
+    PI,
+    RP,
+    RT,
+    TD,
+    TH,
+    TR,
+    TT,
+    UL,
+    AND,
+    ARG,
+    ABS,
+    BIG,
+    BDO,
+    CSC,
+    COL,
+    COS,
+    COT,
+    DEL,
+    DFN,
+    DIR,
+    DIV,
+    EXP,
+    GCD,
+    GEQ,
+    IMG,
+    INS,
+    INT,
+    KBD,
+    LOG,
+    LCM,
+    LEQ,
+    MTD,
+    MIN,
+    MAP,
+    MTR,
+    MAX,
+    NEQ,
+    NOT,
+    NAV,
+    PRE,
+    REM,
+    SUB,
+    SEC,
+    SVG,
+    SUM,
+    SIN,
+    SEP,
+    SUP,
+    SET,
+    TAN,
+    USE,
+    VAR,
+    WBR,
+    XMP,
+    XOR,
+    AREA,
+    ABBR,
+    BASE,
+    BVAR,
+    BODY,
+    CARD,
+    CODE,
+    CITE,
+    CSCH,
+    COSH,
+    COTH,
+    CURL,
+    DESC,
+    DIFF,
+    DEFS,
+    FORM,
+    FONT,
+    GRAD,
+    HEAD,
+    HTML,
+    LINE,
+    LINK,
+    LIST,
+    META,
+    MSUB,
+    MODE,
+    MATH,
+    MARK,
+    MASK,
+    MEAN,
+    MSUP,
+    MENU,
+    MROW,
+    NONE,
+    NOBR,
+    NEST,
+    PATH,
+    PLUS,
+    RULE,
+    REAL,
+    RELN,
+    RECT,
+    ROOT,
+    RUBY,
+    SECH,
+    SINH,
+    SPAN,
+    SAMP,
+    STOP,
+    SDEV,
+    TIME,
+    TRUE,
+    TREF,
+    TANH,
+    TEXT,
+    VIEW,
+    ASIDE,
+    AUDIO,
+    APPLY,
+    EMBED,
+    FRAME,
+    FALSE,
+    FLOOR,
+    GLYPH,
+    HKERN,
+    IMAGE,
+    IDENT,
+    INPUT,
+    LABEL,
+    LIMIT,
+    MFRAC,
+    MPATH,
+    METER,
+    MOVER,
+    MINUS,
+    MROOT,
+    MSQRT,
+    MTEXT,
+    NOTIN,
+    PIECE,
+    PARAM,
+    POWER,
+    REALS,
+    STYLE,
+    SMALL,
+    THEAD,
+    TABLE,
+    TITLE,
+    TSPAN,
+    TIMES,
+    TFOOT,
+    TBODY,
+    UNION,
+    VKERN,
+    VIDEO,
+    ARCSEC,
+    ARCCSC,
+    ARCTAN,
+    ARCSIN,
+    ARCCOS,
+    APPLET,
+    ARCCOT,
+    APPROX,
+    BUTTON,
+    CIRCLE,
+    CENTER,
+    CURSOR,
+    CANVAS,
+    DIVIDE,
+    DEGREE,
+    DIALOG,
+    DOMAIN,
+    EXISTS,
+    FETILE,
+    FIGURE,
+    FORALL,
+    FILTER,
+    FOOTER,
+    HEADER,
+    IFRAME,
+    KEYGEN,
+    LAMBDA,
+    LEGEND,
+    MSPACE,
+    MTABLE,
+    MSTYLE,
+    MGLYPH,
+    MEDIAN,
+    MUNDER,
+    MARKER,
+    MERROR,
+    MOMENT,
+    MATRIX,
+    OPTION,
+    OBJECT,
+    OUTPUT,
+    PRIMES,
+    SOURCE,
+    STRIKE,
+    STRONG,
+    SWITCH,
+    SYMBOL,
+    SPACER,
+    SELECT,
+    SUBSET,
+    SCRIPT,
+    TBREAK,
+    VECTOR,
+    ARTICLE,
+    ANIMATE,
+    ARCSECH,
+    ARCCSCH,
+    ARCTANH,
+    ARCSINH,
+    ARCCOSH,
+    ARCCOTH,
+    ACRONYM,
+    ADDRESS,
+    BGSOUND,
+    COMMAND,
+    COMPOSE,
+    CEILING,
+    CSYMBOL,
+    CAPTION,
+    DISCARD,
+    DECLARE,
+    DETAILS,
+    ELLIPSE,
+    FEFUNCA,
+    FEFUNCB,
+    FEBLEND,
+    FEFLOOD,
+    FEIMAGE,
+    FEMERGE,
+    FEFUNCG,
+    FEFUNCR,
+    HANDLER,
+    INVERSE,
+    IMPLIES,
+    ISINDEX,
+    LOGBASE,
+    LISTING,
+    MFENCED,
+    MPADDED,
+    MARQUEE,
+    MACTION,
+    MSUBSUP,
+    NOEMBED,
+    POLYGON,
+    PATTERN,
+    PRODUCT,
+    SETDIFF,
+    SECTION,
+    TENDSTO,
+    UPLIMIT,
+    ALTGLYPH,
+    BASEFONT,
+    CLIPPATH,
+    CODOMAIN,
+    COLGROUP,
+    DATAGRID,
+    EMPTYSET,
+    FACTOROF,
+    FIELDSET,
+    FRAMESET,
+    FEOFFSET,
+    GLYPHREF,
+    INTERVAL,
+    INTEGERS,
+    INFINITY,
+    LISTENER,
+    LOWLIMIT,
+    METADATA,
+    MENCLOSE,
+    MPHANTOM,
+    NOFRAMES,
+    NOSCRIPT,
+    OPTGROUP,
+    POLYLINE,
+    PREFETCH,
+    PROGRESS,
+    PRSUBSET,
+    QUOTIENT,
+    SELECTOR,
+    TEXTAREA,
+    TEXTPATH,
+    VARIANCE,
+    ANIMATION,
+    CONJUGATE,
+    CONDITION,
+    COMPLEXES,
+    FONT_FACE,
+    FACTORIAL,
+    INTERSECT,
+    IMAGINARY,
+    LAPLACIAN,
+    MATRIXROW,
+    NOTSUBSET,
+    OTHERWISE,
+    PIECEWISE,
+    PLAINTEXT,
+    RATIONALS,
+    SEMANTICS,
+    TRANSPOSE,
+    ANNOTATION,
+    BLOCKQUOTE,
+    DIVERGENCE,
+    EULERGAMMA,
+    EQUIVALENT,
+    IMAGINARYI,
+    MALIGNMARK,
+    MUNDEROVER,
+    MLABELEDTR,
+    NOTANUMBER,
+    SOLIDCOLOR,
+    ALTGLYPHDEF,
+    DETERMINANT,
+    EVENTSOURCE,
+    FEMERGENODE,
+    FECOMPOSITE,
+    FESPOTLIGHT,
+    MALIGNGROUP,
+    MPRESCRIPTS,
+    MOMENTABOUT,
+    NOTPRSUBSET,
+    PARTIALDIFF,
+    ALTGLYPHITEM,
+    ANIMATECOLOR,
+    DATATEMPLATE,
+    EXPONENTIALE,
+    FETURBULENCE,
+    FEPOINTLIGHT,
+    FEMORPHOLOGY,
+    OUTERPRODUCT,
+    ANIMATEMOTION,
+    COLOR_PROFILE,
+    FONT_FACE_SRC,
+    FONT_FACE_URI,
+    FOREIGNOBJECT,
+    FECOLORMATRIX,
+    MISSING_GLYPH,
+    MMULTISCRIPTS,
+    SCALARPRODUCT,
+    VECTORPRODUCT,
+    ANNOTATION_XML,
+    DEFINITION_SRC,
+    FONT_FACE_NAME,
+    FEGAUSSIANBLUR,
+    FEDISTANTLIGHT,
+    LINEARGRADIENT,
+    NATURALNUMBERS,
+    RADIALGRADIENT,
+    ANIMATETRANSFORM,
+    CARTESIANPRODUCT,
+    FONT_FACE_FORMAT,
+    FECONVOLVEMATRIX,
+    FEDIFFUSELIGHTING,
+    FEDISPLACEMENTMAP,
+    FESPECULARLIGHTING,
+    DOMAINOFAPPLICATION,
+    FECOMPONENTTRANSFER,
+    };
+    private final static int[] ELEMENT_HASHES = {
+    1057,
+    1090,
+    1255,
+    1321,
+    1552,
+    1585,
+    1651,
+    1717,
+    68162,
+    68899,
+    69059,
+    69764,
+    70020,
+    70276,
+    71077,
+    71205,
+    72134,
+    72232,
+    72264,
+    72296,
+    72328,
+    72360,
+    72392,
+    73351,
+    74312,
+    75209,
+    78124,
+    78284,
+    78476,
+    79149,
+    79309,
+    79341,
+    79469,
+    81295,
+    81487,
+    82224,
+    84498,
+    84626,
+    86164,
+    86292,
+    86612,
+    86676,
+    87445,
+    3183041,
+    3186241,
+    3198017,
+    3218722,
+    3226754,
+    3247715,
+    3256803,
+    3263971,
+    3264995,
+    3289252,
+    3291332,
+    3295524,
+    3299620,
+    3326725,
+    3379303,
+    3392679,
+    3448233,
+    3460553,
+    3461577,
+    3510347,
+    3546604,
+    3552364,
+    3556524,
+    3576461,
+    3586349,
+    3588141,
+    3590797,
+    3596333,
+    3622062,
+    3625454,
+    3627054,
+    3675728,
+    3749042,
+    3771059,
+    3771571,
+    3776211,
+    3782323,
+    3782963,
+    3784883,
+    3785395,
+    3788979,
+    3815476,
+    3839605,
+    3885110,
+    3917911,
+    3948984,
+    3951096,
+    135304769,
+    135858241,
+    136498210,
+    136906434,
+    137138658,
+    137512995,
+    137531875,
+    137548067,
+    137629283,
+    137645539,
+    137646563,
+    137775779,
+    138529956,
+    138615076,
+    139040932,
+    140954086,
+    141179366,
+    141690439,
+    142738600,
+    143013512,
+    146979116,
+    147175724,
+    147475756,
+    147902637,
+    147936877,
+    148017645,
+    148131885,
+    148228141,
+    148229165,
+    148309165,
+    148395629,
+    148551853,
+    148618829,
+    149076462,
+    149490158,
+    149572782,
+    151277616,
+    151639440,
+    153268914,
+    153486514,
+    153563314,
+    153750706,
+    153763314,
+    153914034,
+    154406067,
+    154417459,
+    154600979,
+    154678323,
+    154680979,
+    154866835,
+    155366708,
+    155375188,
+    155391572,
+    155465780,
+    155869364,
+    158045494,
+    168988979,
+    169321621,
+    169652752,
+    173151309,
+    174240818,
+    174247297,
+    174669292,
+    175391532,
+    176638123,
+    177380397,
+    177879204,
+    177886734,
+    180753473,
+    181020073,
+    181503558,
+    181686320,
+    181999237,
+    181999311,
+    182048201,
+    182074866,
+    182078003,
+    182083764,
+    182920847,
+    184716457,
+    184976961,
+    185145071,
+    187281445,
+    187872052,
+    188100653,
+    188875944,
+    188919873,
+    188920457,
+    189203987,
+    189371817,
+    189414886,
+    189567458,
+    190266670,
+    191318187,
+    191337609,
+    202479203,
+    202493027,
+    202835587,
+    202843747,
+    203013219,
+    203036048,
+    203045987,
+    203177552,
+    203898516,
+    204648562,
+    205067918,
+    205078130,
+    205096654,
+    205689142,
+    205690439,
+    205766017,
+    205988909,
+    207213161,
+    207794484,
+    207800999,
+    208023602,
+    208213644,
+    208213647,
+    210310273,
+    210940978,
+    213325049,
+    213946445,
+    214055079,
+    215125040,
+    215134273,
+    215135028,
+    215237420,
+    215418148,
+    215553166,
+    215553394,
+    215563858,
+    215627949,
+    215754324,
+    217529652,
+    217713834,
+    217732628,
+    218731945,
+    221417045,
+    221424946,
+    221493746,
+    221515401,
+    221658189,
+    221844577,
+    221908140,
+    221910626,
+    221921586,
+    222659762,
+    225001091,
+    236105833,
+    236113965,
+    236194995,
+    236195427,
+    236206132,
+    236206387,
+    236211683,
+    236212707,
+    236381647,
+    236571826,
+    237124271,
+    238172205,
+    238210544,
+    238270764,
+    238435405,
+    238501172,
+    239224867,
+    239257644,
+    239710497,
+    240307721,
+    241208789,
+    241241557,
+    241318060,
+    241319404,
+    241343533,
+    241344069,
+    241405397,
+    241765845,
+    243864964,
+    244502085,
+    244946220,
+    245109902,
+    247647266,
+    247707956,
+    248648814,
+    248648836,
+    248682161,
+    248986932,
+    249058914,
+    249697357,
+    252132601,
+    252135604,
+    252317348,
+    255007012,
+    255278388,
+    256365156,
+    257566121,
+    269763372,
+    271202790,
+    271863856,
+    272049197,
+    272127474,
+    272770631,
+    274339449,
+    274939471,
+    275388004,
+    275388005,
+    275388006,
+    275977800,
+    278267602,
+    278513831,
+    278712622,
+    281613765,
+    281683369,
+    282120228,
+    282250732,
+    282508942,
+    283743649,
+    283787570,
+    284710386,
+    285391148,
+    285478533,
+    285854898,
+    285873762,
+    286931113,
+    288964227,
+    289445441,
+    289689648,
+    291671489,
+    303512884,
+    305319975,
+    305610036,
+    305764101,
+    308448294,
+    308675890,
+    312085683,
+    312264750,
+    315032867,
+    316391000,
+    317331042,
+    317902135,
+    318950711,
+    319447220,
+    321499182,
+    322538804,
+    323145200,
+    337067316,
+    337826293,
+    339905989,
+    340833697,
+    341457068,
+    345302593,
+    349554733,
+    349771471,
+    349786245,
+    350819405,
+    356072847,
+    370349192,
+    373962798,
+    374509141,
+    375558638,
+    375574835,
+    376053993,
+    383276530,
+    383373833,
+    383407586,
+    384439906,
+    386079012,
+    404133513,
+    404307343,
+    407031852,
+    408072233,
+    409112005,
+    409608425,
+    409771500,
+    419040932,
+    437730612,
+    439529766,
+    442616365,
+    442813037,
+    443157674,
+    443295316,
+    450118444,
+    450482697,
+    456789668,
+    459935396,
+    471217869,
+    474073645,
+    476230702,
+    476665218,
+    476717289,
+    483014825,
+    485083298,
+    489306281,
+    538364390,
+    540675748,
+    543819186,
+    543958612,
+    576960820,
+    577242548,
+    610515252,
+    642202932,
+    644420819,
+    };
+
+
+}
diff --git a/parser/html/java/htmlparser/src/ErrorReportingTokenizer.java b/parser/html/java/htmlparser/src/ErrorReportingTokenizer.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/ErrorReportingTokenizer.java
@@ -0,0 +1,655 @@
+/*
+ * Copyright (c) 2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.Inline;
+import nu.validator.htmlparser.annotation.NoLength;
+import nu.validator.htmlparser.common.TokenHandler;
+import nu.validator.htmlparser.common.XmlViolationPolicy;
+
+import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
+
+public class ErrorReportingTokenizer extends Tokenizer {
+
+    /**
+     * Magic value for UTF-16 operations.
+     */
+    private static final int SURROGATE_OFFSET = (0x10000 - (0xD800 << 10) - 0xDC00);
+
+    /**
+     * The policy for non-space non-XML characters.
+     */
+    private XmlViolationPolicy contentNonXmlCharPolicy = XmlViolationPolicy.ALTER_INFOSET;
+    
+    /**
+     * Used together with <code>nonAsciiProhibited</code>.
+     */
+    private boolean alreadyComplainedAboutNonAscii;
+
+    /**
+     * Keeps track of PUA warnings.
+     */
+    private boolean alreadyWarnedAboutPrivateUseCharacters;
+    
+    /**
+     * The current line number in the current resource being parsed. (First line
+     * is 1.) Passed on as locator data.
+     */
+    private int line;
+
+    private int linePrev;
+
+    /**
+     * The current column number in the current resource being tokenized. (First
+     * column is 1, counted by UTF-16 code units.) Passed on as locator data.
+     */
+    private int col;
+
+    private int colPrev;
+
+    private boolean nextCharOnNewLine;
+
+    private char prev;
+    
+    /**
+     * @param tokenHandler
+     * @param newAttributesEachTime
+     */
+    public ErrorReportingTokenizer(TokenHandler tokenHandler,
+            boolean newAttributesEachTime) {
+        super(tokenHandler, newAttributesEachTime);
+    }
+
+    /**
+     * @param tokenHandler
+     */
+    public ErrorReportingTokenizer(TokenHandler tokenHandler) {
+        super(tokenHandler);
+    }
+
+    /**
+     * @see org.xml.sax.Locator#getLineNumber()
+     */
+    public int getLineNumber() {
+        if (line > 0) {
+            return line;
+        } else {
+            return -1;
+        }
+    }
+
+    /**
+     * @see org.xml.sax.Locator#getColumnNumber()
+     */
+    public int getColumnNumber() {
+        if (col > 0) {
+            return col;
+        } else {
+            return -1;
+        }
+    }
+    
+    /**
+     * Sets the contentNonXmlCharPolicy.
+     * 
+     * @param contentNonXmlCharPolicy
+     *            the contentNonXmlCharPolicy to set
+     */
+    public void setContentNonXmlCharPolicy(
+            XmlViolationPolicy contentNonXmlCharPolicy) {
+        this.contentNonXmlCharPolicy = contentNonXmlCharPolicy;
+    }
+    
+    protected void startErrorReporting() throws SAXException {
+        alreadyComplainedAboutNonAscii = false;   
+        line = linePrev = 0;
+        col = colPrev = 1;
+        nextCharOnNewLine = true;
+        prev = '\u0000';
+        alreadyWarnedAboutPrivateUseCharacters = false;
+    }
+    
+    @Inline protected void silentCarriageReturn() {
+        nextCharOnNewLine = true;
+        lastCR = true;
+    }
+
+    @Inline protected void silentLineFeed() {
+        nextCharOnNewLine = true;
+    }
+    
+    /**
+     * Returns the line.
+     * 
+     * @return the line
+     */
+    public int getLine() {
+        return line;
+    }
+
+    /**
+     * Returns the col.
+     * 
+     * @return the col
+     */
+    public int getCol() {
+        return col;
+    }
+    
+    /**
+     * Returns the nextCharOnNewLine.
+     * 
+     * @return the nextCharOnNewLine
+     */
+    public boolean isNextCharOnNewLine() {
+        return nextCharOnNewLine;
+    }
+    
+    private void complainAboutNonAscii() throws SAXException {
+        String encoding = null;
+        if (encodingDeclarationHandler != null) {
+            encoding = encodingDeclarationHandler.getCharacterEncoding();
+        }
+        if (encoding == null) {
+            err("The character encoding of the document was not explicit but the document contains non-ASCII.");
+        } else {
+            err("No explicit character encoding declaration has been seen yet (assumed \u201C"
+                    + encoding + "\u201D) but the document contains non-ASCII.");
+        }
+    }
+
+    /**
+     * Returns the alreadyComplainedAboutNonAscii.
+     * 
+     * @return the alreadyComplainedAboutNonAscii
+     */
+    public boolean isAlreadyComplainedAboutNonAscii() {
+        return alreadyComplainedAboutNonAscii;
+    }
+    
+    /**
+     * Flushes coalesced character tokens.
+     * @param buf TODO
+     * @param pos TODO
+     * 
+     * @throws SAXException
+     */
+    @Override protected void flushChars(char[] buf, int pos) throws SAXException {
+        if (pos > cstart) {
+            int currLine = line;
+            int currCol = col;
+            line = linePrev;
+            col = colPrev;
+            tokenHandler.characters(buf, cstart, pos - cstart);
+            line = currLine;
+            col = currCol;
+        }
+        cstart = 0x7fffffff;
+    }
+    
+    @Override protected char checkChar(@NoLength char[] buf, int pos) throws SAXException {
+        linePrev = line;
+        colPrev = col;
+        if (nextCharOnNewLine) {
+            line++;
+            col = 1;
+            nextCharOnNewLine = false;
+        } else {
+            col++;
+        }
+
+        char c = buf[pos];
+        if (!confident && !alreadyComplainedAboutNonAscii && c > '\u007F') {
+            complainAboutNonAscii();
+            alreadyComplainedAboutNonAscii = true;
+        }
+        switch (c) {
+            case '\u0000':
+                err("Saw U+0000 in stream.");
+            case '\t':
+            case '\r':
+            case '\n':
+                break;
+            case '\u000C':
+                if (contentNonXmlCharPolicy == XmlViolationPolicy.FATAL) {
+                    fatal("This document is not mappable to XML 1.0 without data loss due to "
+                            + toUPlusString(c)
+                            + " which is not a legal XML 1.0 character.");
+                } else {
+                    if (contentNonXmlCharPolicy == XmlViolationPolicy.ALTER_INFOSET) {
+                        c = buf[pos] = ' ';
+                    }
+                    warn("This document is not mappable to XML 1.0 without data loss due to "
+                            + toUPlusString(c)
+                            + " which is not a legal XML 1.0 character.");
+                }
+                break;
+            default:
+                if ((c & 0xFC00) == 0xDC00) {
+                    // Got a low surrogate. See if prev was high
+                    // surrogate
+                    if ((prev & 0xFC00) == 0xD800) {
+                        int intVal = (prev << 10) + c
+                                + SURROGATE_OFFSET;
+                        if ((intVal & 0xFFFE) == 0xFFFE) {
+                            err("Astral non-character.");
+                        }
+                        if (isAstralPrivateUse(intVal)) {
+                            warnAboutPrivateUseChar();
+                        }
+                    }
+                } else if ((c < ' ' || ((c & 0xFFFE) == 0xFFFE))) {
+                    switch (contentNonXmlCharPolicy) {
+                        case FATAL:
+                            fatal("Forbidden code point " + toUPlusString(c)
+                                    + ".");
+                            break;
+                        case ALTER_INFOSET:
+                            c = buf[pos] = '\uFFFD';
+                            // fall through
+                        case ALLOW:
+                            err("Forbidden code point " + toUPlusString(c)
+                                    + ".");
+                    }
+                } else if ((c >= '\u007F') && (c <= '\u009F')
+                        || (c >= '\uFDD0') && (c <= '\uFDDF')) {
+                    err("Forbidden code point " + toUPlusString(c) + ".");
+                } else if (isPrivateUse(c)) {
+                    warnAboutPrivateUseChar();
+                }
+        }
+        prev = c;
+        return c;
+    }
+
+    private String toUPlusString(char c) {
+        String hexString = Integer.toHexString(c);
+        switch (hexString.length()) {
+            case 1:
+                return "U+000" + hexString;
+            case 2:
+                return "U+00" + hexString;
+            case 3:
+                return "U+0" + hexString;
+            case 4:
+                return "U+" + hexString;
+            default:
+                throw new RuntimeException("Unreachable.");
+        }
+    }
+
+    /**
+     * Emits a warning about private use characters if the warning has not been
+     * emitted yet.
+     * 
+     * @throws SAXException
+     */
+    private void warnAboutPrivateUseChar() throws SAXException {
+        if (!alreadyWarnedAboutPrivateUseCharacters) {
+            warn("Document uses the Unicode Private Use Area(s), which should not be used in publicly exchanged documents. (Charmod C073)");
+            alreadyWarnedAboutPrivateUseCharacters = true;
+        }
+    }
+    
+    /**
+     * Tells if the argument is a BMP PUA character.
+     * 
+     * @param c
+     *            the UTF-16 code unit to check
+     * @return <code>true</code> if PUA character
+     */
+    private boolean isPrivateUse(char c) {
+        return c >= '\uE000' && c <= '\uF8FF';
+    }
+
+    /**
+     * Tells if the argument is an astral PUA character.
+     * 
+     * @param c
+     *            the code point to check
+     * @return <code>true</code> if astral private use
+     */
+    private boolean isAstralPrivateUse(int c) {
+        return (c >= 0xF0000 && c <= 0xFFFFD)
+                || (c >= 0x100000 && c <= 0x10FFFD);
+    }
+
+    
+    @Override protected void errGarbageAfterLtSlash() throws SAXException {
+        err("Garbage after \u201C</\u201D.");
+    }
+
+    @Override protected void errLtSlashGt() throws SAXException {
+        err("Saw \u201C</>\u201D. Probable causes: Unescaped \u201C<\u201D (escape as \u201C&lt;\u201D) or mistyped end tag.");
+    }
+
+    @Override protected void errWarnLtSlashInRcdata() throws SAXException {
+        if (html4) {
+            err((stateSave == Tokenizer.DATA ? "CDATA" : "RCDATA")
+                    + " element \u201C"
+                    + contentModelElement
+                    + "\u201D contained the string \u201C</\u201D, but it was not the start of the end tag. (HTML4-only error)");
+        } else {
+            warn((stateSave == Tokenizer.DATA ? "CDATA" : "RCDATA")
+                    + " element \u201C"
+                    + contentModelElement
+                    + "\u201D contained the string \u201C</\u201D, but this did not close the element.");
+        }
+    }
+
+    @Override protected void errHtml4LtSlashInRcdata(char folded)
+            throws SAXException {
+                if (html4 && (index > 0 || (folded >= 'a' && folded <= 'z'))
+                        && ElementName.IFRAME != contentModelElement) {
+                    err((stateSave == Tokenizer.DATA ? "CDATA" : "RCDATA")
+                            + " element \u201C"
+                            + contentModelElement.name
+                            + "\u201D contained the string \u201C</\u201D, but it was not the start of the end tag. (HTML4-only error)");
+                }
+            }
+
+    @Override protected void errCharRefLacksSemicolon() throws SAXException {
+        err("Character reference was not terminated by a semicolon.");
+    }
+
+    @Override protected void errNoDigitsInNCR() throws SAXException {
+        err("No digits after \u201C" + strBufToString() + "\u201D.");
+    }
+
+    @Override protected void errGtInSystemId() throws SAXException {
+        err("\u201C>\u201D in system identifier.");
+    }
+
+    @Override protected void errGtInPublicId() throws SAXException {
+        err("\u201C>\u201D in public identifier.");
+    }
+
+    @Override protected void errNamelessDoctype() throws SAXException {
+        err("Nameless doctype.");
+    }
+
+    @Override protected void errConsecutiveHyphens() throws SAXException {
+        err("Consecutive hyphens did not terminate a comment. \u201C--\u201D is not permitted inside a comment, but e.g. \u201C- -\u201D is.");
+    }
+
+    @Override protected void errPrematureEndOfComment() throws SAXException {
+        err("Premature end of comment. Use \u201C-->\u201D to end a comment properly.");
+    }
+
+    @Override protected void errBogusComment() throws SAXException {
+        err("Bogus comment.");
+    }
+
+    @Override protected void errUnquotedAttributeValOrNull(char c)
+            throws SAXException {
+                if (c == '<') {
+                    err("\u201C<\u201D in an unquoted attribute value. Probable cause: Missing \u201C>\u201D immediately before.");
+                } else if (c != '\uFFFD') {
+                    err("\u201C"
+                            + c
+                            + "\u201D in an unquoted attribute value. Probable causes: Attributes running together or a URL query string in an unquoted attribute value.");
+                }
+            }
+
+    @Override protected void errSlashNotFollowedByGt() throws SAXException {
+        err("A slash was not immediate followed by \u201C>\u201D.");
+    }
+
+    @Override protected void errHtml4XmlVoidSyntax() throws SAXException {
+        if (html4) {
+            err("The \u201C/>\u201D syntax on void elements is not allowed.  (This is an HTML4-only error.)");
+        }
+    }
+
+    @Override protected void errNoSpaceBetweenAttributes()
+            throws SAXException {
+                err("No space between attributes.");
+            }
+
+    @Override protected void errHtml4NonNameInUnquotedAttribute(char c)
+            throws SAXException {
+                if (html4
+                        && !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
+                                || (c >= '0' && c <= '9') || c == '.' || c == '-'
+                                || c == '_' || c == ':')) {
+                    err("Non-name character in an unquoted attribute value. (This is an HTML4-only error.)");
+                }
+            }
+
+    @Override protected void errLtOrEqualsInUnquotedAttributeOrNull(char c)
+            throws SAXException {
+        switch (c) {
+            case '=':
+                err("\u201C=\u201D in an unquoted attribute value. Probable cause: Stray duplicate equals sign.");
+                return;
+            case '<':
+                err("\u201C<\u201D in an unquoted attribute value. Probable cause: Missing \u201C>\u201D immediately before.");
+                return;
+        }
+    }
+
+    @Override protected void errAttributeValueMissing() throws SAXException {
+        err("Attribute value missing.");
+    }
+
+    @Override protected void errBadCharBeforeAttributeNameOrNull(char c)
+            throws SAXException {
+                if (c == '<') {
+                    err("Saw \u201C<\u201D when expecting an attribute name. Probable cause: Missing \u201C>\u201D immediately before.");                    
+                } else if (c == '=') {
+                    errEqualsSignBeforeAttributeName();
+                } else if (c != '\uFFFD') {
+                    errQuoteBeforeAttributeName(c);
+                }
+            }
+
+    @Override protected void errEqualsSignBeforeAttributeName()
+            throws SAXException {
+                err("Saw \u201C=\u201D when expecting an attribute name. Probable cause: Attribute name missing.");
+            }
+
+    @Override protected void errBadCharAfterLt(char c)
+            throws SAXException {
+                err("Bad character \u201C"
+                        + c
+                        + "\u201D after \u201C<\u201D. Probable cause: Unescaped \u201C<\u201D. Try escaping it as \u201C&lt;\u201D.");
+            }
+
+    @Override protected void errLtGt() throws SAXException {
+        err("Saw \u201C<>\u201D. Probable causes: Unescaped \u201C<\u201D (escape as \u201C&lt;\u201D) or mistyped start tag.");
+    }
+
+    @Override protected void errProcessingInstruction() throws SAXException {
+        err("Saw \u201C<?\u201D. Probable cause: Attempt to use an XML processing instruction in HTML. (XML processing instructions are not supported in HTML.)");
+    }
+
+    @Override protected void errUnescapedAmpersandInterpretedAsCharacterReference()
+            throws SAXException {
+                if (errorHandler == null) {
+                    return;
+                }
+                SAXParseException spe = new SAXParseException(
+                        "The string following \u201C&\u201D was interpreted as a character reference. (\u201C&\u201D probably should have been escaped as \u201C&amp;\u201D.)",
+                        ampersandLocation);
+                errorHandler.error(spe);
+            }
+
+    @Override protected void errNotSemicolonTerminated() throws SAXException {
+        err("Named character reference was not terminated by a semicolon. (Or \u201C&\u201D should have been escaped as \u201C&amp;\u201D.)");
+    }
+
+    @Override protected void errNoNamedCharacterMatch() throws SAXException {
+        if (errorHandler == null) {
+            return;
+        }
+        SAXParseException spe = new SAXParseException(
+                "\u201C&\u201D did not start a character reference. (\u201C&\u201D probably should have been escaped as \u201C&amp;\u201D.)",
+                ampersandLocation);
+        errorHandler.error(spe);
+    }
+
+    @Override protected void errQuoteBeforeAttributeName(char c)
+            throws SAXException {
+                err("Saw \u201C"
+                        + c
+                        + "\u201D when expecting an attribute name. Probable cause: \u201C=\u201D missing immediately before.");
+    }
+
+    @Override protected void errQuoteOrLtInAttributeNameOrNull(char c)
+            throws SAXException {
+        if (c == '<') {
+            err("\u201C<\u201D in attribute name. Probable cause: \u201C>\u201D missing immediately before.");            
+        } else if (c != '\uFFFD') {
+            err("Quote \u201C"
+                    + c
+                    + "\u201D in attribute name. Probable cause: Matching quote missing somewhere earlier.");
+        }
+    }
+
+    @Override protected void errExpectedPublicId() throws SAXException {
+        err("Expected a public identifier but the doctype ended.");
+    }
+
+    @Override protected void errBogusDoctype() throws SAXException {
+        err("Bogus doctype.");
+    }
+
+    @Override protected void maybeWarnPrivateUseAstral() throws SAXException {
+        if (errorHandler != null && isAstralPrivateUse(value)) {
+            warnAboutPrivateUseChar();
+        }
+    }
+
+    @Override protected void maybeWarnPrivateUse(char ch)
+            throws SAXException {
+                if (errorHandler != null && isPrivateUse(ch)) {
+                    warnAboutPrivateUseChar();
+                }
+            }
+
+    @Override protected void maybeErrAttributesOnEndTag(HtmlAttributes attrs)
+            throws SAXException {
+                if (attrs.getLength() != 0) {
+                    /*
+                     * When an end tag token is emitted with attributes, that is a parse
+                     * error.
+                     */
+                    err("End tag had attributes.");
+                }
+            }
+
+    @Override protected void maybeErrSlashInEndTag(boolean selfClosing)
+            throws SAXException {
+                if (selfClosing && endTag) {
+                    err("Stray \u201C/\u201D at the end of an end tag.");
+                }
+            }
+
+    @Override protected void errNcrNonCharacter() throws SAXException {
+        err("Character reference expands to a non-character.");
+    }
+
+    @Override protected void errNcrSurrogate() throws SAXException {
+        err("Character reference expands to a surrogate.");
+    }
+
+    @Override protected void errNcrControlChar() throws SAXException {
+        err("Character reference expands to a control character ("
+                + toUPlusString((char) value) + ").");
+    }
+
+    @Override protected void errRcnCr() throws SAXException {
+        err("A numeric character reference expanded to carriage return.");
+    }
+
+    @Override protected void errNcrInC1Range() throws SAXException {
+        err("A numeric character reference expanded to the C1 controls range.");
+    }
+
+    @Override protected void errEofInPublicId() throws SAXException {
+        err("End of file inside public identifier.");
+    }
+
+    @Override protected void errEofInComment() throws SAXException {
+        err("End of file inside comment.");
+    }
+
+    @Override protected void errEofInDoctype() throws SAXException {
+        err("End of file inside doctype.");
+    }
+
+    @Override protected void errEofInAttributeValue() throws SAXException {
+        err("End of file reached when inside an attribute value. Ignoring tag.");
+    }
+
+    @Override protected void errEofInAttributeName() throws SAXException {
+        err("End of file occurred in an attribute name. Ignoring tag.");
+    }
+
+    @Override protected void errEofWithoutGt() throws SAXException {
+        err("Saw end of file without the previous tag ending with \u201C>\u201D. Ignoring tag.");
+    }
+
+    @Override protected void errEofInTagName() throws SAXException {
+        err("End of file seen when looking for tag name. Ignoring tag.");
+    }
+
+    @Override protected void errEofInEndTag() throws SAXException {
+        err("End of file inside end tag. Ignoring tag.");
+    }
+
+    @Override protected void errEofAfterLt() throws SAXException {
+        err("End of file after \u201C<\u201D.");
+    }
+
+    @Override protected void errNcrOutOfRange() throws SAXException {
+        err("Character reference outside the permissible Unicode range.");
+    }
+
+    @Override protected void errNcrUnassigned() throws SAXException {
+        err("Character reference expands to a permanently unassigned code point.");
+    }
+
+    @Override protected void errDuplicateAttribute() throws SAXException {
+        err("Duplicate attribute \u201C"
+                + attributeName.getLocal(AttributeName.HTML) + "\u201D.");
+    }
+
+    @Override protected void errEofInSystemId() throws SAXException {
+        err("End of file inside system identifier.");
+    }
+
+    @Override protected void errExpectedSystemId() throws SAXException {
+        err("Expected a system identifier but the doctype ended.");
+    }
+
+    @Override protected void errMissingSpaceBeforeDoctypeName()
+            throws SAXException {
+        err("Missing space before doctype name.");
+    }
+
+    @Override protected void errHyphenHyphenBang() throws SAXException {
+        err("\u201C--!\u201D found in comment.");
+    }
+}
diff --git a/parser/html/java/htmlparser/src/HtmlAttributes.java b/parser/html/java/htmlparser/src/HtmlAttributes.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/HtmlAttributes.java
@@ -0,0 +1,486 @@
+/*
+ * Copyright (c) 2007 Henri Sivonen
+ * Copyright (c) 2008-2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.IdType;
+import nu.validator.htmlparser.annotation.Local;
+import nu.validator.htmlparser.annotation.NsUri;
+import nu.validator.htmlparser.annotation.Prefix;
+import nu.validator.htmlparser.annotation.QName;
+import nu.validator.htmlparser.common.XmlViolationPolicy;
+
+import org.xml.sax.Attributes;
+import org.xml.sax.SAXException;
+
+/**
+ * Be careful with this class. QName is the name in from HTML tokenization.
+ * Otherwise, please refer to the interface doc.
+ * 
+ * @version $Id: AttributesImpl.java 206 2008-03-20 14:09:29Z hsivonen $
+ * @author hsivonen
+ */
+public final class HtmlAttributes implements Attributes {
+
+    // [NOCPP[
+
+    private static final AttributeName[] EMPTY_ATTRIBUTENAMES = new AttributeName[0];
+
+    private static final String[] EMPTY_STRINGS = new String[0];
+
+    // ]NOCPP]
+
+    public static final HtmlAttributes EMPTY_ATTRIBUTES = new HtmlAttributes(
+            AttributeName.HTML);
+
+    private int mode;
+
+    private int length;
+
+    private AttributeName[] names;
+
+    private String[] values; // XXX perhaps make this @NoLength?
+
+    // [NOCPP[
+
+    private String idValue;
+
+    private int xmlnsLength;
+
+    private AttributeName[] xmlnsNames;
+
+    private String[] xmlnsValues;
+
+    // ]NOCPP]
+
+    public HtmlAttributes(int mode) {
+        this.mode = mode;
+        this.length = 0;
+        /*
+         * The length of 5 covers covers 98.3% of elements
+         * according to Hixie
+         */
+        this.names = new AttributeName[5];
+        this.values = new String[5];
+
+        // [NOCPP[
+
+        this.idValue = null;
+
+        this.xmlnsLength = 0;
+
+        this.xmlnsNames = HtmlAttributes.EMPTY_ATTRIBUTENAMES;
+
+        this.xmlnsValues = HtmlAttributes.EMPTY_STRINGS;
+
+        // ]NOCPP]
+    }
+    /*
+    public HtmlAttributes(HtmlAttributes other) {
+        this.mode = other.mode;
+        this.length = other.length;
+        this.names = new AttributeName[other.length];
+        this.values = new String[other.length];
+        // [NOCPP[
+        this.idValue = other.idValue;
+        this.xmlnsLength = other.xmlnsLength;
+        this.xmlnsNames = new AttributeName[other.xmlnsLength];
+        this.xmlnsValues = new String[other.xmlnsLength];
+        // ]NOCPP]
+    }
+    */
+
+    void destructor() {
+        clear(0);
+        Portability.releaseArray(names);
+        Portability.releaseArray(values);
+    }
+    
+    /**
+     * Only use with a static argument
+     * 
+     * @param name
+     * @return
+     */
+    public int getIndex(AttributeName name) {
+        for (int i = 0; i < length; i++) {
+            if (names[i] == name) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    // [NOCPP[
+    
+    public int getIndex(String qName) {
+        for (int i = 0; i < length; i++) {
+            if (names[i].getQName(mode).equals(qName)) {
+                return i;
+            }
+        }
+        return -1;
+    }
+    
+    public int getIndex(String uri, String localName) {
+        for (int i = 0; i < length; i++) {
+            if (names[i].getLocal(mode).equals(localName)
+                    && names[i].getUri(mode).equals(uri)) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    public @IdType String getType(String qName) {
+        int index = getIndex(qName);
+        if (index == -1) {
+            return null;
+        } else {
+            return getType(index);
+        }
+    }
+
+    public @IdType String getType(String uri, String localName) {
+        int index = getIndex(uri, localName);
+        if (index == -1) {
+            return null;
+        } else {
+            return getType(index);
+        }
+    }
+    
+    public String getValue(String qName) {
+        int index = getIndex(qName);
+        if (index == -1) {
+            return null;
+        } else {
+            return getValue(index);
+        }
+    }
+
+    public String getValue(String uri, String localName) {
+        int index = getIndex(uri, localName);
+        if (index == -1) {
+            return null;
+        } else {
+            return getValue(index);
+        }
+    }
+    
+    // ]NOCPP]
+    
+    public int getLength() {
+        return length;
+    }
+
+    public @Local String getLocalName(int index) {
+        if (index < length && index >= 0) {
+            return names[index].getLocal(mode);
+        } else {
+            return null;
+        }
+    }
+
+    // [NOCPP[
+    
+    public @QName String getQName(int index) {
+        if (index < length && index >= 0) {
+            return names[index].getQName(mode);
+        } else {
+            return null;
+        }
+    }
+
+    public @IdType String getType(int index) {
+        if (index < length && index >= 0) {
+            return names[index].getType(mode);
+        } else {
+            return null;
+        }
+    }
+
+    // ]NOCPP]
+    
+    public AttributeName getAttributeName(int index) {
+        if (index < length && index >= 0) {
+            return names[index];
+        } else {
+            return null;
+        }
+    }
+
+    public @NsUri String getURI(int index) {
+        if (index < length && index >= 0) {
+            return names[index].getUri(mode);
+        } else {
+            return null;
+        }
+    }
+
+    public @Prefix String getPrefix(int index) {
+        if (index < length && index >= 0) {
+            return names[index].getPrefix(mode);
+        } else {
+            return null;
+        }
+    }
+
+    public String getValue(int index) {
+        if (index < length && index >= 0) {
+            return values[index];
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Only use with static argument.
+     * 
+     * @see org.xml.sax.Attributes#getValue(java.lang.String)
+     */
+    public String getValue(AttributeName name) {
+        int index = getIndex(name);
+        if (index == -1) {
+            return null;
+        } else {
+            return getValue(index);
+        }
+    }
+    
+    // [NOCPP[
+
+    public String getId() {
+        return idValue;
+    }
+
+    public int getXmlnsLength() {
+        return xmlnsLength;
+    }
+
+    public @Local String getXmlnsLocalName(int index) {
+        if (index < xmlnsLength && index >= 0) {
+            return xmlnsNames[index].getLocal(mode);
+        } else {
+            return null;
+        }
+    }
+
+    public @NsUri String getXmlnsURI(int index) {
+        if (index < xmlnsLength && index >= 0) {
+            return xmlnsNames[index].getUri(mode);
+        } else {
+            return null;
+        }
+    }
+
+    public String getXmlnsValue(int index) {
+        if (index < xmlnsLength && index >= 0) {
+            return xmlnsValues[index];
+        } else {
+            return null;
+        }
+    }
+    
+    public int getXmlnsIndex(AttributeName name) {
+        for (int i = 0; i < xmlnsLength; i++) {
+            if (xmlnsNames[i] == name) {
+                return i;
+            }
+        }
+        return -1;
+    }
+    
+    public String getXmlnsValue(AttributeName name) {
+        int index = getXmlnsIndex(name);
+        if (index == -1) {
+            return null;
+        } else {
+            return getXmlnsValue(index);
+        }
+    }
+    
+    public AttributeName getXmlnsAttributeName(int index) {
+        if (index < xmlnsLength && index >= 0) {
+            return xmlnsNames[index];
+        } else {
+            return null;
+        }
+    }
+
+    // ]NOCPP]
+
+    void addAttribute(AttributeName name, String value
+            // [NOCPP[
+            , XmlViolationPolicy xmlnsPolicy
+    // ]NOCPP]        
+    ) throws SAXException {
+        // [NOCPP[
+        if (name == AttributeName.ID) {
+            idValue = value;
+        }
+
+        if (name.isXmlns()) {
+            if (xmlnsNames.length == xmlnsLength) {
+                int newLen = xmlnsLength == 0 ? 2 : xmlnsLength << 1;
+                AttributeName[] newNames = new AttributeName[newLen];
+                System.arraycopy(xmlnsNames, 0, newNames, 0, xmlnsNames.length);
+                xmlnsNames = newNames;
+                String[] newValues = new String[newLen];
+                System.arraycopy(xmlnsValues, 0, newValues, 0, xmlnsValues.length);
+                xmlnsValues = newValues;
+            }
+            xmlnsNames[xmlnsLength] = name;
+            xmlnsValues[xmlnsLength] = value;
+            xmlnsLength++;
+            switch (xmlnsPolicy) {
+                case FATAL:
+                    // this is ugly
+                    throw new SAXException("Saw an xmlns attribute.");
+                case ALTER_INFOSET:
+                    return;
+                case ALLOW:
+                    // fall through
+            }
+        }
+
+        // ]NOCPP]
+
+        if (names.length == length) {
+            int newLen = length << 1; // The first growth covers virtually
+            // 100% of elements according to
+            // Hixie
+            AttributeName[] newNames = new AttributeName[newLen];
+            System.arraycopy(names, 0, newNames, 0, names.length);
+            Portability.releaseArray(names);
+            names = newNames;
+            String[] newValues = new String[newLen];
+            System.arraycopy(values, 0, newValues, 0, values.length);
+            Portability.releaseArray(values);
+            values = newValues;
+        }
+        names[length] = name;
+        values[length] = value;
+        length++;
+    }
+
+    void clear(int m) {
+        for (int i = 0; i < length; i++) {
+            names[i].release();
+            names[i] = null;
+            Portability.releaseString(values[i]);
+            values[i] = null;
+        }
+        length = 0;
+        mode = m;
+        // [NOCPP[
+        idValue = null;
+        for (int i = 0; i < xmlnsLength; i++) {
+            xmlnsNames[i] = null;
+            xmlnsValues[i] = null;
+        }
+        xmlnsLength = 0;
+        // ]NOCPP]
+    }
+    
+    /**
+     * This is used in C++ to release special <code>isindex</code>
+     * attribute values whose ownership is not transferred.
+     */
+    void releaseValue(int i) {
+        Portability.releaseString(values[i]);        
+    }
+    
+    /**
+     * This is only used for <code>AttributeName</code> ownership transfer
+     * in the isindex case to avoid freeing custom names twice in C++.
+     */
+    void clearWithoutReleasingContents() {
+        for (int i = 0; i < length; i++) {
+            names[i] = null;
+            values[i] = null;
+        }
+        length = 0;
+    }
+
+    boolean contains(AttributeName name) {
+        for (int i = 0; i < length; i++) {
+            if (name.equalsAnother(names[i])) {
+                return true;
+            }
+        }
+        // [NOCPP[
+        for (int i = 0; i < xmlnsLength; i++) {
+            if (name.equalsAnother(xmlnsNames[i])) {
+                return true;
+            }
+        }
+        // ]NOCPP]
+        return false;
+    }
+
+    public void adjustForMath() {
+        mode = AttributeName.MATHML;
+    }
+
+    public void adjustForSvg() {
+        mode = AttributeName.SVG;
+    }
+
+    // [NOCPP[
+    
+    void processNonNcNames(TreeBuilder<?> treeBuilder, XmlViolationPolicy namePolicy) throws SAXException {
+        for (int i = 0; i < length; i++) {
+            AttributeName attName = names[i];
+            if (!attName.isNcName(mode)) {
+                String name = attName.getLocal(mode);
+                switch (namePolicy) {
+                    case ALTER_INFOSET:
+                        names[i] = AttributeName.create(NCName.escapeName(name));
+                        // fall through
+                    case ALLOW:
+                        if (attName != AttributeName.XML_LANG) {
+                            treeBuilder.warn("Attribute \u201C" + name + "\u201D is not serializable as XML 1.0.");
+                        }
+                        break;
+                    case FATAL:
+                        treeBuilder.fatal("Attribute \u201C" + name + "\u201D is not serializable as XML 1.0.");
+                        break;
+                }
+            }
+        }
+    }
+    
+    public void merge(HtmlAttributes attributes) throws SAXException {
+        int len = attributes.getLength();
+        for (int i = 0; i < len; i++) {
+            AttributeName name = attributes.getAttributeName(i);
+            if (!contains(name)) {
+                addAttribute(name, attributes.getValue(i), XmlViolationPolicy.ALLOW);
+            }
+        }
+    }
+
+    // ]NOCPP]
+    
+}
diff --git a/parser/html/java/htmlparser/src/LocatorImpl.java b/parser/html/java/htmlparser/src/LocatorImpl.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/LocatorImpl.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2007 Henri Sivonen
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import org.xml.sax.Locator;
+
+public final class LocatorImpl implements Locator {
+
+    private final String systemId;
+
+    private final String publicId;
+
+    private final int column;
+
+    private final int line;
+
+    public LocatorImpl(Locator locator) {
+        this.systemId = locator.getSystemId();
+        this.publicId = locator.getPublicId();
+        this.column = locator.getColumnNumber();
+        this.line = locator.getLineNumber();
+    }
+
+    public int getColumnNumber() {
+        return column;
+    }
+
+    public int getLineNumber() {
+        return line;
+    }
+
+    public String getPublicId() {
+        return publicId;
+    }
+
+    public String getSystemId() {
+        return systemId;
+    }
+}
diff --git a/parser/html/java/htmlparser/src/MetaScanner.java b/parser/html/java/htmlparser/src/MetaScanner.java
new file mode 100755
--- /dev/null
+++ b/parser/html/java/htmlparser/src/MetaScanner.java
@@ -0,0 +1,696 @@
+/*
+ * Copyright (c) 2007 Henri Sivonen
+ * Copyright (c) 2008-2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import java.io.IOException;
+
+import nu.validator.htmlparser.annotation.NoLength;
+import nu.validator.htmlparser.common.ByteReadable;
+
+import org.xml.sax.SAXException;
+
+public abstract class MetaScanner {
+
+    private static final @NoLength char[] CHARSET = "charset".toCharArray();
+    
+    private static final @NoLength char[] CONTENT = "content".toCharArray();
+
+    private static final int NO = 0;
+
+    private static final int M = 1;
+    
+    private static final int E = 2;
+    
+    private static final int T = 3;
+
+    private static final int A = 4;
+    
+    private static final int DATA = 0;
+
+    private static final int TAG_OPEN = 1;
+
+    private static final int SCAN_UNTIL_GT = 2;
+
+    private static final int TAG_NAME = 3;
+
+    private static final int BEFORE_ATTRIBUTE_NAME = 4;
+
+    private static final int ATTRIBUTE_NAME = 5;
+
+    private static final int AFTER_ATTRIBUTE_NAME = 6;
+
+    private static final int BEFORE_ATTRIBUTE_VALUE = 7;
+
+    private static final int ATTRIBUTE_VALUE_DOUBLE_QUOTED = 8;
+
+    private static final int ATTRIBUTE_VALUE_SINGLE_QUOTED = 9;
+
+    private static final int ATTRIBUTE_VALUE_UNQUOTED = 10;
+
+    private static final int AFTER_ATTRIBUTE_VALUE_QUOTED = 11;
+
+    private static final int MARKUP_DECLARATION_OPEN = 13;
+    
+    private static final int MARKUP_DECLARATION_HYPHEN = 14;
+
+    private static final int COMMENT_START = 15;
+
+    private static final int COMMENT_START_DASH = 16;
+
+    private static final int COMMENT = 17;
+
+    private static final int COMMENT_END_DASH = 18;
+
+    private static final int COMMENT_END = 19;
+    
+    private static final int SELF_CLOSING_START_TAG = 20;
+    
+    protected ByteReadable readable;
+    
+    private int metaState = NO;
+
+    private int contentIndex = -1;
+    
+    private int charsetIndex = -1;
+
+    protected int stateSave = DATA;
+
+    private int strBufLen;
+
+    private char[] strBuf;
+    
+    // [NOCPP[
+    
+    /**
+     * @param source
+     * @param errorHandler
+     * @param publicId
+     * @param systemId
+     */
+    public MetaScanner() {
+        this.readable = null;
+        this.metaState = NO;
+        this.contentIndex = -1;
+        this.charsetIndex = -1;
+        this.stateSave = DATA;
+        strBufLen = 0;
+        strBuf = new char[36];
+    }
+    
+    /**
+     * -1 means end.
+     * @return
+     * @throws IOException
+     */
+    protected int read() throws IOException {
+        return readable.readByte();
+    }
+
+    // ]NOCPP]
+
+    // WARNING When editing this, makes sure the bytecode length shown by javap
+    // stays under 8000 bytes!
+    protected final void stateLoop(int state)
+            throws SAXException, IOException {
+        int c = -1;
+        boolean reconsume = false;
+        stateloop: for (;;) {
+            switch (state) {
+                case DATA:
+                    dataloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            c = read();
+                        }
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '<':
+                                state = MetaScanner.TAG_OPEN;
+                                break dataloop; // FALL THROUGH continue
+                            // stateloop;
+                            default:
+                                continue;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case TAG_OPEN:
+                    tagopenloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case 'm':
+                            case 'M':
+                                metaState = M;
+                                state = MetaScanner.TAG_NAME;
+                                break tagopenloop;
+                                // continue stateloop;                                
+                            case '!':
+                                state = MetaScanner.MARKUP_DECLARATION_OPEN;
+                                continue stateloop;
+                            case '?':
+                            case '/':
+                                state = MetaScanner.SCAN_UNTIL_GT;
+                                continue stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            default:
+                                if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
+                                    metaState = NO;
+                                    state = MetaScanner.TAG_NAME;
+                                    break tagopenloop;
+                                    // continue stateloop;
+                                }
+                                state = MetaScanner.DATA;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALL THROUGH DON'T REORDER
+                case TAG_NAME:
+                    tagnameloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\n':
+                            case '\u000C':
+                                state = MetaScanner.BEFORE_ATTRIBUTE_NAME;
+                                break tagnameloop;
+                            // continue stateloop;
+                            case '/':
+                                state = MetaScanner.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            case 'e':
+                            case 'E':
+                                if (metaState == M) {
+                                    metaState = E;
+                                } else {
+                                    metaState = NO;
+                                }
+                                continue;
+                            case 't':
+                            case 'T':
+                                if (metaState == E) {
+                                    metaState = T;
+                                } else {
+                                    metaState = NO;
+                                }
+                                continue;
+                            case 'a':
+                            case 'A':
+                                if (metaState == T) {
+                                    metaState = A;
+                                } else {
+                                    metaState = NO;
+                                }
+                                continue;
+                            default:
+                                metaState = NO;
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BEFORE_ATTRIBUTE_NAME:
+                    beforeattributenameloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            c = read();
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\n':
+                            case '\u000C':
+                                continue;
+                            case '/':
+                                state = MetaScanner.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '>':
+                                state = DATA;
+                                continue stateloop;
+                            case 'c':
+                            case 'C':
+                                contentIndex = 0;
+                                charsetIndex = 0;
+                                state = MetaScanner.ATTRIBUTE_NAME;
+                                break beforeattributenameloop;                                
+                            default:
+                                contentIndex = -1;
+                                charsetIndex = -1;
+                                state = MetaScanner.ATTRIBUTE_NAME;
+                                break beforeattributenameloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case ATTRIBUTE_NAME:
+                    attributenameloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\n':
+                            case '\u000C':
+                                state = MetaScanner.AFTER_ATTRIBUTE_NAME;
+                                continue stateloop;
+                            case '/':
+                                state = MetaScanner.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '=':
+                                strBufLen = 0;
+                                state = MetaScanner.BEFORE_ATTRIBUTE_VALUE;
+                                break attributenameloop;
+                            // continue stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            default:
+                                if (metaState == A) {
+                                    if (c >= 'A' && c <= 'Z') {
+                                        c += 0x20;
+                                    }
+                                    if (contentIndex == 6) {
+                                        contentIndex = -1;
+                                    } else if (contentIndex > -1
+                                            && contentIndex < 6
+                                            && (c == CONTENT[contentIndex + 1])) {
+                                        contentIndex++;
+                                    }
+                                    if (charsetIndex == 6) {
+                                        charsetIndex = -1;
+                                    } else if (charsetIndex > -1
+                                            && charsetIndex < 6
+                                            && (c == CHARSET[charsetIndex + 1])) {
+                                        charsetIndex++;
+                                    }
+                                }
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BEFORE_ATTRIBUTE_VALUE:
+                    beforeattributevalueloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\n':
+                            case '\u000C':
+                                continue;
+                            case '"':
+                                state = MetaScanner.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
+                                break beforeattributevalueloop;
+                            // continue stateloop;
+                            case '\'':
+                                state = MetaScanner.ATTRIBUTE_VALUE_SINGLE_QUOTED;
+                                continue stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            default:
+                                if (charsetIndex == 6 || contentIndex == 6) {
+                                    addToBuffer(c);
+                                }
+                                state = MetaScanner.ATTRIBUTE_VALUE_UNQUOTED;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case ATTRIBUTE_VALUE_DOUBLE_QUOTED:
+                    attributevaluedoublequotedloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            c = read();
+                        }
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '"':
+                                if (tryCharset()) {
+                                    break stateloop;
+                                }
+                                state = MetaScanner.AFTER_ATTRIBUTE_VALUE_QUOTED;
+                                break attributevaluedoublequotedloop;
+                            // continue stateloop;
+                            default:
+                                if (metaState == A && (contentIndex == 6 || charsetIndex == 6)) {
+                                    addToBuffer(c);
+                                }
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case AFTER_ATTRIBUTE_VALUE_QUOTED:
+                    afterattributevaluequotedloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\n':
+                            case '\u000C':
+                                state = MetaScanner.BEFORE_ATTRIBUTE_NAME;
+                                continue stateloop;
+                            case '/':
+                                state = MetaScanner.SELF_CLOSING_START_TAG;
+                                break afterattributevaluequotedloop;
+                            // continue stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            default:
+                                state = MetaScanner.BEFORE_ATTRIBUTE_NAME;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case SELF_CLOSING_START_TAG:
+                    c = read();
+                    switch (c) {
+                        case -1:
+                            break stateloop;
+                        case '>':
+                            state = MetaScanner.DATA;
+                            continue stateloop;
+                        default:
+                            state = MetaScanner.BEFORE_ATTRIBUTE_NAME;
+                            reconsume = true;
+                            continue stateloop;
+                    }
+                    // XXX reorder point
+                case ATTRIBUTE_VALUE_UNQUOTED:
+                    for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            c = read();
+                        }
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\n':
+
+                            case '\u000C':
+                                if (tryCharset()) {
+                                    break stateloop;
+                                }
+                                state = MetaScanner.BEFORE_ATTRIBUTE_NAME;
+                                continue stateloop;
+                            case '>':
+                                if (tryCharset()) {
+                                    break stateloop;
+                                }
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            default:
+                                if (metaState == A && (contentIndex == 6 || charsetIndex == 6)) {
+                                    addToBuffer(c);
+                                }
+                                continue;
+                        }
+                    }
+                    // XXX reorder point
+                case AFTER_ATTRIBUTE_NAME:
+                    for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\n':
+                            case '\u000C':
+                                continue;
+                            case '/':
+                                if (tryCharset()) {
+                                    break stateloop;
+                                }
+                                state = MetaScanner.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '=':
+                                state = MetaScanner.BEFORE_ATTRIBUTE_VALUE;
+                                continue stateloop;
+                            case '>':
+                                if (tryCharset()) {
+                                    break stateloop;
+                                }
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            case 'c':
+                            case 'C':
+                                contentIndex = 0;
+                                charsetIndex = 0;
+                                state = MetaScanner.ATTRIBUTE_NAME;
+                                continue stateloop;
+                            default:
+                                contentIndex = -1;
+                                charsetIndex = -1;
+                                state = MetaScanner.ATTRIBUTE_NAME;
+                                continue stateloop;
+                        }
+                    }
+                    // XXX reorder point
+                case MARKUP_DECLARATION_OPEN:
+                    markupdeclarationopenloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '-':
+                                state = MetaScanner.MARKUP_DECLARATION_HYPHEN;
+                                break markupdeclarationopenloop;
+                            // continue stateloop;
+                            default:
+                                state = MetaScanner.SCAN_UNTIL_GT;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case MARKUP_DECLARATION_HYPHEN:
+                    markupdeclarationhyphenloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '-':
+                                state = MetaScanner.COMMENT_START;
+                                break markupdeclarationhyphenloop;
+                            // continue stateloop;
+                            default:
+                                state = MetaScanner.SCAN_UNTIL_GT;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT_START:
+                    commentstartloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '-':
+                                state = MetaScanner.COMMENT_START_DASH;
+                                continue stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            default:
+                                state = MetaScanner.COMMENT;
+                                break commentstartloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT:
+                    commentloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '-':
+                                state = MetaScanner.COMMENT_END_DASH;
+                                break commentloop;
+                            // continue stateloop;
+                            default:
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT_END_DASH:
+                    commentenddashloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '-':
+                                state = MetaScanner.COMMENT_END;
+                                break commentenddashloop;
+                            // continue stateloop;
+                            default:
+                                state = MetaScanner.COMMENT;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT_END:
+                    for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            case '-':
+                                continue;
+                            default:
+                                state = MetaScanner.COMMENT;
+                                continue stateloop;
+                        }
+                    }
+                    // XXX reorder point
+                case COMMENT_START_DASH:
+                    c = read();
+                    switch (c) {
+                        case -1:
+                            break stateloop;
+                        case '-':
+                            state = MetaScanner.COMMENT_END;
+                            continue stateloop;
+                        case '>':
+                            state = MetaScanner.DATA;
+                            continue stateloop;
+                        default:
+                            state = MetaScanner.COMMENT;
+                            continue stateloop;
+                    }
+                    // XXX reorder point
+                case ATTRIBUTE_VALUE_SINGLE_QUOTED:
+                    for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            c = read();
+                        }
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '\'':
+                                if (tryCharset()) {
+                                    break stateloop;
+                                }
+                                state = MetaScanner.AFTER_ATTRIBUTE_VALUE_QUOTED;
+                                continue stateloop;
+                            default:
+                                if (metaState == A && (contentIndex == 6 || charsetIndex == 6)) {
+                                    addToBuffer(c);
+                                }
+                                continue;
+                        }
+                    }
+                    // XXX reorder point
+                case SCAN_UNTIL_GT:
+                    for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            c = read();
+                        }
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            default:
+                                continue;
+                        }
+                    }
+            }
+        }
+        stateSave  = state;
+    }
+
+    private void addToBuffer(int c) {
+        if (strBufLen == strBuf.length) {
+            char[] newBuf = new char[strBuf.length + (strBuf.length << 1)];
+            System.arraycopy(strBuf, 0, newBuf, 0, strBuf.length);
+            Portability.releaseArray(strBuf);
+            strBuf = newBuf;
+        }
+        strBuf[strBufLen++] = (char)c;
+    }
+
+    private boolean tryCharset() throws SAXException {
+        if (metaState != A || !(contentIndex == 6 || charsetIndex == 6)) {
+            return false;
+        }
+        String attVal = Portability.newStringFromBuffer(strBuf, 0, strBufLen);
+        String candidateEncoding;
+        if (contentIndex == 6) {
+            candidateEncoding = TreeBuilder.extractCharsetFromContent(attVal);
+            Portability.releaseString(attVal);
+        } else {
+            candidateEncoding = attVal;
+        }
+        if (candidateEncoding == null) {
+            return false;
+        }
+        boolean success = tryCharset(candidateEncoding);
+        Portability.releaseString(candidateEncoding);
+        contentIndex = -1;
+        charsetIndex = -1;
+        return success;
+    }
+    
+    protected abstract boolean tryCharset(String encoding) throws SAXException;
+
+    
+}
diff --git a/parser/html/java/htmlparser/src/NCName.java b/parser/html/java/htmlparser/src/NCName.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/NCName.java
@@ -0,0 +1,495 @@
+/*
+ * Copyright (c) 2008 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+public final class NCName {
+    // [NOCPP[
+
+    private static final int SURROGATE_OFFSET = 0x10000 - (0xD800 << 10) - 0xDC00;
+    
+    private static final char[] HEX_TABLE = "0123456789ABCDEF".toCharArray();
+    
+    public static boolean isNCNameStart(char c) {
+        return ((c >= '\u0041' && c <= '\u005A')
+                || (c >= '\u0061' && c <= '\u007A')
+                || (c >= '\u00C0' && c <= '\u00D6')
+                || (c >= '\u00D8' && c <= '\u00F6')
+                || (c >= '\u00F8' && c <= '\u00FF')
+                || (c >= '\u0100' && c <= '\u0131')
+                || (c >= '\u0134' && c <= '\u013E')
+                || (c >= '\u0141' && c <= '\u0148')
+                || (c >= '\u014A' && c <= '\u017E')
+                || (c >= '\u0180' && c <= '\u01C3')
+                || (c >= '\u01CD' && c <= '\u01F0')
+                || (c >= '\u01F4' && c <= '\u01F5')
+                || (c >= '\u01FA' && c <= '\u0217')
+                || (c >= '\u0250' && c <= '\u02A8')
+                || (c >= '\u02BB' && c <= '\u02C1') || (c == '\u0386')
+                || (c >= '\u0388' && c <= '\u038A') || (c == '\u038C')
+                || (c >= '\u038E' && c <= '\u03A1')
+                || (c >= '\u03A3' && c <= '\u03CE')
+                || (c >= '\u03D0' && c <= '\u03D6') || (c == '\u03DA')
+                || (c == '\u03DC') || (c == '\u03DE') || (c == '\u03E0')
+                || (c >= '\u03E2' && c <= '\u03F3')
+                || (c >= '\u0401' && c <= '\u040C')
+                || (c >= '\u040E' && c <= '\u044F')
+                || (c >= '\u0451' && c <= '\u045C')
+                || (c >= '\u045E' && c <= '\u0481')
+                || (c >= '\u0490' && c <= '\u04C4')
+                || (c >= '\u04C7' && c <= '\u04C8')
+                || (c >= '\u04CB' && c <= '\u04CC')
+                || (c >= '\u04D0' && c <= '\u04EB')
+                || (c >= '\u04EE' && c <= '\u04F5')
+                || (c >= '\u04F8' && c <= '\u04F9')
+                || (c >= '\u0531' && c <= '\u0556') || (c == '\u0559')
+                || (c >= '\u0561' && c <= '\u0586')
+                || (c >= '\u05D0' && c <= '\u05EA')
+                || (c >= '\u05F0' && c <= '\u05F2')
+                || (c >= '\u0621' && c <= '\u063A')
+                || (c >= '\u0641' && c <= '\u064A')
+                || (c >= '\u0671' && c <= '\u06B7')
+                || (c >= '\u06BA' && c <= '\u06BE')
+                || (c >= '\u06C0' && c <= '\u06CE')
+                || (c >= '\u06D0' && c <= '\u06D3') || (c == '\u06D5')
+                || (c >= '\u06E5' && c <= '\u06E6')
+                || (c >= '\u0905' && c <= '\u0939') || (c == '\u093D')
+                || (c >= '\u0958' && c <= '\u0961')
+                || (c >= '\u0985' && c <= '\u098C')
+                || (c >= '\u098F' && c <= '\u0990')
+                || (c >= '\u0993' && c <= '\u09A8')
+                || (c >= '\u09AA' && c <= '\u09B0') || (c == '\u09B2')
+                || (c >= '\u09B6' && c <= '\u09B9')
+                || (c >= '\u09DC' && c <= '\u09DD')
+                || (c >= '\u09DF' && c <= '\u09E1')
+                || (c >= '\u09F0' && c <= '\u09F1')
+                || (c >= '\u0A05' && c <= '\u0A0A')
+                || (c >= '\u0A0F' && c <= '\u0A10')
+                || (c >= '\u0A13' && c <= '\u0A28')
+                || (c >= '\u0A2A' && c <= '\u0A30')
+                || (c >= '\u0A32' && c <= '\u0A33')
+                || (c >= '\u0A35' && c <= '\u0A36')
+                || (c >= '\u0A38' && c <= '\u0A39')
+                || (c >= '\u0A59' && c <= '\u0A5C') || (c == '\u0A5E')
+                || (c >= '\u0A72' && c <= '\u0A74')
+                || (c >= '\u0A85' && c <= '\u0A8B') || (c == '\u0A8D')
+                || (c >= '\u0A8F' && c <= '\u0A91')
+                || (c >= '\u0A93' && c <= '\u0AA8')
+                || (c >= '\u0AAA' && c <= '\u0AB0')
+                || (c >= '\u0AB2' && c <= '\u0AB3')
+                || (c >= '\u0AB5' && c <= '\u0AB9') || (c == '\u0ABD')
+                || (c == '\u0AE0') || (c >= '\u0B05' && c <= '\u0B0C')
+                || (c >= '\u0B0F' && c <= '\u0B10')
+                || (c >= '\u0B13' && c <= '\u0B28')
+                || (c >= '\u0B2A' && c <= '\u0B30')
+                || (c >= '\u0B32' && c <= '\u0B33')
+                || (c >= '\u0B36' && c <= '\u0B39') || (c == '\u0B3D')
+                || (c >= '\u0B5C' && c <= '\u0B5D')
+                || (c >= '\u0B5F' && c <= '\u0B61')
+                || (c >= '\u0B85' && c <= '\u0B8A')
+                || (c >= '\u0B8E' && c <= '\u0B90')
+                || (c >= '\u0B92' && c <= '\u0B95')
+                || (c >= '\u0B99' && c <= '\u0B9A') || (c == '\u0B9C')
+                || (c >= '\u0B9E' && c <= '\u0B9F')
+                || (c >= '\u0BA3' && c <= '\u0BA4')
+                || (c >= '\u0BA8' && c <= '\u0BAA')
+                || (c >= '\u0BAE' && c <= '\u0BB5')
+                || (c >= '\u0BB7' && c <= '\u0BB9')
+                || (c >= '\u0C05' && c <= '\u0C0C')
+                || (c >= '\u0C0E' && c <= '\u0C10')
+                || (c >= '\u0C12' && c <= '\u0C28')
+                || (c >= '\u0C2A' && c <= '\u0C33')
+                || (c >= '\u0C35' && c <= '\u0C39')
+                || (c >= '\u0C60' && c <= '\u0C61')
+                || (c >= '\u0C85' && c <= '\u0C8C')
+                || (c >= '\u0C8E' && c <= '\u0C90')
+                || (c >= '\u0C92' && c <= '\u0CA8')
+                || (c >= '\u0CAA' && c <= '\u0CB3')
+                || (c >= '\u0CB5' && c <= '\u0CB9') || (c == '\u0CDE')
+                || (c >= '\u0CE0' && c <= '\u0CE1')
+                || (c >= '\u0D05' && c <= '\u0D0C')
+                || (c >= '\u0D0E' && c <= '\u0D10')
+                || (c >= '\u0D12' && c <= '\u0D28')
+                || (c >= '\u0D2A' && c <= '\u0D39')
+                || (c >= '\u0D60' && c <= '\u0D61')
+                || (c >= '\u0E01' && c <= '\u0E2E') || (c == '\u0E30')
+                || (c >= '\u0E32' && c <= '\u0E33')
+                || (c >= '\u0E40' && c <= '\u0E45')
+                || (c >= '\u0E81' && c <= '\u0E82') || (c == '\u0E84')
+                || (c >= '\u0E87' && c <= '\u0E88') || (c == '\u0E8A')
+                || (c == '\u0E8D') || (c >= '\u0E94' && c <= '\u0E97')
+                || (c >= '\u0E99' && c <= '\u0E9F')
+                || (c >= '\u0EA1' && c <= '\u0EA3') || (c == '\u0EA5')
+                || (c == '\u0EA7') || (c >= '\u0EAA' && c <= '\u0EAB')
+                || (c >= '\u0EAD' && c <= '\u0EAE') || (c == '\u0EB0')
+                || (c >= '\u0EB2' && c <= '\u0EB3') || (c == '\u0EBD')
+                || (c >= '\u0EC0' && c <= '\u0EC4')
+                || (c >= '\u0F40' && c <= '\u0F47')
+                || (c >= '\u0F49' && c <= '\u0F69')
+                || (c >= '\u10A0' && c <= '\u10C5')
+                || (c >= '\u10D0' && c <= '\u10F6') || (c == '\u1100')
+                || (c >= '\u1102' && c <= '\u1103')
+                || (c >= '\u1105' && c <= '\u1107') || (c == '\u1109')
+                || (c >= '\u110B' && c <= '\u110C')
+                || (c >= '\u110E' && c <= '\u1112') || (c == '\u113C')
+                || (c == '\u113E') || (c == '\u1140') || (c == '\u114C')
+                || (c == '\u114E') || (c == '\u1150')
+                || (c >= '\u1154' && c <= '\u1155') || (c == '\u1159')
+                || (c >= '\u115F' && c <= '\u1161') || (c == '\u1163')
+                || (c == '\u1165') || (c == '\u1167') || (c == '\u1169')
+                || (c >= '\u116D' && c <= '\u116E')
+                || (c >= '\u1172' && c <= '\u1173') || (c == '\u1175')
+                || (c == '\u119E') || (c == '\u11A8') || (c == '\u11AB')
+                || (c >= '\u11AE' && c <= '\u11AF')
+                || (c >= '\u11B7' && c <= '\u11B8') || (c == '\u11BA')
+                || (c >= '\u11BC' && c <= '\u11C2') || (c == '\u11EB')
+                || (c == '\u11F0') || (c == '\u11F9')
+                || (c >= '\u1E00' && c <= '\u1E9B')
+                || (c >= '\u1EA0' && c <= '\u1EF9')
+                || (c >= '\u1F00' && c <= '\u1F15')
+                || (c >= '\u1F18' && c <= '\u1F1D')
+                || (c >= '\u1F20' && c <= '\u1F45')
+                || (c >= '\u1F48' && c <= '\u1F4D')
+                || (c >= '\u1F50' && c <= '\u1F57') || (c == '\u1F59')
+                || (c == '\u1F5B') || (c == '\u1F5D')
+                || (c >= '\u1F5F' && c <= '\u1F7D')
+                || (c >= '\u1F80' && c <= '\u1FB4')
+                || (c >= '\u1FB6' && c <= '\u1FBC') || (c == '\u1FBE')
+                || (c >= '\u1FC2' && c <= '\u1FC4')
+                || (c >= '\u1FC6' && c <= '\u1FCC')
+                || (c >= '\u1FD0' && c <= '\u1FD3')
+                || (c >= '\u1FD6' && c <= '\u1FDB')
+                || (c >= '\u1FE0' && c <= '\u1FEC')
+                || (c >= '\u1FF2' && c <= '\u1FF4')
+                || (c >= '\u1FF6' && c <= '\u1FFC') || (c == '\u2126')
+                || (c >= '\u212A' && c <= '\u212B') || (c == '\u212E')
+                || (c >= '\u2180' && c <= '\u2182')
+                || (c >= '\u3041' && c <= '\u3094')
+                || (c >= '\u30A1' && c <= '\u30FA')
+                || (c >= '\u3105' && c <= '\u312C')
+                || (c >= '\uAC00' && c <= '\uD7A3')
+                || (c >= '\u4E00' && c <= '\u9FA5') || (c == '\u3007')
+                || (c >= '\u3021' && c <= '\u3029') || (c == '_'));
+    }
+
+    public static boolean isNCNameTrail(char c) {
+        return ((c >= '\u0030' && c <= '\u0039')
+                || (c >= '\u0660' && c <= '\u0669')
+                || (c >= '\u06F0' && c <= '\u06F9')
+                || (c >= '\u0966' && c <= '\u096F')
+                || (c >= '\u09E6' && c <= '\u09EF')
+                || (c >= '\u0A66' && c <= '\u0A6F')
+                || (c >= '\u0AE6' && c <= '\u0AEF')
+                || (c >= '\u0B66' && c <= '\u0B6F')
+                || (c >= '\u0BE7' && c <= '\u0BEF')
+                || (c >= '\u0C66' && c <= '\u0C6F')
+                || (c >= '\u0CE6' && c <= '\u0CEF')
+                || (c >= '\u0D66' && c <= '\u0D6F')
+                || (c >= '\u0E50' && c <= '\u0E59')
+                || (c >= '\u0ED0' && c <= '\u0ED9')
+                || (c >= '\u0F20' && c <= '\u0F29')
+                || (c >= '\u0041' && c <= '\u005A')
+                || (c >= '\u0061' && c <= '\u007A')
+                || (c >= '\u00C0' && c <= '\u00D6')
+                || (c >= '\u00D8' && c <= '\u00F6')
+                || (c >= '\u00F8' && c <= '\u00FF')
+                || (c >= '\u0100' && c <= '\u0131')
+                || (c >= '\u0134' && c <= '\u013E')
+                || (c >= '\u0141' && c <= '\u0148')
+                || (c >= '\u014A' && c <= '\u017E')
+                || (c >= '\u0180' && c <= '\u01C3')
+                || (c >= '\u01CD' && c <= '\u01F0')
+                || (c >= '\u01F4' && c <= '\u01F5')
+                || (c >= '\u01FA' && c <= '\u0217')
+                || (c >= '\u0250' && c <= '\u02A8')
+                || (c >= '\u02BB' && c <= '\u02C1') || (c == '\u0386')
+                || (c >= '\u0388' && c <= '\u038A') || (c == '\u038C')
+                || (c >= '\u038E' && c <= '\u03A1')
+                || (c >= '\u03A3' && c <= '\u03CE')
+                || (c >= '\u03D0' && c <= '\u03D6') || (c == '\u03DA')
+                || (c == '\u03DC') || (c == '\u03DE') || (c == '\u03E0')
+                || (c >= '\u03E2' && c <= '\u03F3')
+                || (c >= '\u0401' && c <= '\u040C')
+                || (c >= '\u040E' && c <= '\u044F')
+                || (c >= '\u0451' && c <= '\u045C')
+                || (c >= '\u045E' && c <= '\u0481')
+                || (c >= '\u0490' && c <= '\u04C4')
+                || (c >= '\u04C7' && c <= '\u04C8')
+                || (c >= '\u04CB' && c <= '\u04CC')
+                || (c >= '\u04D0' && c <= '\u04EB')
+                || (c >= '\u04EE' && c <= '\u04F5')
+                || (c >= '\u04F8' && c <= '\u04F9')
+                || (c >= '\u0531' && c <= '\u0556') || (c == '\u0559')
+                || (c >= '\u0561' && c <= '\u0586')
+                || (c >= '\u05D0' && c <= '\u05EA')
+                || (c >= '\u05F0' && c <= '\u05F2')
+                || (c >= '\u0621' && c <= '\u063A')
+                || (c >= '\u0641' && c <= '\u064A')
+                || (c >= '\u0671' && c <= '\u06B7')
+                || (c >= '\u06BA' && c <= '\u06BE')
+                || (c >= '\u06C0' && c <= '\u06CE')
+                || (c >= '\u06D0' && c <= '\u06D3') || (c == '\u06D5')
+                || (c >= '\u06E5' && c <= '\u06E6')
+                || (c >= '\u0905' && c <= '\u0939') || (c == '\u093D')
+                || (c >= '\u0958' && c <= '\u0961')
+                || (c >= '\u0985' && c <= '\u098C')
+                || (c >= '\u098F' && c <= '\u0990')
+                || (c >= '\u0993' && c <= '\u09A8')
+                || (c >= '\u09AA' && c <= '\u09B0') || (c == '\u09B2')
+                || (c >= '\u09B6' && c <= '\u09B9')
+                || (c >= '\u09DC' && c <= '\u09DD')
+                || (c >= '\u09DF' && c <= '\u09E1')
+                || (c >= '\u09F0' && c <= '\u09F1')
+                || (c >= '\u0A05' && c <= '\u0A0A')
+                || (c >= '\u0A0F' && c <= '\u0A10')
+                || (c >= '\u0A13' && c <= '\u0A28')
+                || (c >= '\u0A2A' && c <= '\u0A30')
+                || (c >= '\u0A32' && c <= '\u0A33')
+                || (c >= '\u0A35' && c <= '\u0A36')
+                || (c >= '\u0A38' && c <= '\u0A39')
+                || (c >= '\u0A59' && c <= '\u0A5C') || (c == '\u0A5E')
+                || (c >= '\u0A72' && c <= '\u0A74')
+                || (c >= '\u0A85' && c <= '\u0A8B') || (c == '\u0A8D')
+                || (c >= '\u0A8F' && c <= '\u0A91')
+                || (c >= '\u0A93' && c <= '\u0AA8')
+                || (c >= '\u0AAA' && c <= '\u0AB0')
+                || (c >= '\u0AB2' && c <= '\u0AB3')
+                || (c >= '\u0AB5' && c <= '\u0AB9') || (c == '\u0ABD')
+                || (c == '\u0AE0') || (c >= '\u0B05' && c <= '\u0B0C')
+                || (c >= '\u0B0F' && c <= '\u0B10')
+                || (c >= '\u0B13' && c <= '\u0B28')
+                || (c >= '\u0B2A' && c <= '\u0B30')
+                || (c >= '\u0B32' && c <= '\u0B33')
+                || (c >= '\u0B36' && c <= '\u0B39') || (c == '\u0B3D')
+                || (c >= '\u0B5C' && c <= '\u0B5D')
+                || (c >= '\u0B5F' && c <= '\u0B61')
+                || (c >= '\u0B85' && c <= '\u0B8A')
+                || (c >= '\u0B8E' && c <= '\u0B90')
+                || (c >= '\u0B92' && c <= '\u0B95')
+                || (c >= '\u0B99' && c <= '\u0B9A') || (c == '\u0B9C')
+                || (c >= '\u0B9E' && c <= '\u0B9F')
+                || (c >= '\u0BA3' && c <= '\u0BA4')
+                || (c >= '\u0BA8' && c <= '\u0BAA')
+                || (c >= '\u0BAE' && c <= '\u0BB5')
+                || (c >= '\u0BB7' && c <= '\u0BB9')
+                || (c >= '\u0C05' && c <= '\u0C0C')
+                || (c >= '\u0C0E' && c <= '\u0C10')
+                || (c >= '\u0C12' && c <= '\u0C28')
+                || (c >= '\u0C2A' && c <= '\u0C33')
+                || (c >= '\u0C35' && c <= '\u0C39')
+                || (c >= '\u0C60' && c <= '\u0C61')
+                || (c >= '\u0C85' && c <= '\u0C8C')
+                || (c >= '\u0C8E' && c <= '\u0C90')
+                || (c >= '\u0C92' && c <= '\u0CA8')
+                || (c >= '\u0CAA' && c <= '\u0CB3')
+                || (c >= '\u0CB5' && c <= '\u0CB9') || (c == '\u0CDE')
+                || (c >= '\u0CE0' && c <= '\u0CE1')
+                || (c >= '\u0D05' && c <= '\u0D0C')
+                || (c >= '\u0D0E' && c <= '\u0D10')
+                || (c >= '\u0D12' && c <= '\u0D28')
+                || (c >= '\u0D2A' && c <= '\u0D39')
+                || (c >= '\u0D60' && c <= '\u0D61')
+                || (c >= '\u0E01' && c <= '\u0E2E') || (c == '\u0E30')
+                || (c >= '\u0E32' && c <= '\u0E33')
+                || (c >= '\u0E40' && c <= '\u0E45')
+                || (c >= '\u0E81' && c <= '\u0E82') || (c == '\u0E84')
+                || (c >= '\u0E87' && c <= '\u0E88') || (c == '\u0E8A')
+                || (c == '\u0E8D') || (c >= '\u0E94' && c <= '\u0E97')
+                || (c >= '\u0E99' && c <= '\u0E9F')
+                || (c >= '\u0EA1' && c <= '\u0EA3') || (c == '\u0EA5')
+                || (c == '\u0EA7') || (c >= '\u0EAA' && c <= '\u0EAB')
+                || (c >= '\u0EAD' && c <= '\u0EAE') || (c == '\u0EB0')
+                || (c >= '\u0EB2' && c <= '\u0EB3') || (c == '\u0EBD')
+                || (c >= '\u0EC0' && c <= '\u0EC4')
+                || (c >= '\u0F40' && c <= '\u0F47')
+                || (c >= '\u0F49' && c <= '\u0F69')
+                || (c >= '\u10A0' && c <= '\u10C5')
+                || (c >= '\u10D0' && c <= '\u10F6') || (c == '\u1100')
+                || (c >= '\u1102' && c <= '\u1103')
+                || (c >= '\u1105' && c <= '\u1107') || (c == '\u1109')
+                || (c >= '\u110B' && c <= '\u110C')
+                || (c >= '\u110E' && c <= '\u1112') || (c == '\u113C')
+                || (c == '\u113E') || (c == '\u1140') || (c == '\u114C')
+                || (c == '\u114E') || (c == '\u1150')
+                || (c >= '\u1154' && c <= '\u1155') || (c == '\u1159')
+                || (c >= '\u115F' && c <= '\u1161') || (c == '\u1163')
+                || (c == '\u1165') || (c == '\u1167') || (c == '\u1169')
+                || (c >= '\u116D' && c <= '\u116E')
+                || (c >= '\u1172' && c <= '\u1173') || (c == '\u1175')
+                || (c == '\u119E') || (c == '\u11A8') || (c == '\u11AB')
+                || (c >= '\u11AE' && c <= '\u11AF')
+                || (c >= '\u11B7' && c <= '\u11B8') || (c == '\u11BA')
+                || (c >= '\u11BC' && c <= '\u11C2') || (c == '\u11EB')
+                || (c == '\u11F0') || (c == '\u11F9')
+                || (c >= '\u1E00' && c <= '\u1E9B')
+                || (c >= '\u1EA0' && c <= '\u1EF9')
+                || (c >= '\u1F00' && c <= '\u1F15')
+                || (c >= '\u1F18' && c <= '\u1F1D')
+                || (c >= '\u1F20' && c <= '\u1F45')
+                || (c >= '\u1F48' && c <= '\u1F4D')
+                || (c >= '\u1F50' && c <= '\u1F57') || (c == '\u1F59')
+                || (c == '\u1F5B') || (c == '\u1F5D')
+                || (c >= '\u1F5F' && c <= '\u1F7D')
+                || (c >= '\u1F80' && c <= '\u1FB4')
+                || (c >= '\u1FB6' && c <= '\u1FBC') || (c == '\u1FBE')
+                || (c >= '\u1FC2' && c <= '\u1FC4')
+                || (c >= '\u1FC6' && c <= '\u1FCC')
+                || (c >= '\u1FD0' && c <= '\u1FD3')
+                || (c >= '\u1FD6' && c <= '\u1FDB')
+                || (c >= '\u1FE0' && c <= '\u1FEC')
+                || (c >= '\u1FF2' && c <= '\u1FF4')
+                || (c >= '\u1FF6' && c <= '\u1FFC') || (c == '\u2126')
+                || (c >= '\u212A' && c <= '\u212B') || (c == '\u212E')
+                || (c >= '\u2180' && c <= '\u2182')
+                || (c >= '\u3041' && c <= '\u3094')
+                || (c >= '\u30A1' && c <= '\u30FA')
+                || (c >= '\u3105' && c <= '\u312C')
+                || (c >= '\uAC00' && c <= '\uD7A3')
+                || (c >= '\u4E00' && c <= '\u9FA5') || (c == '\u3007')
+                || (c >= '\u3021' && c <= '\u3029') || (c == '_') || (c == '.')
+                || (c == '-') || (c >= '\u0300' && c <= '\u0345')
+                || (c >= '\u0360' && c <= '\u0361')
+                || (c >= '\u0483' && c <= '\u0486')
+                || (c >= '\u0591' && c <= '\u05A1')
+                || (c >= '\u05A3' && c <= '\u05B9')
+                || (c >= '\u05BB' && c <= '\u05BD') || (c == '\u05BF')
+                || (c >= '\u05C1' && c <= '\u05C2') || (c == '\u05C4')
+                || (c >= '\u064B' && c <= '\u0652') || (c == '\u0670')
+                || (c >= '\u06D6' && c <= '\u06DC')
+                || (c >= '\u06DD' && c <= '\u06DF')
+                || (c >= '\u06E0' && c <= '\u06E4')
+                || (c >= '\u06E7' && c <= '\u06E8')
+                || (c >= '\u06EA' && c <= '\u06ED')
+                || (c >= '\u0901' && c <= '\u0903') || (c == '\u093C')
+                || (c >= '\u093E' && c <= '\u094C') || (c == '\u094D')
+                || (c >= '\u0951' && c <= '\u0954')
+                || (c >= '\u0962' && c <= '\u0963')
+                || (c >= '\u0981' && c <= '\u0983') || (c == '\u09BC')
+                || (c == '\u09BE') || (c == '\u09BF')
+                || (c >= '\u09C0' && c <= '\u09C4')
+                || (c >= '\u09C7' && c <= '\u09C8')
+                || (c >= '\u09CB' && c <= '\u09CD') || (c == '\u09D7')
+                || (c >= '\u09E2' && c <= '\u09E3') || (c == '\u0A02')
+                || (c == '\u0A3C') || (c == '\u0A3E') || (c == '\u0A3F')
+                || (c >= '\u0A40' && c <= '\u0A42')
+                || (c >= '\u0A47' && c <= '\u0A48')
+                || (c >= '\u0A4B' && c <= '\u0A4D')
+                || (c >= '\u0A70' && c <= '\u0A71')
+                || (c >= '\u0A81' && c <= '\u0A83') || (c == '\u0ABC')
+                || (c >= '\u0ABE' && c <= '\u0AC5')
+                || (c >= '\u0AC7' && c <= '\u0AC9')
+                || (c >= '\u0ACB' && c <= '\u0ACD')
+                || (c >= '\u0B01' && c <= '\u0B03') || (c == '\u0B3C')
+                || (c >= '\u0B3E' && c <= '\u0B43')
+                || (c >= '\u0B47' && c <= '\u0B48')
+                || (c >= '\u0B4B' && c <= '\u0B4D')
+                || (c >= '\u0B56' && c <= '\u0B57')
+                || (c >= '\u0B82' && c <= '\u0B83')
+                || (c >= '\u0BBE' && c <= '\u0BC2')
+                || (c >= '\u0BC6' && c <= '\u0BC8')
+                || (c >= '\u0BCA' && c <= '\u0BCD') || (c == '\u0BD7')
+                || (c >= '\u0C01' && c <= '\u0C03')
+                || (c >= '\u0C3E' && c <= '\u0C44')
+                || (c >= '\u0C46' && c <= '\u0C48')
+                || (c >= '\u0C4A' && c <= '\u0C4D')
+                || (c >= '\u0C55' && c <= '\u0C56')
+                || (c >= '\u0C82' && c <= '\u0C83')
+                || (c >= '\u0CBE' && c <= '\u0CC4')
+                || (c >= '\u0CC6' && c <= '\u0CC8')
+                || (c >= '\u0CCA' && c <= '\u0CCD')
+                || (c >= '\u0CD5' && c <= '\u0CD6')
+                || (c >= '\u0D02' && c <= '\u0D03')
+                || (c >= '\u0D3E' && c <= '\u0D43')
+                || (c >= '\u0D46' && c <= '\u0D48')
+                || (c >= '\u0D4A' && c <= '\u0D4D') || (c == '\u0D57')
+                || (c == '\u0E31') || (c >= '\u0E34' && c <= '\u0E3A')
+                || (c >= '\u0E47' && c <= '\u0E4E') || (c == '\u0EB1')
+                || (c >= '\u0EB4' && c <= '\u0EB9')
+                || (c >= '\u0EBB' && c <= '\u0EBC')
+                || (c >= '\u0EC8' && c <= '\u0ECD')
+                || (c >= '\u0F18' && c <= '\u0F19') || (c == '\u0F35')
+                || (c == '\u0F37') || (c == '\u0F39') || (c == '\u0F3E')
+                || (c == '\u0F3F') || (c >= '\u0F71' && c <= '\u0F84')
+                || (c >= '\u0F86' && c <= '\u0F8B')
+                || (c >= '\u0F90' && c <= '\u0F95') || (c == '\u0F97')
+                || (c >= '\u0F99' && c <= '\u0FAD')
+                || (c >= '\u0FB1' && c <= '\u0FB7') || (c == '\u0FB9')
+                || (c >= '\u20D0' && c <= '\u20DC') || (c == '\u20E1')
+                || (c >= '\u302A' && c <= '\u302F') || (c == '\u3099')
+                || (c == '\u309A') || (c == '\u00B7') || (c == '\u02D0')
+                || (c == '\u02D1') || (c == '\u0387') || (c == '\u0640')
+                || (c == '\u0E46') || (c == '\u0EC6') || (c == '\u3005')
+                || (c >= '\u3031' && c <= '\u3035')
+                || (c >= '\u309D' && c <= '\u309E') || (c >= '\u30FC' && c <= '\u30FE'));
+    }
+
+    public static boolean isNCName(String str) {
+        if (str == null) {
+            return false;
+        } else {
+            int len = str.length();
+            switch (len) {
+                case 0:
+                    return false;
+                case 1:
+                    return NCName.isNCNameStart(str.charAt(0));
+                default:
+                    if (!NCName.isNCNameStart(str.charAt(0))) {
+                        return false;
+                    }
+                    for (int i = 1; i < len; i++) {
+                        if (!NCName.isNCNameTrail(str.charAt(i))) {
+                            return false;
+                        }
+                    }
+            }
+            return true;
+        }
+    }
+    
+    private static void appendUHexTo(StringBuilder sb, int c) {
+        sb.append('U');
+        for (int i = 0; i < 6; i++) {
+            sb.append(HEX_TABLE[(c & 0xF0000) >> 16]);
+            c <<= 4;
+        }
+    }
+    
+    public static String escapeName(String str) {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < str.length(); i++) {
+            char c = str.charAt(i);
+            if ((c & 0xFC00) == 0xD800) {
+                char next = str.charAt(++i);
+                appendUHexTo(sb, (c << 10) + next + SURROGATE_OFFSET);          
+            } else if (i == 0 && !isNCNameStart(c)) {
+                appendUHexTo(sb, c);
+            } else if (i != 0 && !isNCNameTrail(c)) {
+                appendUHexTo(sb, c);                
+            } else {
+                sb.append(c);
+            }
+        }
+        return sb.toString().intern();
+    }
+    // ]NOCPP]
+}
diff --git a/parser/html/java/htmlparser/src/NamedCharacters.java b/parser/html/java/htmlparser/src/NamedCharacters.java
new file mode 100755
--- /dev/null
+++ b/parser/html/java/htmlparser/src/NamedCharacters.java
@@ -0,0 +1,1644 @@
+/*
+ * Copyright (c) 2005 Henri Sivonen
+ * Copyright (c) 2008 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.NoLength;
+
+/**
+ * @version $Id: NamedCharacters.java 455 2008-09-29 07:00:58Z hsivonen $
+ * @author hsivonen
+ */
+public final class NamedCharacters {
+    static final char[][] NAMES = { "AElig".toCharArray(),
+            "AElig;".toCharArray(), "AMP".toCharArray(), "AMP;".toCharArray(),
+            "Aacute".toCharArray(), "Aacute;".toCharArray(),
+            "Abreve;".toCharArray(), "Acirc".toCharArray(),
+            "Acirc;".toCharArray(), "Acy;".toCharArray(), "Afr;".toCharArray(),
+            "Agrave".toCharArray(), "Agrave;".toCharArray(),
+            "Alpha;".toCharArray(), "Amacr;".toCharArray(),
+            "And;".toCharArray(), "Aogon;".toCharArray(),
+            "Aopf;".toCharArray(), "ApplyFunction;".toCharArray(),
+            "Aring".toCharArray(), "Aring;".toCharArray(),
+            "Ascr;".toCharArray(), "Assign;".toCharArray(),
+            "Atilde".toCharArray(), "Atilde;".toCharArray(),
+            "Auml".toCharArray(), "Auml;".toCharArray(),
+            "Backslash;".toCharArray(), "Barv;".toCharArray(),
+            "Barwed;".toCharArray(), "Bcy;".toCharArray(),
+            "Because;".toCharArray(), "Bernoullis;".toCharArray(),
+            "Beta;".toCharArray(), "Bfr;".toCharArray(), "Bopf;".toCharArray(),
+            "Breve;".toCharArray(), "Bscr;".toCharArray(),
+            "Bumpeq;".toCharArray(), "CHcy;".toCharArray(),
+            "COPY".toCharArray(), "COPY;".toCharArray(),
+            "Cacute;".toCharArray(), "Cap;".toCharArray(),
+            "CapitalDifferentialD;".toCharArray(), "Cayleys;".toCharArray(),
+            "Ccaron;".toCharArray(), "Ccedil".toCharArray(),
+            "Ccedil;".toCharArray(), "Ccirc;".toCharArray(),
+            "Cconint;".toCharArray(), "Cdot;".toCharArray(),
+            "Cedilla;".toCharArray(), "CenterDot;".toCharArray(),
+            "Cfr;".toCharArray(), "Chi;".toCharArray(),
+            "CircleDot;".toCharArray(), "CircleMinus;".toCharArray(),
+            "CirclePlus;".toCharArray(), "CircleTimes;".toCharArray(),
+            "ClockwiseContourIntegral;".toCharArray(),
+            "CloseCurlyDoubleQuote;".toCharArray(),
+            "CloseCurlyQuote;".toCharArray(), "Colon;".toCharArray(),
+            "Colone;".toCharArray(), "Congruent;".toCharArray(),
+            "Conint;".toCharArray(), "ContourIntegral;".toCharArray(),
+            "Copf;".toCharArray(), "Coproduct;".toCharArray(),
+            "CounterClockwiseContourIntegral;".toCharArray(),
+            "Cross;".toCharArray(), "Cscr;".toCharArray(),
+            "Cup;".toCharArray(), "CupCap;".toCharArray(), "DD;".toCharArray(),
+            "DDotrahd;".toCharArray(), "DJcy;".toCharArray(),
+            "DScy;".toCharArray(), "DZcy;".toCharArray(),
+            "Dagger;".toCharArray(), "Darr;".toCharArray(),
+            "Dashv;".toCharArray(), "Dcaron;".toCharArray(),
+            "Dcy;".toCharArray(), "Del;".toCharArray(), "Delta;".toCharArray(),
+            "Dfr;".toCharArray(), "DiacriticalAcute;".toCharArray(),
+            "DiacriticalDot;".toCharArray(),
+            "DiacriticalDoubleAcute;".toCharArray(),
+            "DiacriticalGrave;".toCharArray(),
+            "DiacriticalTilde;".toCharArray(), "Diamond;".toCharArray(),
+            "DifferentialD;".toCharArray(), "Dopf;".toCharArray(),
+            "Dot;".toCharArray(), "DotDot;".toCharArray(),
+            "DotEqual;".toCharArray(), "DoubleContourIntegral;".toCharArray(),
+            "DoubleDot;".toCharArray(), "DoubleDownArrow;".toCharArray(),
+            "DoubleLeftArrow;".toCharArray(),
+            "DoubleLeftRightArrow;".toCharArray(),
+            "DoubleLeftTee;".toCharArray(),
+            "DoubleLongLeftArrow;".toCharArray(),
+            "DoubleLongLeftRightArrow;".toCharArray(),
+            "DoubleLongRightArrow;".toCharArray(),
+            "DoubleRightArrow;".toCharArray(), "DoubleRightTee;".toCharArray(),
+            "DoubleUpArrow;".toCharArray(), "DoubleUpDownArrow;".toCharArray(),
+            "DoubleVerticalBar;".toCharArray(), "DownArrow;".toCharArray(),
+            "DownArrowBar;".toCharArray(), "DownArrowUpArrow;".toCharArray(),
+            "DownBreve;".toCharArray(), "DownLeftRightVector;".toCharArray(),
+            "DownLeftTeeVector;".toCharArray(),
+            "DownLeftVector;".toCharArray(),
+            "DownLeftVectorBar;".toCharArray(),
+            "DownRightTeeVector;".toCharArray(),
+            "DownRightVector;".toCharArray(),
+            "DownRightVectorBar;".toCharArray(), "DownTee;".toCharArray(),
+            "DownTeeArrow;".toCharArray(), "Downarrow;".toCharArray(),
+            "Dscr;".toCharArray(), "Dstrok;".toCharArray(),
+            "ENG;".toCharArray(), "ETH".toCharArray(), "ETH;".toCharArray(),
+            "Eacute".toCharArray(), "Eacute;".toCharArray(),
+            "Ecaron;".toCharArray(), "Ecirc".toCharArray(),
+            "Ecirc;".toCharArray(), "Ecy;".toCharArray(),
+            "Edot;".toCharArray(), "Efr;".toCharArray(),
+            "Egrave".toCharArray(), "Egrave;".toCharArray(),
+            "Element;".toCharArray(), "Emacr;".toCharArray(),
+            "EmptySmallSquare;".toCharArray(),
+            "EmptyVerySmallSquare;".toCharArray(), "Eogon;".toCharArray(),
+            "Eopf;".toCharArray(), "Epsilon;".toCharArray(),
+            "Equal;".toCharArray(), "EqualTilde;".toCharArray(),
+            "Equilibrium;".toCharArray(), "Escr;".toCharArray(),
+            "Esim;".toCharArray(), "Eta;".toCharArray(), "Euml".toCharArray(),
+            "Euml;".toCharArray(), "Exists;".toCharArray(),
+            "ExponentialE;".toCharArray(), "Fcy;".toCharArray(),
+            "Ffr;".toCharArray(), "FilledSmallSquare;".toCharArray(),
+            "FilledVerySmallSquare;".toCharArray(), "Fopf;".toCharArray(),
+            "ForAll;".toCharArray(), "Fouriertrf;".toCharArray(),
+            "Fscr;".toCharArray(), "GJcy;".toCharArray(), "GT".toCharArray(),
+            "GT;".toCharArray(), "Gamma;".toCharArray(),
+            "Gammad;".toCharArray(), "Gbreve;".toCharArray(),
+            "Gcedil;".toCharArray(), "Gcirc;".toCharArray(),
+            "Gcy;".toCharArray(), "Gdot;".toCharArray(), "Gfr;".toCharArray(),
+            "Gg;".toCharArray(), "Gopf;".toCharArray(),
+            "GreaterEqual;".toCharArray(), "GreaterEqualLess;".toCharArray(),
+            "GreaterFullEqual;".toCharArray(), "GreaterGreater;".toCharArray(),
+            "GreaterLess;".toCharArray(), "GreaterSlantEqual;".toCharArray(),
+            "GreaterTilde;".toCharArray(), "Gscr;".toCharArray(),
+            "Gt;".toCharArray(), "HARDcy;".toCharArray(),
+            "Hacek;".toCharArray(), "Hat;".toCharArray(),
+            "Hcirc;".toCharArray(), "Hfr;".toCharArray(),
+            "HilbertSpace;".toCharArray(), "Hopf;".toCharArray(),
+            "HorizontalLine;".toCharArray(), "Hscr;".toCharArray(),
+            "Hstrok;".toCharArray(), "HumpDownHump;".toCharArray(),
+            "HumpEqual;".toCharArray(), "IEcy;".toCharArray(),
+            "IJlig;".toCharArray(), "IOcy;".toCharArray(),
+            "Iacute".toCharArray(), "Iacute;".toCharArray(),
+            "Icirc".toCharArray(), "Icirc;".toCharArray(),
+            "Icy;".toCharArray(), "Idot;".toCharArray(), "Ifr;".toCharArray(),
+            "Igrave".toCharArray(), "Igrave;".toCharArray(),
+            "Im;".toCharArray(), "Imacr;".toCharArray(),
+            "ImaginaryI;".toCharArray(), "Implies;".toCharArray(),
+            "Int;".toCharArray(), "Integral;".toCharArray(),
+            "Intersection;".toCharArray(), "InvisibleComma;".toCharArray(),
+            "InvisibleTimes;".toCharArray(), "Iogon;".toCharArray(),
+            "Iopf;".toCharArray(), "Iota;".toCharArray(),
+            "Iscr;".toCharArray(), "Itilde;".toCharArray(),
+            "Iukcy;".toCharArray(), "Iuml".toCharArray(),
+            "Iuml;".toCharArray(), "Jcirc;".toCharArray(),
+            "Jcy;".toCharArray(), "Jfr;".toCharArray(), "Jopf;".toCharArray(),
+            "Jscr;".toCharArray(), "Jsercy;".toCharArray(),
+            "Jukcy;".toCharArray(), "KHcy;".toCharArray(),
+            "KJcy;".toCharArray(), "Kappa;".toCharArray(),
+            "Kcedil;".toCharArray(), "Kcy;".toCharArray(),
+            "Kfr;".toCharArray(), "Kopf;".toCharArray(), "Kscr;".toCharArray(),
+            "LJcy;".toCharArray(), "LT".toCharArray(), "LT;".toCharArray(),
+            "Lacute;".toCharArray(), "Lambda;".toCharArray(),
+            "Lang;".toCharArray(), "Laplacetrf;".toCharArray(),
+            "Larr;".toCharArray(), "Lcaron;".toCharArray(),
+            "Lcedil;".toCharArray(), "Lcy;".toCharArray(),
+            "LeftAngleBracket;".toCharArray(), "LeftArrow;".toCharArray(),
+            "LeftArrowBar;".toCharArray(),
+            "LeftArrowRightArrow;".toCharArray(), "LeftCeiling;".toCharArray(),
+            "LeftDoubleBracket;".toCharArray(),
+            "LeftDownTeeVector;".toCharArray(),
+            "LeftDownVector;".toCharArray(),
+            "LeftDownVectorBar;".toCharArray(), "LeftFloor;".toCharArray(),
+            "LeftRightArrow;".toCharArray(), "LeftRightVector;".toCharArray(),
+            "LeftTee;".toCharArray(), "LeftTeeArrow;".toCharArray(),
+            "LeftTeeVector;".toCharArray(), "LeftTriangle;".toCharArray(),
+            "LeftTriangleBar;".toCharArray(),
+            "LeftTriangleEqual;".toCharArray(),
+            "LeftUpDownVector;".toCharArray(),
+            "LeftUpTeeVector;".toCharArray(), "LeftUpVector;".toCharArray(),
+            "LeftUpVectorBar;".toCharArray(), "LeftVector;".toCharArray(),
+            "LeftVectorBar;".toCharArray(), "Leftarrow;".toCharArray(),
+            "Leftrightarrow;".toCharArray(), "LessEqualGreater;".toCharArray(),
+            "LessFullEqual;".toCharArray(), "LessGreater;".toCharArray(),
+            "LessLess;".toCharArray(), "LessSlantEqual;".toCharArray(),
+            "LessTilde;".toCharArray(), "Lfr;".toCharArray(),
+            "Ll;".toCharArray(), "Lleftarrow;".toCharArray(),
+            "Lmidot;".toCharArray(), "LongLeftArrow;".toCharArray(),
+            "LongLeftRightArrow;".toCharArray(),
+            "LongRightArrow;".toCharArray(), "Longleftarrow;".toCharArray(),
+            "Longleftrightarrow;".toCharArray(),
+            "Longrightarrow;".toCharArray(), "Lopf;".toCharArray(),
+            "LowerLeftArrow;".toCharArray(), "LowerRightArrow;".toCharArray(),
+            "Lscr;".toCharArray(), "Lsh;".toCharArray(),
+            "Lstrok;".toCharArray(), "Lt;".toCharArray(), "Map;".toCharArray(),
+            "Mcy;".toCharArray(), "MediumSpace;".toCharArray(),
+            "Mellintrf;".toCharArray(), "Mfr;".toCharArray(),
+            "MinusPlus;".toCharArray(), "Mopf;".toCharArray(),
+            "Mscr;".toCharArray(), "Mu;".toCharArray(), "NJcy;".toCharArray(),
+            "Nacute;".toCharArray(), "Ncaron;".toCharArray(),
+            "Ncedil;".toCharArray(), "Ncy;".toCharArray(),
+            "NegativeMediumSpace;".toCharArray(),
+            "NegativeThickSpace;".toCharArray(),
+            "NegativeThinSpace;".toCharArray(),
+            "NegativeVeryThinSpace;".toCharArray(),
+            "NestedGreaterGreater;".toCharArray(),
+            "NestedLessLess;".toCharArray(), "NewLine;".toCharArray(),
+            "Nfr;".toCharArray(), "NoBreak;".toCharArray(),
+            "NonBreakingSpace;".toCharArray(), "Nopf;".toCharArray(),
+            "Not;".toCharArray(), "NotCongruent;".toCharArray(),
+            "NotCupCap;".toCharArray(), "NotDoubleVerticalBar;".toCharArray(),
+            "NotElement;".toCharArray(), "NotEqual;".toCharArray(),
+            "NotExists;".toCharArray(), "NotGreater;".toCharArray(),
+            "NotGreaterEqual;".toCharArray(), "NotGreaterLess;".toCharArray(),
+            "NotGreaterTilde;".toCharArray(), "NotLeftTriangle;".toCharArray(),
+            "NotLeftTriangleEqual;".toCharArray(), "NotLess;".toCharArray(),
+            "NotLessEqual;".toCharArray(), "NotLessGreater;".toCharArray(),
+            "NotLessTilde;".toCharArray(), "NotPrecedes;".toCharArray(),
+            "NotPrecedesSlantEqual;".toCharArray(),
+            "NotReverseElement;".toCharArray(),
+            "NotRightTriangle;".toCharArray(),
+            "NotRightTriangleEqual;".toCharArray(),
+            "NotSquareSubsetEqual;".toCharArray(),
+            "NotSquareSupersetEqual;".toCharArray(),
+            "NotSubsetEqual;".toCharArray(), "NotSucceeds;".toCharArray(),
+            "NotSucceedsSlantEqual;".toCharArray(),
+            "NotSupersetEqual;".toCharArray(), "NotTilde;".toCharArray(),
+            "NotTildeEqual;".toCharArray(), "NotTildeFullEqual;".toCharArray(),
+            "NotTildeTilde;".toCharArray(), "NotVerticalBar;".toCharArray(),
+            "Nscr;".toCharArray(), "Ntilde".toCharArray(),
+            "Ntilde;".toCharArray(), "Nu;".toCharArray(),
+            "OElig;".toCharArray(), "Oacute".toCharArray(),
+            "Oacute;".toCharArray(), "Ocirc".toCharArray(),
+            "Ocirc;".toCharArray(), "Ocy;".toCharArray(),
+            "Odblac;".toCharArray(), "Ofr;".toCharArray(),
+            "Ograve".toCharArray(), "Ograve;".toCharArray(),
+            "Omacr;".toCharArray(), "Omega;".toCharArray(),
+            "Omicron;".toCharArray(), "Oopf;".toCharArray(),
+            "OpenCurlyDoubleQuote;".toCharArray(),
+            "OpenCurlyQuote;".toCharArray(), "Or;".toCharArray(),
+            "Oscr;".toCharArray(), "Oslash".toCharArray(),
+            "Oslash;".toCharArray(), "Otilde".toCharArray(),
+            "Otilde;".toCharArray(), "Otimes;".toCharArray(),
+            "Ouml".toCharArray(), "Ouml;".toCharArray(),
+            "OverBar;".toCharArray(), "OverBrace;".toCharArray(),
+            "OverBracket;".toCharArray(), "OverParenthesis;".toCharArray(),
+            "PartialD;".toCharArray(), "Pcy;".toCharArray(),
+            "Pfr;".toCharArray(), "Phi;".toCharArray(), "Pi;".toCharArray(),
+            "PlusMinus;".toCharArray(), "Poincareplane;".toCharArray(),
+            "Popf;".toCharArray(), "Pr;".toCharArray(),
+            "Precedes;".toCharArray(), "PrecedesEqual;".toCharArray(),
+            "PrecedesSlantEqual;".toCharArray(),
+            "PrecedesTilde;".toCharArray(), "Prime;".toCharArray(),
+            "Product;".toCharArray(), "Proportion;".toCharArray(),
+            "Proportional;".toCharArray(), "Pscr;".toCharArray(),
+            "Psi;".toCharArray(), "QUOT".toCharArray(), "QUOT;".toCharArray(),
+            "Qfr;".toCharArray(), "Qopf;".toCharArray(), "Qscr;".toCharArray(),
+            "RBarr;".toCharArray(), "REG".toCharArray(), "REG;".toCharArray(),
+            "Racute;".toCharArray(), "Rang;".toCharArray(),
+            "Rarr;".toCharArray(), "Rarrtl;".toCharArray(),
+            "Rcaron;".toCharArray(), "Rcedil;".toCharArray(),
+            "Rcy;".toCharArray(), "Re;".toCharArray(),
+            "ReverseElement;".toCharArray(),
+            "ReverseEquilibrium;".toCharArray(),
+            "ReverseUpEquilibrium;".toCharArray(), "Rfr;".toCharArray(),
+            "Rho;".toCharArray(), "RightAngleBracket;".toCharArray(),
+            "RightArrow;".toCharArray(), "RightArrowBar;".toCharArray(),
+            "RightArrowLeftArrow;".toCharArray(),
+            "RightCeiling;".toCharArray(), "RightDoubleBracket;".toCharArray(),
+            "RightDownTeeVector;".toCharArray(),
+            "RightDownVector;".toCharArray(),
+            "RightDownVectorBar;".toCharArray(), "RightFloor;".toCharArray(),
+            "RightTee;".toCharArray(), "RightTeeArrow;".toCharArray(),
+            "RightTeeVector;".toCharArray(), "RightTriangle;".toCharArray(),
+            "RightTriangleBar;".toCharArray(),
+            "RightTriangleEqual;".toCharArray(),
+            "RightUpDownVector;".toCharArray(),
+            "RightUpTeeVector;".toCharArray(), "RightUpVector;".toCharArray(),
+            "RightUpVectorBar;".toCharArray(), "RightVector;".toCharArray(),
+            "RightVectorBar;".toCharArray(), "Rightarrow;".toCharArray(),
+            "Ropf;".toCharArray(), "RoundImplies;".toCharArray(),
+            "Rrightarrow;".toCharArray(), "Rscr;".toCharArray(),
+            "Rsh;".toCharArray(), "RuleDelayed;".toCharArray(),
+            "SHCHcy;".toCharArray(), "SHcy;".toCharArray(),
+            "SOFTcy;".toCharArray(), "Sacute;".toCharArray(),
+            "Sc;".toCharArray(), "Scaron;".toCharArray(),
+            "Scedil;".toCharArray(), "Scirc;".toCharArray(),
+            "Scy;".toCharArray(), "Sfr;".toCharArray(),
+            "ShortDownArrow;".toCharArray(), "ShortLeftArrow;".toCharArray(),
+            "ShortRightArrow;".toCharArray(), "ShortUpArrow;".toCharArray(),
+            "Sigma;".toCharArray(), "SmallCircle;".toCharArray(),
+            "Sopf;".toCharArray(), "Sqrt;".toCharArray(),
+            "Square;".toCharArray(), "SquareIntersection;".toCharArray(),
+            "SquareSubset;".toCharArray(), "SquareSubsetEqual;".toCharArray(),
+            "SquareSuperset;".toCharArray(),
+            "SquareSupersetEqual;".toCharArray(), "SquareUnion;".toCharArray(),
+            "Sscr;".toCharArray(), "Star;".toCharArray(), "Sub;".toCharArray(),
+            "Subset;".toCharArray(), "SubsetEqual;".toCharArray(),
+            "Succeeds;".toCharArray(), "SucceedsEqual;".toCharArray(),
+            "SucceedsSlantEqual;".toCharArray(),
+            "SucceedsTilde;".toCharArray(), "SuchThat;".toCharArray(),
+            "Sum;".toCharArray(), "Sup;".toCharArray(),
+            "Superset;".toCharArray(), "SupersetEqual;".toCharArray(),
+            "Supset;".toCharArray(), "THORN".toCharArray(),
+            "THORN;".toCharArray(), "TRADE;".toCharArray(),
+            "TSHcy;".toCharArray(), "TScy;".toCharArray(),
+            "Tab;".toCharArray(), "Tau;".toCharArray(),
+            "Tcaron;".toCharArray(), "Tcedil;".toCharArray(),
+            "Tcy;".toCharArray(), "Tfr;".toCharArray(),
+            "Therefore;".toCharArray(), "Theta;".toCharArray(),
+            "ThinSpace;".toCharArray(), "Tilde;".toCharArray(),
+            "TildeEqual;".toCharArray(), "TildeFullEqual;".toCharArray(),
+            "TildeTilde;".toCharArray(), "Topf;".toCharArray(),
+            "TripleDot;".toCharArray(), "Tscr;".toCharArray(),
+            "Tstrok;".toCharArray(), "Uacute".toCharArray(),
+            "Uacute;".toCharArray(), "Uarr;".toCharArray(),
+            "Uarrocir;".toCharArray(), "Ubrcy;".toCharArray(),
+            "Ubreve;".toCharArray(), "Ucirc".toCharArray(),
+            "Ucirc;".toCharArray(), "Ucy;".toCharArray(),
+            "Udblac;".toCharArray(), "Ufr;".toCharArray(),
+            "Ugrave".toCharArray(), "Ugrave;".toCharArray(),
+            "Umacr;".toCharArray(), "UnderBar;".toCharArray(),
+            "UnderBrace;".toCharArray(), "UnderBracket;".toCharArray(),
+            "UnderParenthesis;".toCharArray(), "Union;".toCharArray(),
+            "UnionPlus;".toCharArray(), "Uogon;".toCharArray(),
+            "Uopf;".toCharArray(), "UpArrow;".toCharArray(),
+            "UpArrowBar;".toCharArray(), "UpArrowDownArrow;".toCharArray(),
+            "UpDownArrow;".toCharArray(), "UpEquilibrium;".toCharArray(),
+            "UpTee;".toCharArray(), "UpTeeArrow;".toCharArray(),
+            "Uparrow;".toCharArray(), "Updownarrow;".toCharArray(),
+            "UpperLeftArrow;".toCharArray(), "UpperRightArrow;".toCharArray(),
+            "Upsi;".toCharArray(), "Upsilon;".toCharArray(),
+            "Uring;".toCharArray(), "Uscr;".toCharArray(),
+            "Utilde;".toCharArray(), "Uuml".toCharArray(),
+            "Uuml;".toCharArray(), "VDash;".toCharArray(),
+            "Vbar;".toCharArray(), "Vcy;".toCharArray(),
+            "Vdash;".toCharArray(), "Vdashl;".toCharArray(),
+            "Vee;".toCharArray(), "Verbar;".toCharArray(),
+            "Vert;".toCharArray(), "VerticalBar;".toCharArray(),
+            "VerticalLine;".toCharArray(), "VerticalSeparator;".toCharArray(),
+            "VerticalTilde;".toCharArray(), "VeryThinSpace;".toCharArray(),
+            "Vfr;".toCharArray(), "Vopf;".toCharArray(), "Vscr;".toCharArray(),
+            "Vvdash;".toCharArray(), "Wcirc;".toCharArray(),
+            "Wedge;".toCharArray(), "Wfr;".toCharArray(),
+            "Wopf;".toCharArray(), "Wscr;".toCharArray(), "Xfr;".toCharArray(),
+            "Xi;".toCharArray(), "Xopf;".toCharArray(), "Xscr;".toCharArray(),
+            "YAcy;".toCharArray(), "YIcy;".toCharArray(),
+            "YUcy;".toCharArray(), "Yacute".toCharArray(),
+            "Yacute;".toCharArray(), "Ycirc;".toCharArray(),
+            "Ycy;".toCharArray(), "Yfr;".toCharArray(), "Yopf;".toCharArray(),
+            "Yscr;".toCharArray(), "Yuml;".toCharArray(),
+            "ZHcy;".toCharArray(), "Zacute;".toCharArray(),
+            "Zcaron;".toCharArray(), "Zcy;".toCharArray(),
+            "Zdot;".toCharArray(), "ZeroWidthSpace;".toCharArray(),
+            "Zeta;".toCharArray(), "Zfr;".toCharArray(), "Zopf;".toCharArray(),
+            "Zscr;".toCharArray(), "aacute".toCharArray(),
+            "aacute;".toCharArray(), "abreve;".toCharArray(),
+            "ac;".toCharArray(), "acd;".toCharArray(), "acirc".toCharArray(),
+            "acirc;".toCharArray(), "acute".toCharArray(),
+            "acute;".toCharArray(), "acy;".toCharArray(),
+            "aelig".toCharArray(), "aelig;".toCharArray(), "af;".toCharArray(),
+            "afr;".toCharArray(), "agrave".toCharArray(),
+            "agrave;".toCharArray(), "alefsym;".toCharArray(),
+            "aleph;".toCharArray(), "alpha;".toCharArray(),
+            "amacr;".toCharArray(), "amalg;".toCharArray(),
+            "amp".toCharArray(), "amp;".toCharArray(), "and;".toCharArray(),
+            "andand;".toCharArray(), "andd;".toCharArray(),
+            "andslope;".toCharArray(), "andv;".toCharArray(),
+            "ang;".toCharArray(), "ange;".toCharArray(),
+            "angle;".toCharArray(), "angmsd;".toCharArray(),
+            "angmsdaa;".toCharArray(), "angmsdab;".toCharArray(),
+            "angmsdac;".toCharArray(), "angmsdad;".toCharArray(),
+            "angmsdae;".toCharArray(), "angmsdaf;".toCharArray(),
+            "angmsdag;".toCharArray(), "angmsdah;".toCharArray(),
+            "angrt;".toCharArray(), "angrtvb;".toCharArray(),
+            "angrtvbd;".toCharArray(), "angsph;".toCharArray(),
+            "angst;".toCharArray(), "angzarr;".toCharArray(),
+            "aogon;".toCharArray(), "aopf;".toCharArray(), "ap;".toCharArray(),
+            "apE;".toCharArray(), "apacir;".toCharArray(),
+            "ape;".toCharArray(), "apid;".toCharArray(), "apos;".toCharArray(),
+            "approx;".toCharArray(), "approxeq;".toCharArray(),
+            "aring".toCharArray(), "aring;".toCharArray(),
+            "ascr;".toCharArray(), "ast;".toCharArray(),
+            "asymp;".toCharArray(), "asympeq;".toCharArray(),
+            "atilde".toCharArray(), "atilde;".toCharArray(),
+            "auml".toCharArray(), "auml;".toCharArray(),
+            "awconint;".toCharArray(), "awint;".toCharArray(),
+            "bNot;".toCharArray(), "backcong;".toCharArray(),
+            "backepsilon;".toCharArray(), "backprime;".toCharArray(),
+            "backsim;".toCharArray(), "backsimeq;".toCharArray(),
+            "barvee;".toCharArray(), "barwed;".toCharArray(),
+            "barwedge;".toCharArray(), "bbrk;".toCharArray(),
+            "bbrktbrk;".toCharArray(), "bcong;".toCharArray(),
+            "bcy;".toCharArray(), "bdquo;".toCharArray(),
+            "becaus;".toCharArray(), "because;".toCharArray(),
+            "bemptyv;".toCharArray(), "bepsi;".toCharArray(),
+            "bernou;".toCharArray(), "beta;".toCharArray(),
+            "beth;".toCharArray(), "between;".toCharArray(),
+            "bfr;".toCharArray(), "bigcap;".toCharArray(),
+            "bigcirc;".toCharArray(), "bigcup;".toCharArray(),
+            "bigodot;".toCharArray(), "bigoplus;".toCharArray(),
+            "bigotimes;".toCharArray(), "bigsqcup;".toCharArray(),
+            "bigstar;".toCharArray(), "bigtriangledown;".toCharArray(),
+            "bigtriangleup;".toCharArray(), "biguplus;".toCharArray(),
+            "bigvee;".toCharArray(), "bigwedge;".toCharArray(),
+            "bkarow;".toCharArray(), "blacklozenge;".toCharArray(),
+            "blacksquare;".toCharArray(), "blacktriangle;".toCharArray(),
+            "blacktriangledown;".toCharArray(),
+            "blacktriangleleft;".toCharArray(),
+            "blacktriangleright;".toCharArray(), "blank;".toCharArray(),
+            "blk12;".toCharArray(), "blk14;".toCharArray(),
+            "blk34;".toCharArray(), "block;".toCharArray(),
+            "bnot;".toCharArray(), "bopf;".toCharArray(), "bot;".toCharArray(),
+            "bottom;".toCharArray(), "bowtie;".toCharArray(),
+            "boxDL;".toCharArray(), "boxDR;".toCharArray(),
+            "boxDl;".toCharArray(), "boxDr;".toCharArray(),
+            "boxH;".toCharArray(), "boxHD;".toCharArray(),
+            "boxHU;".toCharArray(), "boxHd;".toCharArray(),
+            "boxHu;".toCharArray(), "boxUL;".toCharArray(),
+            "boxUR;".toCharArray(), "boxUl;".toCharArray(),
+            "boxUr;".toCharArray(), "boxV;".toCharArray(),
+            "boxVH;".toCharArray(), "boxVL;".toCharArray(),
+            "boxVR;".toCharArray(), "boxVh;".toCharArray(),
+            "boxVl;".toCharArray(), "boxVr;".toCharArray(),
+            "boxbox;".toCharArray(), "boxdL;".toCharArray(),
+            "boxdR;".toCharArray(), "boxdl;".toCharArray(),
+            "boxdr;".toCharArray(), "boxh;".toCharArray(),
+            "boxhD;".toCharArray(), "boxhU;".toCharArray(),
+            "boxhd;".toCharArray(), "boxhu;".toCharArray(),
+            "boxminus;".toCharArray(), "boxplus;".toCharArray(),
+            "boxtimes;".toCharArray(), "boxuL;".toCharArray(),
+            "boxuR;".toCharArray(), "boxul;".toCharArray(),
+            "boxur;".toCharArray(), "boxv;".toCharArray(),
+            "boxvH;".toCharArray(), "boxvL;".toCharArray(),
+            "boxvR;".toCharArray(), "boxvh;".toCharArray(),
+            "boxvl;".toCharArray(), "boxvr;".toCharArray(),
+            "bprime;".toCharArray(), "breve;".toCharArray(),
+            "brvbar".toCharArray(), "brvbar;".toCharArray(),
+            "bscr;".toCharArray(), "bsemi;".toCharArray(),
+            "bsim;".toCharArray(), "bsime;".toCharArray(),
+            "bsol;".toCharArray(), "bsolb;".toCharArray(),
+            "bull;".toCharArray(), "bullet;".toCharArray(),
+            "bump;".toCharArray(), "bumpE;".toCharArray(),
+            "bumpe;".toCharArray(), "bumpeq;".toCharArray(),
+            "cacute;".toCharArray(), "cap;".toCharArray(),
+            "capand;".toCharArray(), "capbrcup;".toCharArray(),
+            "capcap;".toCharArray(), "capcup;".toCharArray(),
+            "capdot;".toCharArray(), "caret;".toCharArray(),
+            "caron;".toCharArray(), "ccaps;".toCharArray(),
+            "ccaron;".toCharArray(), "ccedil".toCharArray(),
+            "ccedil;".toCharArray(), "ccirc;".toCharArray(),
+            "ccups;".toCharArray(), "ccupssm;".toCharArray(),
+            "cdot;".toCharArray(), "cedil".toCharArray(),
+            "cedil;".toCharArray(), "cemptyv;".toCharArray(),
+            "cent".toCharArray(), "cent;".toCharArray(),
+            "centerdot;".toCharArray(), "cfr;".toCharArray(),
+            "chcy;".toCharArray(), "check;".toCharArray(),
+            "checkmark;".toCharArray(), "chi;".toCharArray(),
+            "cir;".toCharArray(), "cirE;".toCharArray(), "circ;".toCharArray(),
+            "circeq;".toCharArray(), "circlearrowleft;".toCharArray(),
+            "circlearrowright;".toCharArray(), "circledR;".toCharArray(),
+            "circledS;".toCharArray(), "circledast;".toCharArray(),
+            "circledcirc;".toCharArray(), "circleddash;".toCharArray(),
+            "cire;".toCharArray(), "cirfnint;".toCharArray(),
+            "cirmid;".toCharArray(), "cirscir;".toCharArray(),
+            "clubs;".toCharArray(), "clubsuit;".toCharArray(),
+            "colon;".toCharArray(), "colone;".toCharArray(),
+            "coloneq;".toCharArray(), "comma;".toCharArray(),
+            "commat;".toCharArray(), "comp;".toCharArray(),
+            "compfn;".toCharArray(), "complement;".toCharArray(),
+            "complexes;".toCharArray(), "cong;".toCharArray(),
+            "congdot;".toCharArray(), "conint;".toCharArray(),
+            "copf;".toCharArray(), "coprod;".toCharArray(),
+            "copy".toCharArray(), "copy;".toCharArray(),
+            "copysr;".toCharArray(), "crarr;".toCharArray(),
+            "cross;".toCharArray(), "cscr;".toCharArray(),
+            "csub;".toCharArray(), "csube;".toCharArray(),
+            "csup;".toCharArray(), "csupe;".toCharArray(),
+            "ctdot;".toCharArray(), "cudarrl;".toCharArray(),
+            "cudarrr;".toCharArray(), "cuepr;".toCharArray(),
+            "cuesc;".toCharArray(), "cularr;".toCharArray(),
+            "cularrp;".toCharArray(), "cup;".toCharArray(),
+            "cupbrcap;".toCharArray(), "cupcap;".toCharArray(),
+            "cupcup;".toCharArray(), "cupdot;".toCharArray(),
+            "cupor;".toCharArray(), "curarr;".toCharArray(),
+            "curarrm;".toCharArray(), "curlyeqprec;".toCharArray(),
+            "curlyeqsucc;".toCharArray(), "curlyvee;".toCharArray(),
+            "curlywedge;".toCharArray(), "curren".toCharArray(),
+            "curren;".toCharArray(), "curvearrowleft;".toCharArray(),
+            "curvearrowright;".toCharArray(), "cuvee;".toCharArray(),
+            "cuwed;".toCharArray(), "cwconint;".toCharArray(),
+            "cwint;".toCharArray(), "cylcty;".toCharArray(),
+            "dArr;".toCharArray(), "dHar;".toCharArray(),
+            "dagger;".toCharArray(), "daleth;".toCharArray(),
+            "darr;".toCharArray(), "dash;".toCharArray(),
+            "dashv;".toCharArray(), "dbkarow;".toCharArray(),
+            "dblac;".toCharArray(), "dcaron;".toCharArray(),
+            "dcy;".toCharArray(), "dd;".toCharArray(),
+            "ddagger;".toCharArray(), "ddarr;".toCharArray(),
+            "ddotseq;".toCharArray(), "deg".toCharArray(),
+            "deg;".toCharArray(), "delta;".toCharArray(),
+            "demptyv;".toCharArray(), "dfisht;".toCharArray(),
+            "dfr;".toCharArray(), "dharl;".toCharArray(),
+            "dharr;".toCharArray(), "diam;".toCharArray(),
+            "diamond;".toCharArray(), "diamondsuit;".toCharArray(),
+            "diams;".toCharArray(), "die;".toCharArray(),
+            "digamma;".toCharArray(), "disin;".toCharArray(),
+            "div;".toCharArray(), "divide".toCharArray(),
+            "divide;".toCharArray(), "divideontimes;".toCharArray(),
+            "divonx;".toCharArray(), "djcy;".toCharArray(),
+            "dlcorn;".toCharArray(), "dlcrop;".toCharArray(),
+            "dollar;".toCharArray(), "dopf;".toCharArray(),
+            "dot;".toCharArray(), "doteq;".toCharArray(),
+            "doteqdot;".toCharArray(), "dotminus;".toCharArray(),
+            "dotplus;".toCharArray(), "dotsquare;".toCharArray(),
+            "doublebarwedge;".toCharArray(), "downarrow;".toCharArray(),
+            "downdownarrows;".toCharArray(), "downharpoonleft;".toCharArray(),
+            "downharpoonright;".toCharArray(), "drbkarow;".toCharArray(),
+            "drcorn;".toCharArray(), "drcrop;".toCharArray(),
+            "dscr;".toCharArray(), "dscy;".toCharArray(),
+            "dsol;".toCharArray(), "dstrok;".toCharArray(),
+            "dtdot;".toCharArray(), "dtri;".toCharArray(),
+            "dtrif;".toCharArray(), "duarr;".toCharArray(),
+            "duhar;".toCharArray(), "dwangle;".toCharArray(),
+            "dzcy;".toCharArray(), "dzigrarr;".toCharArray(),
+            "eDDot;".toCharArray(), "eDot;".toCharArray(),
+            "eacute".toCharArray(), "eacute;".toCharArray(),
+            "easter;".toCharArray(), "ecaron;".toCharArray(),
+            "ecir;".toCharArray(), "ecirc".toCharArray(),
+            "ecirc;".toCharArray(), "ecolon;".toCharArray(),
+            "ecy;".toCharArray(), "edot;".toCharArray(), "ee;".toCharArray(),
+            "efDot;".toCharArray(), "efr;".toCharArray(), "eg;".toCharArray(),
+            "egrave".toCharArray(), "egrave;".toCharArray(),
+            "egs;".toCharArray(), "egsdot;".toCharArray(), "el;".toCharArray(),
+            "elinters;".toCharArray(), "ell;".toCharArray(),
+            "els;".toCharArray(), "elsdot;".toCharArray(),
+            "emacr;".toCharArray(), "empty;".toCharArray(),
+            "emptyset;".toCharArray(), "emptyv;".toCharArray(),
+            "emsp13;".toCharArray(), "emsp14;".toCharArray(),
+            "emsp;".toCharArray(), "eng;".toCharArray(), "ensp;".toCharArray(),
+            "eogon;".toCharArray(), "eopf;".toCharArray(),
+            "epar;".toCharArray(), "eparsl;".toCharArray(),
+            "eplus;".toCharArray(), "epsi;".toCharArray(),
+            "epsilon;".toCharArray(), "epsiv;".toCharArray(),
+            "eqcirc;".toCharArray(), "eqcolon;".toCharArray(),
+            "eqsim;".toCharArray(), "eqslantgtr;".toCharArray(),
+            "eqslantless;".toCharArray(), "equals;".toCharArray(),
+            "equest;".toCharArray(), "equiv;".toCharArray(),
+            "equivDD;".toCharArray(), "eqvparsl;".toCharArray(),
+            "erDot;".toCharArray(), "erarr;".toCharArray(),
+            "escr;".toCharArray(), "esdot;".toCharArray(),
+            "esim;".toCharArray(), "eta;".toCharArray(), "eth".toCharArray(),
+            "eth;".toCharArray(), "euml".toCharArray(), "euml;".toCharArray(),
+            "euro;".toCharArray(), "excl;".toCharArray(),
+            "exist;".toCharArray(), "expectation;".toCharArray(),
+            "exponentiale;".toCharArray(), "fallingdotseq;".toCharArray(),
+            "fcy;".toCharArray(), "female;".toCharArray(),
+            "ffilig;".toCharArray(), "fflig;".toCharArray(),
+            "ffllig;".toCharArray(), "ffr;".toCharArray(),
+            "filig;".toCharArray(), "flat;".toCharArray(),
+            "fllig;".toCharArray(), "fltns;".toCharArray(),
+            "fnof;".toCharArray(), "fopf;".toCharArray(),
+            "forall;".toCharArray(), "fork;".toCharArray(),
+            "forkv;".toCharArray(), "fpartint;".toCharArray(),
+            "frac12".toCharArray(), "frac12;".toCharArray(),
+            "frac13;".toCharArray(), "frac14".toCharArray(),
+            "frac14;".toCharArray(), "frac15;".toCharArray(),
+            "frac16;".toCharArray(), "frac18;".toCharArray(),
+            "frac23;".toCharArray(), "frac25;".toCharArray(),
+            "frac34".toCharArray(), "frac34;".toCharArray(),
+            "frac35;".toCharArray(), "frac38;".toCharArray(),
+            "frac45;".toCharArray(), "frac56;".toCharArray(),
+            "frac58;".toCharArray(), "frac78;".toCharArray(),
+            "frasl;".toCharArray(), "frown;".toCharArray(),
+            "fscr;".toCharArray(), "gE;".toCharArray(), "gEl;".toCharArray(),
+            "gacute;".toCharArray(), "gamma;".toCharArray(),
+            "gammad;".toCharArray(), "gap;".toCharArray(),
+            "gbreve;".toCharArray(), "gcirc;".toCharArray(),
+            "gcy;".toCharArray(), "gdot;".toCharArray(), "ge;".toCharArray(),
+            "gel;".toCharArray(), "geq;".toCharArray(), "geqq;".toCharArray(),
+            "geqslant;".toCharArray(), "ges;".toCharArray(),
+            "gescc;".toCharArray(), "gesdot;".toCharArray(),
+            "gesdoto;".toCharArray(), "gesdotol;".toCharArray(),
+            "gesles;".toCharArray(), "gfr;".toCharArray(), "gg;".toCharArray(),
+            "ggg;".toCharArray(), "gimel;".toCharArray(),
+            "gjcy;".toCharArray(), "gl;".toCharArray(), "glE;".toCharArray(),
+            "gla;".toCharArray(), "glj;".toCharArray(), "gnE;".toCharArray(),
+            "gnap;".toCharArray(), "gnapprox;".toCharArray(),
+            "gne;".toCharArray(), "gneq;".toCharArray(),
+            "gneqq;".toCharArray(), "gnsim;".toCharArray(),
+            "gopf;".toCharArray(), "grave;".toCharArray(),
+            "gscr;".toCharArray(), "gsim;".toCharArray(),
+            "gsime;".toCharArray(), "gsiml;".toCharArray(), "gt".toCharArray(),
+            "gt;".toCharArray(), "gtcc;".toCharArray(), "gtcir;".toCharArray(),
+            "gtdot;".toCharArray(), "gtlPar;".toCharArray(),
+            "gtquest;".toCharArray(), "gtrapprox;".toCharArray(),
+            "gtrarr;".toCharArray(), "gtrdot;".toCharArray(),
+            "gtreqless;".toCharArray(), "gtreqqless;".toCharArray(),
+            "gtrless;".toCharArray(), "gtrsim;".toCharArray(),
+            "hArr;".toCharArray(), "hairsp;".toCharArray(),
+            "half;".toCharArray(), "hamilt;".toCharArray(),
+            "hardcy;".toCharArray(), "harr;".toCharArray(),
+            "harrcir;".toCharArray(), "harrw;".toCharArray(),
+            "hbar;".toCharArray(), "hcirc;".toCharArray(),
+            "hearts;".toCharArray(), "heartsuit;".toCharArray(),
+            "hellip;".toCharArray(), "hercon;".toCharArray(),
+            "hfr;".toCharArray(), "hksearow;".toCharArray(),
+            "hkswarow;".toCharArray(), "hoarr;".toCharArray(),
+            "homtht;".toCharArray(), "hookleftarrow;".toCharArray(),
+            "hookrightarrow;".toCharArray(), "hopf;".toCharArray(),
+            "horbar;".toCharArray(), "hscr;".toCharArray(),
+            "hslash;".toCharArray(), "hstrok;".toCharArray(),
+            "hybull;".toCharArray(), "hyphen;".toCharArray(),
+            "iacute".toCharArray(), "iacute;".toCharArray(),
+            "ic;".toCharArray(), "icirc".toCharArray(), "icirc;".toCharArray(),
+            "icy;".toCharArray(), "iecy;".toCharArray(), "iexcl".toCharArray(),
+            "iexcl;".toCharArray(), "iff;".toCharArray(), "ifr;".toCharArray(),
+            "igrave".toCharArray(), "igrave;".toCharArray(),
+            "ii;".toCharArray(), "iiiint;".toCharArray(),
+            "iiint;".toCharArray(), "iinfin;".toCharArray(),
+            "iiota;".toCharArray(), "ijlig;".toCharArray(),
+            "imacr;".toCharArray(), "image;".toCharArray(),
+            "imagline;".toCharArray(), "imagpart;".toCharArray(),
+            "imath;".toCharArray(), "imof;".toCharArray(),
+            "imped;".toCharArray(), "in;".toCharArray(),
+            "incare;".toCharArray(), "infin;".toCharArray(),
+            "infintie;".toCharArray(), "inodot;".toCharArray(),
+            "int;".toCharArray(), "intcal;".toCharArray(),
+            "integers;".toCharArray(), "intercal;".toCharArray(),
+            "intlarhk;".toCharArray(), "intprod;".toCharArray(),
+            "iocy;".toCharArray(), "iogon;".toCharArray(),
+            "iopf;".toCharArray(), "iota;".toCharArray(),
+            "iprod;".toCharArray(), "iquest".toCharArray(),
+            "iquest;".toCharArray(), "iscr;".toCharArray(),
+            "isin;".toCharArray(), "isinE;".toCharArray(),
+            "isindot;".toCharArray(), "isins;".toCharArray(),
+            "isinsv;".toCharArray(), "isinv;".toCharArray(),
+            "it;".toCharArray(), "itilde;".toCharArray(),
+            "iukcy;".toCharArray(), "iuml".toCharArray(),
+            "iuml;".toCharArray(), "jcirc;".toCharArray(),
+            "jcy;".toCharArray(), "jfr;".toCharArray(), "jmath;".toCharArray(),
+            "jopf;".toCharArray(), "jscr;".toCharArray(),
+            "jsercy;".toCharArray(), "jukcy;".toCharArray(),
+            "kappa;".toCharArray(), "kappav;".toCharArray(),
+            "kcedil;".toCharArray(), "kcy;".toCharArray(),
+            "kfr;".toCharArray(), "kgreen;".toCharArray(),
+            "khcy;".toCharArray(), "kjcy;".toCharArray(),
+            "kopf;".toCharArray(), "kscr;".toCharArray(),
+            "lAarr;".toCharArray(), "lArr;".toCharArray(),
+            "lAtail;".toCharArray(), "lBarr;".toCharArray(),
+            "lE;".toCharArray(), "lEg;".toCharArray(), "lHar;".toCharArray(),
+            "lacute;".toCharArray(), "laemptyv;".toCharArray(),
+            "lagran;".toCharArray(), "lambda;".toCharArray(),
+            "lang;".toCharArray(), "langd;".toCharArray(),
+            "langle;".toCharArray(), "lap;".toCharArray(),
+            "laquo".toCharArray(), "laquo;".toCharArray(),
+            "larr;".toCharArray(), "larrb;".toCharArray(),
+            "larrbfs;".toCharArray(), "larrfs;".toCharArray(),
+            "larrhk;".toCharArray(), "larrlp;".toCharArray(),
+            "larrpl;".toCharArray(), "larrsim;".toCharArray(),
+            "larrtl;".toCharArray(), "lat;".toCharArray(),
+            "latail;".toCharArray(), "late;".toCharArray(),
+            "lbarr;".toCharArray(), "lbbrk;".toCharArray(),
+            "lbrace;".toCharArray(), "lbrack;".toCharArray(),
+            "lbrke;".toCharArray(), "lbrksld;".toCharArray(),
+            "lbrkslu;".toCharArray(), "lcaron;".toCharArray(),
+            "lcedil;".toCharArray(), "lceil;".toCharArray(),
+            "lcub;".toCharArray(), "lcy;".toCharArray(), "ldca;".toCharArray(),
+            "ldquo;".toCharArray(), "ldquor;".toCharArray(),
+            "ldrdhar;".toCharArray(), "ldrushar;".toCharArray(),
+            "ldsh;".toCharArray(), "le;".toCharArray(),
+            "leftarrow;".toCharArray(), "leftarrowtail;".toCharArray(),
+            "leftharpoondown;".toCharArray(), "leftharpoonup;".toCharArray(),
+            "leftleftarrows;".toCharArray(), "leftrightarrow;".toCharArray(),
+            "leftrightarrows;".toCharArray(),
+            "leftrightharpoons;".toCharArray(),
+            "leftrightsquigarrow;".toCharArray(),
+            "leftthreetimes;".toCharArray(), "leg;".toCharArray(),
+            "leq;".toCharArray(), "leqq;".toCharArray(),
+            "leqslant;".toCharArray(), "les;".toCharArray(),
+            "lescc;".toCharArray(), "lesdot;".toCharArray(),
+            "lesdoto;".toCharArray(), "lesdotor;".toCharArray(),
+            "lesges;".toCharArray(), "lessapprox;".toCharArray(),
+            "lessdot;".toCharArray(), "lesseqgtr;".toCharArray(),
+            "lesseqqgtr;".toCharArray(), "lessgtr;".toCharArray(),
+            "lesssim;".toCharArray(), "lfisht;".toCharArray(),
+            "lfloor;".toCharArray(), "lfr;".toCharArray(), "lg;".toCharArray(),
+            "lgE;".toCharArray(), "lhard;".toCharArray(),
+            "lharu;".toCharArray(), "lharul;".toCharArray(),
+            "lhblk;".toCharArray(), "ljcy;".toCharArray(), "ll;".toCharArray(),
+            "llarr;".toCharArray(), "llcorner;".toCharArray(),
+            "llhard;".toCharArray(), "lltri;".toCharArray(),
+            "lmidot;".toCharArray(), "lmoust;".toCharArray(),
+            "lmoustache;".toCharArray(), "lnE;".toCharArray(),
+            "lnap;".toCharArray(), "lnapprox;".toCharArray(),
+            "lne;".toCharArray(), "lneq;".toCharArray(),
+            "lneqq;".toCharArray(), "lnsim;".toCharArray(),
+            "loang;".toCharArray(), "loarr;".toCharArray(),
+            "lobrk;".toCharArray(), "longleftarrow;".toCharArray(),
+            "longleftrightarrow;".toCharArray(), "longmapsto;".toCharArray(),
+            "longrightarrow;".toCharArray(), "looparrowleft;".toCharArray(),
+            "looparrowright;".toCharArray(), "lopar;".toCharArray(),
+            "lopf;".toCharArray(), "loplus;".toCharArray(),
+            "lotimes;".toCharArray(), "lowast;".toCharArray(),
+            "lowbar;".toCharArray(), "loz;".toCharArray(),
+            "lozenge;".toCharArray(), "lozf;".toCharArray(),
+            "lpar;".toCharArray(), "lparlt;".toCharArray(),
+            "lrarr;".toCharArray(), "lrcorner;".toCharArray(),
+            "lrhar;".toCharArray(), "lrhard;".toCharArray(),
+            "lrm;".toCharArray(), "lrtri;".toCharArray(),
+            "lsaquo;".toCharArray(), "lscr;".toCharArray(),
+            "lsh;".toCharArray(), "lsim;".toCharArray(),
+            "lsime;".toCharArray(), "lsimg;".toCharArray(),
+            "lsqb;".toCharArray(), "lsquo;".toCharArray(),
+            "lsquor;".toCharArray(), "lstrok;".toCharArray(),
+            "lt".toCharArray(), "lt;".toCharArray(), "ltcc;".toCharArray(),
+            "ltcir;".toCharArray(), "ltdot;".toCharArray(),
+            "lthree;".toCharArray(), "ltimes;".toCharArray(),
+            "ltlarr;".toCharArray(), "ltquest;".toCharArray(),
+            "ltrPar;".toCharArray(), "ltri;".toCharArray(),
+            "ltrie;".toCharArray(), "ltrif;".toCharArray(),
+            "lurdshar;".toCharArray(), "luruhar;".toCharArray(),
+            "mDDot;".toCharArray(), "macr".toCharArray(),
+            "macr;".toCharArray(), "male;".toCharArray(),
+            "malt;".toCharArray(), "maltese;".toCharArray(),
+            "map;".toCharArray(), "mapsto;".toCharArray(),
+            "mapstodown;".toCharArray(), "mapstoleft;".toCharArray(),
+            "mapstoup;".toCharArray(), "marker;".toCharArray(),
+            "mcomma;".toCharArray(), "mcy;".toCharArray(),
+            "mdash;".toCharArray(), "measuredangle;".toCharArray(),
+            "mfr;".toCharArray(), "mho;".toCharArray(), "micro".toCharArray(),
+            "micro;".toCharArray(), "mid;".toCharArray(),
+            "midast;".toCharArray(), "midcir;".toCharArray(),
+            "middot".toCharArray(), "middot;".toCharArray(),
+            "minus;".toCharArray(), "minusb;".toCharArray(),
+            "minusd;".toCharArray(), "minusdu;".toCharArray(),
+            "mlcp;".toCharArray(), "mldr;".toCharArray(),
+            "mnplus;".toCharArray(), "models;".toCharArray(),
+            "mopf;".toCharArray(), "mp;".toCharArray(), "mscr;".toCharArray(),
+            "mstpos;".toCharArray(), "mu;".toCharArray(),
+            "multimap;".toCharArray(), "mumap;".toCharArray(),
+            "nLeftarrow;".toCharArray(), "nLeftrightarrow;".toCharArray(),
+            "nRightarrow;".toCharArray(), "nVDash;".toCharArray(),
+            "nVdash;".toCharArray(), "nabla;".toCharArray(),
+            "nacute;".toCharArray(), "nap;".toCharArray(),
+            "napos;".toCharArray(), "napprox;".toCharArray(),
+            "natur;".toCharArray(), "natural;".toCharArray(),
+            "naturals;".toCharArray(), "nbsp".toCharArray(),
+            "nbsp;".toCharArray(), "ncap;".toCharArray(),
+            "ncaron;".toCharArray(), "ncedil;".toCharArray(),
+            "ncong;".toCharArray(), "ncup;".toCharArray(),
+            "ncy;".toCharArray(), "ndash;".toCharArray(), "ne;".toCharArray(),
+            "neArr;".toCharArray(), "nearhk;".toCharArray(),
+            "nearr;".toCharArray(), "nearrow;".toCharArray(),
+            "nequiv;".toCharArray(), "nesear;".toCharArray(),
+            "nexist;".toCharArray(), "nexists;".toCharArray(),
+            "nfr;".toCharArray(), "nge;".toCharArray(), "ngeq;".toCharArray(),
+            "ngsim;".toCharArray(), "ngt;".toCharArray(),
+            "ngtr;".toCharArray(), "nhArr;".toCharArray(),
+            "nharr;".toCharArray(), "nhpar;".toCharArray(),
+            "ni;".toCharArray(), "nis;".toCharArray(), "nisd;".toCharArray(),
+            "niv;".toCharArray(), "njcy;".toCharArray(),
+            "nlArr;".toCharArray(), "nlarr;".toCharArray(),
+            "nldr;".toCharArray(), "nle;".toCharArray(),
+            "nleftarrow;".toCharArray(), "nleftrightarrow;".toCharArray(),
+            "nleq;".toCharArray(), "nless;".toCharArray(),
+            "nlsim;".toCharArray(), "nlt;".toCharArray(),
+            "nltri;".toCharArray(), "nltrie;".toCharArray(),
+            "nmid;".toCharArray(), "nopf;".toCharArray(), "not".toCharArray(),
+            "not;".toCharArray(), "notin;".toCharArray(),
+            "notinva;".toCharArray(), "notinvb;".toCharArray(),
+            "notinvc;".toCharArray(), "notni;".toCharArray(),
+            "notniva;".toCharArray(), "notnivb;".toCharArray(),
+            "notnivc;".toCharArray(), "npar;".toCharArray(),
+            "nparallel;".toCharArray(), "npolint;".toCharArray(),
+            "npr;".toCharArray(), "nprcue;".toCharArray(),
+            "nprec;".toCharArray(), "nrArr;".toCharArray(),
+            "nrarr;".toCharArray(), "nrightarrow;".toCharArray(),
+            "nrtri;".toCharArray(), "nrtrie;".toCharArray(),
+            "nsc;".toCharArray(), "nsccue;".toCharArray(),
+            "nscr;".toCharArray(), "nshortmid;".toCharArray(),
+            "nshortparallel;".toCharArray(), "nsim;".toCharArray(),
+            "nsime;".toCharArray(), "nsimeq;".toCharArray(),
+            "nsmid;".toCharArray(), "nspar;".toCharArray(),
+            "nsqsube;".toCharArray(), "nsqsupe;".toCharArray(),
+            "nsub;".toCharArray(), "nsube;".toCharArray(),
+            "nsubseteq;".toCharArray(), "nsucc;".toCharArray(),
+            "nsup;".toCharArray(), "nsupe;".toCharArray(),
+            "nsupseteq;".toCharArray(), "ntgl;".toCharArray(),
+            "ntilde".toCharArray(), "ntilde;".toCharArray(),
+            "ntlg;".toCharArray(), "ntriangleleft;".toCharArray(),
+            "ntrianglelefteq;".toCharArray(), "ntriangleright;".toCharArray(),
+            "ntrianglerighteq;".toCharArray(), "nu;".toCharArray(),
+            "num;".toCharArray(), "numero;".toCharArray(),
+            "numsp;".toCharArray(), "nvDash;".toCharArray(),
+            "nvHarr;".toCharArray(), "nvdash;".toCharArray(),
+            "nvinfin;".toCharArray(), "nvlArr;".toCharArray(),
+            "nvrArr;".toCharArray(), "nwArr;".toCharArray(),
+            "nwarhk;".toCharArray(), "nwarr;".toCharArray(),
+            "nwarrow;".toCharArray(), "nwnear;".toCharArray(),
+            "oS;".toCharArray(), "oacute".toCharArray(),
+            "oacute;".toCharArray(), "oast;".toCharArray(),
+            "ocir;".toCharArray(), "ocirc".toCharArray(),
+            "ocirc;".toCharArray(), "ocy;".toCharArray(),
+            "odash;".toCharArray(), "odblac;".toCharArray(),
+            "odiv;".toCharArray(), "odot;".toCharArray(),
+            "odsold;".toCharArray(), "oelig;".toCharArray(),
+            "ofcir;".toCharArray(), "ofr;".toCharArray(),
+            "ogon;".toCharArray(), "ograve".toCharArray(),
+            "ograve;".toCharArray(), "ogt;".toCharArray(),
+            "ohbar;".toCharArray(), "ohm;".toCharArray(),
+            "oint;".toCharArray(), "olarr;".toCharArray(),
+            "olcir;".toCharArray(), "olcross;".toCharArray(),
+            "oline;".toCharArray(), "olt;".toCharArray(),
+            "omacr;".toCharArray(), "omega;".toCharArray(),
+            "omicron;".toCharArray(), "omid;".toCharArray(),
+            "ominus;".toCharArray(), "oopf;".toCharArray(),
+            "opar;".toCharArray(), "operp;".toCharArray(),
+            "oplus;".toCharArray(), "or;".toCharArray(),
+            "orarr;".toCharArray(), "ord;".toCharArray(),
+            "order;".toCharArray(), "orderof;".toCharArray(),
+            "ordf".toCharArray(), "ordf;".toCharArray(), "ordm".toCharArray(),
+            "ordm;".toCharArray(), "origof;".toCharArray(),
+            "oror;".toCharArray(), "orslope;".toCharArray(),
+            "orv;".toCharArray(), "oscr;".toCharArray(),
+            "oslash".toCharArray(), "oslash;".toCharArray(),
+            "osol;".toCharArray(), "otilde".toCharArray(),
+            "otilde;".toCharArray(), "otimes;".toCharArray(),
+            "otimesas;".toCharArray(), "ouml".toCharArray(),
+            "ouml;".toCharArray(), "ovbar;".toCharArray(),
+            "par;".toCharArray(), "para".toCharArray(), "para;".toCharArray(),
+            "parallel;".toCharArray(), "parsim;".toCharArray(),
+            "parsl;".toCharArray(), "part;".toCharArray(),
+            "pcy;".toCharArray(), "percnt;".toCharArray(),
+            "period;".toCharArray(), "permil;".toCharArray(),
+            "perp;".toCharArray(), "pertenk;".toCharArray(),
+            "pfr;".toCharArray(), "phi;".toCharArray(), "phiv;".toCharArray(),
+            "phmmat;".toCharArray(), "phone;".toCharArray(),
+            "pi;".toCharArray(), "pitchfork;".toCharArray(),
+            "piv;".toCharArray(), "planck;".toCharArray(),
+            "planckh;".toCharArray(), "plankv;".toCharArray(),
+            "plus;".toCharArray(), "plusacir;".toCharArray(),
+            "plusb;".toCharArray(), "pluscir;".toCharArray(),
+            "plusdo;".toCharArray(), "plusdu;".toCharArray(),
+            "pluse;".toCharArray(), "plusmn".toCharArray(),
+            "plusmn;".toCharArray(), "plussim;".toCharArray(),
+            "plustwo;".toCharArray(), "pm;".toCharArray(),
+            "pointint;".toCharArray(), "popf;".toCharArray(),
+            "pound".toCharArray(), "pound;".toCharArray(), "pr;".toCharArray(),
+            "prE;".toCharArray(), "prap;".toCharArray(),
+            "prcue;".toCharArray(), "pre;".toCharArray(),
+            "prec;".toCharArray(), "precapprox;".toCharArray(),
+            "preccurlyeq;".toCharArray(), "preceq;".toCharArray(),
+            "precnapprox;".toCharArray(), "precneqq;".toCharArray(),
+            "precnsim;".toCharArray(), "precsim;".toCharArray(),
+            "prime;".toCharArray(), "primes;".toCharArray(),
+            "prnE;".toCharArray(), "prnap;".toCharArray(),
+            "prnsim;".toCharArray(), "prod;".toCharArray(),
+            "profalar;".toCharArray(), "profline;".toCharArray(),
+            "profsurf;".toCharArray(), "prop;".toCharArray(),
+            "propto;".toCharArray(), "prsim;".toCharArray(),
+            "prurel;".toCharArray(), "pscr;".toCharArray(),
+            "psi;".toCharArray(), "puncsp;".toCharArray(),
+            "qfr;".toCharArray(), "qint;".toCharArray(), "qopf;".toCharArray(),
+            "qprime;".toCharArray(), "qscr;".toCharArray(),
+            "quaternions;".toCharArray(), "quatint;".toCharArray(),
+            "quest;".toCharArray(), "questeq;".toCharArray(),
+            "quot".toCharArray(), "quot;".toCharArray(),
+            "rAarr;".toCharArray(), "rArr;".toCharArray(),
+            "rAtail;".toCharArray(), "rBarr;".toCharArray(),
+            "rHar;".toCharArray(), "race;".toCharArray(),
+            "racute;".toCharArray(), "radic;".toCharArray(),
+            "raemptyv;".toCharArray(), "rang;".toCharArray(),
+            "rangd;".toCharArray(), "range;".toCharArray(),
+            "rangle;".toCharArray(), "raquo".toCharArray(),
+            "raquo;".toCharArray(), "rarr;".toCharArray(),
+            "rarrap;".toCharArray(), "rarrb;".toCharArray(),
+            "rarrbfs;".toCharArray(), "rarrc;".toCharArray(),
+            "rarrfs;".toCharArray(), "rarrhk;".toCharArray(),
+            "rarrlp;".toCharArray(), "rarrpl;".toCharArray(),
+            "rarrsim;".toCharArray(), "rarrtl;".toCharArray(),
+            "rarrw;".toCharArray(), "ratail;".toCharArray(),
+            "ratio;".toCharArray(), "rationals;".toCharArray(),
+            "rbarr;".toCharArray(), "rbbrk;".toCharArray(),
+            "rbrace;".toCharArray(), "rbrack;".toCharArray(),
+            "rbrke;".toCharArray(), "rbrksld;".toCharArray(),
+            "rbrkslu;".toCharArray(), "rcaron;".toCharArray(),
+            "rcedil;".toCharArray(), "rceil;".toCharArray(),
+            "rcub;".toCharArray(), "rcy;".toCharArray(), "rdca;".toCharArray(),
+            "rdldhar;".toCharArray(), "rdquo;".toCharArray(),
+            "rdquor;".toCharArray(), "rdsh;".toCharArray(),
+            "real;".toCharArray(), "realine;".toCharArray(),
+            "realpart;".toCharArray(), "reals;".toCharArray(),
+            "rect;".toCharArray(), "reg".toCharArray(), "reg;".toCharArray(),
+            "rfisht;".toCharArray(), "rfloor;".toCharArray(),
+            "rfr;".toCharArray(), "rhard;".toCharArray(),
+            "rharu;".toCharArray(), "rharul;".toCharArray(),
+            "rho;".toCharArray(), "rhov;".toCharArray(),
+            "rightarrow;".toCharArray(), "rightarrowtail;".toCharArray(),
+            "rightharpoondown;".toCharArray(), "rightharpoonup;".toCharArray(),
+            "rightleftarrows;".toCharArray(),
+            "rightleftharpoons;".toCharArray(),
+            "rightrightarrows;".toCharArray(),
+            "rightsquigarrow;".toCharArray(), "rightthreetimes;".toCharArray(),
+            "ring;".toCharArray(), "risingdotseq;".toCharArray(),
+            "rlarr;".toCharArray(), "rlhar;".toCharArray(),
+            "rlm;".toCharArray(), "rmoust;".toCharArray(),
+            "rmoustache;".toCharArray(), "rnmid;".toCharArray(),
+            "roang;".toCharArray(), "roarr;".toCharArray(),
+            "robrk;".toCharArray(), "ropar;".toCharArray(),
+            "ropf;".toCharArray(), "roplus;".toCharArray(),
+            "rotimes;".toCharArray(), "rpar;".toCharArray(),
+            "rpargt;".toCharArray(), "rppolint;".toCharArray(),
+            "rrarr;".toCharArray(), "rsaquo;".toCharArray(),
+            "rscr;".toCharArray(), "rsh;".toCharArray(), "rsqb;".toCharArray(),
+            "rsquo;".toCharArray(), "rsquor;".toCharArray(),
+            "rthree;".toCharArray(), "rtimes;".toCharArray(),
+            "rtri;".toCharArray(), "rtrie;".toCharArray(),
+            "rtrif;".toCharArray(), "rtriltri;".toCharArray(),
+            "ruluhar;".toCharArray(), "rx;".toCharArray(),
+            "sacute;".toCharArray(), "sbquo;".toCharArray(),
+            "sc;".toCharArray(), "scE;".toCharArray(), "scap;".toCharArray(),
+            "scaron;".toCharArray(), "sccue;".toCharArray(),
+            "sce;".toCharArray(), "scedil;".toCharArray(),
+            "scirc;".toCharArray(), "scnE;".toCharArray(),
+            "scnap;".toCharArray(), "scnsim;".toCharArray(),
+            "scpolint;".toCharArray(), "scsim;".toCharArray(),
+            "scy;".toCharArray(), "sdot;".toCharArray(),
+            "sdotb;".toCharArray(), "sdote;".toCharArray(),
+            "seArr;".toCharArray(), "searhk;".toCharArray(),
+            "searr;".toCharArray(), "searrow;".toCharArray(),
+            "sect".toCharArray(), "sect;".toCharArray(), "semi;".toCharArray(),
+            "seswar;".toCharArray(), "setminus;".toCharArray(),
+            "setmn;".toCharArray(), "sext;".toCharArray(),
+            "sfr;".toCharArray(), "sfrown;".toCharArray(),
+            "sharp;".toCharArray(), "shchcy;".toCharArray(),
+            "shcy;".toCharArray(), "shortmid;".toCharArray(),
+            "shortparallel;".toCharArray(), "shy".toCharArray(),
+            "shy;".toCharArray(), "sigma;".toCharArray(),
+            "sigmaf;".toCharArray(), "sigmav;".toCharArray(),
+            "sim;".toCharArray(), "simdot;".toCharArray(),
+            "sime;".toCharArray(), "simeq;".toCharArray(),
+            "simg;".toCharArray(), "simgE;".toCharArray(),
+            "siml;".toCharArray(), "simlE;".toCharArray(),
+            "simne;".toCharArray(), "simplus;".toCharArray(),
+            "simrarr;".toCharArray(), "slarr;".toCharArray(),
+            "smallsetminus;".toCharArray(), "smashp;".toCharArray(),
+            "smeparsl;".toCharArray(), "smid;".toCharArray(),
+            "smile;".toCharArray(), "smt;".toCharArray(),
+            "smte;".toCharArray(), "softcy;".toCharArray(),
+            "sol;".toCharArray(), "solb;".toCharArray(),
+            "solbar;".toCharArray(), "sopf;".toCharArray(),
+            "spades;".toCharArray(), "spadesuit;".toCharArray(),
+            "spar;".toCharArray(), "sqcap;".toCharArray(),
+            "sqcup;".toCharArray(), "sqsub;".toCharArray(),
+            "sqsube;".toCharArray(), "sqsubset;".toCharArray(),
+            "sqsubseteq;".toCharArray(), "sqsup;".toCharArray(),
+            "sqsupe;".toCharArray(), "sqsupset;".toCharArray(),
+            "sqsupseteq;".toCharArray(), "squ;".toCharArray(),
+            "square;".toCharArray(), "squarf;".toCharArray(),
+            "squf;".toCharArray(), "srarr;".toCharArray(),
+            "sscr;".toCharArray(), "ssetmn;".toCharArray(),
+            "ssmile;".toCharArray(), "sstarf;".toCharArray(),
+            "star;".toCharArray(), "starf;".toCharArray(),
+            "straightepsilon;".toCharArray(), "straightphi;".toCharArray(),
+            "strns;".toCharArray(), "sub;".toCharArray(),
+            "subE;".toCharArray(), "subdot;".toCharArray(),
+            "sube;".toCharArray(), "subedot;".toCharArray(),
+            "submult;".toCharArray(), "subnE;".toCharArray(),
+            "subne;".toCharArray(), "subplus;".toCharArray(),
+            "subrarr;".toCharArray(), "subset;".toCharArray(),
+            "subseteq;".toCharArray(), "subseteqq;".toCharArray(),
+            "subsetneq;".toCharArray(), "subsetneqq;".toCharArray(),
+            "subsim;".toCharArray(), "subsub;".toCharArray(),
+            "subsup;".toCharArray(), "succ;".toCharArray(),
+            "succapprox;".toCharArray(), "succcurlyeq;".toCharArray(),
+            "succeq;".toCharArray(), "succnapprox;".toCharArray(),
+            "succneqq;".toCharArray(), "succnsim;".toCharArray(),
+            "succsim;".toCharArray(), "sum;".toCharArray(),
+            "sung;".toCharArray(), "sup1".toCharArray(), "sup1;".toCharArray(),
+            "sup2".toCharArray(), "sup2;".toCharArray(), "sup3".toCharArray(),
+            "sup3;".toCharArray(), "sup;".toCharArray(), "supE;".toCharArray(),
+            "supdot;".toCharArray(), "supdsub;".toCharArray(),
+            "supe;".toCharArray(), "supedot;".toCharArray(),
+            "suphsub;".toCharArray(), "suplarr;".toCharArray(),
+            "supmult;".toCharArray(), "supnE;".toCharArray(),
+            "supne;".toCharArray(), "supplus;".toCharArray(),
+            "supset;".toCharArray(), "supseteq;".toCharArray(),
+            "supseteqq;".toCharArray(), "supsetneq;".toCharArray(),
+            "supsetneqq;".toCharArray(), "supsim;".toCharArray(),
+            "supsub;".toCharArray(), "supsup;".toCharArray(),
+            "swArr;".toCharArray(), "swarhk;".toCharArray(),
+            "swarr;".toCharArray(), "swarrow;".toCharArray(),
+            "swnwar;".toCharArray(), "szlig".toCharArray(),
+            "szlig;".toCharArray(), "target;".toCharArray(),
+            "tau;".toCharArray(), "tbrk;".toCharArray(),
+            "tcaron;".toCharArray(), "tcedil;".toCharArray(),
+            "tcy;".toCharArray(), "tdot;".toCharArray(),
+            "telrec;".toCharArray(), "tfr;".toCharArray(),
+            "there4;".toCharArray(), "therefore;".toCharArray(),
+            "theta;".toCharArray(), "thetasym;".toCharArray(),
+            "thetav;".toCharArray(), "thickapprox;".toCharArray(),
+            "thicksim;".toCharArray(), "thinsp;".toCharArray(),
+            "thkap;".toCharArray(), "thksim;".toCharArray(),
+            "thorn".toCharArray(), "thorn;".toCharArray(),
+            "tilde;".toCharArray(), "times".toCharArray(),
+            "times;".toCharArray(), "timesb;".toCharArray(),
+            "timesbar;".toCharArray(), "timesd;".toCharArray(),
+            "tint;".toCharArray(), "toea;".toCharArray(), "top;".toCharArray(),
+            "topbot;".toCharArray(), "topcir;".toCharArray(),
+            "topf;".toCharArray(), "topfork;".toCharArray(),
+            "tosa;".toCharArray(), "tprime;".toCharArray(),
+            "trade;".toCharArray(), "triangle;".toCharArray(),
+            "triangledown;".toCharArray(), "triangleleft;".toCharArray(),
+            "trianglelefteq;".toCharArray(), "triangleq;".toCharArray(),
+            "triangleright;".toCharArray(), "trianglerighteq;".toCharArray(),
+            "tridot;".toCharArray(), "trie;".toCharArray(),
+            "triminus;".toCharArray(), "triplus;".toCharArray(),
+            "trisb;".toCharArray(), "tritime;".toCharArray(),
+            "trpezium;".toCharArray(), "tscr;".toCharArray(),
+            "tscy;".toCharArray(), "tshcy;".toCharArray(),
+            "tstrok;".toCharArray(), "twixt;".toCharArray(),
+            "twoheadleftarrow;".toCharArray(),
+            "twoheadrightarrow;".toCharArray(), "uArr;".toCharArray(),
+            "uHar;".toCharArray(), "uacute".toCharArray(),
+            "uacute;".toCharArray(), "uarr;".toCharArray(),
+            "ubrcy;".toCharArray(), "ubreve;".toCharArray(),
+            "ucirc".toCharArray(), "ucirc;".toCharArray(),
+            "ucy;".toCharArray(), "udarr;".toCharArray(),
+            "udblac;".toCharArray(), "udhar;".toCharArray(),
+            "ufisht;".toCharArray(), "ufr;".toCharArray(),
+            "ugrave".toCharArray(), "ugrave;".toCharArray(),
+            "uharl;".toCharArray(), "uharr;".toCharArray(),
+            "uhblk;".toCharArray(), "ulcorn;".toCharArray(),
+            "ulcorner;".toCharArray(), "ulcrop;".toCharArray(),
+            "ultri;".toCharArray(), "umacr;".toCharArray(),
+            "uml".toCharArray(), "uml;".toCharArray(), "uogon;".toCharArray(),
+            "uopf;".toCharArray(), "uparrow;".toCharArray(),
+            "updownarrow;".toCharArray(), "upharpoonleft;".toCharArray(),
+            "upharpoonright;".toCharArray(), "uplus;".toCharArray(),
+            "upsi;".toCharArray(), "upsih;".toCharArray(),
+            "upsilon;".toCharArray(), "upuparrows;".toCharArray(),
+            "urcorn;".toCharArray(), "urcorner;".toCharArray(),
+            "urcrop;".toCharArray(), "uring;".toCharArray(),
+            "urtri;".toCharArray(), "uscr;".toCharArray(),
+            "utdot;".toCharArray(), "utilde;".toCharArray(),
+            "utri;".toCharArray(), "utrif;".toCharArray(),
+            "uuarr;".toCharArray(), "uuml".toCharArray(),
+            "uuml;".toCharArray(), "uwangle;".toCharArray(),
+            "vArr;".toCharArray(), "vBar;".toCharArray(),
+            "vBarv;".toCharArray(), "vDash;".toCharArray(),
+            "vangrt;".toCharArray(), "varepsilon;".toCharArray(),
+            "varkappa;".toCharArray(), "varnothing;".toCharArray(),
+            "varphi;".toCharArray(), "varpi;".toCharArray(),
+            "varpropto;".toCharArray(), "varr;".toCharArray(),
+            "varrho;".toCharArray(), "varsigma;".toCharArray(),
+            "vartheta;".toCharArray(), "vartriangleleft;".toCharArray(),
+            "vartriangleright;".toCharArray(), "vcy;".toCharArray(),
+            "vdash;".toCharArray(), "vee;".toCharArray(),
+            "veebar;".toCharArray(), "veeeq;".toCharArray(),
+            "vellip;".toCharArray(), "verbar;".toCharArray(),
+            "vert;".toCharArray(), "vfr;".toCharArray(),
+            "vltri;".toCharArray(), "vopf;".toCharArray(),
+            "vprop;".toCharArray(), "vrtri;".toCharArray(),
+            "vscr;".toCharArray(), "vzigzag;".toCharArray(),
+            "wcirc;".toCharArray(), "wedbar;".toCharArray(),
+            "wedge;".toCharArray(), "wedgeq;".toCharArray(),
+            "weierp;".toCharArray(), "wfr;".toCharArray(),
+            "wopf;".toCharArray(), "wp;".toCharArray(), "wr;".toCharArray(),
+            "wreath;".toCharArray(), "wscr;".toCharArray(),
+            "xcap;".toCharArray(), "xcirc;".toCharArray(),
+            "xcup;".toCharArray(), "xdtri;".toCharArray(),
+            "xfr;".toCharArray(), "xhArr;".toCharArray(),
+            "xharr;".toCharArray(), "xi;".toCharArray(),
+            "xlArr;".toCharArray(), "xlarr;".toCharArray(),
+            "xmap;".toCharArray(), "xnis;".toCharArray(),
+            "xodot;".toCharArray(), "xopf;".toCharArray(),
+            "xoplus;".toCharArray(), "xotime;".toCharArray(),
+            "xrArr;".toCharArray(), "xrarr;".toCharArray(),
+            "xscr;".toCharArray(), "xsqcup;".toCharArray(),
+            "xuplus;".toCharArray(), "xutri;".toCharArray(),
+            "xvee;".toCharArray(), "xwedge;".toCharArray(),
+            "yacute".toCharArray(), "yacute;".toCharArray(),
+            "yacy;".toCharArray(), "ycirc;".toCharArray(),
+            "ycy;".toCharArray(), "yen".toCharArray(), "yen;".toCharArray(),
+            "yfr;".toCharArray(), "yicy;".toCharArray(), "yopf;".toCharArray(),
+            "yscr;".toCharArray(), "yucy;".toCharArray(), "yuml".toCharArray(),
+            "yuml;".toCharArray(), "zacute;".toCharArray(),
+            "zcaron;".toCharArray(), "zcy;".toCharArray(),
+            "zdot;".toCharArray(), "zeetrf;".toCharArray(),
+            "zeta;".toCharArray(), "zfr;".toCharArray(), "zhcy;".toCharArray(),
+            "zigrarr;".toCharArray(), "zopf;".toCharArray(),
+            "zscr;".toCharArray(), "zwj;".toCharArray(), "zwnj;".toCharArray(), };
+
+    static final @NoLength char[][] VALUES = { { '\u00c6' }, { '\u00c6' },
+            { '\u0026' }, { '\u0026' }, { '\u00c1' }, { '\u00c1' },
+            { '\u0102' }, { '\u00c2' }, { '\u00c2' }, { '\u0410' },
+            { '\ud835', '\udd04' }, { '\u00c0' }, { '\u00c0' }, { '\u0391' },
+            { '\u0100' }, { '\u2a53' }, { '\u0104' }, { '\ud835', '\udd38' },
+            { '\u2061' }, { '\u00c5' }, { '\u00c5' }, { '\ud835', '\udc9c' },
+            { '\u2254' }, { '\u00c3' }, { '\u00c3' }, { '\u00c4' },
+            { '\u00c4' }, { '\u2216' }, { '\u2ae7' }, { '\u2306' },
+            { '\u0411' }, { '\u2235' }, { '\u212c' }, { '\u0392' },
+            { '\ud835', '\udd05' }, { '\ud835', '\udd39' }, { '\u02d8' },
+            { '\u212c' }, { '\u224e' }, { '\u0427' }, { '\u00a9' },
+            { '\u00a9' }, { '\u0106' }, { '\u22d2' }, { '\u2145' },
+            { '\u212d' }, { '\u010c' }, { '\u00c7' }, { '\u00c7' },
+            { '\u0108' }, { '\u2230' }, { '\u010a' }, { '\u00b8' },
+            { '\u00b7' }, { '\u212d' }, { '\u03a7' }, { '\u2299' },
+            { '\u2296' }, { '\u2295' }, { '\u2297' }, { '\u2232' },
+            { '\u201d' }, { '\u2019' }, { '\u2237' }, { '\u2a74' },
+            { '\u2261' }, { '\u222f' }, { '\u222e' }, { '\u2102' },
+            { '\u2210' }, { '\u2233' }, { '\u2a2f' }, { '\ud835', '\udc9e' },
+            { '\u22d3' }, { '\u224d' }, { '\u2145' }, { '\u2911' },
+            { '\u0402' }, { '\u0405' }, { '\u040f' }, { '\u2021' },
+            { '\u21a1' }, { '\u2ae4' }, { '\u010e' }, { '\u0414' },
+            { '\u2207' }, { '\u0394' }, { '\ud835', '\udd07' }, { '\u00b4' },
+            { '\u02d9' }, { '\u02dd' }, { '\u0060' }, { '\u02dc' },
+            { '\u22c4' }, { '\u2146' }, { '\ud835', '\udd3b' }, { '\u00a8' },
+            { '\u20dc' }, { '\u2250' }, { '\u222f' }, { '\u00a8' },
+            { '\u21d3' }, { '\u21d0' }, { '\u21d4' }, { '\u2ae4' },
+            { '\u27f8' }, { '\u27fa' }, { '\u27f9' }, { '\u21d2' },
+            { '\u22a8' }, { '\u21d1' }, { '\u21d5' }, { '\u2225' },
+            { '\u2193' }, { '\u2913' }, { '\u21f5' }, { '\u0311' },
+            { '\u2950' }, { '\u295e' }, { '\u21bd' }, { '\u2956' },
+            { '\u295f' }, { '\u21c1' }, { '\u2957' }, { '\u22a4' },
+            { '\u21a7' }, { '\u21d3' }, { '\ud835', '\udc9f' }, { '\u0110' },
+            { '\u014a' }, { '\u00d0' }, { '\u00d0' }, { '\u00c9' },
+            { '\u00c9' }, { '\u011a' }, { '\u00ca' }, { '\u00ca' },
+            { '\u042d' }, { '\u0116' }, { '\ud835', '\udd08' }, { '\u00c8' },
+            { '\u00c8' }, { '\u2208' }, { '\u0112' }, { '\u25fb' },
+            { '\u25ab' }, { '\u0118' }, { '\ud835', '\udd3c' }, { '\u0395' },
+            { '\u2a75' }, { '\u2242' }, { '\u21cc' }, { '\u2130' },
+            { '\u2a73' }, { '\u0397' }, { '\u00cb' }, { '\u00cb' },
+            { '\u2203' }, { '\u2147' }, { '\u0424' }, { '\ud835', '\udd09' },
+            { '\u25fc' }, { '\u25aa' }, { '\ud835', '\udd3d' }, { '\u2200' },
+            { '\u2131' }, { '\u2131' }, { '\u0403' }, { '\u003e' },
+            { '\u003e' }, { '\u0393' }, { '\u03dc' }, { '\u011e' },
+            { '\u0122' }, { '\u011c' }, { '\u0413' }, { '\u0120' },
+            { '\ud835', '\udd0a' }, { '\u22d9' }, { '\ud835', '\udd3e' },
+            { '\u2265' }, { '\u22db' }, { '\u2267' }, { '\u2aa2' },
+            { '\u2277' }, { '\u2a7e' }, { '\u2273' }, { '\ud835', '\udca2' },
+            { '\u226b' }, { '\u042a' }, { '\u02c7' }, { '\u005e' },
+            { '\u0124' }, { '\u210c' }, { '\u210b' }, { '\u210d' },
+            { '\u2500' }, { '\u210b' }, { '\u0126' }, { '\u224e' },
+            { '\u224f' }, { '\u0415' }, { '\u0132' }, { '\u0401' },
+            { '\u00cd' }, { '\u00cd' }, { '\u00ce' }, { '\u00ce' },
+            { '\u0418' }, { '\u0130' }, { '\u2111' }, { '\u00cc' },
+            { '\u00cc' }, { '\u2111' }, { '\u012a' }, { '\u2148' },
+            { '\u21d2' }, { '\u222c' }, { '\u222b' }, { '\u22c2' },
+            { '\u2063' }, { '\u2062' }, { '\u012e' }, { '\ud835', '\udd40' },
+            { '\u0399' }, { '\u2110' }, { '\u0128' }, { '\u0406' },
+            { '\u00cf' }, { '\u00cf' }, { '\u0134' }, { '\u0419' },
+            { '\ud835', '\udd0d' }, { '\ud835', '\udd41' },
+            { '\ud835', '\udca5' }, { '\u0408' }, { '\u0404' }, { '\u0425' },
+            { '\u040c' }, { '\u039a' }, { '\u0136' }, { '\u041a' },
+            { '\ud835', '\udd0e' }, { '\ud835', '\udd42' },
+            { '\ud835', '\udca6' }, { '\u0409' }, { '\u003c' }, { '\u003c' },
+            { '\u0139' }, { '\u039b' }, { '\u27ea' }, { '\u2112' },
+            { '\u219e' }, { '\u013d' }, { '\u013b' }, { '\u041b' },
+            { '\u27e8' }, { '\u2190' }, { '\u21e4' }, { '\u21c6' },
+            { '\u2308' }, { '\u27e6' }, { '\u2961' }, { '\u21c3' },
+            { '\u2959' }, { '\u230a' }, { '\u2194' }, { '\u294e' },
+            { '\u22a3' }, { '\u21a4' }, { '\u295a' }, { '\u22b2' },
+            { '\u29cf' }, { '\u22b4' }, { '\u2951' }, { '\u2960' },
+            { '\u21bf' }, { '\u2958' }, { '\u21bc' }, { '\u2952' },
+            { '\u21d0' }, { '\u21d4' }, { '\u22da' }, { '\u2266' },
+            { '\u2276' }, { '\u2aa1' }, { '\u2a7d' }, { '\u2272' },
+            { '\ud835', '\udd0f' }, { '\u22d8' }, { '\u21da' }, { '\u013f' },
+            { '\u27f5' }, { '\u27f7' }, { '\u27f6' }, { '\u27f8' },
+            { '\u27fa' }, { '\u27f9' }, { '\ud835', '\udd43' }, { '\u2199' },
+            { '\u2198' }, { '\u2112' }, { '\u21b0' }, { '\u0141' },
+            { '\u226a' }, { '\u2905' }, { '\u041c' }, { '\u205f' },
+            { '\u2133' }, { '\ud835', '\udd10' }, { '\u2213' },
+            { '\ud835', '\udd44' }, { '\u2133' }, { '\u039c' }, { '\u040a' },
+            { '\u0143' }, { '\u0147' }, { '\u0145' }, { '\u041d' },
+            { '\u200b' }, { '\u200b' }, { '\u200b' }, { '\u200b' },
+            { '\u226b' }, { '\u226a' }, { '\n' }, { '\ud835', '\udd11' },
+            { '\u2060' }, { '\u00a0' }, { '\u2115' }, { '\u2aec' },
+            { '\u2262' }, { '\u226d' }, { '\u2226' }, { '\u2209' },
+            { '\u2260' }, { '\u2204' }, { '\u226f' }, { '\u2271' },
+            { '\u2279' }, { '\u2275' }, { '\u22ea' }, { '\u22ec' },
+            { '\u226e' }, { '\u2270' }, { '\u2278' }, { '\u2274' },
+            { '\u2280' }, { '\u22e0' }, { '\u220c' }, { '\u22eb' },
+            { '\u22ed' }, { '\u22e2' }, { '\u22e3' }, { '\u2288' },
+            { '\u2281' }, { '\u22e1' }, { '\u2289' }, { '\u2241' },
+            { '\u2244' }, { '\u2247' }, { '\u2249' }, { '\u2224' },
+            { '\ud835', '\udca9' }, { '\u00d1' }, { '\u00d1' }, { '\u039d' },
+            { '\u0152' }, { '\u00d3' }, { '\u00d3' }, { '\u00d4' },
+            { '\u00d4' }, { '\u041e' }, { '\u0150' }, { '\ud835', '\udd12' },
+            { '\u00d2' }, { '\u00d2' }, { '\u014c' }, { '\u03a9' },
+            { '\u039f' }, { '\ud835', '\udd46' }, { '\u201c' }, { '\u2018' },
+            { '\u2a54' }, { '\ud835', '\udcaa' }, { '\u00d8' }, { '\u00d8' },
+            { '\u00d5' }, { '\u00d5' }, { '\u2a37' }, { '\u00d6' },
+            { '\u00d6' }, { '\u00af' }, { '\u23de' }, { '\u23b4' },
+            { '\u23dc' }, { '\u2202' }, { '\u041f' }, { '\ud835', '\udd13' },
+            { '\u03a6' }, { '\u03a0' }, { '\u00b1' }, { '\u210c' },
+            { '\u2119' }, { '\u2abb' }, { '\u227a' }, { '\u2aaf' },
+            { '\u227c' }, { '\u227e' }, { '\u2033' }, { '\u220f' },
+            { '\u2237' }, { '\u221d' }, { '\ud835', '\udcab' }, { '\u03a8' },
+            { '\u0022' }, { '\u0022' }, { '\ud835', '\udd14' }, { '\u211a' },
+            { '\ud835', '\udcac' }, { '\u2910' }, { '\u00ae' }, { '\u00ae' },
+            { '\u0154' }, { '\u27eb' }, { '\u21a0' }, { '\u2916' },
+            { '\u0158' }, { '\u0156' }, { '\u0420' }, { '\u211c' },
+            { '\u220b' }, { '\u21cb' }, { '\u296f' }, { '\u211c' },
+            { '\u03a1' }, { '\u27e9' }, { '\u2192' }, { '\u21e5' },
+            { '\u21c4' }, { '\u2309' }, { '\u27e7' }, { '\u295d' },
+            { '\u21c2' }, { '\u2955' }, { '\u230b' }, { '\u22a2' },
+            { '\u21a6' }, { '\u295b' }, { '\u22b3' }, { '\u29d0' },
+            { '\u22b5' }, { '\u294f' }, { '\u295c' }, { '\u21be' },
+            { '\u2954' }, { '\u21c0' }, { '\u2953' }, { '\u21d2' },
+            { '\u211d' }, { '\u2970' }, { '\u21db' }, { '\u211b' },
+            { '\u21b1' }, { '\u29f4' }, { '\u0429' }, { '\u0428' },
+            { '\u042c' }, { '\u015a' }, { '\u2abc' }, { '\u0160' },
+            { '\u015e' }, { '\u015c' }, { '\u0421' }, { '\ud835', '\udd16' },
+            { '\u2193' }, { '\u2190' }, { '\u2192' }, { '\u2191' },
+            { '\u03a3' }, { '\u2218' }, { '\ud835', '\udd4a' }, { '\u221a' },
+            { '\u25a1' }, { '\u2293' }, { '\u228f' }, { '\u2291' },
+            { '\u2290' }, { '\u2292' }, { '\u2294' }, { '\ud835', '\udcae' },
+            { '\u22c6' }, { '\u22d0' }, { '\u22d0' }, { '\u2286' },
+            { '\u227b' }, { '\u2ab0' }, { '\u227d' }, { '\u227f' },
+            { '\u220b' }, { '\u2211' }, { '\u22d1' }, { '\u2283' },
+            { '\u2287' }, { '\u22d1' }, { '\u00de' }, { '\u00de' },
+            { '\u2122' }, { '\u040b' }, { '\u0426' }, { '\u0009' },
+            { '\u03a4' }, { '\u0164' }, { '\u0162' }, { '\u0422' },
+            { '\ud835', '\udd17' }, { '\u2234' }, { '\u0398' }, { '\u2009' },
+            { '\u223c' }, { '\u2243' }, { '\u2245' }, { '\u2248' },
+            { '\ud835', '\udd4b' }, { '\u20db' }, { '\ud835', '\udcaf' },
+            { '\u0166' }, { '\u00da' }, { '\u00da' }, { '\u219f' },
+            { '\u2949' }, { '\u040e' }, { '\u016c' }, { '\u00db' },
+            { '\u00db' }, { '\u0423' }, { '\u0170' }, { '\ud835', '\udd18' },
+            { '\u00d9' }, { '\u00d9' }, { '\u016a' }, { '\u0332' },
+            { '\u23df' }, { '\u23b5' }, { '\u23dd' }, { '\u22c3' },
+            { '\u228e' }, { '\u0172' }, { '\ud835', '\udd4c' }, { '\u2191' },
+            { '\u2912' }, { '\u21c5' }, { '\u2195' }, { '\u296e' },
+            { '\u22a5' }, { '\u21a5' }, { '\u21d1' }, { '\u21d5' },
+            { '\u2196' }, { '\u2197' }, { '\u03d2' }, { '\u03a5' },
+            { '\u016e' }, { '\ud835', '\udcb0' }, { '\u0168' }, { '\u00dc' },
+            { '\u00dc' }, { '\u22ab' }, { '\u2aeb' }, { '\u0412' },
+            { '\u22a9' }, { '\u2ae6' }, { '\u22c1' }, { '\u2016' },
+            { '\u2016' }, { '\u2223' }, { '\u007c' }, { '\u2758' },
+            { '\u2240' }, { '\u200a' }, { '\ud835', '\udd19' },
+            { '\ud835', '\udd4d' }, { '\ud835', '\udcb1' }, { '\u22aa' },
+            { '\u0174' }, { '\u22c0' }, { '\ud835', '\udd1a' },
+            { '\ud835', '\udd4e' }, { '\ud835', '\udcb2' },
+            { '\ud835', '\udd1b' }, { '\u039e' }, { '\ud835', '\udd4f' },
+            { '\ud835', '\udcb3' }, { '\u042f' }, { '\u0407' }, { '\u042e' },
+            { '\u00dd' }, { '\u00dd' }, { '\u0176' }, { '\u042b' },
+            { '\ud835', '\udd1c' }, { '\ud835', '\udd50' },
+            { '\ud835', '\udcb4' }, { '\u0178' }, { '\u0416' }, { '\u0179' },
+            { '\u017d' }, { '\u0417' }, { '\u017b' }, { '\u200b' },
+            { '\u0396' }, { '\u2128' }, { '\u2124' }, { '\ud835', '\udcb5' },
+            { '\u00e1' }, { '\u00e1' }, { '\u0103' }, { '\u223e' },
+            { '\u223f' }, { '\u00e2' }, { '\u00e2' }, { '\u00b4' },
+            { '\u00b4' }, { '\u0430' }, { '\u00e6' }, { '\u00e6' },
+            { '\u2061' }, { '\ud835', '\udd1e' }, { '\u00e0' }, { '\u00e0' },
+            { '\u2135' }, { '\u2135' }, { '\u03b1' }, { '\u0101' },
+            { '\u2a3f' }, { '\u0026' }, { '\u0026' }, { '\u2227' },
+            { '\u2a55' }, { '\u2a5c' }, { '\u2a58' }, { '\u2a5a' },
+            { '\u2220' }, { '\u29a4' }, { '\u2220' }, { '\u2221' },
+            { '\u29a8' }, { '\u29a9' }, { '\u29aa' }, { '\u29ab' },
+            { '\u29ac' }, { '\u29ad' }, { '\u29ae' }, { '\u29af' },
+            { '\u221f' }, { '\u22be' }, { '\u299d' }, { '\u2222' },
+            { '\u212b' }, { '\u237c' }, { '\u0105' }, { '\ud835', '\udd52' },
+            { '\u2248' }, { '\u2a70' }, { '\u2a6f' }, { '\u224a' },
+            { '\u224b' }, { '\'' }, { '\u2248' }, { '\u224a' }, { '\u00e5' },
+            { '\u00e5' }, { '\ud835', '\udcb6' }, { '\u002a' }, { '\u2248' },
+            { '\u224d' }, { '\u00e3' }, { '\u00e3' }, { '\u00e4' },
+            { '\u00e4' }, { '\u2233' }, { '\u2a11' }, { '\u2aed' },
+            { '\u224c' }, { '\u03f6' }, { '\u2035' }, { '\u223d' },
+            { '\u22cd' }, { '\u22bd' }, { '\u2305' }, { '\u2305' },
+            { '\u23b5' }, { '\u23b6' }, { '\u224c' }, { '\u0431' },
+            { '\u201e' }, { '\u2235' }, { '\u2235' }, { '\u29b0' },
+            { '\u03f6' }, { '\u212c' }, { '\u03b2' }, { '\u2136' },
+            { '\u226c' }, { '\ud835', '\udd1f' }, { '\u22c2' }, { '\u25ef' },
+            { '\u22c3' }, { '\u2a00' }, { '\u2a01' }, { '\u2a02' },
+            { '\u2a06' }, { '\u2605' }, { '\u25bd' }, { '\u25b3' },
+            { '\u2a04' }, { '\u22c1' }, { '\u22c0' }, { '\u290d' },
+            { '\u29eb' }, { '\u25aa' }, { '\u25b4' }, { '\u25be' },
+            { '\u25c2' }, { '\u25b8' }, { '\u2423' }, { '\u2592' },
+            { '\u2591' }, { '\u2593' }, { '\u2588' }, { '\u2310' },
+            { '\ud835', '\udd53' }, { '\u22a5' }, { '\u22a5' }, { '\u22c8' },
+            { '\u2557' }, { '\u2554' }, { '\u2556' }, { '\u2553' },
+            { '\u2550' }, { '\u2566' }, { '\u2569' }, { '\u2564' },
+            { '\u2567' }, { '\u255d' }, { '\u255a' }, { '\u255c' },
+            { '\u2559' }, { '\u2551' }, { '\u256c' }, { '\u2563' },
+            { '\u2560' }, { '\u256b' }, { '\u2562' }, { '\u255f' },
+            { '\u29c9' }, { '\u2555' }, { '\u2552' }, { '\u2510' },
+            { '\u250c' }, { '\u2500' }, { '\u2565' }, { '\u2568' },
+            { '\u252c' }, { '\u2534' }, { '\u229f' }, { '\u229e' },
+            { '\u22a0' }, { '\u255b' }, { '\u2558' }, { '\u2518' },
+            { '\u2514' }, { '\u2502' }, { '\u256a' }, { '\u2561' },
+            { '\u255e' }, { '\u253c' }, { '\u2524' }, { '\u251c' },
+            { '\u2035' }, { '\u02d8' }, { '\u00a6' }, { '\u00a6' },
+            { '\ud835', '\udcb7' }, { '\u204f' }, { '\u223d' }, { '\u22cd' },
+            { '\\' }, { '\u29c5' }, { '\u2022' }, { '\u2022' }, { '\u224e' },
+            { '\u2aae' }, { '\u224f' }, { '\u224f' }, { '\u0107' },
+            { '\u2229' }, { '\u2a44' }, { '\u2a49' }, { '\u2a4b' },
+            { '\u2a47' }, { '\u2a40' }, { '\u2041' }, { '\u02c7' },
+            { '\u2a4d' }, { '\u010d' }, { '\u00e7' }, { '\u00e7' },
+            { '\u0109' }, { '\u2a4c' }, { '\u2a50' }, { '\u010b' },
+            { '\u00b8' }, { '\u00b8' }, { '\u29b2' }, { '\u00a2' },
+            { '\u00a2' }, { '\u00b7' }, { '\ud835', '\udd20' }, { '\u0447' },
+            { '\u2713' }, { '\u2713' }, { '\u03c7' }, { '\u25cb' },
+            { '\u29c3' }, { '\u02c6' }, { '\u2257' }, { '\u21ba' },
+            { '\u21bb' }, { '\u00ae' }, { '\u24c8' }, { '\u229b' },
+            { '\u229a' }, { '\u229d' }, { '\u2257' }, { '\u2a10' },
+            { '\u2aef' }, { '\u29c2' }, { '\u2663' }, { '\u2663' },
+            { '\u003a' }, { '\u2254' }, { '\u2254' }, { '\u002c' },
+            { '\u0040' }, { '\u2201' }, { '\u2218' }, { '\u2201' },
+            { '\u2102' }, { '\u2245' }, { '\u2a6d' }, { '\u222e' },
+            { '\ud835', '\udd54' }, { '\u2210' }, { '\u00a9' }, { '\u00a9' },
+            { '\u2117' }, { '\u21b5' }, { '\u2717' }, { '\ud835', '\udcb8' },
+            { '\u2acf' }, { '\u2ad1' }, { '\u2ad0' }, { '\u2ad2' },
+            { '\u22ef' }, { '\u2938' }, { '\u2935' }, { '\u22de' },
+            { '\u22df' }, { '\u21b6' }, { '\u293d' }, { '\u222a' },
+            { '\u2a48' }, { '\u2a46' }, { '\u2a4a' }, { '\u228d' },
+            { '\u2a45' }, { '\u21b7' }, { '\u293c' }, { '\u22de' },
+            { '\u22df' }, { '\u22ce' }, { '\u22cf' }, { '\u00a4' },
+            { '\u00a4' }, { '\u21b6' }, { '\u21b7' }, { '\u22ce' },
+            { '\u22cf' }, { '\u2232' }, { '\u2231' }, { '\u232d' },
+            { '\u21d3' }, { '\u2965' }, { '\u2020' }, { '\u2138' },
+            { '\u2193' }, { '\u2010' }, { '\u22a3' }, { '\u290f' },
+            { '\u02dd' }, { '\u010f' }, { '\u0434' }, { '\u2146' },
+            { '\u2021' }, { '\u21ca' }, { '\u2a77' }, { '\u00b0' },
+            { '\u00b0' }, { '\u03b4' }, { '\u29b1' }, { '\u297f' },
+            { '\ud835', '\udd21' }, { '\u21c3' }, { '\u21c2' }, { '\u22c4' },
+            { '\u22c4' }, { '\u2666' }, { '\u2666' }, { '\u00a8' },
+            { '\u03dd' }, { '\u22f2' }, { '\u00f7' }, { '\u00f7' },
+            { '\u00f7' }, { '\u22c7' }, { '\u22c7' }, { '\u0452' },
+            { '\u231e' }, { '\u230d' }, { '\u0024' }, { '\ud835', '\udd55' },
+            { '\u02d9' }, { '\u2250' }, { '\u2251' }, { '\u2238' },
+            { '\u2214' }, { '\u22a1' }, { '\u2306' }, { '\u2193' },
+            { '\u21ca' }, { '\u21c3' }, { '\u21c2' }, { '\u2910' },
+            { '\u231f' }, { '\u230c' }, { '\ud835', '\udcb9' }, { '\u0455' },
+            { '\u29f6' }, { '\u0111' }, { '\u22f1' }, { '\u25bf' },
+            { '\u25be' }, { '\u21f5' }, { '\u296f' }, { '\u29a6' },
+            { '\u045f' }, { '\u27ff' }, { '\u2a77' }, { '\u2251' },
+            { '\u00e9' }, { '\u00e9' }, { '\u2a6e' }, { '\u011b' },
+            { '\u2256' }, { '\u00ea' }, { '\u00ea' }, { '\u2255' },
+            { '\u044d' }, { '\u0117' }, { '\u2147' }, { '\u2252' },
+            { '\ud835', '\udd22' }, { '\u2a9a' }, { '\u00e8' }, { '\u00e8' },
+            { '\u2a96' }, { '\u2a98' }, { '\u2a99' }, { '\u23e7' },
+            { '\u2113' }, { '\u2a95' }, { '\u2a97' }, { '\u0113' },
+            { '\u2205' }, { '\u2205' }, { '\u2205' }, { '\u2004' },
+            { '\u2005' }, { '\u2003' }, { '\u014b' }, { '\u2002' },
+            { '\u0119' }, { '\ud835', '\udd56' }, { '\u22d5' }, { '\u29e3' },
+            { '\u2a71' }, { '\u03f5' }, { '\u03b5' }, { '\u03b5' },
+            { '\u2256' }, { '\u2255' }, { '\u2242' }, { '\u2a96' },
+            { '\u2a95' }, { '\u003d' }, { '\u225f' }, { '\u2261' },
+            { '\u2a78' }, { '\u29e5' }, { '\u2253' }, { '\u2971' },
+            { '\u212f' }, { '\u2250' }, { '\u2242' }, { '\u03b7' },
+            { '\u00f0' }, { '\u00f0' }, { '\u00eb' }, { '\u00eb' },
+            { '\u20ac' }, { '\u0021' }, { '\u2203' }, { '\u2130' },
+            { '\u2147' }, { '\u2252' }, { '\u0444' }, { '\u2640' },
+            { '\ufb03' }, { '\ufb00' }, { '\ufb04' }, { '\ud835', '\udd23' },
+            { '\ufb01' }, { '\u266d' }, { '\ufb02' }, { '\u25b1' },
+            { '\u0192' }, { '\ud835', '\udd57' }, { '\u2200' }, { '\u22d4' },
+            { '\u2ad9' }, { '\u2a0d' }, { '\u00bd' }, { '\u00bd' },
+            { '\u2153' }, { '\u00bc' }, { '\u00bc' }, { '\u2155' },
+            { '\u2159' }, { '\u215b' }, { '\u2154' }, { '\u2156' },
+            { '\u00be' }, { '\u00be' }, { '\u2157' }, { '\u215c' },
+            { '\u2158' }, { '\u215a' }, { '\u215d' }, { '\u215e' },
+            { '\u2044' }, { '\u2322' }, { '\ud835', '\udcbb' }, { '\u2267' },
+            { '\u2a8c' }, { '\u01f5' }, { '\u03b3' }, { '\u03dd' },
+            { '\u2a86' }, { '\u011f' }, { '\u011d' }, { '\u0433' },
+            { '\u0121' }, { '\u2265' }, { '\u22db' }, { '\u2265' },
+            { '\u2267' }, { '\u2a7e' }, { '\u2a7e' }, { '\u2aa9' },
+            { '\u2a80' }, { '\u2a82' }, { '\u2a84' }, { '\u2a94' },
+            { '\ud835', '\udd24' }, { '\u226b' }, { '\u22d9' }, { '\u2137' },
+            { '\u0453' }, { '\u2277' }, { '\u2a92' }, { '\u2aa5' },
+            { '\u2aa4' }, { '\u2269' }, { '\u2a8a' }, { '\u2a8a' },
+            { '\u2a88' }, { '\u2a88' }, { '\u2269' }, { '\u22e7' },
+            { '\ud835', '\udd58' }, { '\u0060' }, { '\u210a' }, { '\u2273' },
+            { '\u2a8e' }, { '\u2a90' }, { '\u003e' }, { '\u003e' },
+            { '\u2aa7' }, { '\u2a7a' }, { '\u22d7' }, { '\u2995' },
+            { '\u2a7c' }, { '\u2a86' }, { '\u2978' }, { '\u22d7' },
+            { '\u22db' }, { '\u2a8c' }, { '\u2277' }, { '\u2273' },
+            { '\u21d4' }, { '\u200a' }, { '\u00bd' }, { '\u210b' },
+            { '\u044a' }, { '\u2194' }, { '\u2948' }, { '\u21ad' },
+            { '\u210f' }, { '\u0125' }, { '\u2665' }, { '\u2665' },
+            { '\u2026' }, { '\u22b9' }, { '\ud835', '\udd25' }, { '\u2925' },
+            { '\u2926' }, { '\u21ff' }, { '\u223b' }, { '\u21a9' },
+            { '\u21aa' }, { '\ud835', '\udd59' }, { '\u2015' },
+            { '\ud835', '\udcbd' }, { '\u210f' }, { '\u0127' }, { '\u2043' },
+            { '\u2010' }, { '\u00ed' }, { '\u00ed' }, { '\u2063' },
+            { '\u00ee' }, { '\u00ee' }, { '\u0438' }, { '\u0435' },
+            { '\u00a1' }, { '\u00a1' }, { '\u21d4' }, { '\ud835', '\udd26' },
+            { '\u00ec' }, { '\u00ec' }, { '\u2148' }, { '\u2a0c' },
+            { '\u222d' }, { '\u29dc' }, { '\u2129' }, { '\u0133' },
+            { '\u012b' }, { '\u2111' }, { '\u2110' }, { '\u2111' },
+            { '\u0131' }, { '\u22b7' }, { '\u01b5' }, { '\u2208' },
+            { '\u2105' }, { '\u221e' }, { '\u29dd' }, { '\u0131' },
+            { '\u222b' }, { '\u22ba' }, { '\u2124' }, { '\u22ba' },
+            { '\u2a17' }, { '\u2a3c' }, { '\u0451' }, { '\u012f' },
+            { '\ud835', '\udd5a' }, { '\u03b9' }, { '\u2a3c' }, { '\u00bf' },
+            { '\u00bf' }, { '\ud835', '\udcbe' }, { '\u2208' }, { '\u22f9' },
+            { '\u22f5' }, { '\u22f4' }, { '\u22f3' }, { '\u2208' },
+            { '\u2062' }, { '\u0129' }, { '\u0456' }, { '\u00ef' },
+            { '\u00ef' }, { '\u0135' }, { '\u0439' }, { '\ud835', '\udd27' },
+            { '\u0237' }, { '\ud835', '\udd5b' }, { '\ud835', '\udcbf' },
+            { '\u0458' }, { '\u0454' }, { '\u03ba' }, { '\u03f0' },
+            { '\u0137' }, { '\u043a' }, { '\ud835', '\udd28' }, { '\u0138' },
+            { '\u0445' }, { '\u045c' }, { '\ud835', '\udd5c' },
+            { '\ud835', '\udcc0' }, { '\u21da' }, { '\u21d0' }, { '\u291b' },
+            { '\u290e' }, { '\u2266' }, { '\u2a8b' }, { '\u2962' },
+            { '\u013a' }, { '\u29b4' }, { '\u2112' }, { '\u03bb' },
+            { '\u27e8' }, { '\u2991' }, { '\u27e8' }, { '\u2a85' },
+            { '\u00ab' }, { '\u00ab' }, { '\u2190' }, { '\u21e4' },
+            { '\u291f' }, { '\u291d' }, { '\u21a9' }, { '\u21ab' },
+            { '\u2939' }, { '\u2973' }, { '\u21a2' }, { '\u2aab' },
+            { '\u2919' }, { '\u2aad' }, { '\u290c' }, { '\u2772' },
+            { '\u007b' }, { '\u005b' }, { '\u298b' }, { '\u298f' },
+            { '\u298d' }, { '\u013e' }, { '\u013c' }, { '\u2308' },
+            { '\u007b' }, { '\u043b' }, { '\u2936' }, { '\u201c' },
+            { '\u201e' }, { '\u2967' }, { '\u294b' }, { '\u21b2' },
+            { '\u2264' }, { '\u2190' }, { '\u21a2' }, { '\u21bd' },
+            { '\u21bc' }, { '\u21c7' }, { '\u2194' }, { '\u21c6' },
+            { '\u21cb' }, { '\u21ad' }, { '\u22cb' }, { '\u22da' },
+            { '\u2264' }, { '\u2266' }, { '\u2a7d' }, { '\u2a7d' },
+            { '\u2aa8' }, { '\u2a7f' }, { '\u2a81' }, { '\u2a83' },
+            { '\u2a93' }, { '\u2a85' }, { '\u22d6' }, { '\u22da' },
+            { '\u2a8b' }, { '\u2276' }, { '\u2272' }, { '\u297c' },
+            { '\u230a' }, { '\ud835', '\udd29' }, { '\u2276' }, { '\u2a91' },
+            { '\u21bd' }, { '\u21bc' }, { '\u296a' }, { '\u2584' },
+            { '\u0459' }, { '\u226a' }, { '\u21c7' }, { '\u231e' },
+            { '\u296b' }, { '\u25fa' }, { '\u0140' }, { '\u23b0' },
+            { '\u23b0' }, { '\u2268' }, { '\u2a89' }, { '\u2a89' },
+            { '\u2a87' }, { '\u2a87' }, { '\u2268' }, { '\u22e6' },
+            { '\u27ec' }, { '\u21fd' }, { '\u27e6' }, { '\u27f5' },
+            { '\u27f7' }, { '\u27fc' }, { '\u27f6' }, { '\u21ab' },
+            { '\u21ac' }, { '\u2985' }, { '\ud835', '\udd5d' }, { '\u2a2d' },
+            { '\u2a34' }, { '\u2217' }, { '\u005f' }, { '\u25ca' },
+            { '\u25ca' }, { '\u29eb' }, { '\u0028' }, { '\u2993' },
+            { '\u21c6' }, { '\u231f' }, { '\u21cb' }, { '\u296d' },
+            { '\u200e' }, { '\u22bf' }, { '\u2039' }, { '\ud835', '\udcc1' },
+            { '\u21b0' }, { '\u2272' }, { '\u2a8d' }, { '\u2a8f' },
+            { '\u005b' }, { '\u2018' }, { '\u201a' }, { '\u0142' },
+            { '\u003c' }, { '\u003c' }, { '\u2aa6' }, { '\u2a79' },
+            { '\u22d6' }, { '\u22cb' }, { '\u22c9' }, { '\u2976' },
+            { '\u2a7b' }, { '\u2996' }, { '\u25c3' }, { '\u22b4' },
+            { '\u25c2' }, { '\u294a' }, { '\u2966' }, { '\u223a' },
+            { '\u00af' }, { '\u00af' }, { '\u2642' }, { '\u2720' },
+            { '\u2720' }, { '\u21a6' }, { '\u21a6' }, { '\u21a7' },
+            { '\u21a4' }, { '\u21a5' }, { '\u25ae' }, { '\u2a29' },
+            { '\u043c' }, { '\u2014' }, { '\u2221' }, { '\ud835', '\udd2a' },
+            { '\u2127' }, { '\u00b5' }, { '\u00b5' }, { '\u2223' },
+            { '\u002a' }, { '\u2af0' }, { '\u00b7' }, { '\u00b7' },
+            { '\u2212' }, { '\u229f' }, { '\u2238' }, { '\u2a2a' },
+            { '\u2adb' }, { '\u2026' }, { '\u2213' }, { '\u22a7' },
+            { '\ud835', '\udd5e' }, { '\u2213' }, { '\ud835', '\udcc2' },
+            { '\u223e' }, { '\u03bc' }, { '\u22b8' }, { '\u22b8' },
+            { '\u21cd' }, { '\u21ce' }, { '\u21cf' }, { '\u22af' },
+            { '\u22ae' }, { '\u2207' }, { '\u0144' }, { '\u2249' },
+            { '\u0149' }, { '\u2249' }, { '\u266e' }, { '\u266e' },
+            { '\u2115' }, { '\u00a0' }, { '\u00a0' }, { '\u2a43' },
+            { '\u0148' }, { '\u0146' }, { '\u2247' }, { '\u2a42' },
+            { '\u043d' }, { '\u2013' }, { '\u2260' }, { '\u21d7' },
+            { '\u2924' }, { '\u2197' }, { '\u2197' }, { '\u2262' },
+            { '\u2928' }, { '\u2204' }, { '\u2204' }, { '\ud835', '\udd2b' },
+            { '\u2271' }, { '\u2271' }, { '\u2275' }, { '\u226f' },
+            { '\u226f' }, { '\u21ce' }, { '\u21ae' }, { '\u2af2' },
+            { '\u220b' }, { '\u22fc' }, { '\u22fa' }, { '\u220b' },
+            { '\u045a' }, { '\u21cd' }, { '\u219a' }, { '\u2025' },
+            { '\u2270' }, { '\u219a' }, { '\u21ae' }, { '\u2270' },
+            { '\u226e' }, { '\u2274' }, { '\u226e' }, { '\u22ea' },
+            { '\u22ec' }, { '\u2224' }, { '\ud835', '\udd5f' }, { '\u00ac' },
+            { '\u00ac' }, { '\u2209' }, { '\u2209' }, { '\u22f7' },
+            { '\u22f6' }, { '\u220c' }, { '\u220c' }, { '\u22fe' },
+            { '\u22fd' }, { '\u2226' }, { '\u2226' }, { '\u2a14' },
+            { '\u2280' }, { '\u22e0' }, { '\u2280' }, { '\u21cf' },
+            { '\u219b' }, { '\u219b' }, { '\u22eb' }, { '\u22ed' },
+            { '\u2281' }, { '\u22e1' }, { '\ud835', '\udcc3' }, { '\u2224' },
+            { '\u2226' }, { '\u2241' }, { '\u2244' }, { '\u2244' },
+            { '\u2224' }, { '\u2226' }, { '\u22e2' }, { '\u22e3' },
+            { '\u2284' }, { '\u2288' }, { '\u2288' }, { '\u2281' },
+            { '\u2285' }, { '\u2289' }, { '\u2289' }, { '\u2279' },
+            { '\u00f1' }, { '\u00f1' }, { '\u2278' }, { '\u22ea' },
+            { '\u22ec' }, { '\u22eb' }, { '\u22ed' }, { '\u03bd' },
+            { '\u0023' }, { '\u2116' }, { '\u2007' }, { '\u22ad' },
+            { '\u2904' }, { '\u22ac' }, { '\u29de' }, { '\u2902' },
+            { '\u2903' }, { '\u21d6' }, { '\u2923' }, { '\u2196' },
+            { '\u2196' }, { '\u2927' }, { '\u24c8' }, { '\u00f3' },
+            { '\u00f3' }, { '\u229b' }, { '\u229a' }, { '\u00f4' },
+            { '\u00f4' }, { '\u043e' }, { '\u229d' }, { '\u0151' },
+            { '\u2a38' }, { '\u2299' }, { '\u29bc' }, { '\u0153' },
+            { '\u29bf' }, { '\ud835', '\udd2c' }, { '\u02db' }, { '\u00f2' },
+            { '\u00f2' }, { '\u29c1' }, { '\u29b5' }, { '\u2126' },
+            { '\u222e' }, { '\u21ba' }, { '\u29be' }, { '\u29bb' },
+            { '\u203e' }, { '\u29c0' }, { '\u014d' }, { '\u03c9' },
+            { '\u03bf' }, { '\u29b6' }, { '\u2296' }, { '\ud835', '\udd60' },
+            { '\u29b7' }, { '\u29b9' }, { '\u2295' }, { '\u2228' },
+            { '\u21bb' }, { '\u2a5d' }, { '\u2134' }, { '\u2134' },
+            { '\u00aa' }, { '\u00aa' }, { '\u00ba' }, { '\u00ba' },
+            { '\u22b6' }, { '\u2a56' }, { '\u2a57' }, { '\u2a5b' },
+            { '\u2134' }, { '\u00f8' }, { '\u00f8' }, { '\u2298' },
+            { '\u00f5' }, { '\u00f5' }, { '\u2297' }, { '\u2a36' },
+            { '\u00f6' }, { '\u00f6' }, { '\u233d' }, { '\u2225' },
+            { '\u00b6' }, { '\u00b6' }, { '\u2225' }, { '\u2af3' },
+            { '\u2afd' }, { '\u2202' }, { '\u043f' }, { '\u0025' },
+            { '\u002e' }, { '\u2030' }, { '\u22a5' }, { '\u2031' },
+            { '\ud835', '\udd2d' }, { '\u03c6' }, { '\u03c6' }, { '\u2133' },
+            { '\u260e' }, { '\u03c0' }, { '\u22d4' }, { '\u03d6' },
+            { '\u210f' }, { '\u210e' }, { '\u210f' }, { '\u002b' },
+            { '\u2a23' }, { '\u229e' }, { '\u2a22' }, { '\u2214' },
+            { '\u2a25' }, { '\u2a72' }, { '\u00b1' }, { '\u00b1' },
+            { '\u2a26' }, { '\u2a27' }, { '\u00b1' }, { '\u2a15' },
+            { '\ud835', '\udd61' }, { '\u00a3' }, { '\u00a3' }, { '\u227a' },
+            { '\u2ab3' }, { '\u2ab7' }, { '\u227c' }, { '\u2aaf' },
+            { '\u227a' }, { '\u2ab7' }, { '\u227c' }, { '\u2aaf' },
+            { '\u2ab9' }, { '\u2ab5' }, { '\u22e8' }, { '\u227e' },
+            { '\u2032' }, { '\u2119' }, { '\u2ab5' }, { '\u2ab9' },
+            { '\u22e8' }, { '\u220f' }, { '\u232e' }, { '\u2312' },
+            { '\u2313' }, { '\u221d' }, { '\u221d' }, { '\u227e' },
+            { '\u22b0' }, { '\ud835', '\udcc5' }, { '\u03c8' }, { '\u2008' },
+            { '\ud835', '\udd2e' }, { '\u2a0c' }, { '\ud835', '\udd62' },
+            { '\u2057' }, { '\ud835', '\udcc6' }, { '\u210d' }, { '\u2a16' },
+            { '\u003f' }, { '\u225f' }, { '\u0022' }, { '\u0022' },
+            { '\u21db' }, { '\u21d2' }, { '\u291c' }, { '\u290f' },
+            { '\u2964' }, { '\u29da' }, { '\u0155' }, { '\u221a' },
+            { '\u29b3' }, { '\u27e9' }, { '\u2992' }, { '\u29a5' },
+            { '\u27e9' }, { '\u00bb' }, { '\u00bb' }, { '\u2192' },
+            { '\u2975' }, { '\u21e5' }, { '\u2920' }, { '\u2933' },
+            { '\u291e' }, { '\u21aa' }, { '\u21ac' }, { '\u2945' },
+            { '\u2974' }, { '\u21a3' }, { '\u219d' }, { '\u291a' },
+            { '\u2236' }, { '\u211a' }, { '\u290d' }, { '\u2773' },
+            { '\u007d' }, { '\u005d' }, { '\u298c' }, { '\u298e' },
+            { '\u2990' }, { '\u0159' }, { '\u0157' }, { '\u2309' },
+            { '\u007d' }, { '\u0440' }, { '\u2937' }, { '\u2969' },
+            { '\u201d' }, { '\u201d' }, { '\u21b3' }, { '\u211c' },
+            { '\u211b' }, { '\u211c' }, { '\u211d' }, { '\u25ad' },
+            { '\u00ae' }, { '\u00ae' }, { '\u297d' }, { '\u230b' },
+            { '\ud835', '\udd2f' }, { '\u21c1' }, { '\u21c0' }, { '\u296c' },
+            { '\u03c1' }, { '\u03f1' }, { '\u2192' }, { '\u21a3' },
+            { '\u21c1' }, { '\u21c0' }, { '\u21c4' }, { '\u21cc' },
+            { '\u21c9' }, { '\u219d' }, { '\u22cc' }, { '\u02da' },
+            { '\u2253' }, { '\u21c4' }, { '\u21cc' }, { '\u200f' },
+            { '\u23b1' }, { '\u23b1' }, { '\u2aee' }, { '\u27ed' },
+            { '\u21fe' }, { '\u27e7' }, { '\u2986' }, { '\ud835', '\udd63' },
+            { '\u2a2e' }, { '\u2a35' }, { '\u0029' }, { '\u2994' },
+            { '\u2a12' }, { '\u21c9' }, { '\u203a' }, { '\ud835', '\udcc7' },
+            { '\u21b1' }, { '\u005d' }, { '\u2019' }, { '\u2019' },
+            { '\u22cc' }, { '\u22ca' }, { '\u25b9' }, { '\u22b5' },
+            { '\u25b8' }, { '\u29ce' }, { '\u2968' }, { '\u211e' },
+            { '\u015b' }, { '\u201a' }, { '\u227b' }, { '\u2ab4' },
+            { '\u2ab8' }, { '\u0161' }, { '\u227d' }, { '\u2ab0' },
+            { '\u015f' }, { '\u015d' }, { '\u2ab6' }, { '\u2aba' },
+            { '\u22e9' }, { '\u2a13' }, { '\u227f' }, { '\u0441' },
+            { '\u22c5' }, { '\u22a1' }, { '\u2a66' }, { '\u21d8' },
+            { '\u2925' }, { '\u2198' }, { '\u2198' }, { '\u00a7' },
+            { '\u00a7' }, { '\u003b' }, { '\u2929' }, { '\u2216' },
+            { '\u2216' }, { '\u2736' }, { '\ud835', '\udd30' }, { '\u2322' },
+            { '\u266f' }, { '\u0449' }, { '\u0448' }, { '\u2223' },
+            { '\u2225' }, { '\u00ad' }, { '\u00ad' }, { '\u03c3' },
+            { '\u03c2' }, { '\u03c2' }, { '\u223c' }, { '\u2a6a' },
+            { '\u2243' }, { '\u2243' }, { '\u2a9e' }, { '\u2aa0' },
+            { '\u2a9d' }, { '\u2a9f' }, { '\u2246' }, { '\u2a24' },
+            { '\u2972' }, { '\u2190' }, { '\u2216' }, { '\u2a33' },
+            { '\u29e4' }, { '\u2223' }, { '\u2323' }, { '\u2aaa' },
+            { '\u2aac' }, { '\u044c' }, { '\u002f' }, { '\u29c4' },
+            { '\u233f' }, { '\ud835', '\udd64' }, { '\u2660' }, { '\u2660' },
+            { '\u2225' }, { '\u2293' }, { '\u2294' }, { '\u228f' },
+            { '\u2291' }, { '\u228f' }, { '\u2291' }, { '\u2290' },
+            { '\u2292' }, { '\u2290' }, { '\u2292' }, { '\u25a1' },
+            { '\u25a1' }, { '\u25aa' }, { '\u25aa' }, { '\u2192' },
+            { '\ud835', '\udcc8' }, { '\u2216' }, { '\u2323' }, { '\u22c6' },
+            { '\u2606' }, { '\u2605' }, { '\u03f5' }, { '\u03d5' },
+            { '\u00af' }, { '\u2282' }, { '\u2ac5' }, { '\u2abd' },
+            { '\u2286' }, { '\u2ac3' }, { '\u2ac1' }, { '\u2acb' },
+            { '\u228a' }, { '\u2abf' }, { '\u2979' }, { '\u2282' },
+            { '\u2286' }, { '\u2ac5' }, { '\u228a' }, { '\u2acb' },
+            { '\u2ac7' }, { '\u2ad5' }, { '\u2ad3' }, { '\u227b' },
+            { '\u2ab8' }, { '\u227d' }, { '\u2ab0' }, { '\u2aba' },
+            { '\u2ab6' }, { '\u22e9' }, { '\u227f' }, { '\u2211' },
+            { '\u266a' }, { '\u00b9' }, { '\u00b9' }, { '\u00b2' },
+            { '\u00b2' }, { '\u00b3' }, { '\u00b3' }, { '\u2283' },
+            { '\u2ac6' }, { '\u2abe' }, { '\u2ad8' }, { '\u2287' },
+            { '\u2ac4' }, { '\u2ad7' }, { '\u297b' }, { '\u2ac2' },
+            { '\u2acc' }, { '\u228b' }, { '\u2ac0' }, { '\u2283' },
+            { '\u2287' }, { '\u2ac6' }, { '\u228b' }, { '\u2acc' },
+            { '\u2ac8' }, { '\u2ad4' }, { '\u2ad6' }, { '\u21d9' },
+            { '\u2926' }, { '\u2199' }, { '\u2199' }, { '\u292a' },
+            { '\u00df' }, { '\u00df' }, { '\u2316' }, { '\u03c4' },
+            { '\u23b4' }, { '\u0165' }, { '\u0163' }, { '\u0442' },
+            { '\u20db' }, { '\u2315' }, { '\ud835', '\udd31' }, { '\u2234' },
+            { '\u2234' }, { '\u03b8' }, { '\u03d1' }, { '\u03d1' },
+            { '\u2248' }, { '\u223c' }, { '\u2009' }, { '\u2248' },
+            { '\u223c' }, { '\u00fe' }, { '\u00fe' }, { '\u02dc' },
+            { '\u00d7' }, { '\u00d7' }, { '\u22a0' }, { '\u2a31' },
+            { '\u2a30' }, { '\u222d' }, { '\u2928' }, { '\u22a4' },
+            { '\u2336' }, { '\u2af1' }, { '\ud835', '\udd65' }, { '\u2ada' },
+            { '\u2929' }, { '\u2034' }, { '\u2122' }, { '\u25b5' },
+            { '\u25bf' }, { '\u25c3' }, { '\u22b4' }, { '\u225c' },
+            { '\u25b9' }, { '\u22b5' }, { '\u25ec' }, { '\u225c' },
+            { '\u2a3a' }, { '\u2a39' }, { '\u29cd' }, { '\u2a3b' },
+            { '\u23e2' }, { '\ud835', '\udcc9' }, { '\u0446' }, { '\u045b' },
+            { '\u0167' }, { '\u226c' }, { '\u219e' }, { '\u21a0' },
+            { '\u21d1' }, { '\u2963' }, { '\u00fa' }, { '\u00fa' },
+            { '\u2191' }, { '\u045e' }, { '\u016d' }, { '\u00fb' },
+            { '\u00fb' }, { '\u0443' }, { '\u21c5' }, { '\u0171' },
+            { '\u296e' }, { '\u297e' }, { '\ud835', '\udd32' }, { '\u00f9' },
+            { '\u00f9' }, { '\u21bf' }, { '\u21be' }, { '\u2580' },
+            { '\u231c' }, { '\u231c' }, { '\u230f' }, { '\u25f8' },
+            { '\u016b' }, { '\u00a8' }, { '\u00a8' }, { '\u0173' },
+            { '\ud835', '\udd66' }, { '\u2191' }, { '\u2195' }, { '\u21bf' },
+            { '\u21be' }, { '\u228e' }, { '\u03c5' }, { '\u03d2' },
+            { '\u03c5' }, { '\u21c8' }, { '\u231d' }, { '\u231d' },
+            { '\u230e' }, { '\u016f' }, { '\u25f9' }, { '\ud835', '\udcca' },
+            { '\u22f0' }, { '\u0169' }, { '\u25b5' }, { '\u25b4' },
+            { '\u21c8' }, { '\u00fc' }, { '\u00fc' }, { '\u29a7' },
+            { '\u21d5' }, { '\u2ae8' }, { '\u2ae9' }, { '\u22a8' },
+            { '\u299c' }, { '\u03b5' }, { '\u03f0' }, { '\u2205' },
+            { '\u03c6' }, { '\u03d6' }, { '\u221d' }, { '\u2195' },
+            { '\u03f1' }, { '\u03c2' }, { '\u03d1' }, { '\u22b2' },
+            { '\u22b3' }, { '\u0432' }, { '\u22a2' }, { '\u2228' },
+            { '\u22bb' }, { '\u225a' }, { '\u22ee' }, { '\u007c' },
+            { '\u007c' }, { '\ud835', '\udd33' }, { '\u22b2' },
+            { '\ud835', '\udd67' }, { '\u221d' }, { '\u22b3' },
+            { '\ud835', '\udccb' }, { '\u299a' }, { '\u0175' }, { '\u2a5f' },
+            { '\u2227' }, { '\u2259' }, { '\u2118' }, { '\ud835', '\udd34' },
+            { '\ud835', '\udd68' }, { '\u2118' }, { '\u2240' }, { '\u2240' },
+            { '\ud835', '\udccc' }, { '\u22c2' }, { '\u25ef' }, { '\u22c3' },
+            { '\u25bd' }, { '\ud835', '\udd35' }, { '\u27fa' }, { '\u27f7' },
+            { '\u03be' }, { '\u27f8' }, { '\u27f5' }, { '\u27fc' },
+            { '\u22fb' }, { '\u2a00' }, { '\ud835', '\udd69' }, { '\u2a01' },
+            { '\u2a02' }, { '\u27f9' }, { '\u27f6' }, { '\ud835', '\udccd' },
+            { '\u2a06' }, { '\u2a04' }, { '\u25b3' }, { '\u22c1' },
+            { '\u22c0' }, { '\u00fd' }, { '\u00fd' }, { '\u044f' },
+            { '\u0177' }, { '\u044b' }, { '\u00a5' }, { '\u00a5' },
+            { '\ud835', '\udd36' }, { '\u0457' }, { '\ud835', '\udd6a' },
+            { '\ud835', '\udcce' }, { '\u044e' }, { '\u00ff' }, { '\u00ff' },
+            { '\u017a' }, { '\u017e' }, { '\u0437' }, { '\u017c' },
+            { '\u2128' }, { '\u03b6' }, { '\ud835', '\udd37' }, { '\u0436' },
+            { '\u21dd' }, { '\ud835', '\udd6b' }, { '\ud835', '\udccf' },
+            { '\u200d' }, { '\u200c' }, };
+
+    final static char[][] WINDOWS_1252 = { { '\u20AC' }, { '\uFFFD' },
+            { '\u201A' }, { '\u0192' }, { '\u201E' }, { '\u2026' },
+            { '\u2020' }, { '\u2021' }, { '\u02C6' }, { '\u2030' },
+            { '\u0160' }, { '\u2039' }, { '\u0152' }, { '\uFFFD' },
+            { '\u017D' }, { '\uFFFD' }, { '\uFFFD' }, { '\u2018' },
+            { '\u2019' }, { '\u201C' }, { '\u201D' }, { '\u2022' },
+            { '\u2013' }, { '\u2014' }, { '\u02DC' }, { '\u2122' },
+            { '\u0161' }, { '\u203A' }, { '\u0153' }, { '\uFFFD' },
+            { '\u017E' }, { '\u0178' } };
+
+}
diff --git a/parser/html/java/htmlparser/src/Portability.java b/parser/html/java/htmlparser/src/Portability.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/Portability.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (c) 2008-2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.Literal;
+import nu.validator.htmlparser.annotation.Local;
+import nu.validator.htmlparser.annotation.NoLength;
+
+public final class Portability {
+
+    // Allocating methods
+
+    /**
+     * Allocates a new local name object. In C++, the refcount must be set up in such a way that 
+     * calling <code>releaseLocal</code> on the return value balances the refcount set by this method.
+     */
+    public static @Local String newLocalNameFromBuffer(@NoLength char[] buf, int offset, int length) {
+        return new String(buf, offset, length).intern();
+    }
+
+    public static String newStringFromBuffer(@NoLength char[] buf, int offset, int length) {
+        return new String(buf, offset, length);
+    }
+
+    public static String newEmptyString() {
+        return "";
+    }
+
+    public static String newStringFromLiteral(@Literal String literal) {
+        return literal;
+    }
+    
+    // XXX get rid of this
+    public static char[] newCharArrayFromLocal(@Local String local) {
+        return local.toCharArray();
+    }
+
+    public static char[] newCharArrayFromString(String string) {
+        return string.toCharArray();
+    }
+    
+    // Deallocation methods
+    
+    public static void releaseString(String str) {
+        // No-op in Java
+    }
+    
+    public static void retainLocal(@Local String local) {
+        // No-op in Java
+    }
+
+    /**
+     * This MUST be a no-op on locals that are known at compile time.
+     * @param local
+     */
+    public static void releaseLocal(@Local String local) {
+        // No-op in Java
+    }
+    
+    /**
+     * Releases a Java array. This method is magically replaced by a macro in C++.
+     * @param arr
+     */
+    public static void releaseArray(Object arr) {
+        // No-op in Java
+    }    
+    
+    public static void retainElement(Object elt) {
+        // No-op in Java
+    }
+
+    public static void releaseElement(Object elt) {
+        // No-op in Java
+    }
+    
+    // Comparison methods
+    
+    public static boolean localEqualsBuffer(@Local String local, @NoLength char[] buf, int offset, int length) {
+        if (local.length() != length) {
+            return false;
+        }
+        for (int i = 0; i < length; i++) {
+            if (local.charAt(i) != buf[offset + i]) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public static boolean lowerCaseLiteralIsPrefixOfIgnoreAsciiCaseString(@Literal String lowerCaseLiteral,
+            String string) {
+        if (string == null) {
+            return false;
+        }
+        if (lowerCaseLiteral.length() > string.length()) {
+            return false;
+        }
+        for (int i = 0; i < lowerCaseLiteral.length(); i++) {
+            char c0 = lowerCaseLiteral.charAt(i);
+            char c1 = string.charAt(i);
+            if (c1 >= 'A' && c1 <= 'Z') {
+                c1 += 0x20;
+            }
+            if (c0 != c1) {
+                return false;
+            }
+        }
+        return true;
+    }
+    
+    public static boolean lowerCaseLiteralEqualsIgnoreAsciiCaseString(@Literal String lowerCaseLiteral,
+            String string) {
+        if (string == null) {
+            return false;
+        }
+        if (lowerCaseLiteral.length() != string.length()) {
+            return false;
+        }
+        for (int i = 0; i < lowerCaseLiteral.length(); i++) {
+            char c0 = lowerCaseLiteral.charAt(i);
+            char c1 = string.charAt(i);
+            if (c1 >= 'A' && c1 <= 'Z') {
+                c1 += 0x20;
+            }
+            if (c0 != c1) {
+                return false;
+            }
+        }
+        return true;
+    }
+    
+    public static boolean literalEqualsString(@Literal String literal, String string) {
+        return literal.equals(string);
+    }
+
+    public static char[] isIndexPrompt() {
+        return "This is a searchable index. Insert your search keywords here: ".toCharArray();
+    }
+
+    public static void delete(Object o) {
+        
+    }
+
+    public static void deleteArray(Object o) {
+        
+    }
+}
diff --git a/parser/html/java/htmlparser/src/PushedLocation.java b/parser/html/java/htmlparser/src/PushedLocation.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/PushedLocation.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 2008 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+public class PushedLocation {
+    private final int line;
+
+    private final int linePrev;
+
+    private final int col;
+
+    private final int colPrev;
+
+    private final boolean nextCharOnNewLine;
+
+    private final String publicId;
+
+    private final String systemId;
+
+    private final PushedLocation next;
+
+    /**
+     * @param line
+     * @param linePrev
+     * @param col
+     * @param colPrev
+     * @param nextCharOnNewLine
+     * @param publicId
+     * @param systemId
+     * @param next
+     */
+    public PushedLocation(int line, int linePrev, int col, int colPrev,
+            boolean nextCharOnNewLine, String publicId, String systemId,
+            PushedLocation next) {
+        this.line = line;
+        this.linePrev = linePrev;
+        this.col = col;
+        this.colPrev = colPrev;
+        this.nextCharOnNewLine = nextCharOnNewLine;
+        this.publicId = publicId;
+        this.systemId = systemId;
+        this.next = next;
+    }
+
+    /**
+     * Returns the line.
+     * 
+     * @return the line
+     */
+    public int getLine() {
+        return line;
+    }
+
+    /**
+     * Returns the linePrev.
+     * 
+     * @return the linePrev
+     */
+    public int getLinePrev() {
+        return linePrev;
+    }
+
+    /**
+     * Returns the col.
+     * 
+     * @return the col
+     */
+    public int getCol() {
+        return col;
+    }
+
+    /**
+     * Returns the colPrev.
+     * 
+     * @return the colPrev
+     */
+    public int getColPrev() {
+        return colPrev;
+    }
+
+    /**
+     * Returns the nextCharOnNewLine.
+     * 
+     * @return the nextCharOnNewLine
+     */
+    public boolean isNextCharOnNewLine() {
+        return nextCharOnNewLine;
+    }
+
+    /**
+     * Returns the publicId.
+     * 
+     * @return the publicId
+     */
+    public String getPublicId() {
+        return publicId;
+    }
+
+    /**
+     * Returns the systemId.
+     * 
+     * @return the systemId
+     */
+    public String getSystemId() {
+        return systemId;
+    }
+
+    /**
+     * Returns the next.
+     * 
+     * @return the next
+     */
+    public PushedLocation getNext() {
+        return next;
+    }
+}
diff --git a/parser/html/java/htmlparser/src/StackNode.java b/parser/html/java/htmlparser/src/StackNode.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/StackNode.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2007 Henri Sivonen
+ * Copyright (c) 2007-2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.Local;
+import nu.validator.htmlparser.annotation.NsUri;
+
+final class StackNode<T> {
+    final int group;
+
+    final @Local String name;
+
+    final @Local String popName;
+
+    final @NsUri String ns;
+
+    final T node;
+
+    final boolean scoping;
+
+    final boolean special;
+
+    final boolean fosterParenting;
+    
+    private int refcount = 1;
+
+    /**
+     * @param group
+     *            TODO
+     * @param name
+     * @param node
+     * @param scoping
+     * @param special
+     * @param popName
+     *            TODO
+     */
+    StackNode(int group, final @NsUri String ns, final @Local String name, final T node,
+            final boolean scoping, final boolean special,
+            final boolean fosterParenting, final @Local String popName) {
+        this.group = group;
+        this.name = name;
+        this.popName = popName;
+        this.ns = ns;
+        this.node = node;
+        this.scoping = scoping;
+        this.special = special;
+        this.fosterParenting = fosterParenting;
+        this.refcount = 1;
+        Portability.retainLocal(name);
+        Portability.retainLocal(popName);
+        Portability.retainElement(node);
+        // not retaining namespace for now        
+    }
+
+    /**
+     * @param elementName
+     *            TODO
+     * @param node
+     */
+    StackNode(final @NsUri String ns, ElementName elementName, final T node) {
+        this.group = elementName.group;
+        this.name = elementName.name;
+        this.popName = elementName.name;
+        this.ns = ns;
+        this.node = node;
+        this.scoping = elementName.scoping;
+        this.special = elementName.special;
+        this.fosterParenting = elementName.fosterParenting;
+        this.refcount = 1;
+        Portability.retainLocal(name);
+        Portability.retainLocal(popName);
+        Portability.retainElement(node);
+        // not retaining namespace for now        
+    }
+
+    StackNode(final @NsUri String ns, ElementName elementName, final T node, @Local String popName) {
+        this.group = elementName.group;
+        this.name = elementName.name;
+        this.popName = popName;
+        this.ns = ns;
+        this.node = node;
+        this.scoping = elementName.scoping;
+        this.special = elementName.special;
+        this.fosterParenting = elementName.fosterParenting;
+        this.refcount = 1;
+        Portability.retainLocal(name);
+        Portability.retainLocal(popName);
+        Portability.retainElement(node);
+        // not retaining namespace for now        
+    }
+
+    StackNode(final @NsUri String ns, ElementName elementName, final T node, @Local String popName, boolean scoping) {
+        this.group = elementName.group;
+        this.name = elementName.name;
+        this.popName = popName;
+        this.ns = ns;
+        this.node = node;
+        this.scoping = scoping;
+        this.special = false;
+        this.fosterParenting = false;
+        this.refcount = 1;
+        Portability.retainLocal(name);
+        Portability.retainLocal(popName);
+        Portability.retainElement(node);
+        // not retaining namespace for now        
+    }
+    
+    @SuppressWarnings("unused") private void destructor() {
+        Portability.releaseLocal(name);
+        Portability.releaseLocal(popName);
+        Portability.releaseElement(node);
+        // not releasing namespace for now        
+    }
+    
+    // [NOCPP[
+    /**
+     * @see java.lang.Object#toString()
+     */
+    @Override public @Local String toString() {
+        return name;
+    }
+    // ]NOCPP]
+    
+    public void retain() {   
+        refcount++;
+    }
+    
+    public void release() {
+        refcount--;
+        if (refcount == 0) {
+            Portability.delete(this);
+        }
+    }
+}
diff --git a/parser/html/java/htmlparser/src/StateSnapshot.java b/parser/html/java/htmlparser/src/StateSnapshot.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/StateSnapshot.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+
+public class StateSnapshot<T> {
+
+    /**
+     * @param stack
+     * @param listOfActiveFormattingElements
+     * @param formPointer
+     */
+    StateSnapshot(StackNode<T>[] stack,
+            StackNode<T>[] listOfActiveFormattingElements, T formPointer) {
+        this.stack = stack;
+        this.listOfActiveFormattingElements = listOfActiveFormattingElements;
+        this.formPointer = formPointer;
+    }
+
+    final StackNode<T>[] stack;
+
+    final StackNode<T>[] listOfActiveFormattingElements;
+
+    final T formPointer;
+    
+    @SuppressWarnings("unused") private void destructor() {
+        for (int i = 0; i < stack.length; i++) {
+            stack[i].release();
+        }
+        Portability.releaseArray(stack);
+        for (int i = 0; i < listOfActiveFormattingElements.length; i++) {
+            if (listOfActiveFormattingElements[i] != null) {
+                listOfActiveFormattingElements[i].release();                
+            }
+        }
+        Portability.releaseArray(listOfActiveFormattingElements);
+        Portability.retainElement(formPointer);
+    }
+}
diff --git a/parser/html/java/htmlparser/src/Tokenizer.java b/parser/html/java/htmlparser/src/Tokenizer.java
new file mode 100755
--- /dev/null
+++ b/parser/html/java/htmlparser/src/Tokenizer.java
@@ -0,0 +1,5888 @@
+/*
+ * Copyright (c) 2005-2007 Henri Sivonen
+ * Copyright (c) 2007-2009 Mozilla Foundation
+ * Portions of comments Copyright 2004-2008 Apple Computer, Inc., Mozilla 
+ * Foundation, and Opera Software ASA.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * The comments following this one that use the same comment syntax as this 
+ * comment are quotes from the WHATWG HTML 5 spec as of 2 June 2007 
+ * amended as of June 18 2008.
+ * That document came with this statement:
+ * " Copyright 2004-2008 Apple Computer, Inc., Mozilla Foundation, and 
+ * Opera Software ASA. You are granted a license to use, reproduce and 
+ * create derivative works of this document."
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.Inline;
+import nu.validator.htmlparser.annotation.Local;
+import nu.validator.htmlparser.annotation.NoLength;
+import nu.validator.htmlparser.common.EncodingDeclarationHandler;
+import nu.validator.htmlparser.common.TokenHandler;
+import nu.validator.htmlparser.common.XmlViolationPolicy;
+
+import org.xml.sax.ErrorHandler;
+import org.xml.sax.Locator;
+import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
+
+/**
+ * An implementation of
+ * http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html
+ * 
+ * This class implements the <code>Locator</code> interface. This is not an
+ * incidental implementation detail: Users of this class are encouraged to make
+ * use of the <code>Locator</code> nature.
+ * 
+ * By default, the tokenizer may report data that XML 1.0 bans. The tokenizer
+ * can be configured to treat these conditions as fatal or to coerce the infoset
+ * to something that XML 1.0 allows.
+ * 
+ * @version $Id: Tokenizer.java 565 2009-07-03 14:40:35Z hsivonen $
+ * @author hsivonen
+ */
+public class Tokenizer implements Locator {
+
+    public static final int DATA = 0;
+
+    public static final int RCDATA = 1;
+
+    public static final int CDATA = 2;
+
+    public static final int PLAINTEXT = 3;
+
+    private static final int TAG_OPEN = 4;
+
+    private static final int CLOSE_TAG_OPEN_PCDATA = 5;
+
+    private static final int TAG_NAME = 6;
+
+    private static final int BEFORE_ATTRIBUTE_NAME = 7;
+
+    private static final int ATTRIBUTE_NAME = 8;
+
+    private static final int AFTER_ATTRIBUTE_NAME = 9;
+
+    private static final int BEFORE_ATTRIBUTE_VALUE = 10;
+
+    private static final int ATTRIBUTE_VALUE_DOUBLE_QUOTED = 11;
+
+    private static final int ATTRIBUTE_VALUE_SINGLE_QUOTED = 12;
+
+    private static final int ATTRIBUTE_VALUE_UNQUOTED = 13;
+
+    private static final int AFTER_ATTRIBUTE_VALUE_QUOTED = 14;
+
+    private static final int BOGUS_COMMENT = 15;
+
+    private static final int MARKUP_DECLARATION_OPEN = 16;
+
+    private static final int DOCTYPE = 17;
+
+    private static final int BEFORE_DOCTYPE_NAME = 18;
+
+    private static final int DOCTYPE_NAME = 19;
+
+    private static final int AFTER_DOCTYPE_NAME = 20;
+
+    private static final int BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 21;
+
+    private static final int DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 22;
+
+    private static final int DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 23;
+
+    private static final int AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 24;
+
+    private static final int BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 25;
+
+    private static final int DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 26;
+
+    private static final int DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 27;
+
+    private static final int AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 28;
+
+    private static final int BOGUS_DOCTYPE = 29;
+
+    private static final int COMMENT_START = 30;
+
+    private static final int COMMENT_START_DASH = 31;
+
+    private static final int COMMENT = 32;
+
+    private static final int COMMENT_END_DASH = 33;
+
+    private static final int COMMENT_END = 34;
+
+    private static final int COMMENT_END_SPACE = 35;
+
+    private static final int COMMENT_END_BANG = 36;
+
+    private static final int CLOSE_TAG_OPEN_NOT_PCDATA = 37;
+
+    private static final int MARKUP_DECLARATION_HYPHEN = 38;
+
+    private static final int MARKUP_DECLARATION_OCTYPE = 39;
+
+    private static final int DOCTYPE_UBLIC = 40;
+
+    private static final int DOCTYPE_YSTEM = 41;
+
+    private static final int CONSUME_CHARACTER_REFERENCE = 42;
+
+    private static final int CONSUME_NCR = 43;
+
+    private static final int CHARACTER_REFERENCE_LOOP = 44;
+
+    private static final int HEX_NCR_LOOP = 45;
+
+    private static final int DECIMAL_NRC_LOOP = 46;
+
+    private static final int HANDLE_NCR_VALUE = 47;
+
+    private static final int SELF_CLOSING_START_TAG = 48;
+
+    private static final int CDATA_START = 49;
+
+    private static final int CDATA_SECTION = 50;
+
+    private static final int CDATA_RSQB = 51;
+
+    private static final int CDATA_RSQB_RSQB = 52;
+
+    private static final int TAG_OPEN_NON_PCDATA = 53;
+
+    private static final int ESCAPE_EXCLAMATION = 54;
+
+    private static final int ESCAPE_EXCLAMATION_HYPHEN = 55;
+
+    private static final int ESCAPE = 56;
+
+    private static final int ESCAPE_HYPHEN = 57;
+
+    private static final int ESCAPE_HYPHEN_HYPHEN = 58;
+
+    private static final int BOGUS_COMMENT_HYPHEN = 59;
+
+    /**
+     * Magic value for UTF-16 operations.
+     */
+    private static final int LEAD_OFFSET = (0xD800 - (0x10000 >> 10));
+
+    /**
+     * UTF-16 code unit array containing less than and greater than for emitting
+     * those characters on certain parse errors.
+     */
+    private static final @NoLength char[] LT_GT = { '<', '>' };
+
+    /**
+     * UTF-16 code unit array containing less than and solidus for emitting
+     * those characters on certain parse errors.
+     */
+    private static final @NoLength char[] LT_SOLIDUS = { '<', '/' };
+
+    /**
+     * UTF-16 code unit array containing ]] for emitting those characters on
+     * state transitions.
+     */
+    private static final @NoLength char[] RSQB_RSQB = { ']', ']' };
+
+    /**
+     * Array version of U+FFFD.
+     */
+    private static final @NoLength char[] REPLACEMENT_CHARACTER = { '\uFFFD' };
+
+    // [NOCPP[
+
+    /**
+     * Array version of space.
+     */
+    private static final @NoLength char[] SPACE = { ' ' };
+
+    // ]NOCPP]
+
+    /**
+     * Array version of line feed.
+     */
+    private static final @NoLength char[] LF = { '\n' };
+
+    /**
+     * Buffer growth parameter.
+     */
+    private static final int BUFFER_GROW_BY = 1024;
+
+    /**
+     * "CDATA[" as <code>char[]</code>
+     */
+    private static final @NoLength char[] CDATA_LSQB = "CDATA[".toCharArray();
+
+    /**
+     * "octype" as <code>char[]</code>
+     */
+    private static final @NoLength char[] OCTYPE = "octype".toCharArray();
+
+    /**
+     * "ublic" as <code>char[]</code>
+     */
+    private static final @NoLength char[] UBLIC = "ublic".toCharArray();
+
+    /**
+     * "ystem" as <code>char[]</code>
+     */
+    private static final @NoLength char[] YSTEM = "ystem".toCharArray();
+
+    private static final char[] TITLE_ARR = { 't', 'i', 't', 'l', 'e' };
+
+    private static final char[] SCRIPT_ARR = { 's', 'c', 'r', 'i', 'p', 't' };
+
+    private static final char[] STYLE_ARR = { 's', 't', 'y', 'l', 'e' };
+
+    private static final char[] PLAINTEXT_ARR = { 'p', 'l', 'a', 'i', 'n', 't',
+            'e', 'x', 't' };
+
+    private static final char[] XMP_ARR = { 'x', 'm', 'p' };
+
+    private static final char[] TEXTAREA_ARR = { 't', 'e', 'x', 't', 'a', 'r',
+            'e', 'a' };
+
+    private static final char[] IFRAME_ARR = { 'i', 'f', 'r', 'a', 'm', 'e' };
+
+    private static final char[] NOEMBED_ARR = { 'n', 'o', 'e', 'm', 'b', 'e',
+            'd' };
+
+    private static final char[] NOSCRIPT_ARR = { 'n', 'o', 's', 'c', 'r', 'i',
+            'p', 't' };
+
+    private static final char[] NOFRAMES_ARR = { 'n', 'o', 'f', 'r', 'a', 'm',
+            'e', 's' };
+
+    /**
+     * The token handler.
+     */
+    protected final TokenHandler tokenHandler;
+
+    protected EncodingDeclarationHandler encodingDeclarationHandler;
+
+    // [NOCPP[
+
+    /**
+     * The error handler.
+     */
+    protected ErrorHandler errorHandler;
+
+    // ]NOCPP]
+
+    /**
+     * Whether the previous char read was CR.
+     */
+    protected boolean lastCR;
+
+    protected int stateSave;
+
+    private int returnStateSave;
+
+    protected int index;
+
+    private boolean forceQuirks;
+
+    private char additional;
+
+    private int entCol;
+
+    private int lo;
+
+    private int hi;
+
+    private int candidate;
+
+    private int strBufMark;
+
+    private int prevValue;
+
+    protected int value;
+
+    private boolean seenDigits;
+
+    protected int cstart;
+
+    /**
+     * The SAX public id for the resource being tokenized. (Only passed to back
+     * as part of locator data.)
+     */
+    private String publicId;
+
+    /**
+     * The SAX system id for the resource being tokenized. (Only passed to back
+     * as part of locator data.)
+     */
+    private String systemId;
+
+    /**
+     * Buffer for short identifiers.
+     */
+    private char[] strBuf;
+
+    /**
+     * Number of significant <code>char</code>s in <code>strBuf</code>.
+     */
+    private int strBufLen;
+
+    /**
+     * <code>-1</code> to indicate that <code>strBuf</code> is used or otherwise
+     * an offset to the main buffer.
+     */
+    // private int strBufOffset = -1;
+    /**
+     * Buffer for long strings.
+     */
+    private char[] longStrBuf;
+
+    /**
+     * Number of significant <code>char</code>s in <code>longStrBuf</code>.
+     */
+    private int longStrBufLen;
+
+    /**
+     * <code>-1</code> to indicate that <code>longStrBuf</code> is used or
+     * otherwise an offset to the main buffer.
+     */
+    // private int longStrBufOffset = -1;
+    /**
+     * The attribute holder.
+     */
+    private HtmlAttributes attributes;
+
+    /**
+     * Buffer for expanding NCRs falling into the Basic Multilingual Plane.
+     */
+    private final char[] bmpChar;
+
+    /**
+     * Buffer for expanding astral NCRs.
+     */
+    private final char[] astralChar;
+
+    /**
+     * The element whose end tag closes the current CDATA or RCDATA element.
+     */
+    protected ElementName contentModelElement = null;
+
+    private char[] contentModelElementNameAsArray;
+
+    /**
+     * <code>true</code> if tokenizing an end tag
+     */
+    protected boolean endTag;
+
+    /**
+     * The current tag token name.
+     */
+    private ElementName tagName = null;
+
+    /**
+     * The current attribute name.
+     */
+    protected AttributeName attributeName = null;
+
+    // [NOCPP[
+
+    /**
+     * Whether comment tokens are emitted.
+     */
+    private boolean wantsComments = false;
+
+    /**
+     * <code>true</code> when HTML4-specific additional errors are requested.
+     */
+    protected boolean html4;
+
+    /**
+     * Whether the stream is past the first 512 bytes.
+     */
+    private boolean metaBoundaryPassed;
+
+    // ]NOCPP]
+
+    /**
+     * The name of the current doctype token.
+     */
+    private @Local String doctypeName;
+
+    /**
+     * The public id of the current doctype token.
+     */
+    private String publicIdentifier;
+
+    /**
+     * The system id of the current doctype token.
+     */
+    private String systemIdentifier;
+
+    // [NOCPP[
+
+    /**
+     * The policy for vertical tab and form feed.
+     */
+    private XmlViolationPolicy contentSpacePolicy = XmlViolationPolicy.ALTER_INFOSET;
+
+    /**
+     * The policy for comments.
+     */
+    private XmlViolationPolicy commentPolicy = XmlViolationPolicy.ALTER_INFOSET;
+
+    private XmlViolationPolicy xmlnsPolicy = XmlViolationPolicy.ALTER_INFOSET;
+
+    private XmlViolationPolicy namePolicy = XmlViolationPolicy.ALTER_INFOSET;
+
+    private boolean html4ModeCompatibleWithXhtml1Schemata;
+
+    private final boolean newAttributesEachTime;
+
+    // ]NOCPP]
+
+    private int mappingLangToXmlLang;
+
+    private boolean shouldSuspend;
+
+    protected boolean confident;
+
+    private int line;
+
+    // [NOCPP[
+
+    protected LocatorImpl ampersandLocation;
+
+    public Tokenizer(TokenHandler tokenHandler, boolean newAttributesEachTime) {
+        this.tokenHandler = tokenHandler;
+        this.encodingDeclarationHandler = null;
+        this.newAttributesEachTime = newAttributesEachTime;
+        this.bmpChar = new char[1];
+        this.astralChar = new char[2];
+    }
+
+    // ]NOCPP]
+
+    /**
+     * The constructor.
+     * 
+     * @param tokenHandler
+     *            the handler for receiving tokens
+     */
+    public Tokenizer(TokenHandler tokenHandler) {
+        this.tokenHandler = tokenHandler;
+        this.encodingDeclarationHandler = null;
+        // [NOCPP[
+        this.newAttributesEachTime = false;
+        // ]NOCPP]
+        this.bmpChar = new char[1];
+        this.astralChar = new char[2];
+    }
+
+    public void initLocation(String newPublicId, String newSystemId) {
+        this.systemId = newSystemId;
+        this.publicId = newPublicId;
+
+    }
+
+    void destructor() {
+        Portability.releaseArray(bmpChar);
+        Portability.releaseArray(astralChar);
+    }
+
+    // [NOCPP[
+
+    /**
+     * Returns the mappingLangToXmlLang.
+     * 
+     * @return the mappingLangToXmlLang
+     */
+    public boolean isMappingLangToXmlLang() {
+        return mappingLangToXmlLang == AttributeName.HTML_LANG;
+    }
+
+    /**
+     * Sets the mappingLangToXmlLang.
+     * 
+     * @param mappingLangToXmlLang
+     *            the mappingLangToXmlLang to set
+     */
+    public void setMappingLangToXmlLang(boolean mappingLangToXmlLang) {
+        this.mappingLangToXmlLang = mappingLangToXmlLang ? AttributeName.HTML_LANG
+                : AttributeName.HTML;
+    }
+
+    /**
+     * Sets the error handler.
+     * 
+     * @see org.xml.sax.XMLReader#setErrorHandler(org.xml.sax.ErrorHandler)
+     */
+    public void setErrorHandler(ErrorHandler eh) {
+        this.errorHandler = eh;
+    }
+
+    public ErrorHandler getErrorHandler() {
+        return this.errorHandler;
+    }
+
+    /**
+     * Sets the commentPolicy.
+     * 
+     * @param commentPolicy
+     *            the commentPolicy to set
+     */
+    public void setCommentPolicy(XmlViolationPolicy commentPolicy) {
+        this.commentPolicy = commentPolicy;
+    }
+
+    /**
+     * Sets the contentNonXmlCharPolicy.
+     * 
+     * @param contentNonXmlCharPolicy
+     *            the contentNonXmlCharPolicy to set
+     */
+    public void setContentNonXmlCharPolicy(
+            XmlViolationPolicy contentNonXmlCharPolicy) {
+        if (contentNonXmlCharPolicy != XmlViolationPolicy.ALLOW) {
+            throw new IllegalArgumentException(
+                    "Must use ErrorReportingTokenizer to set contentNonXmlCharPolicy to non-ALLOW.");
+        }
+    }
+
+    /**
+     * Sets the contentSpacePolicy.
+     * 
+     * @param contentSpacePolicy
+     *            the contentSpacePolicy to set
+     */
+    public void setContentSpacePolicy(XmlViolationPolicy contentSpacePolicy) {
+        this.contentSpacePolicy = contentSpacePolicy;
+    }
+
+    /**
+     * Sets the xmlnsPolicy.
+     * 
+     * @param xmlnsPolicy
+     *            the xmlnsPolicy to set
+     */
+    public void setXmlnsPolicy(XmlViolationPolicy xmlnsPolicy) {
+        if (xmlnsPolicy == XmlViolationPolicy.FATAL) {
+            throw new IllegalArgumentException("Can't use FATAL here.");
+        }
+        this.xmlnsPolicy = xmlnsPolicy;
+    }
+
+    public void setNamePolicy(XmlViolationPolicy namePolicy) {
+        this.namePolicy = namePolicy;
+    }
+
+    /**
+     * Sets the html4ModeCompatibleWithXhtml1Schemata.
+     * 
+     * @param html4ModeCompatibleWithXhtml1Schemata
+     *            the html4ModeCompatibleWithXhtml1Schemata to set
+     */
+    public void setHtml4ModeCompatibleWithXhtml1Schemata(
+            boolean html4ModeCompatibleWithXhtml1Schemata) {
+        this.html4ModeCompatibleWithXhtml1Schemata = html4ModeCompatibleWithXhtml1Schemata;
+    }
+
+    // ]NOCPP]
+
+    // For the token handler to call
+    /**
+     * Sets the content model flag and the associated element name.
+     * 
+     * @param contentModelFlag
+     *            the flag
+     * @param contentModelElement
+     *            the element causing the flag to be set
+     */
+    public void setContentModelFlag(int contentModelFlag,
+            @Local String contentModelElement) {
+        this.stateSave = contentModelFlag;
+        if (contentModelFlag == Tokenizer.DATA) {
+            return;
+        }
+        // XXX does this make any sense?
+        char[] asArray = Portability.newCharArrayFromLocal(contentModelElement);
+        this.contentModelElement = ElementName.elementNameByBuffer(asArray, 0,
+                asArray.length);
+        Portability.releaseArray(asArray);
+        contentModelElementToArray();
+    }
+
+    /**
+     * Sets the content model flag and the associated element name.
+     * 
+     * @param contentModelFlag
+     *            the flag
+     * @param contentModelElement
+     *            the element causing the flag to be set
+     */
+    public void setContentModelFlag(int contentModelFlag,
+            ElementName contentModelElement) {
+        this.stateSave = contentModelFlag;
+        this.contentModelElement = contentModelElement;
+        contentModelElementToArray();
+    }
+
+    private void contentModelElementToArray() {
+        switch (contentModelElement.group) {
+            case TreeBuilder.TITLE:
+                contentModelElementNameAsArray = TITLE_ARR;
+                return;
+            case TreeBuilder.SCRIPT:
+                contentModelElementNameAsArray = SCRIPT_ARR;
+                return;
+            case TreeBuilder.STYLE:
+                contentModelElementNameAsArray = STYLE_ARR;
+                return;
+            case TreeBuilder.PLAINTEXT:
+                contentModelElementNameAsArray = PLAINTEXT_ARR;
+                return;
+            case TreeBuilder.XMP:
+                contentModelElementNameAsArray = XMP_ARR;
+                return;
+            case TreeBuilder.TEXTAREA:
+                contentModelElementNameAsArray = TEXTAREA_ARR;
+                return;
+            case TreeBuilder.IFRAME:
+                contentModelElementNameAsArray = IFRAME_ARR;
+                return;
+            case TreeBuilder.NOEMBED:
+                contentModelElementNameAsArray = NOEMBED_ARR;
+                return;
+            case TreeBuilder.NOSCRIPT:
+                contentModelElementNameAsArray = NOSCRIPT_ARR;
+                return;
+            case TreeBuilder.NOFRAMES:
+                contentModelElementNameAsArray = NOFRAMES_ARR;
+                return;
+            default:
+                assert false;
+                return;
+        }
+    }
+
+    /**
+     * For C++ use only.
+     */
+    public void setLineNumber(int line) {
+        this.line = line;
+    }
+
+    // start Locator impl
+
+    /**
+     * @see org.xml.sax.Locator#getLineNumber()
+     */
+    @Inline public int getLineNumber() {
+        return line;
+    }
+
+    // [NOCPP[
+
+    /**
+     * @see org.xml.sax.Locator#getColumnNumber()
+     */
+    @Inline public int getColumnNumber() {
+        return -1;
+    }
+
+    /**
+     * @see org.xml.sax.Locator#getPublicId()
+     */
+    public String getPublicId() {
+        return publicId;
+    }
+
+    /**
+     * @see org.xml.sax.Locator#getSystemId()
+     */
+    public String getSystemId() {
+        return systemId;
+    }
+
+    // end Locator impl
+
+    // end public API
+
+    public void notifyAboutMetaBoundary() {
+        metaBoundaryPassed = true;
+    }
+
+    void turnOnAdditionalHtml4Errors() {
+        html4 = true;
+    }
+
+    // ]NOCPP]
+
+    HtmlAttributes emptyAttributes() {
+        // [NOCPP[
+        if (newAttributesEachTime) {
+            return new HtmlAttributes(mappingLangToXmlLang);
+        } else {
+            // ]NOCPP]
+            return HtmlAttributes.EMPTY_ATTRIBUTES;
+            // [NOCPP[
+        }
+        // ]NOCPP]
+    }
+
+    private void clearStrBufAndAppendCurrentC(char c) {
+        strBuf[0] = c;
+
+        strBufLen = 1;
+        // strBufOffset = pos;
+    }
+
+    private void clearStrBufAndAppendForceWrite(char c) {
+        strBuf[0] = c; // test
+
+        strBufLen = 1;
+        // strBufOffset = pos;
+        // buf[pos] = c;
+    }
+
+    private void clearStrBufForNextState() {
+        strBufLen = 0;
+        // strBufOffset = pos + 1;
+    }
+
+    /**
+     * Appends to the smaller buffer.
+     * 
+     * @param c
+     *            the UTF-16 code unit to append
+     */
+    private void appendStrBuf(char c) {
+        // if (strBufOffset != -1) {
+        // strBufLen++;
+        // } else {
+        if (strBufLen == strBuf.length) {
+            char[] newBuf = new char[strBuf.length + Tokenizer.BUFFER_GROW_BY];
+            System.arraycopy(strBuf, 0, newBuf, 0, strBuf.length);
+            Portability.releaseArray(strBuf);
+            strBuf = newBuf;
+        }
+        strBuf[strBufLen++] = c;
+        // }
+    }
+
+    /**
+     * Appends to the smaller buffer.
+     * 
+     * @param c
+     *            the UTF-16 code unit to append
+     */
+    private void appendStrBufForceWrite(char c) {
+        // if (strBufOffset != -1) {
+        // strBufLen++;
+        // buf[pos] = c;
+        // } else {
+        if (strBufLen == strBuf.length) {
+            char[] newBuf = new char[strBuf.length + Tokenizer.BUFFER_GROW_BY];
+            System.arraycopy(strBuf, 0, newBuf, 0, strBuf.length);
+            Portability.releaseArray(strBuf);
+            strBuf = newBuf;
+        }
+        strBuf[strBufLen++] = c;
+        // }
+    }
+
+    /**
+     * The smaller buffer as a String. Currently only used for error reporting.
+     * 
+     * <p>
+     * C++ memory note: The return value must be released.
+     * 
+     * @return the smaller buffer as a string
+     */
+    protected String strBufToString() {
+        // if (strBufOffset != -1) {
+        // return Portability.newStringFromBuffer(buf, strBufOffset, strBufLen);
+        // } else {
+        return Portability.newStringFromBuffer(strBuf, 0, strBufLen);
+        // }
+    }
+
+    /**
+     * Returns the short buffer as a local name. The return value is released in
+     * emitDoctypeToken().
+     * 
+     * @return the smaller buffer as local name
+     */
+    private void strBufToDoctypeName() {
+        doctypeName = Portability.newLocalNameFromBuffer(strBuf, 0, strBufLen);
+    }
+
+    /**
+     * Emits the smaller buffer as character tokens.
+     * 
+     * @throws SAXException
+     *             if the token handler threw
+     */
+    private void emitStrBuf() throws SAXException {
+        if (strBufLen > 0) {
+            // if (strBufOffset != -1) {
+            // tokenHandler.characters(buf, strBufOffset, strBufLen);
+            // } else {
+            tokenHandler.characters(strBuf, 0, strBufLen);
+            // }
+        }
+    }
+
+    private void clearLongStrBufForNextState() {
+        // longStrBufOffset = pos + 1;
+        longStrBufLen = 0;
+    }
+
+    private void clearLongStrBuf() {
+        // longStrBufOffset = pos;
+        longStrBufLen = 0;
+    }
+
+    private void clearLongStrBufAndAppendCurrentC(char c) {
+        longStrBuf[0] = c;
+        longStrBufLen = 1;
+        // longStrBufOffset = pos;
+    }
+
+    private void clearLongStrBufAndAppendToComment(char c) {
+        longStrBuf[0] = c;
+        // longStrBufOffset = pos;
+        longStrBufLen = 1;
+    }
+
+    /**
+     * Appends to the larger buffer.
+     * 
+     * @param c
+     *            the UTF-16 code unit to append
+     */
+    private void appendLongStrBuf(char c) {
+        // if (longStrBufOffset != -1) {
+        // longStrBufLen++;
+        // } else {
+        if (longStrBufLen == longStrBuf.length) {
+            char[] newBuf = new char[longStrBufLen + (longStrBufLen >> 1)];
+            System.arraycopy(longStrBuf, 0, newBuf, 0, longStrBuf.length);
+            Portability.releaseArray(longStrBuf);
+            longStrBuf = newBuf;
+        }
+        longStrBuf[longStrBufLen++] = c;
+        // }
+    }
+
+    private void appendSecondHyphenToBogusComment() throws SAXException {
+        // [NOCPP[
+        switch (commentPolicy) {
+            case ALTER_INFOSET:
+                // detachLongStrBuf();
+                appendLongStrBuf(' ');
+                // FALLTHROUGH
+            case ALLOW:
+                warn("The document is not mappable to XML 1.0 due to two consecutive hyphens in a comment.");
+                // ]NOCPP]
+                appendLongStrBuf('-');
+                // [NOCPP[
+                break;
+            case FATAL:
+                fatal("The document is not mappable to XML 1.0 due to two consecutive hyphens in a comment.");
+                break;
+        }
+        // ]NOCPP]
+    }
+
+    // [NOCPP[
+    private void maybeAppendSpaceToBogusComment() throws SAXException {
+        switch (commentPolicy) {
+            case ALTER_INFOSET:
+                // detachLongStrBuf();
+                appendLongStrBuf(' ');
+                // FALLTHROUGH
+            case ALLOW:
+                warn("The document is not mappable to XML 1.0 due to a trailing hyphen in a comment.");
+                break;
+            case FATAL:
+                fatal("The document is not mappable to XML 1.0 due to a trailing hyphen in a comment.");
+                break;
+        }
+    }
+
+    // ]NOCPP]
+
+    private void adjustDoubleHyphenAndAppendToLongStrBufAndErr(char c)
+            throws SAXException {
+        errConsecutiveHyphens();
+        // [NOCPP[
+        switch (commentPolicy) {
+            case ALTER_INFOSET:
+                // detachLongStrBuf();
+                longStrBufLen--;
+                appendLongStrBuf(' ');
+                appendLongStrBuf('-');
+                // FALLTHROUGH
+            case ALLOW:
+                warn("The document is not mappable to XML 1.0 due to two consecutive hyphens in a comment.");
+                // ]NOCPP]
+                appendLongStrBuf(c);
+                // [NOCPP[
+                break;
+            case FATAL:
+                fatal("The document is not mappable to XML 1.0 due to two consecutive hyphens in a comment.");
+                break;
+        }
+        // ]NOCPP]
+    }
+
+    private void appendLongStrBuf(char[] buffer, int offset, int length) {
+        int reqLen = longStrBufLen + length;
+        if (longStrBuf.length < reqLen) {
+            char[] newBuf = new char[reqLen + (reqLen >> 1)];
+            System.arraycopy(longStrBuf, 0, newBuf, 0, longStrBuf.length);
+            Portability.releaseArray(longStrBuf);
+            longStrBuf = newBuf;
+        }
+        System.arraycopy(buffer, offset, longStrBuf, longStrBufLen, length);
+        longStrBufLen = reqLen;
+    }
+
+    /**
+     * Appends to the larger buffer.
+     * 
+     * @param arr
+     *            the UTF-16 code units to append
+     */
+    private void appendLongStrBuf(char[] arr) {
+        // assert longStrBufOffset == -1;
+        appendLongStrBuf(arr, 0, arr.length);
+    }
+
+    /**
+     * Append the contents of the smaller buffer to the larger one.
+     */
+    private void appendStrBufToLongStrBuf() {
+        // assert longStrBufOffset == -1;
+        // if (strBufOffset != -1) {
+        // appendLongStrBuf(buf, strBufOffset, strBufLen);
+        // } else {
+        appendLongStrBuf(strBuf, 0, strBufLen);
+        // }
+    }
+
+    /**
+     * The larger buffer as a string.
+     * 
+     * <p>
+     * C++ memory note: The return value must be released.
+     * 
+     * @return the larger buffer as a string
+     */
+    private String longStrBufToString() {
+        // if (longStrBufOffset != -1) {
+        // return Portability.newStringFromBuffer(buf, longStrBufOffset,
+        // longStrBufLen);
+        // } else {
+        return Portability.newStringFromBuffer(longStrBuf, 0, longStrBufLen);
+        // }
+    }
+
+    /**
+     * Emits the current comment token.
+     * 
+     * @param pos
+     *            TODO
+     * 
+     * @throws SAXException
+     */
+    private void emitComment(int provisionalHyphens, int pos)
+            throws SAXException {
+        // [NOCPP[
+        if (wantsComments) {
+            // ]NOCPP]
+            // if (longStrBufOffset != -1) {
+            // tokenHandler.comment(buf, longStrBufOffset, longStrBufLen
+            // - provisionalHyphens);
+            // } else {
+            tokenHandler.comment(longStrBuf, 0, longStrBufLen
+                    - provisionalHyphens);
+            // }
+            // [NOCPP[
+        }
+        // ]NOCPP]
+        cstart = pos + 1;
+    }
+
+    /**
+     * Flushes coalesced character tokens.
+     * 
+     * @param buf
+     *            TODO
+     * @param pos
+     *            TODO
+     * 
+     * @throws SAXException
+     */
+    protected void flushChars(@NoLength char[] buf, int pos)
+            throws SAXException {
+        if (pos > cstart) {
+            tokenHandler.characters(buf, cstart, pos - cstart);
+        }
+        cstart = 0x7fffffff;
+    }
+
+    /**
+     * Reports an condition that would make the infoset incompatible with XML
+     * 1.0 as fatal.
+     * 
+     * @param message
+     *            the message
+     * @throws SAXException
+     * @throws SAXParseException
+     */
+    public void fatal(String message) throws SAXException {
+        SAXParseException spe = new SAXParseException(message, this);
+        if (errorHandler != null) {
+            errorHandler.fatalError(spe);
+        }
+        throw spe;
+    }
+
+    /**
+     * Reports a Parse Error.
+     * 
+     * @param message
+     *            the message
+     * @throws SAXException
+     */
+    public void err(String message) throws SAXException {
+        if (errorHandler == null) {
+            return;
+        }
+        SAXParseException spe = new SAXParseException(message, this);
+        errorHandler.error(spe);
+    }
+
+    public void errTreeBuilder(String message) throws SAXException {
+        ErrorHandler eh = null;
+        if (tokenHandler instanceof TreeBuilder<?>) {
+            TreeBuilder<?> treeBuilder = (TreeBuilder<?>) tokenHandler;
+            eh = treeBuilder.getErrorHandler();
+        }
+        if (eh == null) {
+            eh = errorHandler;
+        }
+        if (eh == null) {
+            return;
+        }
+        SAXParseException spe = new SAXParseException(message, this);
+        eh.error(spe);
+    }
+
+    /**
+     * Reports a warning
+     * 
+     * @param message
+     *            the message
+     * @throws SAXException
+     */
+    public void warn(String message) throws SAXException {
+        if (errorHandler == null) {
+            return;
+        }
+        SAXParseException spe = new SAXParseException(message, this);
+        errorHandler.warning(spe);
+    }
+
+    /**
+     * 
+     */
+    private void resetAttributes() {
+        // [NOCPP[
+        if (newAttributesEachTime) {
+            attributes = null;
+        } else {
+            // ]NOCPP]
+            attributes.clear(mappingLangToXmlLang);
+            // [NOCPP[
+        }
+        // ]NOCPP]
+    }
+
+    private void strBufToElementNameString() {
+        // if (strBufOffset != -1) {
+        // return ElementName.elementNameByBuffer(buf, strBufOffset, strBufLen);
+        // } else {
+        tagName = ElementName.elementNameByBuffer(strBuf, 0, strBufLen);
+        // }
+    }
+
+    private int emitCurrentTagToken(boolean selfClosing, int pos)
+            throws SAXException {
+        cstart = pos + 1;
+        maybeErrSlashInEndTag(selfClosing);
+        stateSave = Tokenizer.DATA;
+        HtmlAttributes attrs = (attributes == null ? HtmlAttributes.EMPTY_ATTRIBUTES
+                : attributes);
+        if (endTag) {
+            /*
+             * When an end tag token is emitted, the content model flag must be
+             * switched to the PCDATA state.
+             */
+            maybeErrAttributesOnEndTag(attrs);
+            tokenHandler.endTag(tagName);
+        } else {
+            tokenHandler.startTag(tagName, attrs, selfClosing);
+        }
+        resetAttributes();
+        return stateSave;
+    }
+
+    private void attributeNameComplete() throws SAXException {
+        // if (strBufOffset != -1) {
+        // attributeName = AttributeName.nameByBuffer(buf, strBufOffset,
+        // strBufLen, namePolicy != XmlViolationPolicy.ALLOW);
+        // } else {
+        attributeName = AttributeName.nameByBuffer(strBuf, 0, strBufLen
+        // [NOCPP[
+                , namePolicy != XmlViolationPolicy.ALLOW
+        // ]NOCPP]
+        );
+        // }
+
+        // [NOCPP[
+        if (attributes == null) {
+            attributes = new HtmlAttributes(mappingLangToXmlLang);
+        }
+        // ]NOCPP]
+
+        /*
+         * When the user agent leaves the attribute name state (and before
+         * emitting the tag token, if appropriate), the complete attribute's
+         * name must be compared to the other attributes on the same token; if
+         * there is already an attribute on the token with the exact same name,
+         * then this is a parse error and the new attribute must be dropped,
+         * along with the value that gets associated with it (if any).
+         */
+        if (attributes.contains(attributeName)) {
+            errDuplicateAttribute();
+            attributeName.release();
+            attributeName = null;
+        }
+    }
+
+    private void addAttributeWithoutValue() throws SAXException {
+        // [NOCPP[
+        if (metaBoundaryPassed && AttributeName.CHARSET == attributeName
+                && ElementName.META == tagName) {
+            err("A \u201Ccharset\u201D attribute on a \u201Cmeta\u201D element found after the first 512 bytes.");
+        }
+        // ]NOCPP]
+        if (attributeName != null) {
+            // [NOCPP[
+            if (html4) {
+                if (attributeName.isBoolean()) {
+                    if (html4ModeCompatibleWithXhtml1Schemata) {
+                        attributes.addAttribute(attributeName,
+                                attributeName.getLocal(AttributeName.HTML),
+                                xmlnsPolicy);
+                    } else {
+                        attributes.addAttribute(attributeName, "", xmlnsPolicy);
+                    }
+                } else {
+                    err("Attribute value omitted for a non-boolean attribute. (HTML4-only error.)");
+                    attributes.addAttribute(attributeName, "", xmlnsPolicy);
+                }
+            } else {
+                if (AttributeName.SRC == attributeName
+                        || AttributeName.HREF == attributeName) {
+                    warn("Attribute \u201C"
+                            + attributeName.getLocal(AttributeName.HTML)
+                            + "\u201D without an explicit value seen. The attribute may be dropped by IE7.");
+                }
+                // ]NOCPP]
+                attributes.addAttribute(attributeName,
+                        Portability.newEmptyString()
+                        // [NOCPP[
+                        , xmlnsPolicy
+                // ]NOCPP]
+                );
+                // [NOCPP[
+            }
+            // ]NOCPP]
+        }
+    }
+
+    private void addAttributeWithValue() throws SAXException {
+        // [NOCPP[
+        if (metaBoundaryPassed && ElementName.META == tagName
+                && AttributeName.CHARSET == attributeName) {
+            err("A \u201Ccharset\u201D attribute on a \u201Cmeta\u201D element found after the first 512 bytes.");
+        }
+        // ]NOCPP]
+        if (attributeName != null) {
+            String value = longStrBufToString(); // Ownership transferred to
+            // HtmlAttributes
+            // [NOCPP[
+            if (!endTag && html4 && html4ModeCompatibleWithXhtml1Schemata
+                    && attributeName.isCaseFolded()) {
+                value = newAsciiLowerCaseStringFromString(value);
+            }
+            // ]NOCPP]
+            attributes.addAttribute(attributeName, value
+            // [NOCPP[
+                    , xmlnsPolicy
+            // ]NOCPP]
+            );
+        }
+    }
+
+    // [NOCPP[
+
+    private static String newAsciiLowerCaseStringFromString(String str) {
+        if (str == null) {
+            return null;
+        }
+        char[] buf = new char[str.length()];
+        for (int i = 0; i < str.length(); i++) {
+            char c = str.charAt(i);
+            if (c >= 'A' && c <= 'Z') {
+                c += 0x20;
+            }
+            buf[i] = c;
+        }
+        return new String(buf);
+    }
+
+    // ]NOCPP]
+
+    protected void startErrorReporting() throws SAXException {
+
+    }
+
+    public void start() throws SAXException {
+        confident = false;
+        strBuf = new char[64];
+        strBufLen = 0;
+        longStrBuf = new char[1024];
+        longStrBufLen = 0;
+        stateSave = Tokenizer.DATA;
+        line = 1;
+        lastCR = false;
+        // [NOCPP[
+        html4 = false;
+        metaBoundaryPassed = false;
+        // ]NOCPP]
+        tokenHandler.startTokenization(this);
+        // [NOCPP[
+        wantsComments = tokenHandler.wantsComments();
+        // ]NOCPP]
+        index = 0;
+        forceQuirks = false;
+        additional = '\u0000';
+        entCol = -1;
+        lo = 0;
+        hi = (NamedCharacters.NAMES.length - 1);
+        candidate = -1;
+        strBufMark = 0;
+        prevValue = -1;
+        value = 0;
+        seenDigits = false;
+        shouldSuspend = false;
+        // [NOCPP[
+        if (!newAttributesEachTime) {
+            // ]NOCPP]
+            attributes = new HtmlAttributes(mappingLangToXmlLang);
+            // [NOCPP[
+        }
+        startErrorReporting();
+        // ]NOCPP]
+    }
+
+    public boolean tokenizeBuffer(UTF16Buffer buffer) throws SAXException {
+        int state = stateSave;
+        int returnState = returnStateSave;
+        char c = '\u0000';
+        shouldSuspend = false;
+        lastCR = false;
+
+        int start = buffer.getStart();
+        /**
+         * The index of the last <code>char</code> read from <code>buf</code>.
+         */
+        int pos = start - 1;
+
+        /**
+         * The index of the first <code>char</code> in <code>buf</code> that is
+         * part of a coalesced run of character tokens or
+         * <code>Integer.MAX_VALUE</code> if there is not a current run being
+         * coalesced.
+         */
+        switch (state) {
+            case DATA:
+            case RCDATA:
+            case CDATA:
+            case PLAINTEXT:
+            case CDATA_SECTION:
+            case ESCAPE:
+            case ESCAPE_EXCLAMATION:
+            case ESCAPE_EXCLAMATION_HYPHEN:
+            case ESCAPE_HYPHEN:
+            case ESCAPE_HYPHEN_HYPHEN:
+                cstart = start;
+                break;
+            default:
+                cstart = Integer.MAX_VALUE;
+                break;
+        }
+
+        /**
+         * The number of <code>char</code>s in <code>buf</code> that have
+         * meaning. (The rest of the array is garbage and should not be
+         * examined.)
+         */
+        pos = stateLoop(state, c, pos, buffer.getBuffer(), false, returnState,
+                buffer.getEnd());
+        if (pos == buffer.getEnd()) {
+            // exiting due to end of buffer
+            buffer.setStart(pos);
+        } else {
+            buffer.setStart(pos + 1);
+        }
+        return lastCR;
+    }
+
+    // WARNING When editing this, makes sure the bytecode length shown by javap
+    // stays under 8000 bytes!
+    private int stateLoop(int state, char c, int pos, @NoLength char[] buf,
+            boolean reconsume, int returnState, int endPos) throws SAXException {
+        stateloop: for (;;) {
+            switch (state) {
+                case DATA:
+                    dataloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        switch (c) {
+                            case '&':
+                                /*
+                                 * U+0026 AMPERSAND (&) When the content model
+                                 * flag is set to one of the PCDATA or RCDATA
+                                 * states and the escape flag is false: switch
+                                 * to the character reference data state.
+                                 * Otherwise: treat it as per the "anything
+                                 * else" entry below.
+                                 */
+                                flushChars(buf, pos);
+                                clearStrBufAndAppendCurrentC(c);
+                                rememberAmpersandLocation('\u0000');
+                                returnState = state;
+                                state = Tokenizer.CONSUME_CHARACTER_REFERENCE;
+                                continue stateloop;
+                            case '<':
+                                /*
+                                 * U+003C LESS-THAN SIGN (<) When the content
+                                 * model flag is set to the PCDATA state: switch
+                                 * to the tag open state. When the content model
+                                 * flag is set to either the RCDATA state or the
+                                 * CDATA state, and the escape flag is false:
+                                 * switch to the tag open state. Otherwise:
+                                 * treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                                flushChars(buf, pos);
+
+                                state = Tokenizer.TAG_OPEN;
+                                break dataloop; // FALL THROUGH continue
+                            // stateloop;
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                continue;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            default:
+                                /*
+                                 * Anything else Emit the input character as a
+                                 * character token.
+                                 */
+                                /*
+                                 * Stay in the data state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case TAG_OPEN:
+                    tagopenloop: for (;;) {
+                        /*
+                         * The behavior of this state depends on the content
+                         * model flag.
+                         */
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * If the content model flag is set to the PCDATA state
+                         * Consume the next input character:
+                         */
+                        if (c >= 'A' && c <= 'Z') {
+                            /*
+                             * U+0041 LATIN CAPITAL LETTER A through to U+005A
+                             * LATIN CAPITAL LETTER Z Create a new start tag
+                             * token,
+                             */
+                            endTag = false;
+                            /*
+                             * set its tag name to the lowercase version of the
+                             * input character (add 0x0020 to the character's
+                             * code point),
+                             */
+                            clearStrBufAndAppendForceWrite((char) (c + 0x20));
+                            /* then switch to the tag name state. */
+                            state = Tokenizer.TAG_NAME;
+                            /*
+                             * (Don't emit the token yet; further details will
+                             * be filled in before it is emitted.)
+                             */
+                            break tagopenloop;
+                            // continue stateloop;
+                        } else if (c >= 'a' && c <= 'z') {
+                            /*
+                             * U+0061 LATIN SMALL LETTER A through to U+007A
+                             * LATIN SMALL LETTER Z Create a new start tag
+                             * token,
+                             */
+                            endTag = false;
+                            /*
+                             * set its tag name to the input character,
+                             */
+                            clearStrBufAndAppendCurrentC(c);
+                            /* then switch to the tag name state. */
+                            state = Tokenizer.TAG_NAME;
+                            /*
+                             * (Don't emit the token yet; further details will
+                             * be filled in before it is emitted.)
+                             */
+                            break tagopenloop;
+                            // continue stateloop;
+                        }
+                        switch (c) {
+                            case '!':
+                                /*
+                                 * U+0021 EXCLAMATION MARK (!) Switch to the
+                                 * markup declaration open state.
+                                 */
+                                state = Tokenizer.MARKUP_DECLARATION_OPEN;
+                                continue stateloop;
+                            case '/':
+                                /*
+                                 * U+002F SOLIDUS (/) Switch to the close tag
+                                 * open state.
+                                 */
+                                state = Tokenizer.CLOSE_TAG_OPEN_PCDATA;
+                                continue stateloop;
+                            case '?':
+                                /*
+                                 * U+003F QUESTION MARK (?) Parse error.
+                                 */
+                                errProcessingInstruction();
+                                /*
+                                 * Switch to the bogus comment state.
+                                 */
+                                clearLongStrBufAndAppendToComment(c);
+                                state = Tokenizer.BOGUS_COMMENT;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Parse error.
+                                 */
+                                errLtGt();
+                                /*
+                                 * Emit a U+003C LESS-THAN SIGN character token
+                                 * and a U+003E GREATER-THAN SIGN character
+                                 * token.
+                                 */
+                                tokenHandler.characters(Tokenizer.LT_GT, 0, 2);
+                                /* Switch to the data state. */
+                                cstart = pos + 1;
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            default:
+                                /*
+                                 * Anything else Parse error.
+                                 */
+                                errBadCharAfterLt(c);
+                                /*
+                                 * Emit a U+003C LESS-THAN SIGN character token
+                                 */
+                                tokenHandler.characters(Tokenizer.LT_GT, 0, 1);
+                                /*
+                                 * and reconsume the current input character in
+                                 * the data state.
+                                 */
+                                cstart = pos;
+                                state = Tokenizer.DATA;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALL THROUGH DON'T REORDER
+                case TAG_NAME:
+                    tagnameloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                strBufToElementNameString();
+                                state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE
+                                 * Switch to the before attribute name state.
+                                 */
+                                strBufToElementNameString();
+                                state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                break tagnameloop;
+                            // continue stateloop;
+                            case '/':
+                                /*
+                                 * U+002F SOLIDUS (/) Switch to the self-closing
+                                 * start tag state.
+                                 */
+                                strBufToElementNameString();
+                                state = Tokenizer.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * tag token.
+                                 */
+                                strBufToElementNameString();
+                                state = emitCurrentTagToken(false, pos);
+                                if (shouldSuspend) {
+                                    break stateloop;
+                                }
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                if (c >= 'A' && c <= 'Z') {
+                                    /*
+                                     * U+0041 LATIN CAPITAL LETTER A through to
+                                     * U+005A LATIN CAPITAL LETTER Z Append the
+                                     * lowercase version of the current input
+                                     * character (add 0x0020 to the character's
+                                     * code point) to the current tag token's
+                                     * tag name.
+                                     */
+                                    c += 0x20;
+                                }
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current tag token's tag
+                                 * name.
+                                 */
+                                appendStrBuf(c);
+                                /*
+                                 * Stay in the tag name state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BEFORE_ATTRIBUTE_NAME:
+                    beforeattributenameloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the before attribute name state.
+                                 */
+                                continue;
+                            case '/':
+                                /*
+                                 * U+002F SOLIDUS (/) Switch to the self-closing
+                                 * start tag state.
+                                 */
+                                state = Tokenizer.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * tag token.
+                                 */
+                                state = emitCurrentTagToken(false, pos);
+                                if (shouldSuspend) {
+                                    break stateloop;
+                                }
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            case '\"':
+                            case '\'':
+                            case '<':
+                            case '=':
+                                /*
+                                 * U+0022 QUOTATION MARK (") U+0027 APOSTROPHE
+                                 * (') U+003C LESS-THAN SIGN (<) U+003D EQUALS
+                                 * SIGN (=) Parse error.
+                                 */
+                                errBadCharBeforeAttributeNameOrNull(c);
+                                /*
+                                 * Treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                            default:
+                                /*
+                                 * Anything else Start a new attribute in the
+                                 * current tag token.
+                                 */
+                                if (c >= 'A' && c <= 'Z') {
+                                    /*
+                                     * U+0041 LATIN CAPITAL LETTER A through to
+                                     * U+005A LATIN CAPITAL LETTER Z Set that
+                                     * attribute's name to the lowercase version
+                                     * of the current input character (add
+                                     * 0x0020 to the character's code point)
+                                     */
+                                    c += 0x20;
+                                }
+                                /*
+                                 * Set that attribute's name to the current
+                                 * input character,
+                                 */
+                                clearStrBufAndAppendCurrentC(c);
+                                /*
+                                 * and its value to the empty string.
+                                 */
+                                // Will do later.
+                                /*
+                                 * Switch to the attribute name state.
+                                 */
+                                state = Tokenizer.ATTRIBUTE_NAME;
+                                break beforeattributenameloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case ATTRIBUTE_NAME:
+                    attributenameloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                attributeNameComplete();
+                                state = Tokenizer.AFTER_ATTRIBUTE_NAME;
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE
+                                 * Switch to the after attribute name state.
+                                 */
+                                attributeNameComplete();
+                                state = Tokenizer.AFTER_ATTRIBUTE_NAME;
+                                continue stateloop;
+                            case '/':
+                                /*
+                                 * U+002F SOLIDUS (/) Switch to the self-closing
+                                 * start tag state.
+                                 */
+                                attributeNameComplete();
+                                addAttributeWithoutValue();
+                                state = Tokenizer.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '=':
+                                /*
+                                 * U+003D EQUALS SIGN (=) Switch to the before
+                                 * attribute value state.
+                                 */
+                                attributeNameComplete();
+                                state = Tokenizer.BEFORE_ATTRIBUTE_VALUE;
+                                break attributenameloop;
+                            // continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * tag token.
+                                 */
+                                attributeNameComplete();
+                                addAttributeWithoutValue();
+                                state = emitCurrentTagToken(false, pos);
+                                if (shouldSuspend) {
+                                    break stateloop;
+                                }
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            case '\"':
+                            case '\'':
+                            case '<':
+                                /*
+                                 * U+0022 QUOTATION MARK (") U+0027 APOSTROPHE
+                                 * (') U+003C LESS-THAN SIGN (<) Parse error.
+                                 */
+                                errQuoteOrLtInAttributeNameOrNull(c);
+                                /*
+                                 * Treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                            default:
+                                if (c >= 'A' && c <= 'Z') {
+                                    /*
+                                     * U+0041 LATIN CAPITAL LETTER A through to
+                                     * U+005A LATIN CAPITAL LETTER Z Append the
+                                     * lowercase version of the current input
+                                     * character (add 0x0020 to the character's
+                                     * code point) to the current attribute's
+                                     * name.
+                                     */
+                                    c += 0x20;
+                                }
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current attribute's name.
+                                 */
+                                appendStrBuf(c);
+                                /*
+                                 * Stay in the attribute name state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BEFORE_ATTRIBUTE_VALUE:
+                    beforeattributevalueloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the before attribute value state.
+                                 */
+                                continue;
+                            case '"':
+                                /*
+                                 * U+0022 QUOTATION MARK (") Switch to the
+                                 * attribute value (double-quoted) state.
+                                 */
+                                clearLongStrBufForNextState();
+                                state = Tokenizer.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
+                                break beforeattributevalueloop;
+                            // continue stateloop;
+                            case '&':
+                                /*
+                                 * U+0026 AMPERSAND (&) Switch to the attribute
+                                 * value (unquoted) state and reconsume this
+                                 * input character.
+                                 */
+                                clearLongStrBuf();
+                                state = Tokenizer.ATTRIBUTE_VALUE_UNQUOTED;
+                                reconsume = true;
+                                continue stateloop;
+                            case '\'':
+                                /*
+                                 * U+0027 APOSTROPHE (') Switch to the attribute
+                                 * value (single-quoted) state.
+                                 */
+                                clearLongStrBufForNextState();
+                                state = Tokenizer.ATTRIBUTE_VALUE_SINGLE_QUOTED;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Parse error.
+                                 */
+                                errAttributeValueMissing();
+                                /*
+                                 * Emit the current tag token.
+                                 */
+                                addAttributeWithoutValue();
+                                state = emitCurrentTagToken(false, pos);
+                                if (shouldSuspend) {
+                                    break stateloop;
+                                }
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            case '<':
+                            case '=':
+                                /*
+                                 * U+003D EQUALS SIGN (=) Parse error.
+                                 */
+                                errLtOrEqualsInUnquotedAttributeOrNull(c);
+                                /*
+                                 * Treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                            default:
+                                // [NOCPP[
+                                errHtml4NonNameInUnquotedAttribute(c);
+                                // ]NOCPP]
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current attribute's value.
+                                 */
+                                clearLongStrBufAndAppendCurrentC(c);
+                                /*
+                                 * Switch to the attribute value (unquoted)
+                                 * state.
+                                 */
+
+                                state = Tokenizer.ATTRIBUTE_VALUE_UNQUOTED;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case ATTRIBUTE_VALUE_DOUBLE_QUOTED:
+                    attributevaluedoublequotedloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '"':
+                                /*
+                                 * U+0022 QUOTATION MARK (") Switch to the after
+                                 * attribute value (quoted) state.
+                                 */
+                                addAttributeWithValue();
+
+                                state = Tokenizer.AFTER_ATTRIBUTE_VALUE_QUOTED;
+                                break attributevaluedoublequotedloop;
+                            // continue stateloop;
+                            case '&':
+                                /*
+                                 * U+0026 AMPERSAND (&) Switch to the character
+                                 * reference in attribute value state, with the
+                                 * additional allowed character being U+0022
+                                 * QUOTATION MARK (").
+                                 */
+                                clearStrBufAndAppendCurrentC(c);
+                                rememberAmpersandLocation('\"');
+                                returnState = state;
+                                state = Tokenizer.CONSUME_CHARACTER_REFERENCE;
+                                continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current attribute's value.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the attribute value (double-quoted)
+                                 * state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case AFTER_ATTRIBUTE_VALUE_QUOTED:
+                    afterattributevaluequotedloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE
+                                 * Switch to the before attribute name state.
+                                 */
+                                state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                continue stateloop;
+                            case '/':
+                                /*
+                                 * U+002F SOLIDUS (/) Switch to the self-closing
+                                 * start tag state.
+                                 */
+                                state = Tokenizer.SELF_CLOSING_START_TAG;
+                                break afterattributevaluequotedloop;
+                            // continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * tag token.
+                                 */
+                                state = emitCurrentTagToken(false, pos);
+                                if (shouldSuspend) {
+                                    break stateloop;
+                                }
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                continue stateloop;
+                            default:
+                                /*
+                                 * Anything else Parse error.
+                                 */
+                                errNoSpaceBetweenAttributes();
+                                /*
+                                 * Reconsume the character in the before
+                                 * attribute name state.
+                                 */
+                                state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case SELF_CLOSING_START_TAG:
+                    if (++pos == endPos) {
+                        break stateloop;
+                    }
+                    c = checkChar(buf, pos);
+                    /*
+                     * Consume the next input character:
+                     */
+                    switch (c) {
+                        case '>':
+                            /*
+                             * U+003E GREATER-THAN SIGN (>) Set the self-closing
+                             * flag of the current tag token. Emit the current
+                             * tag token.
+                             */
+                            // [NOCPP[
+                            errHtml4XmlVoidSyntax();
+                            // ]NOCPP]
+                            state = emitCurrentTagToken(true, pos);
+                            if (shouldSuspend) {
+                                break stateloop;
+                            }
+                            /*
+                             * Switch to the data state.
+                             */
+                            continue stateloop;
+                        default:
+                            /* Anything else Parse error. */
+                            errSlashNotFollowedByGt();
+                            /*
+                             * Reconsume the character in the before attribute
+                             * name state.
+                             */
+                            state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                            reconsume = true;
+                            continue stateloop;
+                    }
+                    // XXX reorder point
+                case ATTRIBUTE_VALUE_UNQUOTED:
+                    for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                addAttributeWithValue();
+                                state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE
+                                 * Switch to the before attribute name state.
+                                 */
+                                addAttributeWithValue();
+                                state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                continue stateloop;
+                            case '&':
+                                /*
+                                 * U+0026 AMPERSAND (&) Switch to the character
+                                 * reference in attribute value state, with no +
+                                 * additional allowed character.
+                                 */
+                                clearStrBufAndAppendCurrentC(c);
+                                rememberAmpersandLocation('\u0000');
+                                returnState = state;
+                                state = Tokenizer.CONSUME_CHARACTER_REFERENCE;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * tag token.
+                                 */
+                                addAttributeWithValue();
+                                state = emitCurrentTagToken(false, pos);
+                                if (shouldSuspend) {
+                                    break stateloop;
+                                }
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            case '<':
+                            case '\"':
+                            case '\'':
+                            case '=':
+                                /*
+                                 * U+0022 QUOTATION MARK (") U+0027 APOSTROPHE
+                                 * (') U+003D EQUALS SIGN (=) Parse error.
+                                 */
+                                errUnquotedAttributeValOrNull(c);
+                                /*
+                                 * Treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                                // fall through
+                            default:
+                                // [NOCPP]
+                                errHtml4NonNameInUnquotedAttribute(c);
+                                // ]NOCPP]
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current attribute's value.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the attribute value (unquoted) state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // XXX reorder point
+                case AFTER_ATTRIBUTE_NAME:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the after attribute name state.
+                                 */
+                                continue;
+                            case '/':
+                                /*
+                                 * U+002F SOLIDUS (/) Switch to the self-closing
+                                 * start tag state.
+                                 */
+                                addAttributeWithoutValue();
+                                state = Tokenizer.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '=':
+                                /*
+                                 * U+003D EQUALS SIGN (=) Switch to the before
+                                 * attribute value state.
+                                 */
+                                state = Tokenizer.BEFORE_ATTRIBUTE_VALUE;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * tag token.
+                                 */
+                                addAttributeWithoutValue();
+                                state = emitCurrentTagToken(false, pos);
+                                if (shouldSuspend) {
+                                    break stateloop;
+                                }
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            case '\"':
+                            case '\'':
+                            case '<':
+                                errQuoteOrLtInAttributeNameOrNull(c);
+                                /*
+                                 * Treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                            default:
+                                addAttributeWithoutValue();
+                                /*
+                                 * Anything else Start a new attribute in the
+                                 * current tag token.
+                                 */
+                                if (c >= 'A' && c <= 'Z') {
+                                    /*
+                                     * U+0041 LATIN CAPITAL LETTER A through to
+                                     * U+005A LATIN CAPITAL LETTER Z Set that
+                                     * attribute's name to the lowercase version
+                                     * of the current input character (add
+                                     * 0x0020 to the character's code point)
+                                     */
+                                    c += 0x20;
+                                }
+                                /*
+                                 * Set that attribute's name to the current
+                                 * input character,
+                                 */
+                                clearStrBufAndAppendCurrentC(c);
+                                /*
+                                 * and its value to the empty string.
+                                 */
+                                // Will do later.
+                                /*
+                                 * Switch to the attribute name state.
+                                 */
+                                state = Tokenizer.ATTRIBUTE_NAME;
+                                continue stateloop;
+                        }
+                    }
+                    // XXX reorder point
+                case BOGUS_COMMENT:
+                    boguscommentloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * (This can only happen if the content model flag is
+                         * set to the PCDATA state.)
+                         * 
+                         * Consume every character up to and including the first
+                         * U+003E GREATER-THAN SIGN character (>) or the end of
+                         * the file (EOF), whichever comes first. Emit a comment
+                         * token whose data is the concatenation of all the
+                         * characters starting from and including the character
+                         * that caused the state machine to switch into the
+                         * bogus comment state, up to and including the
+                         * character immediately before the last consumed
+                         * character (i.e. up to the character just before the
+                         * U+003E or EOF character). (If the comment was started
+                         * by the end of the file (EOF), the token is empty.)
+                         * 
+                         * Switch to the data state.
+                         * 
+                         * If the end of the file was reached, reconsume the EOF
+                         * character.
+                         */
+                        switch (c) {
+                            case '>':
+                                emitComment(0, pos);
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '-':
+                                appendLongStrBuf(c);
+                                state = Tokenizer.BOGUS_COMMENT_HYPHEN;
+                                break boguscommentloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                appendLongStrBuf(c);
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BOGUS_COMMENT_HYPHEN:
+                    boguscommenthyphenloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '>':
+                                // [NOCPP[
+                                maybeAppendSpaceToBogusComment();
+                                // ]NOCPP]
+                                emitComment(0, pos);
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '-':
+                                appendSecondHyphenToBogusComment();
+                                continue boguscommenthyphenloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                state = Tokenizer.BOGUS_COMMENT;
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                state = Tokenizer.BOGUS_COMMENT;
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                appendLongStrBuf(c);
+                                state = Tokenizer.BOGUS_COMMENT;
+                                continue stateloop;
+                        }
+                    }
+                    // XXX reorder point
+                case MARKUP_DECLARATION_OPEN:
+                    markupdeclarationopenloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * (This can only happen if the content model flag is
+                         * set to the PCDATA state.)
+                         * 
+                         * If the next two characters are both U+002D
+                         * HYPHEN-MINUS (-) characters, consume those two
+                         * characters, create a comment token whose data is the
+                         * empty string, and switch to the comment start state.
+                         * 
+                         * Otherwise, if the next seven characters are an ASCII
+                         * case-insensitive match for the word "DOCTYPE", then
+                         * consume those characters and switch to the DOCTYPE
+                         * state.
+                         * 
+                         * Otherwise, if the insertion mode is "in foreign
+                         * content" and the current node is not an element in
+                         * the HTML namespace and the next seven characters are
+                         * an ASCII case-sensitive match for the string
+                         * "[CDATA[" (the five uppercase letters "CDATA" with a
+                         * U+005B LEFT SQUARE BRACKET character before and
+                         * after), then consume those characters and switch to
+                         * the CDATA section state (which is unrelated to the
+                         * content model flag's CDATA state).
+                         * 
+                         * Otherwise, is is a parse error. Switch to the bogus
+                         * comment state. The next character that is consumed,
+                         * if any, is the first character that will be in the
+                         * comment.
+                         */
+                        switch (c) {
+                            case '-':
+                                clearLongStrBufAndAppendToComment(c);
+                                state = Tokenizer.MARKUP_DECLARATION_HYPHEN;
+                                break markupdeclarationopenloop;
+                            // continue stateloop;
+                            case 'd':
+                            case 'D':
+                                clearLongStrBufAndAppendToComment(c);
+                                index = 0;
+                                state = Tokenizer.MARKUP_DECLARATION_OCTYPE;
+                                continue stateloop;
+                            case '[':
+                                if (tokenHandler.inForeign()) {
+                                    clearLongStrBufAndAppendToComment(c);
+                                    index = 0;
+                                    state = Tokenizer.CDATA_START;
+                                    continue stateloop;
+                                } else {
+                                    // fall through
+                                }
+                            default:
+                                errBogusComment();
+                                clearLongStrBuf();
+                                state = Tokenizer.BOGUS_COMMENT;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case MARKUP_DECLARATION_HYPHEN:
+                    markupdeclarationhyphenloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '\u0000':
+                                break stateloop;
+                            case '-':
+                                clearLongStrBufForNextState();
+                                state = Tokenizer.COMMENT_START;
+                                break markupdeclarationhyphenloop;
+                            // continue stateloop;
+                            default:
+                                errBogusComment();
+                                state = Tokenizer.BOGUS_COMMENT;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT_START:
+                    commentstartloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Comment start state
+                         * 
+                         * 
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '-':
+                                /*
+                                 * U+002D HYPHEN-MINUS (-) Switch to the comment
+                                 * start dash state.
+                                 */
+                                appendLongStrBuf(c);
+                                state = Tokenizer.COMMENT_START_DASH;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Parse error.
+                                 */
+                                errPrematureEndOfComment();
+                                /* Emit the comment token. */
+                                emitComment(0, pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                state = Tokenizer.COMMENT;
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                state = Tokenizer.COMMENT;
+                                break commentstartloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the input character to
+                                 * the comment token's data.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Switch to the comment state.
+                                 */
+                                state = Tokenizer.COMMENT;
+                                break commentstartloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT:
+                    commentloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Comment state Consume the next input character:
+                         */
+                        switch (c) {
+                            case '-':
+                                /*
+                                 * U+002D HYPHEN-MINUS (-) Switch to the comment
+                                 * end dash state
+                                 */
+                                appendLongStrBuf(c);
+                                state = Tokenizer.COMMENT_END_DASH;
+                                break commentloop;
+                            // continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the input character to
+                                 * the comment token's data.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the comment state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT_END_DASH:
+                    commentenddashloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Comment end dash state Consume the next input
+                         * character:
+                         */
+                        switch (c) {
+                            case '-':
+                                /*
+                                 * U+002D HYPHEN-MINUS (-) Switch to the comment
+                                 * end state
+                                 */
+                                appendLongStrBuf(c);
+                                state = Tokenizer.COMMENT_END;
+                                break commentenddashloop;
+                            // continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                state = Tokenizer.COMMENT;
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                state = Tokenizer.COMMENT;
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append a U+002D HYPHEN-MINUS
+                                 * (-) character and the input character to the
+                                 * comment token's data.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Switch to the comment state.
+                                 */
+                                state = Tokenizer.COMMENT;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT_END:
+                    commentendloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Comment end dash state Consume the next input
+                         * character:
+                         */
+                        switch (c) {
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the comment
+                                 * token.
+                                 */
+                                emitComment(2, pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '-':
+                                /* U+002D HYPHEN-MINUS (-) Parse error. */
+                                /*
+                                 * Append a U+002D HYPHEN-MINUS (-) character to
+                                 * the comment token's data.
+                                 */
+                                adjustDoubleHyphenAndAppendToLongStrBufAndErr(c);
+                                /*
+                                 * Stay in the comment end state.
+                                 */
+                                continue;
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * Parse error. Append two U+002D HYPHEN-MINUS
+                                 * (-) characters and the input character to the
+                                 * comment token's data. Switch to the comment
+                                 * end space state.
+                                 */
+                                adjustDoubleHyphenAndAppendToLongStrBufAndErr(c);
+                                state = Tokenizer.COMMENT_END_SPACE;
+                                break commentendloop;
+                            // continue stateloop;
+                            case '\r':
+                                adjustDoubleHyphenAndAppendToLongStrBufCarriageReturn();
+                                state = Tokenizer.COMMENT_END_SPACE;
+                                break stateloop;
+                            case '\n':
+                                adjustDoubleHyphenAndAppendToLongStrBufLineFeed();
+                                state = Tokenizer.COMMENT_END_SPACE;
+                                break commentendloop;
+                            // continue stateloop;
+                            case '!':
+                                errHyphenHyphenBang();
+                                appendLongStrBuf(c);
+                                state = Tokenizer.COMMENT_END_BANG;
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Append two U+002D HYPHEN-MINUS (-) characters
+                                 * and the input character to the comment
+                                 * token's data.
+                                 */
+                                adjustDoubleHyphenAndAppendToLongStrBufAndErr(c);
+                                /*
+                                 * Switch to the comment state.
+                                 */
+                                state = Tokenizer.COMMENT;
+                                continue stateloop;
+                        }
+                    }
+                case COMMENT_END_SPACE:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Comment end space state
+                         * 
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the comment
+                                 * token.
+                                 */
+                                emitComment(0, pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '-':
+                                /*
+                                 * U+002D HYPHEN-MINUS (-) Switch to the comment
+                                 * end dash state.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Switch to the comment end dash state.
+                                 */
+                                state = Tokenizer.COMMENT_END_DASH;
+                                continue stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE
+                                 * Append the input character to the comment
+                                 * token's data. Stay in the comment end space
+                                 * state.
+                                 */
+                                appendLongStrBuf(c);
+                                continue;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the input character to
+                                 * the comment token's data. Switch to the
+                                 * comment state.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Switch to the comment state.
+                                 */
+                                state = Tokenizer.COMMENT;
+                                continue stateloop;
+                        }
+                    }
+                    // XXX reorder point
+                case COMMENT_END_BANG:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Comment end bang state
+                         * 
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the comment
+                                 * token.
+                                 */
+                                emitComment(3, pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '-':
+                                /*
+                                 * Append two U+002D HYPHEN-MINUS (-) characters
+                                 * and a U+0021 EXCLAMATION MARK (!) character
+                                 * to the comment token's data.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Switch to the comment end dash state.
+                                 */
+                                state = Tokenizer.COMMENT_END_DASH;
+                                continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append two U+002D HYPHEN-MINUS
+                                 * (-) characters, a U+0021 EXCLAMATION MARK (!)
+                                 * character, and the input character to the
+                                 * comment token's data. Switch to the comment
+                                 * state.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Switch to the comment state.
+                                 */
+                                state = Tokenizer.COMMENT;
+                                continue stateloop;
+                        }
+                    }
+                    // XXX reorder point
+                case COMMENT_START_DASH:
+                    if (++pos == endPos) {
+                        break stateloop;
+                    }
+                    c = checkChar(buf, pos);
+                    /*
+                     * Comment start dash state
+                     * 
+                     * Consume the next input character:
+                     */
+                    switch (c) {
+                        case '-':
+                            /*
+                             * U+002D HYPHEN-MINUS (-) Switch to the comment end
+                             * state
+                             */
+                            appendLongStrBuf(c);
+                            state = Tokenizer.COMMENT_END;
+                            continue stateloop;
+                        case '>':
+                            errPrematureEndOfComment();
+                            /* Emit the comment token. */
+                            emitComment(1, pos);
+                            /*
+                             * Switch to the data state.
+                             */
+                            state = Tokenizer.DATA;
+                            continue stateloop;
+                        case '\r':
+                            appendLongStrBufCarriageReturn();
+                            state = Tokenizer.COMMENT;
+                            break stateloop;
+                        case '\n':
+                            appendLongStrBufLineFeed();
+                            state = Tokenizer.COMMENT;
+                            continue stateloop;
+                        case '\u0000':
+                            c = '\uFFFD';
+                            // fall thru
+                        default:
+                            /*
+                             * Anything else Append a U+002D HYPHEN-MINUS (-)
+                             * character and the input character to the comment
+                             * token's data.
+                             */
+                            appendLongStrBuf(c);
+                            /*
+                             * Switch to the comment state.
+                             */
+                            state = Tokenizer.COMMENT;
+                            continue stateloop;
+                    }
+                    // XXX reorder point
+                case MARKUP_DECLARATION_OCTYPE:
+                    markupdeclarationdoctypeloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        if (index < 6) { // OCTYPE.length
+                            char folded = c;
+                            if (c >= 'A' && c <= 'Z') {
+                                folded += 0x20;
+                            }
+                            if (folded == Tokenizer.OCTYPE[index]) {
+                                appendLongStrBuf(c);
+                            } else {
+                                errBogusComment();
+                                state = Tokenizer.BOGUS_COMMENT;
+                                reconsume = true;
+                                continue stateloop;
+                            }
+                            index++;
+                            continue;
+                        } else {
+                            state = Tokenizer.DOCTYPE;
+                            reconsume = true;
+                            break markupdeclarationdoctypeloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case DOCTYPE:
+                    doctypeloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        initDoctypeFields();
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                state = Tokenizer.BEFORE_DOCTYPE_NAME;
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE
+                                 * Switch to the before DOCTYPE name state.
+                                 */
+                                state = Tokenizer.BEFORE_DOCTYPE_NAME;
+                                break doctypeloop;
+                            // continue stateloop;
+                            default:
+                                /*
+                                 * Anything else Parse error.
+                                 */
+                                errMissingSpaceBeforeDoctypeName();
+                                /*
+                                 * Reconsume the current character in the before
+                                 * DOCTYPE name state.
+                                 */
+                                state = Tokenizer.BEFORE_DOCTYPE_NAME;
+                                reconsume = true;
+                                break doctypeloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BEFORE_DOCTYPE_NAME:
+                    beforedoctypenameloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the before DOCTYPE name state.
+                                 */
+                                continue;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Parse error.
+                                 */
+                                errNamelessDoctype();
+                                /*
+                                 * Create a new DOCTYPE token. Set its
+                                 * force-quirks flag to on.
+                                 */
+                                forceQuirks = true;
+                                /*
+                                 * Emit the token.
+                                 */
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                if (c >= 'A' && c <= 'Z') {
+                                    /*
+                                     * U+0041 LATIN CAPITAL LETTER A through to
+                                     * U+005A LATIN CAPITAL LETTER Z Create a
+                                     * new DOCTYPE token. Set the token's name
+                                     * to the lowercase version of the input
+                                     * character (add 0x0020 to the character's
+                                     * code point).
+                                     */
+                                    c += 0x20;
+                                }
+                                /* Anything else Create a new DOCTYPE token. */
+                                /*
+                                 * Set the token's name name to the current
+                                 * input character.
+                                 */
+                                clearStrBufAndAppendCurrentC(c);
+                                /*
+                                 * Switch to the DOCTYPE name state.
+                                 */
+                                state = Tokenizer.DOCTYPE_NAME;
+                                break beforedoctypenameloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case DOCTYPE_NAME:
+                    doctypenameloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                strBufToDoctypeName();
+                                state = Tokenizer.AFTER_DOCTYPE_NAME;
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE
+                                 * Switch to the after DOCTYPE name state.
+                                 */
+                                strBufToDoctypeName();
+                                state = Tokenizer.AFTER_DOCTYPE_NAME;
+                                break doctypenameloop;
+                            // continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * DOCTYPE token.
+                                 */
+                                strBufToDoctypeName();
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * U+0041 LATIN CAPITAL LETTER A through to
+                                 * U+005A LATIN CAPITAL LETTER Z Append the
+                                 * lowercase version of the input character (add
+                                 * 0x0020 to the character's code point) to the
+                                 * current DOCTYPE token's name.
+                                 */
+                                if (c >= 'A' && c <= 'Z') {
+                                    c += 0x0020;
+                                }
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current DOCTYPE token's
+                                 * name.
+                                 */
+                                appendStrBuf(c);
+                                /*
+                                 * Stay in the DOCTYPE name state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case AFTER_DOCTYPE_NAME:
+                    afterdoctypenameloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the after DOCTYPE name state.
+                                 */
+                                continue;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * DOCTYPE token.
+                                 */
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case 'p':
+                            case 'P':
+                                index = 0;
+                                state = Tokenizer.DOCTYPE_UBLIC;
+                                break afterdoctypenameloop;
+                            // continue stateloop;
+                            case 's':
+                            case 'S':
+                                index = 0;
+                                state = Tokenizer.DOCTYPE_YSTEM;
+                                continue stateloop;
+                            default:
+                                /*
+                                 * Otherwise, this is the parse error.
+                                 */
+                                bogusDoctype();
+
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                // done by bogusDoctype();
+                                /*
+                                 * Switch to the bogus DOCTYPE state.
+                                 */
+                                state = Tokenizer.BOGUS_DOCTYPE;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case DOCTYPE_UBLIC:
+                    doctypeublicloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * If the six characters starting from the current input
+                         * character are an ASCII case-insensitive match for the
+                         * word "PUBLIC", then consume those characters and
+                         * switch to the before DOCTYPE public identifier state.
+                         */
+                        if (index < 5) { // UBLIC.length
+                            char folded = c;
+                            if (c >= 'A' && c <= 'Z') {
+                                folded += 0x20;
+                            }
+                            if (folded != Tokenizer.UBLIC[index]) {
+                                bogusDoctype();
+                                // forceQuirks = true;
+                                state = Tokenizer.BOGUS_DOCTYPE;
+                                reconsume = true;
+                                continue stateloop;
+                            }
+                            index++;
+                            continue;
+                        } else {
+                            state = Tokenizer.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
+                            reconsume = true;
+                            break doctypeublicloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:
+                    beforedoctypepublicidentifierloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the before DOCTYPE public identifier
+                                 * state.
+                                 */
+                                continue;
+                            case '"':
+                                /*
+                                 * U+0022 QUOTATION MARK (") Set the DOCTYPE
+                                 * token's public identifier to the empty string
+                                 * (not missing),
+                                 */
+                                clearLongStrBufForNextState();
+                                /*
+                                 * then switch to the DOCTYPE public identifier
+                                 * (double-quoted) state.
+                                 */
+                                state = Tokenizer.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
+                                break beforedoctypepublicidentifierloop;
+                            // continue stateloop;
+                            case '\'':
+                                /*
+                                 * U+0027 APOSTROPHE (') Set the DOCTYPE token's
+                                 * public identifier to the empty string (not
+                                 * missing),
+                                 */
+                                clearLongStrBufForNextState();
+                                /*
+                                 * then switch to the DOCTYPE public identifier
+                                 * (single-quoted) state.
+                                 */
+                                state = Tokenizer.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
+                                continue stateloop;
+                            case '>':
+                                /* U+003E GREATER-THAN SIGN (>) Parse error. */
+                                errExpectedPublicId();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                forceQuirks = true;
+                                /*
+                                 * Emit that DOCTYPE token.
+                                 */
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            default:
+                                bogusDoctype();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                // done by bogusDoctype();
+                                /*
+                                 * Switch to the bogus DOCTYPE state.
+                                 */
+                                state = Tokenizer.BOGUS_DOCTYPE;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:
+                    doctypepublicidentifierdoublequotedloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '"':
+                                /*
+                                 * U+0022 QUOTATION MARK (") Switch to the after
+                                 * DOCTYPE public identifier state.
+                                 */
+                                publicIdentifier = longStrBufToString();
+                                state = Tokenizer.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
+                                break doctypepublicidentifierdoublequotedloop;
+                            // continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Parse error.
+                                 */
+                                errGtInPublicId();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                forceQuirks = true;
+                                /*
+                                 * Emit that DOCTYPE token.
+                                 */
+                                publicIdentifier = longStrBufToString();
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current DOCTYPE token's
+                                 * public identifier.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the DOCTYPE public identifier
+                                 * (double-quoted) state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case AFTER_DOCTYPE_PUBLIC_IDENTIFIER:
+                    afterdoctypepublicidentifierloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the after DOCTYPE public identifier state.
+                                 */
+                                continue;
+                            case '"':
+                                /*
+                                 * U+0022 QUOTATION MARK (") Set the DOCTYPE
+                                 * token's system identifier to the empty string
+                                 * (not missing),
+                                 */
+                                clearLongStrBufForNextState();
+                                /*
+                                 * then switch to the DOCTYPE system identifier
+                                 * (double-quoted) state.
+                                 */
+                                state = Tokenizer.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
+                                break afterdoctypepublicidentifierloop;
+                            // continue stateloop;
+                            case '\'':
+                                /*
+                                 * U+0027 APOSTROPHE (') Set the DOCTYPE token's
+                                 * system identifier to the empty string (not
+                                 * missing),
+                                 */
+                                clearLongStrBufForNextState();
+                                /*
+                                 * then switch to the DOCTYPE system identifier
+                                 * (single-quoted) state.
+                                 */
+                                state = Tokenizer.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * DOCTYPE token.
+                                 */
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            default:
+                                bogusDoctype();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                // done by bogusDoctype();
+                                /*
+                                 * Switch to the bogus DOCTYPE state.
+                                 */
+                                state = Tokenizer.BOGUS_DOCTYPE;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:
+                    doctypesystemidentifierdoublequotedloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '"':
+                                /*
+                                 * U+0022 QUOTATION MARK (") Switch to the after
+                                 * DOCTYPE system identifier state.
+                                 */
+                                systemIdentifier = longStrBufToString();
+                                state = Tokenizer.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Parse error.
+                                 */
+                                errGtInSystemId();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                forceQuirks = true;
+                                /*
+                                 * Emit that DOCTYPE token.
+                                 */
+                                systemIdentifier = longStrBufToString();
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current DOCTYPE token's
+                                 * system identifier.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the DOCTYPE system identifier
+                                 * (double-quoted) state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case AFTER_DOCTYPE_SYSTEM_IDENTIFIER:
+                    afterdoctypesystemidentifierloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the after DOCTYPE system identifier state.
+                                 */
+                                continue;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * DOCTYPE token.
+                                 */
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            default:
+                                /*
+                                 * Switch to the bogus DOCTYPE state. (This does
+                                 * not set the DOCTYPE token's force-quirks flag
+                                 * to on.)
+                                 */
+                                bogusDoctypeWithoutQuirks();
+                                state = Tokenizer.BOGUS_DOCTYPE;
+                                break afterdoctypesystemidentifierloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BOGUS_DOCTYPE:
+                    for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit that
+                                 * DOCTYPE token.
+                                 */
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Stay in the bogus DOCTYPE
+                                 * state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // XXX reorder point
+                case DOCTYPE_YSTEM:
+                    doctypeystemloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Otherwise, if the six characters starting from the
+                         * current input character are an ASCII case-insensitive
+                         * match for the word "SYSTEM", then consume those
+                         * characters and switch to the before DOCTYPE system
+                         * identifier state.
+                         */
+                        if (index < 5) { // YSTEM.length
+                            char folded = c;
+                            if (c >= 'A' && c <= 'Z') {
+                                folded += 0x20;
+                            }
+                            if (folded != Tokenizer.YSTEM[index]) {
+                                bogusDoctype();
+                                state = Tokenizer.BOGUS_DOCTYPE;
+                                reconsume = true;
+                                continue stateloop;
+                            }
+                            index++;
+                            continue stateloop;
+                        } else {
+                            state = Tokenizer.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
+                            reconsume = true;
+                            break doctypeystemloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:
+                    beforedoctypesystemidentifierloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the before DOCTYPE system identifier
+                                 * state.
+                                 */
+                                continue;
+                            case '"':
+                                /*
+                                 * U+0022 QUOTATION MARK (") Set the DOCTYPE
+                                 * token's system identifier to the empty string
+                                 * (not missing),
+                                 */
+                                clearLongStrBufForNextState();
+                                /*
+                                 * then switch to the DOCTYPE system identifier
+                                 * (double-quoted) state.
+                                 */
+                                state = Tokenizer.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
+                                continue stateloop;
+                            case '\'':
+                                /*
+                                 * U+0027 APOSTROPHE (') Set the DOCTYPE token's
+                                 * system identifier to the empty string (not
+                                 * missing),
+                                 */
+                                clearLongStrBufForNextState();
+                                /*
+                                 * then switch to the DOCTYPE system identifier
+                                 * (single-quoted) state.
+                                 */
+                                state = Tokenizer.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
+                                break beforedoctypesystemidentifierloop;
+                            // continue stateloop;
+                            case '>':
+                                /* U+003E GREATER-THAN SIGN (>) Parse error. */
+                                errExpectedSystemId();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                forceQuirks = true;
+                                /*
+                                 * Emit that DOCTYPE token.
+                                 */
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            default:
+                                bogusDoctype();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                // done by bogusDoctype();
+                                /*
+                                 * Switch to the bogus DOCTYPE state.
+                                 */
+                                state = Tokenizer.BOGUS_DOCTYPE;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\'':
+                                /*
+                                 * U+0027 APOSTROPHE (') Switch to the after
+                                 * DOCTYPE system identifier state.
+                                 */
+                                systemIdentifier = longStrBufToString();
+                                state = Tokenizer.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
+                                continue stateloop;
+                            case '>':
+                                errGtInSystemId();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                forceQuirks = true;
+                                /*
+                                 * Emit that DOCTYPE token.
+                                 */
+                                systemIdentifier = longStrBufToString();
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current DOCTYPE token's
+                                 * system identifier.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the DOCTYPE system identifier
+                                 * (double-quoted) state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // XXX reorder point
+                case DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\'':
+                                /*
+                                 * U+0027 APOSTROPHE (') Switch to the after
+                                 * DOCTYPE public identifier state.
+                                 */
+                                publicIdentifier = longStrBufToString();
+                                state = Tokenizer.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
+                                continue stateloop;
+                            case '>':
+                                errGtInPublicId();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                forceQuirks = true;
+                                /*
+                                 * Emit that DOCTYPE token.
+                                 */
+                                publicIdentifier = longStrBufToString();
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current DOCTYPE token's
+                                 * public identifier.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the DOCTYPE public identifier
+                                 * (single-quoted) state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // XXX reorder point
+                case CDATA_START:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        if (index < 6) { // CDATA_LSQB.length
+                            if (c == Tokenizer.CDATA_LSQB[index]) {
+                                appendLongStrBuf(c);
+                            } else {
+                                errBogusComment();
+                                state = Tokenizer.BOGUS_COMMENT;
+                                reconsume = true;
+                                continue stateloop;
+                            }
+                            index++;
+                            continue;
+                        } else {
+                            cstart = pos; // start coalescing
+                            state = Tokenizer.CDATA_SECTION;
+                            reconsume = true;
+                            break; // FALL THROUGH continue stateloop;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case CDATA_SECTION:
+                    cdatasectionloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        switch (c) {
+                            case ']':
+                                flushChars(buf, pos);
+                                state = Tokenizer.CDATA_RSQB;
+                                break cdatasectionloop; // FALL THROUGH
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                continue;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            default:
+                                continue;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case CDATA_RSQB:
+                    cdatarsqb: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case ']':
+                                state = Tokenizer.CDATA_RSQB_RSQB;
+                                break cdatarsqb;
+                            default:
+                                tokenHandler.characters(Tokenizer.RSQB_RSQB, 0,
+                                        1);
+                                cstart = pos;
+                                state = Tokenizer.CDATA_SECTION;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case CDATA_RSQB_RSQB:
+                    if (++pos == endPos) {
+                        break stateloop;
+                    }
+                    c = checkChar(buf, pos);
+                    switch (c) {
+                        case '>':
+                            cstart = pos + 1;
+                            state = Tokenizer.DATA;
+                            continue stateloop;
+                        default:
+                            tokenHandler.characters(Tokenizer.RSQB_RSQB, 0, 2);
+                            cstart = pos;
+                            state = Tokenizer.CDATA_SECTION;
+                            reconsume = true;
+                            continue stateloop;
+
+                    }
+                    // XXX reorder point
+                case ATTRIBUTE_VALUE_SINGLE_QUOTED:
+                    attributevaluesinglequotedloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\'':
+                                /*
+                                 * U+0027 APOSTROPHE (') Switch to the after
+                                 * attribute value (quoted) state.
+                                 */
+                                addAttributeWithValue();
+
+                                state = Tokenizer.AFTER_ATTRIBUTE_VALUE_QUOTED;
+                                continue stateloop;
+                            case '&':
+                                /*
+                                 * U+0026 AMPERSAND (&) Switch to the character
+                                 * reference in attribute value state, with the
+                                 * + additional allowed character being U+0027
+                                 * APOSTROPHE (').
+                                 */
+                                clearStrBufAndAppendCurrentC(c);
+                                rememberAmpersandLocation('\'');
+                                returnState = state;
+                                state = Tokenizer.CONSUME_CHARACTER_REFERENCE;
+                                break attributevaluesinglequotedloop;
+                            // continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current attribute's value.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the attribute value (double-quoted)
+                                 * state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case CONSUME_CHARACTER_REFERENCE:
+                    if (++pos == endPos) {
+                        break stateloop;
+                    }
+                    c = checkChar(buf, pos);
+                    if (c == '\u0000') {
+                        break stateloop;
+                    }
+                    /*
+                     * Unlike the definition is the spec, this state does not
+                     * return a value and never requires the caller to
+                     * backtrack. This state takes care of emitting characters
+                     * or appending to the current attribute value. It also
+                     * takes care of that in the case when consuming the
+                     * character reference fails.
+                     */
+                    /*
+                     * This section defines how to consume a character
+                     * reference. This definition is used when parsing character
+                     * references in text and in attributes.
+                     * 
+                     * The behavior depends on the identity of the next
+                     * character (the one immediately after the U+0026 AMPERSAND
+                     * character):
+                     */
+                    switch (c) {
+                        case ' ':
+                        case '\t':
+                        case '\n':
+                        case '\r': // we'll reconsume!
+                        case '\u000C':
+                        case '<':
+                        case '&':
+                            emitOrAppendStrBuf(returnState);
+                            if ((returnState & (~1)) == 0) {
+                                cstart = pos;
+                            }
+                            state = returnState;
+                            reconsume = true;
+                            continue stateloop;
+                        case '#':
+                            /*
+                             * U+0023 NUMBER SIGN (#) Consume the U+0023 NUMBER
+                             * SIGN.
+                             */
+                            appendStrBuf('#');
+                            state = Tokenizer.CONSUME_NCR;
+                            continue stateloop;
+                        default:
+                            if (c == additional) {
+                                emitOrAppendStrBuf(returnState);
+                                state = returnState;
+                                reconsume = true;
+                                continue stateloop;
+                            }
+                            entCol = -1;
+                            lo = 0;
+                            hi = (NamedCharacters.NAMES.length - 1);
+                            candidate = -1;
+                            strBufMark = 0;
+                            state = Tokenizer.CHARACTER_REFERENCE_LOOP;
+                            reconsume = true;
+                            // FALL THROUGH continue stateloop;
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case CHARACTER_REFERENCE_LOOP:
+                    outer: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        if (c == '\u0000') {
+                            break stateloop;
+                        }
+                        entCol++;
+                        /*
+                         * Consume the maximum number of characters possible,
+                         * with the consumed characters matching one of the
+                         * identifiers in the first column of the named
+                         * character references table (in a case-sensitive
+                         * manner).
+                         */
+                        hiloop: for (;;) {
+                            if (hi == -1) {
+                                break hiloop;
+                            }
+                            if (entCol == NamedCharacters.NAMES[hi].length) {
+                                break hiloop;
+                            }
+                            if (entCol > NamedCharacters.NAMES[hi].length) {
+                                break outer;
+                            } else if (c < NamedCharacters.NAMES[hi][entCol]) {
+                                hi--;
+                            } else {
+                                break hiloop;
+                            }
+                        }
+
+                        loloop: for (;;) {
+                            if (hi < lo) {
+                                break outer;
+                            }
+                            if (entCol == NamedCharacters.NAMES[lo].length) {
+                                candidate = lo;
+                                strBufMark = strBufLen;
+                                lo++;
+                            } else if (entCol > NamedCharacters.NAMES[lo].length) {
+                                break outer;
+                            } else if (c > NamedCharacters.NAMES[lo][entCol]) {
+                                lo++;
+                            } else {
+                                break loloop;
+                            }
+                        }
+                        if (hi < lo) {
+                            break outer;
+                        }
+                        appendStrBuf(c);
+                        continue;
+                    }
+
+                    // TODO warn about apos (IE) and TRADE (Opera)
+                    if (candidate == -1) {
+                        // reconsume deals with CR, LF or nul
+                        /*
+                         * If no match can be made, then this is a parse error.
+                         */
+                        errNoNamedCharacterMatch();
+                        emitOrAppendStrBuf(returnState);
+                        if ((returnState & (~1)) == 0) {
+                            cstart = pos;
+                        }
+                        state = returnState;
+                        reconsume = true;
+                        continue stateloop;
+                    } else {
+                        // c can't be CR, LF or nul if we got here
+                        char[] candidateArr = NamedCharacters.NAMES[candidate];
+                        if (candidateArr[candidateArr.length - 1] != ';') {
+                            /*
+                             * If the last character matched is not a U+003B
+                             * SEMICOLON (;), there is a parse error.
+                             */
+                            if ((returnState & (~1)) != 0) {
+                                /*
+                                 * If the entity is being consumed as part of an
+                                 * attribute, and the last character matched is
+                                 * not a U+003B SEMICOLON (;),
+                                 */
+                                char ch;
+                                if (strBufMark == strBufLen) {
+                                    ch = c;
+                                } else {
+                                    // if (strBufOffset != -1) {
+                                    // ch = buf[strBufOffset + strBufMark];
+                                    // } else {
+                                    ch = strBuf[strBufMark];
+                                    // }
+                                }
+                                if ((ch >= '0' && ch <= '9')
+                                        || (ch >= 'A' && ch <= 'Z')
+                                        || (ch >= 'a' && ch <= 'z')) {
+                                    /*
+                                     * and the next character is in the range
+                                     * U+0030 DIGIT ZERO to U+0039 DIGIT NINE,
+                                     * U+0041 LATIN CAPITAL LETTER A to U+005A
+                                     * LATIN CAPITAL LETTER Z, or U+0061 LATIN
+                                     * SMALL LETTER A to U+007A LATIN SMALL
+                                     * LETTER Z, then, for historical reasons,
+                                     * all the characters that were matched
+                                     * after the U+0026 AMPERSAND (&) must be
+                                     * unconsumed, and nothing is returned.
+                                     */
+                                    errNoNamedCharacterMatch();
+                                    appendStrBufToLongStrBuf();
+                                    state = returnState;
+                                    reconsume = true;
+                                    continue stateloop;
+                                }
+                            }
+                            if ((returnState & (~1)) != 0) {
+                                errUnescapedAmpersandInterpretedAsCharacterReference();
+                            } else {
+                                errNotSemicolonTerminated();
+                            }
+                        }
+
+                        /*
+                         * Otherwise, return a character token for the character
+                         * corresponding to the entity name (as given by the
+                         * second column of the named character references
+                         * table).
+                         */
+                        char[] val = NamedCharacters.VALUES[candidate];
+                        emitOrAppend(val, returnState);
+                        // this is so complicated!
+                        if (strBufMark < strBufLen) {
+                            // if (strBufOffset != -1) {
+                            // if ((returnState & (~1)) != 0) {
+                            // for (int i = strBufMark; i < strBufLen; i++) {
+                            // appendLongStrBuf(buf[strBufOffset + i]);
+                            // }
+                            // } else {
+                            // tokenHandler.characters(buf, strBufOffset
+                            // + strBufMark, strBufLen
+                            // - strBufMark);
+                            // }
+                            // } else {
+                            if ((returnState & (~1)) != 0) {
+                                for (int i = strBufMark; i < strBufLen; i++) {
+                                    appendLongStrBuf(strBuf[i]);
+                                }
+                            } else {
+                                tokenHandler.characters(strBuf, strBufMark,
+                                        strBufLen - strBufMark);
+                            }
+                            // }
+                        }
+                        if ((returnState & (~1)) == 0) {
+                            cstart = pos;
+                        }
+                        state = returnState;
+                        reconsume = true;
+                        continue stateloop;
+                        /*
+                         * If the markup contains I'm &notit; I tell you, the
+                         * entity is parsed as "not", as in, I'm it; I tell
+                         * you. But if the markup was I'm &notin; I tell you,
+                         * the entity would be parsed as "notin;", resulting in
+                         * I'm  I tell you.
+                         */
+                    }
+                    // XXX reorder point
+                case CONSUME_NCR:
+                    if (++pos == endPos) {
+                        break stateloop;
+                    }
+                    c = checkChar(buf, pos);
+                    prevValue = -1;
+                    value = 0;
+                    seenDigits = false;
+                    /*
+                     * The behavior further depends on the character after the
+                     * U+0023 NUMBER SIGN:
+                     */
+                    switch (c) {
+                        case 'x':
+                        case 'X':
+
+                            /*
+                             * U+0078 LATIN SMALL LETTER X U+0058 LATIN CAPITAL
+                             * LETTER X Consume the X.
+                             * 
+                             * Follow the steps below, but using the range of
+                             * characters U+0030 DIGIT ZERO through to U+0039
+                             * DIGIT NINE, U+0061 LATIN SMALL LETTER A through
+                             * to U+0066 LATIN SMALL LETTER F, and U+0041 LATIN
+                             * CAPITAL LETTER A, through to U+0046 LATIN CAPITAL
+                             * LETTER F (in other words, 0-9, A-F, a-f).
+                             * 
+                             * When it comes to interpreting the number,
+                             * interpret it as a hexadecimal number.
+                             */
+                            appendStrBuf(c);
+                            state = Tokenizer.HEX_NCR_LOOP;
+                            continue stateloop;
+                        default:
+                            /*
+                             * Anything else Follow the steps below, but using
+                             * the range of characters U+0030 DIGIT ZERO through
+                             * to U+0039 DIGIT NINE (i.e. just 0-9).
+                             * 
+                             * When it comes to interpreting the number,
+                             * interpret it as a decimal number.
+                             */
+                            state = Tokenizer.DECIMAL_NRC_LOOP;
+                            reconsume = true;
+                            // FALL THROUGH continue stateloop;
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case DECIMAL_NRC_LOOP:
+                    decimalloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        // Deal with overflow gracefully
+                        if (value < prevValue) {
+                            value = 0x110000; // Value above Unicode range but
+                            // within int
+                            // range
+                        }
+                        prevValue = value;
+                        /*
+                         * Consume as many characters as match the range of
+                         * characters given above.
+                         */
+                        if (c >= '0' && c <= '9') {
+                            seenDigits = true;
+                            value *= 10;
+                            value += c - '0';
+                            continue;
+                        } else if (c == ';') {
+                            if (seenDigits) {
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos + 1;
+                                }
+                                state = Tokenizer.HANDLE_NCR_VALUE;
+                                // FALL THROUGH continue stateloop;
+                                break decimalloop;
+                            } else {
+                                errNoDigitsInNCR();
+                                appendStrBuf(';');
+                                emitOrAppendStrBuf(returnState);
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos + 1;
+                                }
+                                state = returnState;
+                                continue stateloop;
+                            }
+                        } else {
+                            /*
+                             * If no characters match the range, then don't
+                             * consume any characters (and unconsume the U+0023
+                             * NUMBER SIGN character and, if appropriate, the X
+                             * character). This is a parse error; nothing is
+                             * returned.
+                             * 
+                             * Otherwise, if the next character is a U+003B
+                             * SEMICOLON, consume that too. If it isn't, there
+                             * is a parse error.
+                             */
+                            if (!seenDigits) {
+                                errNoDigitsInNCR();
+                                emitOrAppendStrBuf(returnState);
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos;
+                                }
+                                state = returnState;
+                                reconsume = true;
+                                continue stateloop;
+                            } else {
+                                errCharRefLacksSemicolon();
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos;
+                                }
+                                state = Tokenizer.HANDLE_NCR_VALUE;
+                                reconsume = true;
+                                // FALL THROUGH continue stateloop;
+                                break decimalloop;
+                            }
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case HANDLE_NCR_VALUE:
+                    // WARNING previous state sets reconsume
+                    // XXX inline this case if the method size can take it
+                    handleNcrValue(returnState);
+                    state = returnState;
+                    continue stateloop;
+                    // XXX reorder point
+                case HEX_NCR_LOOP:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        // Deal with overflow gracefully
+                        if (value < prevValue) {
+                            value = 0x110000; // Value above Unicode range but
+                            // within int
+                            // range
+                        }
+                        prevValue = value;
+                        /*
+                         * Consume as many characters as match the range of
+                         * characters given above.
+                         */
+                        if (c >= '0' && c <= '9') {
+                            seenDigits = true;
+                            value *= 16;
+                            value += c - '0';
+                            continue;
+                        } else if (c >= 'A' && c <= 'F') {
+                            seenDigits = true;
+                            value *= 16;
+                            value += c - 'A' + 10;
+                            continue;
+                        } else if (c >= 'a' && c <= 'f') {
+                            seenDigits = true;
+                            value *= 16;
+                            value += c - 'a' + 10;
+                            continue;
+                        } else if (c == ';') {
+                            if (seenDigits) {
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos + 1;
+                                }
+                                state = Tokenizer.HANDLE_NCR_VALUE;
+                                continue stateloop;
+                            } else {
+                                errNoDigitsInNCR();
+                                appendStrBuf(';');
+                                emitOrAppendStrBuf(returnState);
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos + 1;
+                                }
+                                state = returnState;
+                                continue stateloop;
+                            }
+                        } else {
+                            /*
+                             * If no characters match the range, then don't
+                             * consume any characters (and unconsume the U+0023
+                             * NUMBER SIGN character and, if appropriate, the X
+                             * character). This is a parse error; nothing is
+                             * returned.
+                             * 
+                             * Otherwise, if the next character is a U+003B
+                             * SEMICOLON, consume that too. If it isn't, there
+                             * is a parse error.
+                             */
+                            if (!seenDigits) {
+                                errNoDigitsInNCR();
+                                emitOrAppendStrBuf(returnState);
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos;
+                                }
+                                state = returnState;
+                                reconsume = true;
+                                continue stateloop;
+                            } else {
+                                errCharRefLacksSemicolon();
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos;
+                                }
+                                state = Tokenizer.HANDLE_NCR_VALUE;
+                                reconsume = true;
+                                continue stateloop;
+                            }
+                        }
+                    }
+                    // XXX reorder point
+                case PLAINTEXT:
+                    plaintextloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        switch (c) {
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                continue;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            default:
+                                /*
+                                 * Anything else Emit the input character as a
+                                 * character token.
+                                 */
+                                /*
+                                 * Stay in the data state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // XXX reorder point
+                case CDATA:
+                    cdataloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        switch (c) {
+                            case '<':
+                                /*
+                                 * U+003C LESS-THAN SIGN (<) When the content
+                                 * model flag is set to the PCDATA state: switch
+                                 * to the tag open state. When the content model
+                                 * flag is set to either the RCDATA state or the
+                                 * CDATA state, and the escape flag is false:
+                                 * switch to the tag open state. Otherwise:
+                                 * treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                                flushChars(buf, pos);
+
+                                returnState = state;
+                                state = Tokenizer.TAG_OPEN_NON_PCDATA;
+                                break cdataloop; // FALL THRU continue
+                            // stateloop;
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                continue;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            default:
+                                /*
+                                 * Anything else Emit the input character as a
+                                 * character token.
+                                 */
+                                /*
+                                 * Stay in the data state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case TAG_OPEN_NON_PCDATA:
+                    tagopennonpcdataloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '!':
+                                tokenHandler.characters(Tokenizer.LT_GT, 0, 1);
+                                cstart = pos;
+                                state = Tokenizer.ESCAPE_EXCLAMATION;
+                                break tagopennonpcdataloop; // FALL THRU
+                            // continue
+                            // stateloop;
+                            case '/':
+                                /*
+                                 * If the content model flag is set to the
+                                 * RCDATA or CDATA states Consume the next input
+                                 * character.
+                                 */
+                                if (contentModelElement != null) {
+                                    /*
+                                     * If it is a U+002F SOLIDUS (/) character,
+                                     * switch to the close tag open state.
+                                     */
+                                    index = 0;
+                                    clearStrBufForNextState();
+                                    state = Tokenizer.CLOSE_TAG_OPEN_NOT_PCDATA;
+                                    continue stateloop;
+                                } // else fall through
+                            default:
+                                /*
+                                 * Otherwise, emit a U+003C LESS-THAN SIGN
+                                 * character token
+                                 */
+                                tokenHandler.characters(Tokenizer.LT_GT, 0, 1);
+                                /*
+                                 * and reconsume the current input character in
+                                 * the data state.
+                                 */
+                                cstart = pos;
+                                state = returnState;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case ESCAPE_EXCLAMATION:
+                    escapeexclamationloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '-':
+                                state = Tokenizer.ESCAPE_EXCLAMATION_HYPHEN;
+                                break escapeexclamationloop; // FALL THRU
+                            // continue
+                            // stateloop;
+                            default:
+                                state = returnState;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case ESCAPE_EXCLAMATION_HYPHEN:
+                    escapeexclamationhyphenloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '-':
+                                state = Tokenizer.ESCAPE_HYPHEN_HYPHEN;
+                                break escapeexclamationhyphenloop;
+                            // continue stateloop;
+                            default:
+                                state = returnState;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case ESCAPE_HYPHEN_HYPHEN:
+                    escapehyphenhyphenloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '-':
+                                continue;
+                            case '>':
+                                state = returnState;
+                                continue stateloop;
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                state = Tokenizer.ESCAPE;
+                                break escapehyphenhyphenloop;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                state = Tokenizer.ESCAPE;
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            default:
+                                state = Tokenizer.ESCAPE;
+                                break escapehyphenhyphenloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case ESCAPE:
+                    escapeloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '-':
+                                state = Tokenizer.ESCAPE_HYPHEN;
+                                break escapeloop; // FALL THRU continue
+                            // stateloop;
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                continue;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            default:
+                                continue;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case ESCAPE_HYPHEN:
+                    escapehyphenloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '-':
+                                state = Tokenizer.ESCAPE_HYPHEN_HYPHEN;
+                                continue stateloop;
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                state = Tokenizer.ESCAPE;
+                                continue stateloop;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                state = Tokenizer.ESCAPE;
+                                continue stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            default:
+                                state = Tokenizer.ESCAPE;
+                                continue stateloop;
+                        }
+                    }
+                    // XXX reorder point
+                case CLOSE_TAG_OPEN_NOT_PCDATA:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        // ASSERT! when entering this state, set index to 0 and
+                        // call clearStrBuf()
+                        // assert (contentModelElement != null);
+                        /*
+                         * If the content model flag is set to the RCDATA or
+                         * CDATA states but no start tag token has ever been
+                         * emitted by this instance of the tokeniser (fragment
+                         * case), or, if the content model flag is set to the
+                         * RCDATA or CDATA states and the next few characters do
+                         * not match the tag name of the last start tag token
+                         * emitted (compared in an ASCII case-insensitive
+                         * manner), or if they do but they are not immediately
+                         * followed by one of the following characters: + U+0009
+                         * CHARACTER TABULATION + U+000A LINE FEED (LF) + +
+                         * U+000C FORM FEED (FF) + U+0020 SPACE + U+003E
+                         * GREATER-THAN SIGN (>) + U+002F SOLIDUS (/) + EOF
+                         * 
+                         * ...then emit a U+003C LESS-THAN SIGN character token,
+                         * a U+002F SOLIDUS character token, and switch to the
+                         * data state to process the next input character.
+                         */
+                        // Let's implement the above without lookahead. strBuf
+                        // holds
+                        // characters that need to be emitted if looking for an
+                        // end tag
+                        // fails.
+                        // Duplicating the relevant part of tag name state here
+                        // as well.
+                        if (index < contentModelElementNameAsArray.length) {
+                            char e = contentModelElementNameAsArray[index];
+                            char folded = c;
+                            if (c >= 'A' && c <= 'Z') {
+                                folded += 0x20;
+                            }
+                            if (folded != e) {
+                                // [NOCPP[
+                                errHtml4LtSlashInRcdata(folded);
+                                // ]NOCPP]
+                                tokenHandler.characters(Tokenizer.LT_SOLIDUS,
+                                        0, 2);
+                                emitStrBuf();
+                                cstart = pos;
+                                state = returnState;
+                                reconsume = true;
+                                continue stateloop;
+                            }
+                            appendStrBuf(c);
+                            index++;
+                            continue;
+                        } else {
+                            endTag = true;
+                            // XXX replace contentModelElement with different
+                            // type
+                            tagName = contentModelElement;
+                            switch (c) {
+                                case '\r':
+                                    silentCarriageReturn();
+                                    state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                    break stateloop;
+                                case '\n':
+                                    silentLineFeed();
+                                    // fall thru
+                                case ' ':
+                                case '\t':
+                                case '\u000C':
+                                    /*
+                                     * U+0009 CHARACTER TABULATION U+000A LINE
+                                     * FEED (LF) U+000C FORM FEED (FF) U+0020
+                                     * SPACE Switch to the before attribute name
+                                     * state.
+                                     */
+                                    state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                    continue stateloop;
+                                case '>':
+                                    /*
+                                     * U+003E GREATER-THAN SIGN (>) Emit the
+                                     * current tag token.
+                                     */
+                                    state = emitCurrentTagToken(false, pos);
+                                    if (shouldSuspend) {
+                                        break stateloop;
+                                    }
+                                    /*
+                                     * Switch to the data state.
+                                     */
+                                    continue stateloop;
+                                case '/':
+                                    /*
+                                     * U+002F SOLIDUS (/) Switch to the
+                                     * self-closing start tag state.
+                                     */
+                                    state = Tokenizer.SELF_CLOSING_START_TAG;
+                                    continue stateloop;
+                                default:
+                                    // [NOCPP[
+                                    errWarnLtSlashInRcdata();
+                                    // ]NOCPP]
+                                    tokenHandler.characters(
+                                            Tokenizer.LT_SOLIDUS, 0, 2);
+                                    emitStrBuf();
+                                    if (c == '\u0000') {
+                                        emitReplacementCharacter(buf, pos);
+                                    } else {
+                                        cstart = pos; // don't drop the
+                                                      // character
+                                    }
+                                    state = returnState;
+                                    continue stateloop;
+                            }
+                        }
+                    }
+                    // XXX reorder point
+                case CLOSE_TAG_OPEN_PCDATA:
+                    if (++pos == endPos) {
+                        break stateloop;
+                    }
+                    c = checkChar(buf, pos);
+                    /*
+                     * Otherwise, if the content model flag is set to the PCDATA
+                     * state, or if the next few characters do match that tag
+                     * name, consume the next input character:
+                     */
+                    switch (c) {
+                        case '>':
+                            /* U+003E GREATER-THAN SIGN (>) Parse error. */
+                            errLtSlashGt();
+                            /*
+                             * Switch to the data state.
+                             */
+                            cstart = pos + 1;
+                            state = Tokenizer.DATA;
+                            continue stateloop;
+                        case '\r':
+                            silentCarriageReturn();
+                            /* Anything else Parse error. */
+                            errGarbageAfterLtSlash();
+                            /*
+                             * Switch to the bogus comment state.
+                             */
+                            clearLongStrBufAndAppendToComment('\n');
+                            state = Tokenizer.BOGUS_COMMENT;
+                            break stateloop;
+                        case '\n':
+                            silentLineFeed();
+                            /* Anything else Parse error. */
+                            errGarbageAfterLtSlash();
+                            /*
+                             * Switch to the bogus comment state.
+                             */
+                            clearLongStrBufAndAppendToComment('\n');
+                            state = Tokenizer.BOGUS_COMMENT;
+                            continue stateloop;
+                        case '\u0000':
+                            c = '\uFFFD';
+                            // fall thru
+                        default:
+                            if (c >= 'A' && c <= 'Z') {
+                                c += 0x20;
+                            }
+                            if (c >= 'a' && c <= 'z') {
+                                /*
+                                 * U+0061 LATIN SMALL LETTER A through to U+007A
+                                 * LATIN SMALL LETTER Z Create a new end tag
+                                 * token,
+                                 */
+                                endTag = true;
+                                /*
+                                 * set its tag name to the input character,
+                                 */
+                                clearStrBufAndAppendCurrentC(c);
+                                /*
+                                 * then switch to the tag name state. (Don't
+                                 * emit the token yet; further details will be
+                                 * filled in before it is emitted.)
+                                 */
+                                state = Tokenizer.TAG_NAME;
+                                continue stateloop;
+                            } else {
+                                /* Anything else Parse error. */
+                                errGarbageAfterLtSlash();
+                                /*
+                                 * Switch to the bogus comment state.
+                                 */
+                                clearLongStrBufAndAppendToComment(c);
+                                state = Tokenizer.BOGUS_COMMENT;
+                                continue stateloop;
+                            }
+                    }
+                    // XXX reorder point
+                case RCDATA:
+                    rcdataloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        switch (c) {
+                            case '&':
+                                /*
+                                 * U+0026 AMPERSAND (&) When the content model
+                                 * flag is set to one of the PCDATA or RCDATA
+                                 * states and the escape flag is false: switch
+                                 * to the character reference data state.
+                                 * Otherwise: treat it as per the "anything
+                                 * else" entry below.
+                                 */
+                                flushChars(buf, pos);
+                                clearStrBufAndAppendCurrentC(c);
+                                additional = '\u0000';
+                                returnState = state;
+                                state = Tokenizer.CONSUME_CHARACTER_REFERENCE;
+                                continue stateloop;
+                            case '<':
+                                /*
+                                 * U+003C LESS-THAN SIGN (<) When the content
+                                 * model flag is set to the PCDATA state: switch
+                                 * to the tag open state. When the content model
+                                 * flag is set to either the RCDATA state or the
+                                 * CDATA state, and the escape flag is false:
+                                 * switch to the tag open state. Otherwise:
+                                 * treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                                flushChars(buf, pos);
+
+                                returnState = state;
+                                state = Tokenizer.TAG_OPEN_NON_PCDATA;
+                                continue stateloop;
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                continue;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            default:
+                                /*
+                                 * Anything else Emit the input character as a
+                                 * character token.
+                                 */
+                                /*
+                                 * Stay in the data state.
+                                 */
+                                continue;
+                        }
+                    }
+
+            }
+        }
+        flushChars(buf, pos);
+        /*
+         * if (prevCR && pos != endPos) { // why is this needed? pos--; col--; }
+         */
+        // Save locals
+        stateSave = state;
+        returnStateSave = returnState;
+        return pos;
+    }
+
+    @Inline private void initDoctypeFields() {
+        doctypeName = "";
+        systemIdentifier = null;
+        publicIdentifier = null;
+        forceQuirks = false;
+    }
+
+    @Inline private void adjustDoubleHyphenAndAppendToLongStrBufCarriageReturn()
+            throws SAXException {
+        silentCarriageReturn();
+        adjustDoubleHyphenAndAppendToLongStrBufAndErr('\n');
+    }
+
+    @Inline private void adjustDoubleHyphenAndAppendToLongStrBufLineFeed()
+            throws SAXException {
+        silentLineFeed();
+        adjustDoubleHyphenAndAppendToLongStrBufAndErr('\n');
+    }
+
+    @Inline private void appendLongStrBufLineFeed() {
+        silentLineFeed();
+        appendLongStrBuf('\n');
+    }
+
+    @Inline private void appendLongStrBufCarriageReturn() {
+        silentCarriageReturn();
+        appendLongStrBuf('\n');
+    }
+
+    @Inline protected void silentCarriageReturn() {
+        ++line;
+        lastCR = true;
+    }
+
+    @Inline protected void silentLineFeed() {
+        ++line;
+    }
+
+    private void emitCarriageReturn(@NoLength char[] buf, int pos)
+            throws SAXException {
+        silentCarriageReturn();
+        flushChars(buf, pos);
+        tokenHandler.characters(Tokenizer.LF, 0, 1);
+        cstart = Integer.MAX_VALUE;
+    }
+
+    private void emitReplacementCharacter(@NoLength char[] buf, int pos)
+            throws SAXException {
+        silentCarriageReturn();
+        flushChars(buf, pos);
+        tokenHandler.characters(Tokenizer.REPLACEMENT_CHARACTER, 0, 1);
+        cstart = Integer.MAX_VALUE;
+    }
+
+    private void rememberAmpersandLocation(char add) {
+        additional = add;
+        // [NOCPP[
+        ampersandLocation = new LocatorImpl(this);
+        // ]NOCPP]
+    }
+
+    private void bogusDoctype() throws SAXException {
+        errBogusDoctype();
+        forceQuirks = true;
+    }
+
+    private void bogusDoctypeWithoutQuirks() throws SAXException {
+        errBogusDoctype();
+        forceQuirks = false;
+    }
+
+    private void emitOrAppendStrBuf(int returnState) throws SAXException {
+        if ((returnState & (~1)) != 0) {
+            appendStrBufToLongStrBuf();
+        } else {
+            emitStrBuf();
+        }
+    }
+
+    private void handleNcrValue(int returnState) throws SAXException {
+        /*
+         * If one or more characters match the range, then take them all and
+         * interpret the string of characters as a number (either hexadecimal or
+         * decimal as appropriate).
+         */
+        if (value >= 0x80 && value <= 0x9f) {
+            /*
+             * If that number is one of the numbers in the first column of the
+             * following table, then this is a parse error.
+             */
+            errNcrInC1Range();
+            /*
+             * Find the row with that number in the first column, and return a
+             * character token for the Unicode character given in the second
+             * column of that row.
+             */
+            @NoLength char[] val = NamedCharacters.WINDOWS_1252[value - 0x80];
+            emitOrAppendOne(val, returnState);
+        } else if (value == 0x0D) {
+            errRcnCr();
+            emitOrAppendOne(Tokenizer.LF, returnState);
+            // [NOCPP[
+        } else if (value == 0xC
+                && contentSpacePolicy != XmlViolationPolicy.ALLOW) {
+            if (contentSpacePolicy == XmlViolationPolicy.ALTER_INFOSET) {
+                emitOrAppendOne(Tokenizer.SPACE, returnState);
+            } else if (contentSpacePolicy == XmlViolationPolicy.FATAL) {
+                fatal("A character reference expanded to a form feed which is not legal XML 1.0 white space.");
+            }
+            // ]NOCPP]
+        } else if ((value >= 0x0000 && value <= 0x0008) || (value == 0x000B)
+                || (value >= 0x000E && value <= 0x001F) || value == 0x007F) {
+            /*
+             * Otherwise, if the number is in the range 0x0000 to 0x0008, 0x000E
+             * to 0x001F, 0x007F to 0x009F, 0xD800 to 0xDFFF, 0xFDD0 to 0xFDEF,
+             * or is one of 0x000B, 0xFFFE, 0xFFFF, 0x1FFFE, 0x1FFFF, 0x2FFFE,
+             * 0x2FFFF, 0x3FFFE, 0x3FFFF, 0x4FFFE, 0x4FFFF, 0x5FFFE, 0x5FFFF,
+             * 0x6FFFE, 0x6FFFF, 0x7FFFE, 0x7FFFF, 0x8FFFE, 0x8FFFF, 0x9FFFE,
+             * 0x9FFFF, 0xAFFFE, 0xAFFFF, 0xBFFFE, 0xBFFFF, 0xCFFFE, 0xCFFFF,
+             * 0xDFFFE, 0xDFFFF, 0xEFFFE, 0xEFFFF, 0xFFFFE, 0xFFFFF, 0x10FFFE,
+             * or 0x10FFFF, or is higher than 0x10FFFF, then this is a parse
+             * error; return a character token for the U+FFFD REPLACEMENT
+             * CHARACTER character instead.
+             */
+            errNcrControlChar();
+            emitOrAppendOne(Tokenizer.REPLACEMENT_CHARACTER, returnState);
+        } else if ((value & 0xF800) == 0xD800) {
+            errNcrSurrogate();
+            emitOrAppendOne(Tokenizer.REPLACEMENT_CHARACTER, returnState);
+        } else if ((value & 0xFFFE) == 0xFFFE) {
+            errNcrNonCharacter();
+            emitOrAppendOne(Tokenizer.REPLACEMENT_CHARACTER, returnState);
+        } else if (value >= 0xFDD0 && value <= 0xFDEF) {
+            errNcrUnassigned();
+            emitOrAppendOne(Tokenizer.REPLACEMENT_CHARACTER, returnState);
+        } else if (value <= 0xFFFF) {
+            /*
+             * Otherwise, return a character token for the Unicode character
+             * whose code point is that number.
+             */
+            char ch = (char) value;
+            // [NOCPP[
+            maybeWarnPrivateUse(ch);
+            // ]NOCPP]
+            bmpChar[0] = ch;
+            emitOrAppendOne(bmpChar, returnState);
+        } else if (value <= 0x10FFFF) {
+            // [NOCPP[
+            maybeWarnPrivateUseAstral();
+            // ]NOCPP]
+            astralChar[0] = (char) (Tokenizer.LEAD_OFFSET + (value >> 10));
+            astralChar[1] = (char) (0xDC00 + (value & 0x3FF));
+            emitOrAppend(astralChar, returnState);
+        } else {
+            errNcrOutOfRange();
+            emitOrAppendOne(Tokenizer.REPLACEMENT_CHARACTER, returnState);
+        }
+    }
+
+    public void eof() throws SAXException {
+        int state = stateSave;
+        int returnState = returnStateSave;
+
+        eofloop: for (;;) {
+            switch (state) {
+                case TAG_OPEN_NON_PCDATA:
+                    /*
+                     * Otherwise, emit a U+003C LESS-THAN SIGN character token
+                     */
+                    tokenHandler.characters(Tokenizer.LT_GT, 0, 1);
+                    /*
+                     * and reconsume the current input character in the data
+                     * state.
+                     */
+                    break eofloop;
+                case TAG_OPEN:
+                    /*
+                     * The behavior of this state depends on the content model
+                     * flag.
+                     */
+                    /*
+                     * Anything else Parse error.
+                     */
+                    errEofAfterLt();
+                    /*
+                     * Emit a U+003C LESS-THAN SIGN character token
+                     */
+                    tokenHandler.characters(Tokenizer.LT_GT, 0, 1);
+                    /*
+                     * and reconsume the current input character in the data
+                     * state.
+                     */
+                    break eofloop;
+                case CLOSE_TAG_OPEN_NOT_PCDATA:
+                    if (index < contentModelElementNameAsArray.length) {
+                        break eofloop;
+                    } else {
+                        errEofInEndTag();
+                        /*
+                         * Reconsume the EOF character in the data state.
+                         */
+                        break eofloop;
+                    }
+                case CLOSE_TAG_OPEN_PCDATA:
+                    /* EOF Parse error. */
+                    errEofAfterLt();
+                    /*
+                     * Emit a U+003C LESS-THAN SIGN character token and a U+002F
+                     * SOLIDUS character token.
+                     */
+                    tokenHandler.characters(Tokenizer.LT_SOLIDUS, 0, 2);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case TAG_NAME:
+                    /*
+                     * EOF Parse error.
+                     */
+                    errEofInTagName();
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case BEFORE_ATTRIBUTE_NAME:
+                case AFTER_ATTRIBUTE_VALUE_QUOTED:
+                case SELF_CLOSING_START_TAG:
+                    /* EOF Parse error. */
+                    errEofWithoutGt();
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case ATTRIBUTE_NAME:
+                    /*
+                     * EOF Parse error.
+                     */
+                    errEofInAttributeName();
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case AFTER_ATTRIBUTE_NAME:
+                case BEFORE_ATTRIBUTE_VALUE:
+                    /* EOF Parse error. */
+                    errEofWithoutGt();
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case ATTRIBUTE_VALUE_DOUBLE_QUOTED:
+                case ATTRIBUTE_VALUE_SINGLE_QUOTED:
+                case ATTRIBUTE_VALUE_UNQUOTED:
+                    /* EOF Parse error. */
+                    errEofInAttributeValue();
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case BOGUS_COMMENT:
+                    emitComment(0, 0);
+                    break eofloop;
+                case BOGUS_COMMENT_HYPHEN:
+                    // [NOCPP[
+                    maybeAppendSpaceToBogusComment();
+                    // ]NOCPP]
+                    emitComment(0, 0);
+                    break eofloop;
+                case MARKUP_DECLARATION_OPEN:
+                    errBogusComment();
+                    clearLongStrBuf();
+                    emitComment(0, 0);
+                    break eofloop;
+                case MARKUP_DECLARATION_HYPHEN:
+                    errBogusComment();
+                    emitComment(0, 0);
+                    break eofloop;
+                case MARKUP_DECLARATION_OCTYPE:
+                    if (index < 6) {
+                        errBogusComment();
+                        emitComment(0, 0);
+                    } else {
+                        /* EOF Parse error. */
+                        errEofInDoctype();
+                        /*
+                         * Create a new DOCTYPE token. Set its force-quirks flag
+                         * to on.
+                         */
+                        doctypeName = "";
+                        publicIdentifier = null;
+                        systemIdentifier = null;
+                        forceQuirks = true;
+                        /*
+                         * Emit the token.
+                         */
+                        emitDoctypeToken(0);
+                        /*
+                         * Reconsume the EOF character in the data state.
+                         */
+                        break eofloop;
+                    }
+                    break eofloop;
+                case COMMENT_START:
+                case COMMENT:
+                case COMMENT_END_SPACE:
+                    /*
+                     * EOF Parse error.
+                     */
+                    errEofInComment();
+                    /* Emit the comment token. */
+                    emitComment(0, 0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case COMMENT_END:
+                    errEofInComment();
+                    /* Emit the comment token. */
+                    emitComment(2, 0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case COMMENT_END_DASH:
+                case COMMENT_START_DASH:
+                    errEofInComment();
+                    /* Emit the comment token. */
+                    emitComment(1, 0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case COMMENT_END_BANG:
+                    errEofInComment();
+                    /* Emit the comment token. */
+                    emitComment(3, 0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case DOCTYPE:
+                case BEFORE_DOCTYPE_NAME:
+                    errEofInDoctype();
+                    /*
+                     * Create a new DOCTYPE token. Set its force-quirks flag to
+                     * on.
+                     */
+                    forceQuirks = true;
+                    /*
+                     * Emit the token.
+                     */
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case DOCTYPE_NAME:
+                    errEofInDoctype();
+                    strBufToDoctypeName();
+                    /*
+                     * Set the DOCTYPE token's force-quirks flag to on.
+                     */
+                    forceQuirks = true;
+                    /*
+                     * Emit that DOCTYPE token.
+                     */
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case DOCTYPE_UBLIC:
+                case DOCTYPE_YSTEM:
+                case AFTER_DOCTYPE_NAME:
+                case BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:
+                    errEofInDoctype();
+                    /*
+                     * Set the DOCTYPE token's force-quirks flag to on.
+                     */
+                    forceQuirks = true;
+                    /*
+                     * Emit that DOCTYPE token.
+                     */
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:
+                case DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:
+                    /* EOF Parse error. */
+                    errEofInPublicId();
+                    /*
+                     * Set the DOCTYPE token's force-quirks flag to on.
+                     */
+                    forceQuirks = true;
+                    /*
+                     * Emit that DOCTYPE token.
+                     */
+                    publicIdentifier = longStrBufToString();
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case AFTER_DOCTYPE_PUBLIC_IDENTIFIER:
+                case BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:
+                    errEofInDoctype();
+                    /*
+                     * Set the DOCTYPE token's force-quirks flag to on.
+                     */
+                    forceQuirks = true;
+                    /*
+                     * Emit that DOCTYPE token.
+                     */
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:
+                case DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:
+                    /* EOF Parse error. */
+                    errEofInSystemId();
+                    /*
+                     * Set the DOCTYPE token's force-quirks flag to on.
+                     */
+                    forceQuirks = true;
+                    /*
+                     * Emit that DOCTYPE token.
+                     */
+                    systemIdentifier = longStrBufToString();
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case AFTER_DOCTYPE_SYSTEM_IDENTIFIER:
+                    errEofInDoctype();
+                    /*
+                     * Set the DOCTYPE token's force-quirks flag to on.
+                     */
+                    forceQuirks = true;
+                    /*
+                     * Emit that DOCTYPE token.
+                     */
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case BOGUS_DOCTYPE:
+                    /*
+                     * Emit that DOCTYPE token.
+                     */
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case CONSUME_CHARACTER_REFERENCE:
+                    /*
+                     * Unlike the definition is the spec, this state does not
+                     * return a value and never requires the caller to
+                     * backtrack. This state takes care of emitting characters
+                     * or appending to the current attribute value. It also
+                     * takes care of that in the case when consuming the entity
+                     * fails.
+                     */
+                    /*
+                     * This section defines how to consume an entity. This
+                     * definition is used when parsing entities in text and in
+                     * attributes.
+                     * 
+                     * The behavior depends on the identity of the next
+                     * character (the one immediately after the U+0026 AMPERSAND
+                     * character):
+                     */
+
+                    emitOrAppendStrBuf(returnState);
+                    state = returnState;
+                    continue;
+                case CHARACTER_REFERENCE_LOOP:
+                    outer: for (;;) {
+                        char c = '\u0000';
+                        entCol++;
+                        /*
+                         * Consume the maximum number of characters possible,
+                         * with the consumed characters matching one of the
+                         * identifiers in the first column of the named
+                         * character references table (in a case-sensitive
+                         * manner).
+                         */
+                        hiloop: for (;;) {
+                            if (hi == -1) {
+                                break hiloop;
+                            }
+                            if (entCol == NamedCharacters.NAMES[hi].length) {
+                                break hiloop;
+                            }
+                            if (entCol > NamedCharacters.NAMES[hi].length) {
+                                break outer;
+                            } else if (c < NamedCharacters.NAMES[hi][entCol]) {
+                                hi--;
+                            } else {
+                                break hiloop;
+                            }
+                        }
+
+                        loloop: for (;;) {
+                            if (hi < lo) {
+                                break outer;
+                            }
+                            if (entCol == NamedCharacters.NAMES[lo].length) {
+                                candidate = lo;
+                                strBufMark = strBufLen;
+                                lo++;
+                            } else if (entCol > NamedCharacters.NAMES[lo].length) {
+                                break outer;
+                            } else if (c > NamedCharacters.NAMES[lo][entCol]) {
+                                lo++;
+                            } else {
+                                break loloop;
+                            }
+                        }
+                        if (hi < lo) {
+                            break outer;
+                        }
+                        continue;
+                    }
+
+                    // TODO warn about apos (IE) and TRADE (Opera)
+                    if (candidate == -1) {
+                        /*
+                         * If no match can be made, then this is a parse error.
+                         */
+                        errNoNamedCharacterMatch();
+                        emitOrAppendStrBuf(returnState);
+                        state = returnState;
+                        continue eofloop;
+                    } else {
+                        char[] candidateArr = NamedCharacters.NAMES[candidate];
+                        if (candidateArr[candidateArr.length - 1] != ';') {
+                            /*
+                             * If the last character matched is not a U+003B
+                             * SEMICOLON (;), there is a parse error.
+                             */
+                            if ((returnState & (~1)) != 0) {
+                                /*
+                                 * If the entity is being consumed as part of an
+                                 * attribute, and the last character matched is
+                                 * not a U+003B SEMICOLON (;),
+                                 */
+                                char ch;
+                                if (strBufMark == strBufLen) {
+                                    ch = '\u0000';
+                                } else {
+                                    ch = strBuf[strBufMark];
+                                }
+                                if ((ch >= '0' && ch <= '9')
+                                        || (ch >= 'A' && ch <= 'Z')
+                                        || (ch >= 'a' && ch <= 'z')) {
+                                    /*
+                                     * and the next character is in the range
+                                     * U+0030 DIGIT ZERO to U+0039 DIGIT NINE,
+                                     * U+0041 LATIN CAPITAL LETTER A to U+005A
+                                     * LATIN CAPITAL LETTER Z, or U+0061 LATIN
+                                     * SMALL LETTER A to U+007A LATIN SMALL
+                                     * LETTER Z, then, for historical reasons,
+                                     * all the characters that were matched
+                                     * after the U+0026 AMPERSAND (&) must be
+                                     * unconsumed, and nothing is returned.
+                                     */
+                                    errNoNamedCharacterMatch();
+                                    appendStrBufToLongStrBuf();
+                                    state = returnState;
+                                    continue eofloop;
+                                }
+                            }
+                            if ((returnState & (~1)) != 0) {
+                                errUnescapedAmpersandInterpretedAsCharacterReference();
+                            } else {
+                                errNotSemicolonTerminated();
+                            }
+                        }
+
+                        /*
+                         * Otherwise, return a character token for the character
+                         * corresponding to the entity name (as given by the
+                         * second column of the named character references
+                         * table).
+                         */
+                        char[] val = NamedCharacters.VALUES[candidate];
+                        emitOrAppend(val, returnState);
+                        // this is so complicated!
+                        if (strBufMark < strBufLen) {
+                            if ((returnState & (~1)) != 0) {
+                                for (int i = strBufMark; i < strBufLen; i++) {
+                                    appendLongStrBuf(strBuf[i]);
+                                }
+                            } else {
+                                tokenHandler.characters(strBuf, strBufMark,
+                                        strBufLen - strBufMark);
+                            }
+                        }
+                        state = returnState;
+                        continue eofloop;
+                        /*
+                         * If the markup contains I'm &notit; I tell you, the
+                         * entity is parsed as "not", as in, I'm it; I tell
+                         * you. But if the markup was I'm &notin; I tell you,
+                         * the entity would be parsed as "notin;", resulting in
+                         * I'm  I tell you.
+                         */
+                    }
+                case CONSUME_NCR:
+                case DECIMAL_NRC_LOOP:
+                case HEX_NCR_LOOP:
+                    /*
+                     * If no characters match the range, then don't consume any
+                     * characters (and unconsume the U+0023 NUMBER SIGN
+                     * character and, if appropriate, the X character). This is
+                     * a parse error; nothing is returned.
+                     * 
+                     * Otherwise, if the next character is a U+003B SEMICOLON,
+                     * consume that too. If it isn't, there is a parse error.
+                     */
+                    if (!seenDigits) {
+                        errNoDigitsInNCR();
+                        emitOrAppendStrBuf(returnState);
+                        state = returnState;
+                        continue;
+                    } else {
+                        errCharRefLacksSemicolon();
+                    }
+                    // WARNING previous state sets reconsume
+                    handleNcrValue(returnState);
+                    state = returnState;
+                    continue;
+                case DATA:
+                default:
+                    break eofloop;
+            }
+        }
+        // case DATA:
+        /*
+         * EOF Emit an end-of-file token.
+         */
+        tokenHandler.eof();
+        return;
+    }
+
+    private void emitDoctypeToken(int pos) throws SAXException {
+        cstart = pos + 1;
+        tokenHandler.doctype(doctypeName, publicIdentifier, systemIdentifier,
+                forceQuirks);
+        // It is OK and sufficient to release these here, since
+        // there's no way out of the doctype states than through paths
+        // that call this method.
+        Portability.releaseLocal(doctypeName);
+        Portability.releaseString(publicIdentifier);
+        Portability.releaseString(systemIdentifier);
+    }
+
+    @Inline protected char checkChar(@NoLength char[] buf, int pos)
+            throws SAXException {
+        return buf[pos];
+    }
+
+    // [NOCPP[
+
+    /**
+     * Returns the alreadyComplainedAboutNonAscii.
+     * 
+     * @return the alreadyComplainedAboutNonAscii
+     */
+    public boolean isAlreadyComplainedAboutNonAscii() {
+        return true;
+    }
+
+    // ]NOCPP]
+
+    public void internalEncodingDeclaration(String internalCharset)
+            throws SAXException {
+        if (encodingDeclarationHandler != null) {
+            encodingDeclarationHandler.internalEncodingDeclaration(internalCharset);
+        }
+    }
+
+    /**
+     * @param val
+     * @throws SAXException
+     */
+    private void emitOrAppend(char[] val, int returnState) throws SAXException {
+        if ((returnState & (~1)) != 0) {
+            appendLongStrBuf(val);
+        } else {
+            tokenHandler.characters(val, 0, val.length);
+        }
+    }
+
+    private void emitOrAppendOne(@NoLength char[] val, int returnState)
+            throws SAXException {
+        if ((returnState & (~1)) != 0) {
+            appendLongStrBuf(val[0]);
+        } else {
+            tokenHandler.characters(val, 0, 1);
+        }
+    }
+
+    public void end() throws SAXException {
+        strBuf = null;
+        longStrBuf = null;
+        systemIdentifier = null;
+        publicIdentifier = null;
+        doctypeName = null;
+        tagName = null;
+        attributeName = null;
+        tokenHandler.endTokenization();
+        if (attributes != null) {
+            attributes.clear(mappingLangToXmlLang);
+            Portability.delete(attributes);
+            attributes = null;
+        }
+    }
+
+    public void requestSuspension() {
+        shouldSuspend = true;
+    }
+
+    public void becomeConfident() {
+        confident = true;
+    }
+
+    /**
+     * Returns the nextCharOnNewLine.
+     * 
+     * @return the nextCharOnNewLine
+     */
+    public boolean isNextCharOnNewLine() {
+        return false;
+    }
+
+    public boolean isPrevCR() {
+        return lastCR;
+    }
+
+    /**
+     * Returns the line.
+     * 
+     * @return the line
+     */
+    public int getLine() {
+        return -1;
+    }
+
+    /**
+     * Returns the col.
+     * 
+     * @return the col
+     */
+    public int getCol() {
+        return -1;
+    }
+
+    public boolean isInDataState() {
+        return (stateSave == DATA);
+    }
+
+    protected void errGarbageAfterLtSlash() throws SAXException {
+    }
+
+    protected void errLtSlashGt() throws SAXException {
+    }
+
+    protected void errWarnLtSlashInRcdata() throws SAXException {
+    }
+
+    protected void errHtml4LtSlashInRcdata(char folded) throws SAXException {
+    }
+
+    protected void errCharRefLacksSemicolon() throws SAXException {
+    }
+
+    protected void errNoDigitsInNCR() throws SAXException {
+    }
+
+    protected void errGtInSystemId() throws SAXException {
+    }
+
+    protected void errGtInPublicId() throws SAXException {
+    }
+
+    protected void errNamelessDoctype() throws SAXException {
+    }
+
+    protected void errConsecutiveHyphens() throws SAXException {
+    }
+
+    protected void errPrematureEndOfComment() throws SAXException {
+    }
+
+    protected void errBogusComment() throws SAXException {
+    }
+
+    protected void errUnquotedAttributeValOrNull(char c) throws SAXException {
+    }
+
+    protected void errSlashNotFollowedByGt() throws SAXException {
+    }
+
+    protected void errHtml4XmlVoidSyntax() throws SAXException {
+    }
+
+    protected void errNoSpaceBetweenAttributes() throws SAXException {
+    }
+
+    protected void errHtml4NonNameInUnquotedAttribute(char c)
+            throws SAXException {
+    }
+
+    protected void errLtOrEqualsInUnquotedAttributeOrNull(char c)
+            throws SAXException {
+    }
+
+    protected void errAttributeValueMissing() throws SAXException {
+    }
+
+    protected void errBadCharBeforeAttributeNameOrNull(char c)
+            throws SAXException {
+    }
+
+    protected void errEqualsSignBeforeAttributeName() throws SAXException {
+    }
+
+    protected void errBadCharAfterLt(char c) throws SAXException {
+    }
+
+    protected void errLtGt() throws SAXException {
+    }
+
+    protected void errProcessingInstruction() throws SAXException {
+    }
+
+    protected void errUnescapedAmpersandInterpretedAsCharacterReference()
+            throws SAXException {
+    }
+
+    protected void errNotSemicolonTerminated() throws SAXException {
+    }
+
+    protected void errNoNamedCharacterMatch() throws SAXException {
+    }
+
+    protected void errQuoteBeforeAttributeName(char c) throws SAXException {
+    }
+
+    protected void errQuoteOrLtInAttributeNameOrNull(char c) throws SAXException {
+    }
+
+    protected void errExpectedPublicId() throws SAXException {
+    }
+
+    protected void errBogusDoctype() throws SAXException {
+    }
+
+    protected void maybeWarnPrivateUseAstral() throws SAXException {
+    }
+
+    protected void maybeWarnPrivateUse(char ch) throws SAXException {
+    }
+
+    protected void maybeErrAttributesOnEndTag(HtmlAttributes attrs)
+            throws SAXException {
+    }
+
+    protected void maybeErrSlashInEndTag(boolean selfClosing)
+            throws SAXException {
+    }
+
+    protected void errNcrNonCharacter() throws SAXException {
+    }
+
+    protected void errNcrSurrogate() throws SAXException {
+    }
+
+    protected void errNcrControlChar() throws SAXException {
+    }
+
+    protected void errRcnCr() throws SAXException {
+    }
+
+    protected void errNcrInC1Range() throws SAXException {
+    }
+
+    protected void errEofInPublicId() throws SAXException {
+    }
+
+    protected void errEofInComment() throws SAXException {
+    }
+
+    protected void errEofInDoctype() throws SAXException {
+    }
+
+    protected void errEofInAttributeValue() throws SAXException {
+    }
+
+    protected void errEofInAttributeName() throws SAXException {
+    }
+
+    protected void errEofWithoutGt() throws SAXException {
+    }
+
+    protected void errEofInTagName() throws SAXException {
+    }
+
+    protected void errEofInEndTag() throws SAXException {
+    }
+
+    protected void errEofAfterLt() throws SAXException {
+    }
+
+    protected void errNcrOutOfRange() throws SAXException {
+    }
+
+    protected void errNcrUnassigned() throws SAXException {
+    }
+
+    protected void errDuplicateAttribute() throws SAXException {
+    }
+
+    protected void errEofInSystemId() throws SAXException {
+    }
+
+    protected void errExpectedSystemId() throws SAXException {
+    }
+
+    protected void errMissingSpaceBeforeDoctypeName() throws SAXException {
+    }
+
+    protected void errHyphenHyphenBang() throws SAXException {
+    }
+
+    /**
+     * Sets the encodingDeclarationHandler.
+     * 
+     * @param encodingDeclarationHandler
+     *            the encodingDeclarationHandler to set
+     */
+    public void setEncodingDeclarationHandler(
+            EncodingDeclarationHandler encodingDeclarationHandler) {
+        this.encodingDeclarationHandler = encodingDeclarationHandler;
+    }
+
+}
diff --git a/parser/html/java/htmlparser/src/TreeBuilder.java b/parser/html/java/htmlparser/src/TreeBuilder.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/TreeBuilder.java
@@ -0,0 +1,5088 @@
+/*
+ * Copyright (c) 2007 Henri Sivonen
+ * Copyright (c) 2007-2009 Mozilla Foundation
+ * Portions of comments Copyright 2004-2008 Apple Computer, Inc., Mozilla 
+ * Foundation, and Opera Software ASA.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * The comments following this one that use the same comment syntax as this 
+ * comment are quotes from the WHATWG HTML 5 spec as of 27 June 2007 
+ * amended as of June 28 2007.
+ * That document came with this statement:
+ * " Copyright 2004-2007 Apple Computer, Inc., Mozilla Foundation, and 
+ * Opera Software ASA. You are granted a license to use, reproduce and 
+ * create derivative works of this document."
+ */
+
+package nu.validator.htmlparser.impl;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+import nu.validator.htmlparser.annotation.IdType;
+import nu.validator.htmlparser.annotation.Inline;
+import nu.validator.htmlparser.annotation.Literal;
+import nu.validator.htmlparser.annotation.Local;
+import nu.validator.htmlparser.annotation.NoLength;
+import nu.validator.htmlparser.annotation.NsUri;
+import nu.validator.htmlparser.common.DoctypeExpectation;
+import nu.validator.htmlparser.common.DocumentMode;
+import nu.validator.htmlparser.common.DocumentModeHandler;
+import nu.validator.htmlparser.common.TokenHandler;
+import nu.validator.htmlparser.common.XmlViolationPolicy;
+
+import org.xml.sax.ErrorHandler;
+import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
+
+public abstract class TreeBuilder<T> implements TokenHandler {
+
+    // Start dispatch groups
+
+    final static int OTHER = 0;
+
+    final static int A = 1;
+
+    final static int BASE = 2;
+
+    final static int BODY = 3;
+
+    final static int BR = 4;
+
+    final static int BUTTON = 5;
+
+    final static int CAPTION = 6;
+
+    final static int COL = 7;
+
+    final static int COLGROUP = 8;
+
+    final static int FORM = 9;
+
+    final static int FRAME = 10;
+
+    final static int FRAMESET = 11;
+
+    final static int IMAGE = 12;
+
+    final static int INPUT = 13;
+
+    final static int ISINDEX = 14;
+
+    final static int LI = 15;
+
+    final static int LINK = 16;
+
+    final static int MATH = 17;
+
+    final static int META = 18;
+
+    final static int SVG = 19;
+
+    final static int HEAD = 20;
+
+    final static int HR = 22;
+
+    final static int HTML = 23;
+
+    final static int NOBR = 24;
+
+    final static int NOFRAMES = 25;
+
+    final static int NOSCRIPT = 26;
+
+    final static int OPTGROUP = 27;
+
+    final static int OPTION = 28;
+
+    final static int P = 29;
+
+    final static int PLAINTEXT = 30;
+
+    final static int SCRIPT = 31;
+
+    final static int SELECT = 32;
+
+    final static int STYLE = 33;
+
+    final static int TABLE = 34;
+
+    final static int TEXTAREA = 35;
+
+    final static int TITLE = 36;
+
+    final static int TR = 37;
+
+    final static int XMP = 38;
+
+    final static int TBODY_OR_THEAD_OR_TFOOT = 39;
+
+    final static int TD_OR_TH = 40;
+
+    final static int DD_OR_DT = 41;
+
+    final static int H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6 = 42;
+
+    final static int MARQUEE_OR_APPLET = 43;
+
+    final static int PRE_OR_LISTING = 44;
+
+    final static int B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U = 45;
+
+    final static int UL_OR_OL_OR_DL = 46;
+
+    final static int IFRAME = 47;
+
+    final static int EMBED_OR_IMG = 48;
+
+    final static int AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR = 49;
+
+    final static int DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU = 50;
+
+    final static int ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION = 51;
+
+    final static int RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR = 52;
+
+    final static int RT_OR_RP = 53;
+
+    final static int COMMAND_OR_EVENT_SOURCE = 54;
+
+    final static int PARAM_OR_SOURCE = 55;
+
+    final static int MGLYPH_OR_MALIGNMARK = 56;
+
+    final static int MI_MO_MN_MS_MTEXT = 57;
+
+    final static int ANNOTATION_XML = 58;
+
+    final static int FOREIGNOBJECT_OR_DESC = 59;
+
+    final static int NOEMBED = 60;
+
+    final static int FIELDSET = 61;
+
+    final static int OUTPUT_OR_LABEL = 62;
+
+    final static int OBJECT = 63;
+
+    final static int FONT = 64;
+
+    final static int KEYGEN = 65;
+    
+    // start insertion modes
+
+    private static final int INITIAL = 0;
+
+    private static final int BEFORE_HTML = 1;
+
+    private static final int BEFORE_HEAD = 2;
+
+    private static final int IN_HEAD = 3;
+
+    private static final int IN_HEAD_NOSCRIPT = 4;
+
+    private static final int AFTER_HEAD = 5;
+
+    private static final int IN_BODY = 6;
+
+    private static final int IN_TABLE = 7;
+
+    private static final int IN_CAPTION = 8;
+
+    private static final int IN_COLUMN_GROUP = 9;
+
+    private static final int IN_TABLE_BODY = 10;
+
+    private static final int IN_ROW = 11;
+
+    private static final int IN_CELL = 12;
+
+    private static final int IN_SELECT = 13;
+
+    private static final int IN_SELECT_IN_TABLE = 14;
+
+    private static final int AFTER_BODY = 15;
+
+    private static final int IN_FRAMESET = 16;
+
+    private static final int AFTER_FRAMESET = 17;
+
+    private static final int AFTER_AFTER_BODY = 18;
+
+    private static final int AFTER_AFTER_FRAMESET = 19;
+
+    private static final int IN_CDATA_RCDATA = 20;
+
+    private static final int FRAMESET_OK = 21;
+    
+    // start charset states
+
+    private static final int CHARSET_INITIAL = 0;
+
+    private static final int CHARSET_C = 1;
+
+    private static final int CHARSET_H = 2;
+
+    private static final int CHARSET_A = 3;
+
+    private static final int CHARSET_R = 4;
+
+    private static final int CHARSET_S = 5;
+
+    private static final int CHARSET_E = 6;
+
+    private static final int CHARSET_T = 7;
+
+    private static final int CHARSET_EQUALS = 8;
+
+    private static final int CHARSET_SINGLE_QUOTED = 9;
+
+    private static final int CHARSET_DOUBLE_QUOTED = 10;
+
+    private static final int CHARSET_UNQUOTED = 11;
+
+    // end pseudo enums
+
+    private final static char[] ISINDEX_PROMPT = Portability.isIndexPrompt();
+
+    // [NOCPP[
+
+    private final static String[] HTML4_PUBLIC_IDS = {
+            "-//W3C//DTD HTML 4.0 Frameset//EN",
+            "-//W3C//DTD HTML 4.0 Transitional//EN",
+            "-//W3C//DTD HTML 4.0//EN", "-//W3C//DTD HTML 4.01 Frameset//EN",
+            "-//W3C//DTD HTML 4.01 Transitional//EN",
+            "-//W3C//DTD HTML 4.01//EN" };
+
+    // ]NOCPP]
+
+    @Literal private final static String[] QUIRKY_PUBLIC_IDS = {
+            "+//silmaril//dtd html pro v0r11 19970101//",
+            "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
+            "-//as//dtd html 3.0 aswedit + extensions//",
+            "-//ietf//dtd html 2.0 level 1//",
+            "-//ietf//dtd html 2.0 level 2//",
+            "-//ietf//dtd html 2.0 strict level 1//",
+            "-//ietf//dtd html 2.0 strict level 2//",
+            "-//ietf//dtd html 2.0 strict//",
+            "-//ietf//dtd html 2.0//",
+            "-//ietf//dtd html 2.1e//",
+            "-//ietf//dtd html 3.0//",
+            "-//ietf//dtd html 3.2 final//",
+            "-//ietf//dtd html 3.2//",
+            "-//ietf//dtd html 3//",
+            "-//ietf//dtd html level 0//",
+            "-//ietf//dtd html level 1//",
+            "-//ietf//dtd html level 2//",
+            "-//ietf//dtd html level 3//",
+            "-//ietf//dtd html strict level 0//",
+            "-//ietf//dtd html strict level 1//",
+            "-//ietf//dtd html strict level 2//",
+            "-//ietf//dtd html strict level 3//",
+            "-//ietf//dtd html strict//",
+            "-//ietf//dtd html//",
+            "-//metrius//dtd metrius presentational//",
+            "-//microsoft//dtd internet explorer 2.0 html strict//",
+            "-//microsoft//dtd internet explorer 2.0 html//",
+            "-//microsoft//dtd internet explorer 2.0 tables//",
+            "-//microsoft//dtd internet explorer 3.0 html strict//",
+            "-//microsoft//dtd internet explorer 3.0 html//",
+            "-//microsoft//dtd internet explorer 3.0 tables//",
+            "-//netscape comm. corp.//dtd html//",
+            "-//netscape comm. corp.//dtd strict html//",
+            "-//o'reilly and associates//dtd html 2.0//",
+            "-//o'reilly and associates//dtd html extended 1.0//",
+            "-//o'reilly and associates//dtd html extended relaxed 1.0//",
+            "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
+            "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
+            "-//spyglass//dtd html 2.0 extended//",
+            "-//sq//dtd html 2.0 hotmetal + extensions//",
+            "-//sun microsystems corp.//dtd hotjava html//",
+            "-//sun microsystems corp.//dtd hotjava strict html//",
+            "-//w3c//dtd html 3 1995-03-24//", "-//w3c//dtd html 3.2 draft//",
+            "-//w3c//dtd html 3.2 final//", "-//w3c//dtd html 3.2//",
+            "-//w3c//dtd html 3.2s draft//", "-//w3c//dtd html 4.0 frameset//",
+            "-//w3c//dtd html 4.0 transitional//",
+            "-//w3c//dtd html experimental 19960712//",
+            "-//w3c//dtd html experimental 970421//", "-//w3c//dtd w3 html//",
+            "-//w3o//dtd w3 html 3.0//", "-//webtechs//dtd mozilla html 2.0//",
+            "-//webtechs//dtd mozilla html//" };
+
+    private static final int NOT_FOUND_ON_STACK = Integer.MAX_VALUE;
+
+    private static final int IN_FOREIGN = 0;
+
+    private static final int NOT_IN_FOREIGN = 1;
+
+    // [NOCPP[
+    
+    private static final @Local String HTML_LOCAL = "html";
+    
+    // ]NOCPP]
+    
+    private int mode = INITIAL;
+
+    private int originalMode = INITIAL;
+
+    private int foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+
+    protected Tokenizer tokenizer;
+
+    // [NOCPP[
+
+    protected ErrorHandler errorHandler;
+
+    // ]NOCPP]
+
+    private DocumentModeHandler documentModeHandler;
+
+    // [NOCPP[
+
+    private DoctypeExpectation doctypeExpectation = DoctypeExpectation.HTML;
+
+    // ]NOCPP]
+
+    private boolean scriptingEnabled = false;
+
+    private boolean needToDropLF;
+
+    // [NOCPP[
+
+    private boolean wantingComments;
+
+    // ]NOCPP]
+
+    private boolean fragment;
+
+    private @Local String contextName;
+
+    private @NsUri String contextNamespace;
+
+    private T contextNode;
+    
+    private StackNode<T>[] stack;
+
+    private int currentPtr = -1;
+
+    private StackNode<T>[] listOfActiveFormattingElements;
+
+    private int listPtr = -1;
+
+    private T formPointer;
+
+    private T headPointer;
+    
+    protected char[] charBuffer;
+
+    protected int charBufferLen = 0;
+    
+    private boolean quirks = false;
+
+    // [NOCPP[
+
+    private boolean reportingDoctype = true;
+
+    private XmlViolationPolicy namePolicy = XmlViolationPolicy.ALTER_INFOSET;
+
+    private final Map<String, LocatorImpl> idLocations = new HashMap<String, LocatorImpl>();
+
+    private boolean html4;
+
+    // ]NOCPP]
+
+    protected TreeBuilder() {
+        fragment = false;
+    }
+
+    /**
+     * Reports an condition that would make the infoset incompatible with XML
+     * 1.0 as fatal.
+     * 
+     * @throws SAXException
+     * @throws SAXParseException
+     */
+    protected void fatal() throws SAXException {
+    }
+
+    // [NOCPP[
+
+    protected final void fatal(Exception e) throws SAXException {
+        SAXParseException spe = new SAXParseException(e.getMessage(),
+                tokenizer, e);
+        if (errorHandler != null) {
+            errorHandler.fatalError(spe);
+        }
+        throw spe;
+    }
+
+    final void fatal(String s) throws SAXException {
+        SAXParseException spe = new SAXParseException(s, tokenizer);
+        if (errorHandler != null) {
+            errorHandler.fatalError(spe);
+        }
+        throw spe;
+    }
+
+    // ]NOCPP]
+
+    /**
+     * Reports a Parse Error.
+     * 
+     * @param message
+     *            the message
+     * @throws SAXException
+     */
+    final void err(String message) throws SAXException {
+        // [NOCPP[
+        if (errorHandler == null) {
+            return;
+        }
+        SAXParseException spe = new SAXParseException(message, tokenizer);
+        errorHandler.error(spe);
+        // ]NOCPP]
+    }
+
+    /**
+     * Reports a warning
+     * 
+     * @param message
+     *            the message
+     * @throws SAXException
+     */
+    final void warn(String message) throws SAXException {
+        // [NOCPP[
+        if (errorHandler == null) {
+            return;
+        }
+        SAXParseException spe = new SAXParseException(message, tokenizer);
+        errorHandler.warning(spe);
+        // ]NOCPP]
+    }
+
+    public final void startTokenization(Tokenizer self) throws SAXException {
+        tokenizer = self;
+        stack = new StackNode[64];
+        listOfActiveFormattingElements = new StackNode[64];
+        needToDropLF = false;
+        originalMode = INITIAL;
+        currentPtr = -1;
+        listPtr = -1;
+        Portability.releaseElement(formPointer);
+        formPointer = null;
+        Portability.releaseElement(headPointer);
+        headPointer = null;
+        // [NOCPP[
+        html4 = false;
+        idLocations.clear();
+        wantingComments = wantsComments();
+        // ]NOCPP]
+        start(fragment);
+        charBufferLen = 0;
+        charBuffer = new char[1024];
+        if (fragment) {
+            T elt;
+            if (contextNode != null) {
+                elt = contextNode;
+                Portability.retainElement(elt);
+            } else {
+                elt = createHtmlElementSetAsRoot(tokenizer.emptyAttributes());
+            }
+            StackNode<T> node = new StackNode<T>(
+                    "http://www.w3.org/1999/xhtml", ElementName.HTML, elt);
+            currentPtr++;
+            stack[currentPtr] = node;
+            resetTheInsertionMode();
+            if ("title" == contextName || "textarea" == contextName) {
+                tokenizer.setContentModelFlag(Tokenizer.RCDATA, contextName);
+            } else if ("style" == contextName || "script" == contextName
+                    || "xmp" == contextName || "iframe" == contextName
+                    || "noembed" == contextName || "noframes" == contextName
+                    || (scriptingEnabled && "noscript" == contextName)) {
+                tokenizer.setContentModelFlag(Tokenizer.CDATA, contextName);
+            } else if ("plaintext" == contextName) {
+                tokenizer.setContentModelFlag(Tokenizer.PLAINTEXT, contextName);
+            } else {
+                tokenizer.setContentModelFlag(Tokenizer.DATA, contextName);
+            }
+            Portability.releaseLocal(contextName);
+            contextName = null;
+            Portability.releaseElement(contextNode);
+            contextNode = null;
+            Portability.releaseElement(elt);
+        } else {
+            mode = INITIAL;
+            foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+        }
+    }
+
+    public final void doctype(@Local String name, String publicIdentifier,
+            String systemIdentifier, boolean forceQuirks) throws SAXException {
+        needToDropLF = false;
+        doctypeloop: for (;;) {
+            switch (foreignFlag) {
+                case IN_FOREIGN:
+                    break doctypeloop;
+                default:
+                    switch (mode) {
+                        case INITIAL:
+                            // [NOCPP[
+                            if (reportingDoctype) {
+                                // ]NOCPP]
+                                String emptyString = Portability.newEmptyString();
+                                appendDoctypeToDocument(name == null ? ""
+                                        : name,
+                                        publicIdentifier == null ? emptyString
+                                                : publicIdentifier,
+                                        systemIdentifier == null ? emptyString
+                                                : systemIdentifier);
+                                Portability.releaseString(emptyString);
+                                // [NOCPP[
+                            }
+                            switch (doctypeExpectation) {
+                                case HTML:
+                                    // ]NOCPP]
+                                    if (isQuirky(name, publicIdentifier,
+                                            systemIdentifier, forceQuirks)) {
+                                        err("Quirky doctype. Expected \u201C<!DOCTYPE html>\u201D.");
+                                        documentModeInternal(
+                                                DocumentMode.QUIRKS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, false);
+                                    } else if (isAlmostStandards(
+                                            publicIdentifier, systemIdentifier)) {
+                                        err("Almost standards mode doctype. Expected \u201C<!DOCTYPE html>\u201D.");
+                                        documentModeInternal(
+                                                DocumentMode.ALMOST_STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, false);
+                                    } else {
+                                        // [NOCPP[
+                                        if (!((systemIdentifier == null || Portability.literalEqualsString(
+                                                "about:legacy-compat",
+                                                systemIdentifier)) && publicIdentifier == null)) {
+                                            err("Legacy doctype. Expected \u201C<!DOCTYPE html>\u201D.");
+                                        }
+                                        // ]NOCPP]
+                                        documentModeInternal(
+                                                DocumentMode.STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, false);
+                                    }
+                                    // [NOCPP[
+                                    break;
+                                case HTML401_STRICT:
+                                    html4 = true;
+                                    tokenizer.turnOnAdditionalHtml4Errors();
+                                    if (isQuirky(name, publicIdentifier,
+                                            systemIdentifier, forceQuirks)) {
+                                        err("Quirky doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                                        documentModeInternal(
+                                                DocumentMode.QUIRKS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, true);
+                                    } else if (isAlmostStandards(
+                                            publicIdentifier, systemIdentifier)) {
+                                        err("Almost standards mode doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                                        documentModeInternal(
+                                                DocumentMode.ALMOST_STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, true);
+                                    } else {
+                                        if ("-//W3C//DTD HTML 4.01//EN".equals(publicIdentifier)) {
+                                            if (!"http://www.w3.org/TR/html4/strict.dtd".equals(systemIdentifier)) {
+                                                warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                                            }
+                                        } else {
+                                            err("The doctype was not the HTML 4.01 Strict doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                                        }
+                                        documentModeInternal(
+                                                DocumentMode.STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, true);
+                                    }
+                                    break;
+                                case HTML401_TRANSITIONAL:
+                                    html4 = true;
+                                    tokenizer.turnOnAdditionalHtml4Errors();
+                                    if (isQuirky(name, publicIdentifier,
+                                            systemIdentifier, forceQuirks)) {
+                                        err("Quirky doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                                        documentModeInternal(
+                                                DocumentMode.QUIRKS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, true);
+                                    } else if (isAlmostStandards(
+                                            publicIdentifier, systemIdentifier)) {
+                                        if ("-//W3C//DTD HTML 4.01 Transitional//EN".equals(publicIdentifier)
+                                                && systemIdentifier != null) {
+                                            if (!"http://www.w3.org/TR/html4/loose.dtd".equals(systemIdentifier)) {
+                                                warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                                            }
+                                        } else {
+                                            err("The doctype was not a non-quirky HTML 4.01 Transitional doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                                        }
+                                        documentModeInternal(
+                                                DocumentMode.ALMOST_STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, true);
+                                    } else {
+                                        err("The doctype was not the HTML 4.01 Transitional doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                                        documentModeInternal(
+                                                DocumentMode.STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, true);
+                                    }
+                                    break;
+                                case AUTO:
+                                    html4 = isHtml4Doctype(publicIdentifier);
+                                    if (html4) {
+                                        tokenizer.turnOnAdditionalHtml4Errors();
+                                    }
+                                    if (isQuirky(name, publicIdentifier,
+                                            systemIdentifier, forceQuirks)) {
+                                        err("Quirky doctype. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
+                                        documentModeInternal(
+                                                DocumentMode.QUIRKS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, html4);
+                                    } else if (isAlmostStandards(
+                                            publicIdentifier, systemIdentifier)) {
+                                        if ("-//W3C//DTD HTML 4.01 Transitional//EN".equals(publicIdentifier)) {
+                                            if (!"http://www.w3.org/TR/html4/loose.dtd".equals(systemIdentifier)) {
+                                                warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                                            }
+                                        } else {
+                                            err("Almost standards mode doctype. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
+                                        }
+                                        documentModeInternal(
+                                                DocumentMode.ALMOST_STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, html4);
+                                    } else {
+                                        if ("-//W3C//DTD HTML 4.01//EN".equals(publicIdentifier)) {
+                                            if (!"http://www.w3.org/TR/html4/strict.dtd".equals(systemIdentifier)) {
+                                                warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                                            }
+                                        } else {
+                                            if (!(publicIdentifier == null && systemIdentifier == null)) {
+                                                err("Legacy doctype. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
+                                            }
+                                        }
+                                        documentModeInternal(
+                                                DocumentMode.STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, html4);
+                                    }
+                                    break;
+                                case NO_DOCTYPE_ERRORS:
+                                    if (isQuirky(name, publicIdentifier,
+                                            systemIdentifier, forceQuirks)) {
+                                        documentModeInternal(
+                                                DocumentMode.QUIRKS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, false);
+                                    } else if (isAlmostStandards(
+                                            publicIdentifier, systemIdentifier)) {
+                                        documentModeInternal(
+                                                DocumentMode.ALMOST_STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, false);
+                                    } else {
+                                        documentModeInternal(
+                                                DocumentMode.STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, false);
+                                    }
+                                    break;
+                            }
+                            // ]NOCPP]
+
+                            /*
+                             * 
+                             * Then, switch to the root element mode of the tree
+                             * construction stage.
+                             */
+                            mode = BEFORE_HTML;
+                            return;
+                        default:
+                            break doctypeloop;
+                    }
+            }
+
+        }
+        /*
+         * A DOCTYPE token Parse error.
+         */
+        err("Stray doctype.");
+        /*
+         * Ignore the token.
+         */
+        return;
+    }
+
+    // [NOCPP[
+
+    private boolean isHtml4Doctype(String publicIdentifier) {
+        if (publicIdentifier != null
+                && (Arrays.binarySearch(TreeBuilder.HTML4_PUBLIC_IDS,
+                        publicIdentifier) > -1)) {
+            return true;
+        }
+        return false;
+    }
+
+    // ]NOCPP]
+
+    public final void comment(@NoLength char[] buf, int start, int length)
+            throws SAXException {
+        needToDropLF = false;
+        // [NOCPP[
+        if (!wantingComments) {
+            return;
+        }
+        // ]NOCPP]
+        commentloop: for (;;) {
+            switch (foreignFlag) {
+                case IN_FOREIGN:
+                    break commentloop;
+                default:
+                    switch (mode) {
+                        case INITIAL:
+                        case BEFORE_HTML:
+                        case AFTER_AFTER_BODY:
+                        case AFTER_AFTER_FRAMESET:
+                            /*
+                             * A comment token Append a Comment node to the
+                             * Document object with the data attribute set to
+                             * the data given in the comment token.
+                             */
+                            appendCommentToDocument(buf, start, length);
+                            return;
+                        case AFTER_BODY:
+                            /*
+                             * A comment token Append a Comment node to the
+                             * first element in the stack of open elements (the
+                             * html element), with the data attribute set to the
+                             * data given in the comment token.
+                             */
+                            flushCharacters();
+                            appendComment(stack[0].node, buf, start, length);
+                            return;
+                        default:
+                            break commentloop;
+                    }
+            }
+        }
+        /*
+         * A comment token Append a Comment node to the current node with the
+         * data attribute set to the data given in the comment token.
+         */
+        flushCharacters();
+        appendComment(stack[currentPtr].node, buf, start, length);
+        return;
+    }
+
+    /**
+     * @see nu.validator.htmlparser.common.TokenHandler#characters(char[], int,
+     *      int)
+     */
+    public final void characters(@NoLength char[] buf, int start, int length)
+            throws SAXException {
+        if (needToDropLF) {
+            if (buf[start] == '\n') {
+                start++;
+                length--;
+                if (length == 0) {
+                    return;
+                }
+            }
+            needToDropLF = false;
+        }
+
+        // optimize the most common case
+        // XXX should there be an IN FOREIGN check here?
+        switch (mode) {
+            case IN_BODY:
+            case IN_CELL:
+            case IN_CAPTION:
+                reconstructTheActiveFormattingElements();
+                // fall through
+            case IN_CDATA_RCDATA:
+                accumulateCharacters(buf, start, length);
+                return;
+            default:
+                int end = start + length;
+                charactersloop: for (int i = start; i < end; i++) {
+                    switch (buf[i]) {
+                        case ' ':
+                        case '\t':
+                        case '\n':
+                        case '\u000C':
+                            /*
+                             * A character token that is one of one of U+0009
+                             * CHARACTER TABULATION, U+000A LINE FEED (LF),
+                             * U+000C FORM FEED (FF), or U+0020 SPACE
+                             */
+                            switch (mode) {
+                                case INITIAL:
+                                case BEFORE_HTML:
+                                case BEFORE_HEAD:
+                                    /*
+                                     * Ignore the token.
+                                     */
+                                    start = i + 1;
+                                    continue;
+                                case FRAMESET_OK:
+                                case IN_HEAD:
+                                case IN_HEAD_NOSCRIPT:
+                                case AFTER_HEAD:
+                                case IN_COLUMN_GROUP:
+                                case IN_FRAMESET:
+                                case AFTER_FRAMESET:
+                                    /*
+                                     * Append the character to the current node.
+                                     */
+                                    continue;
+                                case IN_BODY:
+                                case IN_CELL:
+                                case IN_CAPTION:
+                                    // XXX is this dead code?
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+
+                                    /*
+                                     * Reconstruct the active formatting
+                                     * elements, if any.
+                                     */
+                                    reconstructTheActiveFormattingElements();
+                                    /*
+                                     * Append the token's character to the
+                                     * current node.
+                                     */
+                                    break charactersloop;
+                                case IN_SELECT:
+                                case IN_SELECT_IN_TABLE:
+                                    break charactersloop;
+                                case IN_TABLE:
+                                case IN_TABLE_BODY:
+                                case IN_ROW:
+                                    reconstructTheActiveFormattingElements();
+                                    accumulateCharacter(buf[i]);
+                                    start = i + 1;
+                                    continue;
+                                case AFTER_BODY:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Reconstruct the active formatting
+                                     * elements, if any.
+                                     */
+                                    reconstructTheActiveFormattingElements();
+                                    /*
+                                     * Append the token's character to the
+                                     * current node.
+                                     */
+                                    continue;
+                                case AFTER_AFTER_BODY:
+                                case AFTER_AFTER_FRAMESET:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Reconstruct the active formatting
+                                     * elements, if any.
+                                     */
+                                    reconstructTheActiveFormattingElements();
+                                    /*
+                                     * Append the token's character to the
+                                     * current node.
+                                     */
+                                    continue;
+                            }
+                        default:
+                            /*
+                             * A character token that is not one of one of
+                             * U+0009 CHARACTER TABULATION, U+000A LINE FEED
+                             * (LF), U+000C FORM FEED (FF), or U+0020 SPACE
+                             */
+                            switch (mode) {
+                                case INITIAL:
+                                    /*
+                                     * Parse error.
+                                     */
+                                    // [NOCPP[
+                                    switch (doctypeExpectation) {
+                                        case AUTO:
+                                            err("Non-space characters found without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
+                                            break;
+                                        case HTML:
+                                            err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D.");
+                                            break;
+                                        case HTML401_STRICT:
+                                            err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                                            break;
+                                        case HTML401_TRANSITIONAL:
+                                            err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                                            break;
+                                        case NO_DOCTYPE_ERRORS:
+                                    }
+                                    // ]NOCPP]
+                                    /*
+                                     * 
+                                     * Set the document to quirks mode.
+                                     */
+                                    documentModeInternal(
+                                            DocumentMode.QUIRKS_MODE, null,
+                                            null, false);
+                                    /*
+                                     * Then, switch to the root element mode of
+                                     * the tree construction stage
+                                     */
+                                    mode = BEFORE_HTML;
+                                    /*
+                                     * and reprocess the current token.
+                                     */
+                                    i--;
+                                    continue;
+                                case BEFORE_HTML:
+                                    /*
+                                     * Create an HTMLElement node with the tag
+                                     * name html, in the HTML namespace. Append
+                                     * it to the Document object.
+                                     */
+                                    appendHtmlElementToDocumentAndPush();
+                                    /* Switch to the main mode */
+                                    mode = BEFORE_HEAD;
+                                    /*
+                                     * reprocess the current token.
+                                     */
+                                    i--;
+                                    continue;
+                                case BEFORE_HEAD:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * /Act as if a start tag token with the tag
+                                     * name "head" and no attributes had been
+                                     * seen,
+                                     */
+                                    appendToCurrentNodeAndPushHeadElement(HtmlAttributes.EMPTY_ATTRIBUTES);
+                                    mode = IN_HEAD;
+                                    /*
+                                     * then reprocess the current token.
+                                     * 
+                                     * This will result in an empty head element
+                                     * being generated, with the current token
+                                     * being reprocessed in the "after head"
+                                     * insertion mode.
+                                     */
+                                    i--;
+                                    continue;
+                                case IN_HEAD:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Act as if an end tag token with the tag
+                                     * name "head" had been seen,
+                                     */
+                                    pop();
+                                    mode = AFTER_HEAD;
+                                    /*
+                                     * and reprocess the current token.
+                                     */
+                                    i--;
+                                    continue;
+                                case IN_HEAD_NOSCRIPT:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Parse error. Act as if an end tag with
+                                     * the tag name "noscript" had been seen
+                                     */
+                                    err("Non-space character inside \u201Cnoscript\u201D inside \u201Chead\u201D.");
+                                    pop();
+                                    mode = IN_HEAD;
+                                    /*
+                                     * and reprocess the current token.
+                                     */
+                                    i--;
+                                    continue;
+                                case AFTER_HEAD:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Act as if a start tag token with the tag
+                                     * name "body" and no attributes had been
+                                     * seen,
+                                     */
+                                    appendToCurrentNodeAndPushBodyElement();
+                                    mode = FRAMESET_OK;
+                                    /*
+                                     * and then reprocess the current token.
+                                     */
+                                    i--;
+                                    continue;
+                                case FRAMESET_OK:
+                                    mode = IN_BODY;
+                                    i--;
+                                    continue;
+                                case IN_BODY:
+                                case IN_CELL:
+                                case IN_CAPTION:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Reconstruct the active formatting
+                                     * elements, if any.
+                                     */
+                                    reconstructTheActiveFormattingElements();
+                                    /*
+                                     * Append the token's character to the
+                                     * current node.
+                                     */
+                                    break charactersloop;
+                                case IN_TABLE:
+                                case IN_TABLE_BODY:
+                                case IN_ROW:
+                                    reconstructTheActiveFormattingElements();
+                                    accumulateCharacter(buf[i]);
+                                    start = i + 1;
+                                    continue;
+                                case IN_COLUMN_GROUP:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Act as if an end tag with the tag name
+                                     * "colgroup" had been seen, and then, if
+                                     * that token wasn't ignored, reprocess the
+                                     * current token.
+                                     */
+                                    if (currentPtr == 0) {
+                                        err("Non-space in \u201Ccolgroup\u201D when parsing fragment.");
+                                        start = i + 1;
+                                        continue;
+                                    }
+                                    pop();
+                                    mode = IN_TABLE;
+                                    i--;
+                                    continue;
+                                case IN_SELECT:
+                                case IN_SELECT_IN_TABLE:
+                                    break charactersloop;
+                                case AFTER_BODY:
+                                    err("Non-space character after body.");
+                                    fatal();
+                                    mode = IN_BODY;
+                                    i--;
+                                    continue;
+                                case IN_FRAMESET:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Parse error.
+                                     */
+                                    err("Non-space in \u201Cframeset\u201D.");
+                                    /*
+                                     * Ignore the token.
+                                     */
+                                    start = i + 1;
+                                    continue;
+                                case AFTER_FRAMESET:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Parse error.
+                                     */
+                                    err("Non-space after \u201Cframeset\u201D.");
+                                    /*
+                                     * Ignore the token.
+                                     */
+                                    start = i + 1;
+                                    continue;
+                                case AFTER_AFTER_BODY:
+                                    /*
+                                     * Parse error.
+                                     */
+                                    err("Non-space character in page trailer.");
+                                    /*
+                                     * Switch back to the main mode and
+                                     * reprocess the token.
+                                     */
+                                    mode = IN_BODY;
+                                    i--;
+                                    continue;
+                                case AFTER_AFTER_FRAMESET:
+                                    /*
+                                     * Parse error.
+                                     */
+                                    err("Non-space character in page trailer.");
+                                    /*
+                                     * Switch back to the main mode and
+                                     * reprocess the token.
+                                     */
+                                    mode = IN_FRAMESET;
+                                    i--;
+                                    continue;
+                            }
+                    }
+                }
+                if (start < end) {
+                    accumulateCharacters(buf, start, end - start);
+                }
+        }
+    }
+
+    public final void eof() throws SAXException {
+        flushCharacters();
+        switch (foreignFlag) {
+            case IN_FOREIGN:
+                err("End of file in a foreign namespace context.");
+                while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
+                    popOnEof();
+                }
+                foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+            default:
+                // fall through
+        }
+        eofloop: for (;;) {
+            switch (mode) {
+                case INITIAL:
+                    /*
+                     * Parse error.
+                     */
+                    // [NOCPP[
+                    switch (doctypeExpectation) {
+                        case AUTO:
+                            err("End of file seen without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
+                            break;
+                        case HTML:
+                            err("End of file seen without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D.");
+                            break;
+                        case HTML401_STRICT:
+                            err("End of file seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                            break;
+                        case HTML401_TRANSITIONAL:
+                            err("End of file seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                            break;
+                        case NO_DOCTYPE_ERRORS:
+                    }
+                    // ]NOCPP]
+                    /*
+                     * 
+                     * Set the document to quirks mode.
+                     */
+                    documentModeInternal(DocumentMode.QUIRKS_MODE, null, null,
+                            false);
+                    /*
+                     * Then, switch to the root element mode of the tree
+                     * construction stage
+                     */
+                    mode = BEFORE_HTML;
+                    /*
+                     * and reprocess the current token.
+                     */
+                    continue;
+                case BEFORE_HTML:
+                    /*
+                     * Create an HTMLElement node with the tag name html, in the
+                     * HTML namespace. Append it to the Document object.
+                     */
+                    appendHtmlElementToDocumentAndPush();
+                    // XXX application cache manifest
+                    /* Switch to the main mode */
+                    mode = BEFORE_HEAD;
+                    /*
+                     * reprocess the current token.
+                     */
+                    continue;
+                case BEFORE_HEAD:
+                    appendToCurrentNodeAndPushHeadElement(HtmlAttributes.EMPTY_ATTRIBUTES);
+                    mode = IN_HEAD;
+                    continue;
+                case IN_HEAD:
+                    if (currentPtr > 1) {
+                        err("End of file seen and there were open elements.");
+                    }
+                    while (currentPtr > 0) {
+                        popOnEof();
+                    }
+                    mode = AFTER_HEAD;
+                    continue;
+                case IN_HEAD_NOSCRIPT:
+                    err("End of file seen and there were open elements.");
+                    while (currentPtr > 1) {
+                        popOnEof();
+                    }
+                    mode = IN_HEAD;
+                    continue;
+                case AFTER_HEAD:
+                    appendToCurrentNodeAndPushBodyElement();
+                    mode = IN_BODY;
+                    continue;
+                case IN_COLUMN_GROUP:
+                    if (currentPtr == 0) {
+                        assert fragment;
+                        break eofloop;
+                    } else {
+                        popOnEof();
+                        mode = IN_TABLE;
+                        continue;
+                    }
+                case FRAMESET_OK:
+                case IN_CAPTION:
+                case IN_CELL:
+                case IN_BODY:
+                    // [NOCPP[
+                    openelementloop: for (int i = currentPtr; i >= 0; i--) {
+                        int group = stack[i].group;
+                        switch (group) {
+                            case DD_OR_DT:
+                            case LI:
+                            case P:
+                            case TBODY_OR_THEAD_OR_TFOOT:
+                            case TD_OR_TH:
+                            case BODY:
+                            case HTML:
+                                break;
+                            default:
+                                err("End of file seen and there were open elements.");
+                                break openelementloop;
+                        }
+                    }
+                    // ]NOCPP]
+                    break eofloop;
+                case IN_CDATA_RCDATA:
+                    err("End of file seen inside an [R]CDATA element.");
+                    // XXX mark script as already executed
+                    if (originalMode == AFTER_HEAD) {
+                        popOnEof();
+                    }
+                    popOnEof();
+                    mode = originalMode;
+                    continue;
+                case IN_TABLE_BODY:
+                case IN_ROW:
+                case IN_TABLE:
+                case IN_SELECT:
+                case IN_SELECT_IN_TABLE:
+                case IN_FRAMESET:
+                    if (currentPtr > 0) {
+                        err("End of file seen and there were open elements.");
+                    }
+                    break eofloop;
+                case AFTER_BODY:
+                case AFTER_FRAMESET:
+                case AFTER_AFTER_BODY:
+                case AFTER_AFTER_FRAMESET:
+                default:
+                    // [NOCPP[
+                    if (currentPtr == 0) { // This silliness is here to poison
+                        // buggy compiler optimizations in
+                        // GWT
+                        System.currentTimeMillis();
+                    }
+                    // ]NOCPP]
+                    break eofloop;
+            }
+        }
+        while (currentPtr > 0) {
+            popOnEof();
+        }
+        if (!fragment) {
+            popOnEof();
+        }
+        /* Stop parsing. */
+    }
+
+    /**
+     * @see nu.validator.htmlparser.common.TokenHandler#endTokenization()
+     */
+    public final void endTokenization() throws SAXException {
+        Portability.releaseElement(formPointer);
+        formPointer = null;
+        Portability.releaseElement(headPointer);
+        headPointer = null;
+        while (currentPtr > -1) {
+            stack[currentPtr].release();
+            currentPtr--;
+        }
+        Portability.releaseArray(stack);
+        stack = null;
+        while (listPtr > -1) {
+            if (listOfActiveFormattingElements[listPtr] != null) {
+                listOfActiveFormattingElements[listPtr].release();
+            }
+            listPtr--;
+        }
+        Portability.releaseArray(listOfActiveFormattingElements);        
+        listOfActiveFormattingElements = null;
+        // [NOCPP[
+        idLocations.clear();
+        // ]NOCPP]
+        Portability.releaseArray(charBuffer);
+        charBuffer = null;
+        end();
+    }
+
+    public final void startTag(ElementName elementName,
+            HtmlAttributes attributes, boolean selfClosing) throws SAXException {
+        // [NOCPP[
+        if (errorHandler != null) {
+            // ID uniqueness
+            @IdType String id = attributes.getId();
+            if (id != null) {
+                LocatorImpl oldLoc = idLocations.get(id);
+                if (oldLoc != null) {
+                    err("Duplicate ID \u201C" + id + "\u201D.");
+                    errorHandler.warning(new SAXParseException(
+                            "The first occurrence of ID \u201C" + id
+                                    + "\u201D was here.", oldLoc));
+                } else {
+                    idLocations.put(id, new LocatorImpl(tokenizer));
+                }
+            }
+        }
+        // ]NOCPP]
+
+        int eltPos;
+        needToDropLF = false;
+        boolean needsPostProcessing = false;
+        starttagloop: for (;;) {
+            int group = elementName.group;
+            @Local String name = elementName.name;
+            switch (foreignFlag) {
+                case IN_FOREIGN:
+                    StackNode<T> currentNode = stack[currentPtr];
+                    @NsUri String currNs = currentNode.ns;
+                    int currGroup = currentNode.group;
+                    if (("http://www.w3.org/1999/xhtml" == currNs)
+                            || ("http://www.w3.org/1998/Math/MathML" == currNs && ((MGLYPH_OR_MALIGNMARK != group && MI_MO_MN_MS_MTEXT == currGroup) || (SVG == group && ANNOTATION_XML == currGroup)))
+                            || ("http://www.w3.org/2000/svg" == currNs && (TITLE == currGroup || (FOREIGNOBJECT_OR_DESC == currGroup)))) {
+                        needsPostProcessing = true;
+                        // fall through to non-foreign behavior
+                    } else {
+                        switch (group) {
+                            case B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U:
+                            case DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU:
+                            case BODY:
+                            case BR:
+                            case RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR:
+                            case DD_OR_DT:
+                            case UL_OR_OL_OR_DL:
+                            case EMBED_OR_IMG:
+                            case H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6:
+                            case HEAD:
+                            case HR:
+                            case LI:
+                            case META:
+                            case NOBR:
+                            case P:
+                            case PRE_OR_LISTING:
+                            case TABLE:
+                                err("HTML start tag \u201C"
+                                        + name
+                                        + "\u201D in a foreign namespace context.");
+                                while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
+                                    pop();
+                                }
+                                foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+                                continue starttagloop;
+                            case FONT:
+                                if (attributes.contains(AttributeName.COLOR) || attributes.contains(AttributeName.FACE) || attributes.contains(AttributeName.SIZE)) {
+                                    err("HTML start tag \u201C"
+                                            + name
+                                            + "\u201D in a foreign namespace context.");
+                                    while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
+                                        pop();
+                                    }
+                                    foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+                                    continue starttagloop;                                    
+                                }
+                                // else fall thru
+                            default:
+                                if ("http://www.w3.org/2000/svg" == currNs) {
+                                    attributes.adjustForSvg();
+                                    if (selfClosing) {
+                                        appendVoidElementToCurrentMayFosterCamelCase(
+                                                currNs, elementName, attributes);
+                                        selfClosing = false;
+                                    } else {
+                                        appendToCurrentNodeAndPushElementMayFosterCamelCase(
+                                                currNs, elementName, attributes);
+                                    }
+                                    break starttagloop;
+                                } else {
+                                    attributes.adjustForMath();
+                                    if (selfClosing) {
+                                        appendVoidElementToCurrentMayFoster(
+                                                currNs, elementName, attributes);
+                                        selfClosing = false;
+                                    } else {
+                                        appendToCurrentNodeAndPushElementMayFosterNoScoping(
+                                                currNs, elementName, attributes);
+                                    }
+                                    break starttagloop;
+                                }
+                        }
+                    }
+                default:
+                    switch (mode) {
+                        case IN_TABLE_BODY:
+                            switch (group) {
+                                case TR:
+                                    clearStackBackTo(findLastInTableScopeOrRootTbodyTheadTfoot());
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    mode = IN_ROW;
+                                    break starttagloop;
+                                case TD_OR_TH:
+                                    err("\u201C" + name
+                                            + "\u201D start tag in table body.");
+                                    clearStackBackTo(findLastInTableScopeOrRootTbodyTheadTfoot());
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            ElementName.TR,
+                                            HtmlAttributes.EMPTY_ATTRIBUTES);
+                                    mode = IN_ROW;
+                                    continue;
+                                case CAPTION:
+                                case COL:
+                                case COLGROUP:
+                                case TBODY_OR_THEAD_OR_TFOOT:
+                                    eltPos = findLastInTableScopeOrRootTbodyTheadTfoot();
+                                    if (eltPos == 0) {
+                                        err("Stray \u201C" + name
+                                                + "\u201D start tag.");
+                                        break starttagloop;
+                                    } else {
+                                        clearStackBackTo(eltPos);
+                                        pop();
+                                        mode = IN_TABLE;
+                                        continue;
+                                    }
+                                default:
+                                    // fall through to IN_TABLE
+                            }
+                        case IN_ROW:
+                            switch (group) {
+                                case TD_OR_TH:
+                                    clearStackBackTo(findLastOrRoot(TreeBuilder.TR));
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    mode = IN_CELL;
+                                    insertMarker();
+                                    break starttagloop;
+                                case CAPTION:
+                                case COL:
+                                case COLGROUP:
+                                case TBODY_OR_THEAD_OR_TFOOT:
+                                case TR:
+                                    eltPos = findLastOrRoot(TreeBuilder.TR);
+                                    if (eltPos == 0) {
+                                        assert fragment;
+                                        err("No table row to close.");
+                                        break starttagloop;
+                                    }
+                                    clearStackBackTo(eltPos);
+                                    pop();
+                                    mode = IN_TABLE_BODY;
+                                    continue;
+                                default:
+                                    // fall through to IN_TABLE
+                            }
+                        case IN_TABLE:
+                            intableloop: for (;;) {
+                                switch (group) {
+                                    case CAPTION:
+                                        clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
+                                        insertMarker();
+                                        appendToCurrentNodeAndPushElement(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        mode = IN_CAPTION;
+                                        break starttagloop;
+                                    case COLGROUP:
+                                        clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
+                                        appendToCurrentNodeAndPushElement(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        mode = IN_COLUMN_GROUP;
+                                        break starttagloop;
+                                    case COL:
+                                        clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
+                                        appendToCurrentNodeAndPushElement(
+                                                "http://www.w3.org/1999/xhtml",
+                                                ElementName.COLGROUP,
+                                                HtmlAttributes.EMPTY_ATTRIBUTES);
+                                        mode = IN_COLUMN_GROUP;
+                                        continue starttagloop;
+                                    case TBODY_OR_THEAD_OR_TFOOT:
+                                        clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
+                                        appendToCurrentNodeAndPushElement(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        mode = IN_TABLE_BODY;
+                                        break starttagloop;
+                                    case TR:
+                                    case TD_OR_TH:
+                                        clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
+                                        appendToCurrentNodeAndPushElement(
+                                                "http://www.w3.org/1999/xhtml",
+                                                ElementName.TBODY,
+                                                HtmlAttributes.EMPTY_ATTRIBUTES);
+                                        mode = IN_TABLE_BODY;
+                                        continue starttagloop;
+                                    case TABLE:
+                                        err("Start tag for \u201Ctable\u201D seen but the previous \u201Ctable\u201D is still open.");
+                                        eltPos = findLastInTableScope(name);
+                                        if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                            assert fragment;
+                                            break starttagloop;
+                                        }
+                                        generateImpliedEndTags();
+                                        // XXX is the next if dead code?
+                                        if (!isCurrent("table")) {
+                                            err("Unclosed elements on stack.");
+                                        }
+                                        while (currentPtr >= eltPos) {
+                                            pop();
+                                        }
+                                        resetTheInsertionMode();
+                                        continue starttagloop;
+                                    case SCRIPT:
+                                    case STYLE:
+                                        // XXX need to manage much more stuff
+                                        // here if
+                                        // supporting
+                                        // document.write()
+                                        appendToCurrentNodeAndPushElement(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        originalMode = mode;
+                                        mode = IN_CDATA_RCDATA;
+                                        tokenizer.setContentModelFlag(
+                                                Tokenizer.CDATA, elementName);
+                                        break starttagloop;
+                                    case INPUT:
+                                        if (!Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                                                        "hidden",
+                                                        attributes.getValue(AttributeName.TYPE))) {
+                                            break intableloop;
+                                        }
+                                        appendVoidElementToCurrent(
+                                                "http://www.w3.org/1999/xhtml",
+                                                name, attributes, formPointer);
+                                        selfClosing = false;
+                                        break starttagloop;
+                                    default:
+                                        err("Start tag \u201C"
+                                                + name
+                                                + "\u201D seen in \u201Ctable\u201D.");
+                                        // fall through to IN_BODY
+                                        break intableloop;
+                                }
+                            }
+                        case IN_CAPTION:
+                            switch (group) {
+                                case CAPTION:
+                                case COL:
+                                case COLGROUP:
+                                case TBODY_OR_THEAD_OR_TFOOT:
+                                case TR:
+                                case TD_OR_TH:
+                                    err("Stray \u201C"
+                                            + name
+                                            + "\u201D start tag in \u201Ccaption\u201D.");
+                                    eltPos = findLastInTableScope("caption");
+                                    if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                        break starttagloop;
+                                    }
+                                    generateImpliedEndTags();
+                                    if (currentPtr != eltPos) {
+                                        err("Unclosed elements on stack.");
+                                    }
+                                    while (currentPtr >= eltPos) {
+                                        pop();
+                                    }
+                                    clearTheListOfActiveFormattingElementsUpToTheLastMarker();
+                                    mode = IN_TABLE;
+                                    continue;
+                                default:
+                                    // fall through to IN_BODY
+                            }
+                        case IN_CELL:
+                            switch (group) {
+                                case CAPTION:
+                                case COL:
+                                case COLGROUP:
+                                case TBODY_OR_THEAD_OR_TFOOT:
+                                case TR:
+                                case TD_OR_TH:
+                                    eltPos = findLastInTableScopeTdTh();
+                                    if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                        err("No cell to close.");
+                                        break starttagloop;
+                                    } else {
+                                        closeTheCell(eltPos);
+                                        continue;
+                                    }
+                                default:
+                                    // fall through to IN_BODY
+                            }
+                        case FRAMESET_OK:
+                            switch (group) {
+                                case FRAMESET:
+                                    if (mode == FRAMESET_OK) {
+                                        if (currentPtr == 0 || stack[1].group != BODY) {
+                                            assert fragment;
+                                            err("Stray \u201Cframeset\u201D start tag.");                                            
+                                            break starttagloop;
+                                        } else {
+                                            err("\u201Cframeset\u201D start tag after \u201Cbody\u201D already open.");
+                                            detachFromParent(stack[1].node);
+                                            while (currentPtr > 0) {
+                                                pop();
+                                            }
+                                            appendToCurrentNodeAndPushElement(
+                                                    "http://www.w3.org/1999/xhtml",
+                                                    elementName, attributes);
+                                            mode = IN_FRAMESET;
+                                            break starttagloop;                                            
+                                        }
+                                    } else {
+                                        err("Stray \u201Cframeset\u201D start tag.");                                            
+                                        break starttagloop;
+                                    }
+                                    // NOT falling through!
+                                case PRE_OR_LISTING:
+                                case LI:
+                                case DD_OR_DT:
+                                case BUTTON:
+                                case MARQUEE_OR_APPLET:
+                                case OBJECT:
+                                case TABLE:
+                                case AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR:
+                                case BR:
+                                case EMBED_OR_IMG:
+                                case INPUT:
+                                case KEYGEN:
+                                case HR:
+                                case TEXTAREA:
+                                case XMP:
+                                case IFRAME:
+                                case SELECT:
+                                    if (mode == FRAMESET_OK) {
+                                        mode = IN_BODY;
+                                    }
+                                    // fall through to IN_BODY 
+                                default:
+                                    // fall through to IN_BODY                                
+                            }
+                        case IN_BODY:
+                            inbodyloop: for (;;) {
+                                switch (group) {
+                                    case HTML:
+                                        err("Stray \u201Chtml\u201D start tag.");
+                                        addAttributesToHtml(attributes);
+                                        break starttagloop;
+                                    case BASE:
+                                    case LINK:
+                                    case META:
+                                    case STYLE:
+                                    case SCRIPT:
+                                    case TITLE:
+                                    case COMMAND_OR_EVENT_SOURCE:
+                                        // Fall through to IN_HEAD
+                                        break inbodyloop;
+                                    case BODY:
+                                        err("\u201Cbody\u201D start tag found but the \u201Cbody\u201D element is already open.");
+                                        addAttributesToBody(attributes);
+                                        break starttagloop;
+                                    case P:
+                                    case DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU:
+                                    case UL_OR_OL_OR_DL:
+                                    case ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION:
+                                        implicitlyCloseP();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6:
+                                        implicitlyCloseP();
+                                        if(stack[currentPtr].group == H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6) {
+                                            err("Heading cannot be a child of another heading.");
+                                            pop();
+                                        }
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case FIELDSET:
+                                        implicitlyCloseP();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes,
+                                                formPointer);
+                                        break starttagloop;
+                                    case PRE_OR_LISTING:
+                                        implicitlyCloseP();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        needToDropLF = true;
+                                        break starttagloop;
+                                    case FORM:
+                                        if (formPointer != null) {
+                                            err("Saw a \u201Cform\u201D start tag, but there was already an active \u201Cform\u201D element. Nested forms are not allowed. Ignoring the tag.");
+                                            break starttagloop;
+                                        } else {
+                                            implicitlyCloseP();
+                                            appendToCurrentNodeAndPushFormElementMayFoster(attributes);
+                                            break starttagloop;
+                                        }
+                                    case LI:
+                                    case DD_OR_DT:
+                                        eltPos = currentPtr;
+                                        for (;;) {
+                                            StackNode<T> node = stack[eltPos]; // weak ref
+                                            if (node.group == group) { // LI or
+                                                // DD_OR_DT
+                                                generateImpliedEndTagsExceptFor(node.name);
+                                                if (eltPos != currentPtr) {
+                                                    err("Unclosed elements inside a list.");
+                                                }
+                                                while (currentPtr >= eltPos) {
+                                                    pop();
+                                                }
+                                                break;
+                                            } else if (node.scoping
+                                                    || (node.special
+                                                            && node.name != "p"
+                                                            && node.name != "address" && node.name != "div")) {
+                                                break;
+                                            }
+                                            eltPos--;
+                                        }
+                                        implicitlyCloseP();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case PLAINTEXT:
+                                        implicitlyCloseP();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        tokenizer.setContentModelFlag(
+                                                Tokenizer.PLAINTEXT,
+                                                elementName);
+                                        break starttagloop;
+                                    case A:
+                                        int activeAPos = findInListOfActiveFormattingElementsContainsBetweenEndAndLastMarker("a");
+                                        if (activeAPos != -1) {
+                                            err("An \u201Ca\u201D start tag seen with already an active \u201Ca\u201D element.");
+                                            StackNode<T> activeA = listOfActiveFormattingElements[activeAPos];
+                                            activeA.retain();
+                                            adoptionAgencyEndTag("a");
+                                            removeFromStack(activeA);
+                                            activeAPos = findInListOfActiveFormattingElements(activeA);
+                                            if (activeAPos != -1) {
+                                                removeFromListOfActiveFormattingElements(activeAPos);
+                                            }
+                                            activeA.release();
+                                        }
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushFormattingElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U:
+                                    case FONT:
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushFormattingElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case NOBR:
+                                        reconstructTheActiveFormattingElements();
+                                        if (TreeBuilder.NOT_FOUND_ON_STACK != findLastInScope("nobr")) {
+                                            err("\u201Cnobr\u201D start tag seen when there was an open \u201Cnobr\u201D element in scope.");
+                                            adoptionAgencyEndTag("nobr");
+                                        }
+                                        appendToCurrentNodeAndPushFormattingElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case BUTTON:
+                                        eltPos = findLastInScope(name);
+                                        if (eltPos != TreeBuilder.NOT_FOUND_ON_STACK) {
+                                            err("\u201Cbutton\u201D start tag seen when there was an open \u201Cbutton\u201D element in scope.");
+                                            generateImpliedEndTags();
+                                            if (!isCurrent("button")) {
+                                                err("There was an open \u201Cbutton\u201D element in scope with unclosed children.");
+                                            }
+                                            while (currentPtr >= eltPos) {
+                                                pop();
+                                            }
+                                            clearTheListOfActiveFormattingElementsUpToTheLastMarker();
+                                            continue starttagloop;
+                                        } else {
+                                            reconstructTheActiveFormattingElements();
+                                            appendToCurrentNodeAndPushElementMayFoster(
+                                                    "http://www.w3.org/1999/xhtml",
+                                                    elementName, attributes,
+                                                    formPointer);
+                                            insertMarker();
+                                            break starttagloop;
+                                        }
+                                    case OBJECT:
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes,
+                                                formPointer);
+                                        insertMarker();
+                                        break starttagloop;
+                                    case MARQUEE_OR_APPLET:
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        insertMarker();
+                                        break starttagloop;
+                                    case XMP:
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        originalMode = mode;
+                                        mode = IN_CDATA_RCDATA;
+                                        tokenizer.setContentModelFlag(
+                                                Tokenizer.CDATA, elementName);
+                                        break starttagloop;
+                                    case TABLE:
+                                        // The only quirk. Blame Hixie and Acid2.
+                                        if (!quirks) {
+                                            implicitlyCloseP();                                            
+                                        }
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        mode = IN_TABLE;
+                                        break starttagloop;
+                                    case BR:
+                                    case EMBED_OR_IMG:
+                                    case AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR:
+                                        reconstructTheActiveFormattingElements();
+                                        // FALL THROUGH to PARAM_OR_SOURCE
+                                    case PARAM_OR_SOURCE:
+                                        appendVoidElementToCurrentMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        selfClosing = false;
+                                        break starttagloop;
+                                    case HR:
+                                        implicitlyCloseP();
+                                        appendVoidElementToCurrentMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        selfClosing = false;
+                                        break starttagloop;
+                                    case IMAGE:
+                                        err("Saw a start tag \u201Cimage\u201D.");
+                                        elementName = ElementName.IMG;
+                                        continue starttagloop;
+                                    case KEYGEN:
+                                    case INPUT:
+                                        reconstructTheActiveFormattingElements();
+                                        appendVoidElementToCurrentMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                name, attributes, formPointer);
+                                        selfClosing = false;
+                                        break starttagloop;
+                                    case ISINDEX:
+                                        err("\u201Cisindex\u201D seen.");
+                                        if (formPointer != null) {
+                                            break starttagloop;
+                                        }
+                                        implicitlyCloseP();
+                                        HtmlAttributes formAttrs = new HtmlAttributes(0);
+                                        int actionIndex = attributes.getIndex(AttributeName.ACTION);
+                                        if (actionIndex > -1) {
+                                            formAttrs.addAttribute(
+                                                    AttributeName.ACTION,
+                                                    attributes.getValue(actionIndex)
+                                                    // [NOCPP[
+                                                    , XmlViolationPolicy.ALLOW
+                                            // ]NOCPP]
+                                            );
+                                        }
+                                        appendToCurrentNodeAndPushFormElementMayFoster(formAttrs);
+                                        appendVoidElementToCurrentMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                ElementName.HR,
+                                                HtmlAttributes.EMPTY_ATTRIBUTES);
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                ElementName.P,
+                                                HtmlAttributes.EMPTY_ATTRIBUTES);
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                ElementName.LABEL,
+                                                HtmlAttributes.EMPTY_ATTRIBUTES);
+                                        int promptIndex = attributes.getIndex(AttributeName.PROMPT);
+                                        if (promptIndex > -1) {
+                                            char[] prompt = Portability.newCharArrayFromString(attributes.getValue(promptIndex));
+                                            appendCharacters(
+                                                    stack[currentPtr].node,
+                                                    prompt, 0, prompt.length);
+                                            Portability.releaseArray(prompt);
+                                        } else {
+                                            // XXX localization
+                                            appendCharacters(
+                                                    stack[currentPtr].node,
+                                                    TreeBuilder.ISINDEX_PROMPT,
+                                                    0,
+                                                    TreeBuilder.ISINDEX_PROMPT.length);
+                                        }
+                                        HtmlAttributes inputAttributes = new HtmlAttributes(0);
+                                        inputAttributes.addAttribute(
+                                                AttributeName.NAME, Portability.newStringFromLiteral("isindex")
+                                                // [NOCPP[
+                                                , XmlViolationPolicy.ALLOW
+                                        // ]NOCPP]
+                                        );
+                                        for (int i = 0; i < attributes.getLength(); i++) {
+                                            AttributeName attributeQName = attributes.getAttributeName(i);
+                                            if (AttributeName.NAME == attributeQName || AttributeName.PROMPT == attributeQName) {
+                                                attributes.releaseValue(i);                                                
+                                            } else if (AttributeName.ACTION != attributeQName) {
+                                                inputAttributes.addAttribute(
+                                                        attributeQName,
+                                                        attributes.getValue(i)
+                                                        // [NOCPP[
+                                                        ,
+                                                        XmlViolationPolicy.ALLOW
+                                                // ]NOCPP]
+
+                                                );
+                                            }
+                                        }
+                                        attributes.clearWithoutReleasingContents();
+                                        appendVoidElementToCurrentMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                "input", inputAttributes,
+                                                formPointer);
+                                        // XXX localization
+                                        pop(); // label
+                                        pop(); // p
+                                        appendVoidElementToCurrentMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                ElementName.HR,
+                                                HtmlAttributes.EMPTY_ATTRIBUTES);
+                                        pop(); // form
+                                        selfClosing = false;
+                                        Portability.delete(formAttrs);
+                                        Portability.delete(inputAttributes);
+                                        break starttagloop;
+                                    case TEXTAREA:
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes,
+                                                formPointer);
+                                        tokenizer.setContentModelFlag(
+                                                Tokenizer.RCDATA, elementName);
+                                        originalMode = mode;
+                                        mode = IN_CDATA_RCDATA;
+                                        needToDropLF = true;
+                                        break starttagloop;
+                                    case NOSCRIPT:
+                                        if (!scriptingEnabled) {
+                                            reconstructTheActiveFormattingElements();
+                                            appendToCurrentNodeAndPushElementMayFoster(
+                                                    "http://www.w3.org/1999/xhtml",
+                                                    elementName, attributes);
+                                            break starttagloop;
+                                        } else {
+                                            // fall through
+                                        }
+                                    case NOFRAMES:
+                                    case IFRAME:
+                                    case NOEMBED:
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        originalMode = mode;
+                                        mode = IN_CDATA_RCDATA;
+                                        tokenizer.setContentModelFlag(
+                                                Tokenizer.CDATA, elementName);
+                                        break starttagloop;
+                                    case SELECT:
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes,
+                                                formPointer);
+                                        switch (mode) {
+                                            case IN_TABLE:
+                                            case IN_CAPTION:
+                                            case IN_COLUMN_GROUP:
+                                            case IN_TABLE_BODY:
+                                            case IN_ROW:
+                                            case IN_CELL:
+                                                mode = IN_SELECT_IN_TABLE;
+                                                break;
+                                            default:
+                                                mode = IN_SELECT;
+                                                break;
+                                        }
+                                        break starttagloop;
+                                    case OPTGROUP:
+                                    case OPTION:
+                                        /*
+                                         * If the stack of open elements has an
+                                         * option element in scope, then act as
+                                         * if an end tag with the tag name
+                                         * "option" had been seen.
+                                         */
+                                        if (findLastInScope("option") != TreeBuilder.NOT_FOUND_ON_STACK) {
+                                            optionendtagloop: for (;;) {
+                                                if (isCurrent("option")) {
+                                                    pop();
+                                                    break optionendtagloop;
+                                                }
+
+                                                eltPos = currentPtr;
+                                                for (;;) {
+                                                    if (stack[eltPos].name == "option") {
+                                                        generateImpliedEndTags();
+                                                        if (!isCurrent("option")) {
+                                                            err("End tag \u201C"
+                                                                    + name
+                                                                    + "\u201D seen but there were unclosed elements.");
+                                                        }
+                                                        while (currentPtr >= eltPos) {
+                                                            pop();
+                                                        }
+                                                        break optionendtagloop;
+                                                    }
+                                                    eltPos--;
+                                                }
+                                            }
+                                        }
+                                        /*
+                                         * Reconstruct the active formatting
+                                         * elements, if any.
+                                         */
+                                        reconstructTheActiveFormattingElements();
+                                        /*
+                                         * Insert an HTML element for the token.
+                                         */
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case RT_OR_RP:
+                                        /*
+                                         * If the stack of open elements has a
+                                         * ruby element in scope, then generate
+                                         * implied end tags. If the current node
+                                         * is not then a ruby element, this is a
+                                         * parse error; pop all the nodes from
+                                         * the current node up to the node
+                                         * immediately before the bottommost
+                                         * ruby element on the stack of open
+                                         * elements.
+                                         * 
+                                         * Insert an HTML element for the token.
+                                         */
+                                        eltPos = findLastInScope("ruby");
+                                        if (eltPos != NOT_FOUND_ON_STACK) {
+                                            generateImpliedEndTags();
+                                        }
+                                        if (eltPos != currentPtr) {
+                                            err("Unclosed children in \u201Cruby\u201D.");
+                                            while (currentPtr > eltPos) {
+                                                pop();
+                                            }
+                                        }
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case MATH:
+                                        reconstructTheActiveFormattingElements();
+                                        attributes.adjustForMath();
+                                        if (selfClosing) {
+                                            appendVoidElementToCurrentMayFoster(
+                                                    "http://www.w3.org/1998/Math/MathML",
+                                                    elementName, attributes);
+                                            selfClosing = false;
+                                        } else {
+                                            appendToCurrentNodeAndPushElementMayFoster(
+                                                    "http://www.w3.org/1998/Math/MathML",
+                                                    elementName, attributes);
+                                            foreignFlag = TreeBuilder.IN_FOREIGN;
+                                        }
+                                        break starttagloop;
+                                    case SVG:
+                                        reconstructTheActiveFormattingElements();
+                                        attributes.adjustForSvg();
+                                        if (selfClosing) {
+                                            appendVoidElementToCurrentMayFosterCamelCase(
+                                                    "http://www.w3.org/2000/svg",
+                                                    elementName, attributes);
+                                            selfClosing = false;
+                                        } else {
+                                            appendToCurrentNodeAndPushElementMayFoster(
+                                                    "http://www.w3.org/2000/svg",
+                                                    elementName, attributes);
+                                            foreignFlag = TreeBuilder.IN_FOREIGN;
+                                        }
+                                        break starttagloop;
+                                    case CAPTION:
+                                    case COL:
+                                    case COLGROUP:
+                                    case TBODY_OR_THEAD_OR_TFOOT:
+                                    case TR:
+                                    case TD_OR_TH:
+                                    case FRAME:
+                                    case FRAMESET:
+                                    case HEAD:
+                                        err("Stray start tag \u201C" + name
+                                                + "\u201D.");
+                                        break starttagloop;
+                                    case OUTPUT_OR_LABEL:
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes,
+                                                formPointer);
+                                        break starttagloop;
+                                    default:
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                }
+                            }
+                        case IN_HEAD:
+                            inheadloop: for (;;) {
+                                switch (group) {
+                                    case HTML:
+                                        err("Stray \u201Chtml\u201D start tag.");
+                                        addAttributesToHtml(attributes);
+                                        break starttagloop;
+                                    case BASE:
+                                    case COMMAND_OR_EVENT_SOURCE:
+                                        appendVoidElementToCurrentMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        selfClosing = false;
+                                        break starttagloop;
+                                    case META:
+                                    case LINK:
+                                        // Fall through to IN_HEAD_NOSCRIPT
+                                        break inheadloop;
+                                    case TITLE:
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        originalMode = mode;
+                                        mode = IN_CDATA_RCDATA;
+                                        tokenizer.setContentModelFlag(
+                                                Tokenizer.RCDATA, elementName);
+                                        break starttagloop;
+                                    case NOSCRIPT:
+                                        if (scriptingEnabled) {
+                                            appendToCurrentNodeAndPushElement(
+                                                    "http://www.w3.org/1999/xhtml",
+                                                    elementName, attributes);
+                                            originalMode = mode;
+                                            mode = IN_CDATA_RCDATA;
+                                            tokenizer.setContentModelFlag(
+                                                    Tokenizer.CDATA,
+                                                    elementName);
+                                        } else {
+                                            appendToCurrentNodeAndPushElementMayFoster(
+                                                    "http://www.w3.org/1999/xhtml",
+                                                    elementName, attributes);
+                                            mode = IN_HEAD_NOSCRIPT;
+                                        }
+                                        break starttagloop;
+                                    case SCRIPT:
+                                    case STYLE:
+                                    case NOFRAMES:
+                                        // XXX need to manage much more stuff
+                                        // here if
+                                        // supporting
+                                        // document.write()
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        originalMode = mode;
+                                        mode = IN_CDATA_RCDATA;
+                                        tokenizer.setContentModelFlag(
+                                                Tokenizer.CDATA, elementName);
+                                        break starttagloop;
+                                    case HEAD:
+                                        /* Parse error. */
+                                        err("Start tag for \u201Chead\u201D seen when \u201Chead\u201D was already open.");
+                                        /* Ignore the token. */
+                                        break starttagloop;
+                                    default:
+                                        pop();
+                                        mode = AFTER_HEAD;
+                                        continue starttagloop;
+                                }
+                            }
+                        case IN_HEAD_NOSCRIPT:
+                            switch (group) {
+                                case HTML:
+                                    // XXX did Hixie really mean to omit "base"
+                                    // here?
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                case LINK:
+                                    appendVoidElementToCurrentMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    selfClosing = false;
+                                    break starttagloop;
+                                case META:
+                                    checkMetaCharset(attributes);
+                                    appendVoidElementToCurrentMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    selfClosing = false;
+                                    break starttagloop;
+                                case STYLE:
+                                case NOFRAMES:
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    originalMode = mode;
+                                    mode = IN_CDATA_RCDATA;
+                                    tokenizer.setContentModelFlag(
+                                            Tokenizer.CDATA, elementName);
+                                    break starttagloop;
+                                case HEAD:
+                                    err("Start tag for \u201Chead\u201D seen when \u201Chead\u201D was already open.");
+                                    break starttagloop;
+                                case NOSCRIPT:
+                                    err("Start tag for \u201Cnoscript\u201D seen when \u201Cnoscript\u201D was already open.");
+                                    break starttagloop;
+                                default:
+                                    err("Bad start tag in \u201C" + name
+                                            + "\u201D in \u201Chead\u201D.");
+                                    pop();
+                                    mode = IN_HEAD;
+                                    continue;
+                            }
+                        case IN_COLUMN_GROUP:
+                            switch (group) {
+                                case HTML:
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                case COL:
+                                    appendVoidElementToCurrentMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    selfClosing = false;
+                                    break starttagloop;
+                                default:
+                                    if (currentPtr == 0) {
+                                        assert fragment;
+                                        err("Garbage in \u201Ccolgroup\u201D fragment.");
+                                        break starttagloop;
+                                    }
+                                    pop();
+                                    mode = IN_TABLE;
+                                    continue;
+                            }
+                        case IN_SELECT_IN_TABLE:
+                            switch (group) {
+                                case CAPTION:
+                                case TBODY_OR_THEAD_OR_TFOOT:
+                                case TR:
+                                case TD_OR_TH:
+                                case TABLE:
+                                    err("\u201C"
+                                            + name
+                                            + "\u201D start tag with \u201Cselect\u201D open.");
+                                    endSelect();
+                                    continue;
+                                default:
+                                    // fall through to IN_SELECT
+                            }
+                        case IN_SELECT:
+                            switch (group) {
+                                case HTML:
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                case OPTION:
+                                    if (isCurrent("option")) {
+                                        pop();
+                                    }
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    break starttagloop;
+                                case OPTGROUP:
+                                    if (isCurrent("option")) {
+                                        pop();
+                                    }
+                                    if (isCurrent("optgroup")) {
+                                        pop();
+                                    }
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    break starttagloop;
+                                case SELECT:
+                                    err("\u201Cselect\u201D start tag where end tag expected.");
+                                    eltPos = findLastInTableScope(name);
+                                    if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                        assert fragment;
+                                        err("No \u201Cselect\u201D in table scope.");
+                                        break starttagloop;
+                                    } else {
+                                        while (currentPtr >= eltPos) {
+                                            pop();
+                                        }
+                                        resetTheInsertionMode();
+                                        break starttagloop;
+                                    }
+                                case INPUT: // XXX keygen?
+                                case TEXTAREA:
+                                    err("\u201C"
+                                            + name
+                                            + "\u201D start tag seen in \u201Cselect\2201D.");
+                                    endSelect();
+                                    continue;
+                                case SCRIPT:
+                                    // XXX need to manage much more stuff
+                                    // here if
+                                    // supporting
+                                    // document.write()
+                                    appendToCurrentNodeAndPushElementMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    originalMode = mode;
+                                    mode = IN_CDATA_RCDATA;
+                                    tokenizer.setContentModelFlag(
+                                            Tokenizer.CDATA, elementName);
+                                    break starttagloop;
+                                default:
+                                    err("Stray \u201C" + name
+                                            + "\u201D start tag.");
+                                    break starttagloop;
+                            }
+                        case AFTER_BODY:
+                            switch (group) {
+                                case HTML:
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                default:
+                                    err("Stray \u201C" + name
+                                            + "\u201D start tag.");
+                                    mode = IN_BODY;
+                                    continue;
+                            }
+                        case IN_FRAMESET:
+                            switch (group) {
+                                case FRAMESET:
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    break starttagloop;
+                                case FRAME:
+                                    appendVoidElementToCurrentMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    selfClosing = false;
+                                    break starttagloop;
+                                default:
+                                    // fall through to AFTER_FRAMESET
+                            }
+                        case AFTER_FRAMESET:
+                            switch (group) {
+                                case HTML:
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                case NOFRAMES:
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    originalMode = mode;
+                                    mode = IN_CDATA_RCDATA;
+                                    tokenizer.setContentModelFlag(
+                                            Tokenizer.CDATA, elementName);
+                                    break starttagloop;
+                                default:
+                                    err("Stray \u201C" + name
+                                            + "\u201D start tag.");
+                                    break starttagloop;
+                            }
+                        case INITIAL:
+                            /*
+                             * Parse error.
+                             */
+                            // [NOCPP[
+                            switch (doctypeExpectation) {
+                                case AUTO:
+                                    err("Start tag seen without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
+                                    break;
+                                case HTML:
+                                    err("Start tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D.");
+                                    break;
+                                case HTML401_STRICT:
+                                    err("Start tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                                    break;
+                                case HTML401_TRANSITIONAL:
+                                    err("Start tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                                    break;
+                                case NO_DOCTYPE_ERRORS:
+                            }
+                            // ]NOCPP]
+                            /*
+                             * 
+                             * Set the document to quirks mode.
+                             */
+                            documentModeInternal(DocumentMode.QUIRKS_MODE,
+                                    null, null, false);
+                            /*
+                             * Then, switch to the root element mode of the tree
+                             * construction stage
+                             */
+                            mode = BEFORE_HTML;
+                            /*
+                             * and reprocess the current token.
+                             */
+                            continue;
+                        case BEFORE_HTML:
+                            switch (group) {
+                                case HTML:
+                                    // optimize error check and streaming SAX by
+                                    // hoisting
+                                    // "html" handling here.
+                                    if (attributes == HtmlAttributes.EMPTY_ATTRIBUTES) {
+                                        // This has the right magic side effect
+                                        // that
+                                        // it
+                                        // makes attributes in SAX Tree mutable.
+                                        appendHtmlElementToDocumentAndPush();
+                                    } else {
+                                        appendHtmlElementToDocumentAndPush(attributes);
+                                    }
+                                    // XXX application cache should fire here
+                                    mode = BEFORE_HEAD;
+                                    break starttagloop;
+                                default:
+                                    /*
+                                     * Create an HTMLElement node with the tag
+                                     * name html, in the HTML namespace. Append
+                                     * it to the Document object.
+                                     */
+                                    appendHtmlElementToDocumentAndPush();
+                                    /* Switch to the main mode */
+                                    mode = BEFORE_HEAD;
+                                    /*
+                                     * reprocess the current token.
+                                     */
+                                    continue;
+                            }
+                        case BEFORE_HEAD:
+                            switch (group) {
+                                case HTML:
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                case HEAD:
+                                    /*
+                                     * A start tag whose tag name is "head"
+                                     * 
+                                     * Create an element for the token.
+                                     * 
+                                     * Set the head element pointer to this new
+                                     * element node.
+                                     * 
+                                     * Append the new element to the current
+                                     * node and push it onto the stack of open
+                                     * elements.
+                                     */
+                                    appendToCurrentNodeAndPushHeadElement(attributes);
+                                    /*
+                                     * 
+                                     * Change the insertion mode to "in head".
+                                     */
+                                    mode = IN_HEAD;
+                                    break starttagloop;
+                                default:
+
+                                    /*
+                                     * Any other start tag token
+                                     */
+
+                                    /*
+                                     * Act as if a start tag token with the tag
+                                     * name "head" and no attributes had been
+                                     * seen,
+                                     */
+                                    appendToCurrentNodeAndPushHeadElement(HtmlAttributes.EMPTY_ATTRIBUTES);
+                                    mode = IN_HEAD;
+                                    /*
+                                     * then reprocess the current token.
+                                     * 
+                                     * This will result in an empty head element
+                                     * being generated, with the current token
+                                     * being reprocessed in the "after head"
+                                     * insertion mode.
+                                     */
+                                    continue;
+                            }
+                        case AFTER_HEAD:
+                            switch (group) {
+                                case HTML:
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                case BODY:
+                                    if (attributes.getLength() == 0) {
+                                        // This has the right magic side effect
+                                        // that
+                                        // it
+                                        // makes attributes in SAX Tree mutable.
+                                        appendToCurrentNodeAndPushBodyElement();
+                                    } else {
+                                        appendToCurrentNodeAndPushBodyElement(attributes);
+                                    }
+                                    mode = FRAMESET_OK;
+                                    break starttagloop;
+                                case FRAMESET:
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    mode = IN_FRAMESET;
+                                    break starttagloop;
+                                case BASE:
+                                    err("\u201Cbase\u201D element outside \u201Chead\u201D.");
+                                    pushHeadPointerOntoStack();
+                                    appendVoidElementToCurrentMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    selfClosing = false;
+                                    pop(); // head
+                                    break starttagloop;
+                                case LINK:
+                                    err("\u201Clink\u201D element outside \u201Chead\u201D.");
+                                    pushHeadPointerOntoStack();
+                                    appendVoidElementToCurrentMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    selfClosing = false;
+                                    pop(); // head
+                                    break starttagloop;
+                                case META:
+                                    err("\u201Cmeta\u201D element outside \u201Chead\u201D.");
+                                    checkMetaCharset(attributes);
+                                    pushHeadPointerOntoStack();
+                                    appendVoidElementToCurrentMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    selfClosing = false;
+                                    pop(); // head
+                                    break starttagloop;
+                                case SCRIPT:
+                                    err("\u201Cscript\u201D element between \u201Chead\u201D and \u201Cbody\u201D.");
+                                    pushHeadPointerOntoStack();
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    originalMode = mode;
+                                    mode = IN_CDATA_RCDATA;
+                                    tokenizer.setContentModelFlag(
+                                            Tokenizer.CDATA, elementName);
+                                    break starttagloop;
+                                case STYLE:
+                                case NOFRAMES:
+                                    err("\u201C"
+                                            + name
+                                            + "\u201D element between \u201Chead\u201D and \u201Cbody\u201D.");
+                                    pushHeadPointerOntoStack();
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    originalMode = mode;
+                                    mode = IN_CDATA_RCDATA;
+                                    tokenizer.setContentModelFlag(
+                                            Tokenizer.CDATA, elementName);
+                                    break starttagloop;
+                                case TITLE:
+                                    err("\u201Ctitle\u201D element outside \u201Chead\u201D.");
+                                    pushHeadPointerOntoStack();
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    originalMode = mode;
+                                    mode = IN_CDATA_RCDATA;
+                                    tokenizer.setContentModelFlag(
+                                            Tokenizer.RCDATA, elementName);
+                                    break starttagloop;
+                                case HEAD:
+                                    err("Stray start tag \u201Chead\u201D.");
+                                    break starttagloop;
+                                default:
+                                    appendToCurrentNodeAndPushBodyElement();
+                                    mode = FRAMESET_OK;
+                                    continue;
+                            }
+                        case AFTER_AFTER_BODY:
+                            switch (group) {
+                                case HTML:
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                default:
+                                    err("Stray \u201C" + name
+                                            + "\u201D start tag.");
+                                    fatal();
+                                    mode = IN_BODY;
+                                    continue;
+                            }
+                        case AFTER_AFTER_FRAMESET:
+                            switch (group) {
+                                case NOFRAMES:
+                                    appendToCurrentNodeAndPushElementMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    originalMode = mode;
+                                    mode = IN_CDATA_RCDATA;
+                                    tokenizer.setContentModelFlag(
+                                            Tokenizer.CDATA, elementName);
+                                    break starttagloop;
+                                default:
+                                    err("Stray \u201C" + name
+                                            + "\u201D start tag.");
+                                    break starttagloop;
+                            }
+                            // [NOCPP[
+                        case IN_CDATA_RCDATA:
+                            assert false;
+                            // ]NOCPP]
+                    }
+            }
+        }
+        if (needsPostProcessing && foreignFlag == TreeBuilder.IN_FOREIGN
+                && !hasForeignInScope()) {
+            /*
+             * If, after doing so, the insertion mode is still "in foreign
+             * content", but there is no element in scope that has a namespace
+             * other than the HTML namespace, switch the insertion mode to the
+             * secondary insertion mode.
+             */
+            foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+        }
+        if (selfClosing) {
+            err("Self-closing syntax (\u201C/>\u201D) used on a non-void HTML element. Ignoring the slash and treating as a start tag.");
+        }
+    }
+
+    /**
+     * 
+     * <p>
+     * C++ memory note: The return value must be released.
+     * 
+     * @return
+     * @throws SAXException
+     * @throws StopSniffingException
+     */
+    public static String extractCharsetFromContent(String attributeValue) {
+        // This is a bit ugly. Converting the string to char array in order to
+        // make the portability layer smaller.
+        int charsetState = CHARSET_INITIAL;
+        int start = -1;
+        int end = -1;
+        char[] buffer = Portability.newCharArrayFromString(attributeValue);
+
+        charsetloop: for (int i = 0; i < buffer.length; i++) {
+            char c = buffer[i];
+            switch (charsetState) {
+                case CHARSET_INITIAL:
+                    switch (c) {
+                        case 'c':
+                        case 'C':
+                            charsetState = CHARSET_C;
+                            continue;
+                        default:
+                            continue;
+                    }
+                case CHARSET_C:
+                    switch (c) {
+                        case 'h':
+                        case 'H':
+                            charsetState = CHARSET_H;
+                            continue;
+                        default:
+                            charsetState = CHARSET_INITIAL;
+                            continue;
+                    }
+                case CHARSET_H:
+                    switch (c) {
+                        case 'a':
+                        case 'A':
+                            charsetState = CHARSET_A;
+                            continue;
+                        default:
+                            charsetState = CHARSET_INITIAL;
+                            continue;
+                    }
+                case CHARSET_A:
+                    switch (c) {
+                        case 'r':
+                        case 'R':
+                            charsetState = CHARSET_R;
+                            continue;
+                        default:
+                            charsetState = CHARSET_INITIAL;
+                            continue;
+                    }
+                case CHARSET_R:
+                    switch (c) {
+                        case 's':
+                        case 'S':
+                            charsetState = CHARSET_S;
+                            continue;
+                        default:
+                            charsetState = CHARSET_INITIAL;
+                            continue;
+                    }
+                case CHARSET_S:
+                    switch (c) {
+                        case 'e':
+                        case 'E':
+                            charsetState = CHARSET_E;
+                            continue;
+                        default:
+                            charsetState = CHARSET_INITIAL;
+                            continue;
+                    }
+                case CHARSET_E:
+                    switch (c) {
+                        case 't':
+                        case 'T':
+                            charsetState = CHARSET_T;
+                            continue;
+                        default:
+                            charsetState = CHARSET_INITIAL;
+                            continue;
+                    }
+                case CHARSET_T:
+                    switch (c) {
+                        case '\t':
+                        case '\n':
+                        case '\u000C':
+                        case '\r':
+                        case ' ':
+                            continue;
+                        case '=':
+                            charsetState = CHARSET_EQUALS;
+                            continue;
+                        default:
+                            return null;
+                    }
+                case CHARSET_EQUALS:
+                    switch (c) {
+                        case '\t':
+                        case '\n':
+                        case '\u000C':
+                        case '\r':
+                        case ' ':
+                            continue;
+                        case '\'':
+                            start = i + 1;
+                            charsetState = CHARSET_SINGLE_QUOTED;
+                            continue;
+                        case '\"':
+                            start = i + 1;
+                            charsetState = CHARSET_DOUBLE_QUOTED;
+                            continue;
+                        default:
+                            start = i;
+                            charsetState = CHARSET_UNQUOTED;
+                            continue;
+                    }
+                case CHARSET_SINGLE_QUOTED:
+                    switch (c) {
+                        case '\'':
+                            end = i;
+                            break charsetloop;
+                        default:
+                            continue;
+                    }
+                case CHARSET_DOUBLE_QUOTED:
+                    switch (c) {
+                        case '\"':
+                            end = i;
+                            break charsetloop;
+                        default:
+                            continue;
+                    }
+                case CHARSET_UNQUOTED:
+                    switch (c) {
+                        case '\t':
+                        case '\n':
+                        case '\u000C':
+                        case '\r':
+                        case ' ':
+                        case ';':
+                            end = i;
+                            break charsetloop;
+                        default:
+                            continue;
+                    }
+            }
+        }
+        String charset = null;
+        if (start != -1) {
+            if (end == -1) {
+                end = buffer.length;
+            }
+            charset = Portability.newStringFromBuffer(buffer, start, end - start);
+        }
+        Portability.releaseArray(buffer);
+        return charset;
+    }
+
+    private void checkMetaCharset(HtmlAttributes attributes)
+            throws SAXException {
+        String content = attributes.getValue(AttributeName.CONTENT);
+        String internalCharsetLegacy = null;
+        if (content != null) {
+            internalCharsetLegacy = TreeBuilder.extractCharsetFromContent(content);
+            // [NOCPP[
+            if (errorHandler != null
+                    && internalCharsetLegacy != null
+                    && !Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                            "content-type",
+                            attributes.getValue(AttributeName.HTTP_EQUIV))) {
+                warn("Attribute \u201Ccontent\u201D would be sniffed as an internal character encoding declaration but there was no matching \u201Chttp-equiv='Content-Type'\u201D attribute.");
+            }
+            // ]NOCPP]
+        }
+        if (internalCharsetLegacy == null) {
+            String internalCharsetHtml5 = attributes.getValue(AttributeName.CHARSET);
+            if (internalCharsetHtml5 != null) {
+                tokenizer.internalEncodingDeclaration(internalCharsetHtml5);
+                requestSuspension();
+            }
+        } else {
+            tokenizer.internalEncodingDeclaration(internalCharsetLegacy);
+            Portability.releaseString(internalCharsetLegacy);
+            requestSuspension();
+        }
+    }
+
+    public final void endTag(ElementName elementName) throws SAXException {
+        needToDropLF = false;
+        int eltPos;
+        endtagloop: for (;;) {
+            int group = elementName.group;
+            @Local String name = elementName.name;
+            switch (mode) {
+                case IN_ROW:
+                    switch (group) {
+                        case TR:
+                            eltPos = findLastOrRoot(TreeBuilder.TR);
+                            if (eltPos == 0) {
+                                assert fragment;
+                                err("No table row to close.");
+                                break endtagloop;
+                            }
+                            clearStackBackTo(eltPos);
+                            pop();
+                            mode = IN_TABLE_BODY;
+                            break endtagloop;
+                        case TABLE:
+                            eltPos = findLastOrRoot(TreeBuilder.TR);
+                            if (eltPos == 0) {
+                                assert fragment;
+                                err("No table row to close.");
+                                break endtagloop;
+                            }
+                            clearStackBackTo(eltPos);
+                            pop();
+                            mode = IN_TABLE_BODY;
+                            continue;
+                        case TBODY_OR_THEAD_OR_TFOOT:
+                            if (findLastInTableScope(name) == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                                break endtagloop;
+                            }
+                            eltPos = findLastOrRoot(TreeBuilder.TR);
+                            if (eltPos == 0) {
+                                assert fragment;
+                                err("No table row to close.");
+                                break endtagloop;
+                            }
+                            clearStackBackTo(eltPos);
+                            pop();
+                            mode = IN_TABLE_BODY;
+                            continue;
+                        case BODY:
+                        case CAPTION:
+                        case COL:
+                        case COLGROUP:
+                        case HTML:
+                        case TD_OR_TH:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                        default:
+                            // fall through to IN_TABLE
+                    }
+                case IN_TABLE_BODY:
+                    switch (group) {
+                        case TBODY_OR_THEAD_OR_TFOOT:
+                            eltPos = findLastOrRoot(name);
+                            if (eltPos == 0) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                                break endtagloop;
+                            }
+                            clearStackBackTo(eltPos);
+                            pop();
+                            mode = IN_TABLE;
+                            break endtagloop;
+                        case TABLE:
+                            eltPos = findLastInTableScopeOrRootTbodyTheadTfoot();
+                            if (eltPos == 0) {
+                                assert fragment;
+                                err("Stray end tag \u201Ctable\u201D.");
+                                break endtagloop;
+                            }
+                            clearStackBackTo(eltPos);
+                            pop();
+                            mode = IN_TABLE;
+                            continue;
+                        case BODY:
+                        case CAPTION:
+                        case COL:
+                        case COLGROUP:
+                        case HTML:
+                        case TD_OR_TH:
+                        case TR:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                        default:
+                            // fall through to IN_TABLE
+                    }
+                case IN_TABLE:
+                    switch (group) {
+                        case TABLE:
+                            eltPos = findLast("table");
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                assert fragment;
+                                err("Stray end tag \u201Ctable\u201D.");
+                                break endtagloop;
+                            }
+                            while (currentPtr >= eltPos) {
+                                pop();
+                            }
+                            resetTheInsertionMode();
+                            break endtagloop;
+                        case BODY:
+                        case CAPTION:
+                        case COL:
+                        case COLGROUP:
+                        case HTML:
+                        case TBODY_OR_THEAD_OR_TFOOT:
+                        case TD_OR_TH:
+                        case TR:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            // fall through to IN_BODY
+                    }
+                case IN_CAPTION:
+                    switch (group) {
+                        case CAPTION:
+                            eltPos = findLastInTableScope("caption");
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                break endtagloop;
+                            }
+                            generateImpliedEndTags();
+                            if (currentPtr != eltPos) {
+                                err("Unclosed elements on stack.");
+                            }
+                            while (currentPtr >= eltPos) {
+                                pop();
+                            }
+                            clearTheListOfActiveFormattingElementsUpToTheLastMarker();
+                            mode = IN_TABLE;
+                            break endtagloop;
+                        case TABLE:
+                            err("\u201Ctable\u201D closed but \u201Ccaption\u201D was still open.");
+                            eltPos = findLastInTableScope("caption");
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                break endtagloop;
+                            }
+                            generateImpliedEndTags();
+                            if (currentPtr != eltPos) {
+                                err("Unclosed elements on stack.");
+                            }
+                            while (currentPtr >= eltPos) {
+                                pop();
+                            }
+                            clearTheListOfActiveFormattingElementsUpToTheLastMarker();
+                            mode = IN_TABLE;
+                            continue;
+                        case BODY:
+                        case COL:
+                        case COLGROUP:
+                        case HTML:
+                        case TBODY_OR_THEAD_OR_TFOOT:
+                        case TD_OR_TH:
+                        case TR:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                        default:
+                            // fall through to IN_BODY
+                    }
+                case IN_CELL:
+                    switch (group) {
+                        case TD_OR_TH:
+                            eltPos = findLastInTableScope(name);
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                                break endtagloop;
+                            }
+                            generateImpliedEndTags();
+                            if (!isCurrent(name)) {
+                                err("Unclosed elements.");
+                            }
+                            while (currentPtr >= eltPos) {
+                                pop();
+                            }
+                            clearTheListOfActiveFormattingElementsUpToTheLastMarker();
+                            mode = IN_ROW;
+                            break endtagloop;
+                        case TABLE:
+                        case TBODY_OR_THEAD_OR_TFOOT:
+                        case TR:
+                            if (findLastInTableScope(name) == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                                break endtagloop;
+                            }
+                            closeTheCell(findLastInTableScopeTdTh());
+                            continue;
+                        case BODY:
+                        case CAPTION:
+                        case COL:
+                        case COLGROUP:
+                        case HTML:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                        default:
+                            // fall through to IN_BODY
+                    }
+                case FRAMESET_OK:
+                case IN_BODY:
+                    switch (group) {
+                        case BODY:
+                            if (!isSecondOnStackBody()) {
+                                assert fragment;
+                                err("Stray end tag \u201Cbody\u201D.");
+                                break endtagloop;
+                            }
+                            assert currentPtr >= 1;
+                            if (errorHandler != null) {
+                                uncloseloop1: for (int i = 2; i <= currentPtr; i++) {
+                                    switch (stack[i].group) {
+                                        case DD_OR_DT:
+                                        case LI:
+                                        case OPTGROUP:
+                                        case OPTION: // is this possible?
+                                        case P:
+                                        case RT_OR_RP:
+                                        case TD_OR_TH:
+                                        case TBODY_OR_THEAD_OR_TFOOT:
+                                            break;
+                                        default:
+                                            err("End tag for \u201Cbody\u201D seen but there were unclosed elements.");
+                                            break uncloseloop1;
+                                    }
+                                }
+                            }
+                            mode = AFTER_BODY;
+                            break endtagloop;
+                        case HTML:
+                            if (!isSecondOnStackBody()) {
+                                assert fragment;
+                                err("Stray end tag \u201Chtml\u201D.");
+                                break endtagloop;
+                            }
+                            if (errorHandler != null) {
+                                uncloseloop2: for (int i = 0; i <= currentPtr; i++) {
+                                    switch (stack[i].group) {
+                                        case DD_OR_DT:
+                                        case LI:
+                                        case P:
+                                        case TBODY_OR_THEAD_OR_TFOOT:
+                                        case TD_OR_TH:
+                                        case BODY:
+                                        case HTML:
+                                            break;
+                                        default:
+                                            err("End tag for \u201Chtml\u201D seen but there were unclosed elements.");
+                                            break uncloseloop2;
+                                    }
+                                }
+                            }
+                            mode = AFTER_BODY;
+                            continue;
+                        case DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU:
+                        case UL_OR_OL_OR_DL:
+                        case PRE_OR_LISTING:
+                        case FIELDSET:
+                        case ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION:
+                            eltPos = findLastInScope(name);
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                            } else {
+                                generateImpliedEndTags();
+                                if (!isCurrent(name)) {
+                                    err("End tag \u201C"
+                                            + name
+                                            + "\u201D seen but there were unclosed elements.");
+                                }
+                                while (currentPtr >= eltPos) {
+                                    pop();
+                                }
+                            }
+                            break endtagloop;
+                        case FORM:
+                            if (formPointer == null) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                                break endtagloop;
+                            }
+                            Portability.releaseElement(formPointer);
+                            formPointer = null;
+                            eltPos = findLastInScope(name);
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                                break endtagloop;
+                            }
+                            generateImpliedEndTags();
+                            if (!isCurrent(name)) {
+                                err("End tag \u201C"
+                                        + name
+                                        + "\u201D seen but there were unclosed elements.");
+                            }
+                            removeFromStack(eltPos);
+                            break endtagloop;
+                        case P:
+                            eltPos = findLastInScope("p");
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("No \u201Cp\u201D element in scope but a \u201Cp\u201D end tag seen.");
+                                // XXX inline this case
+                                if (foreignFlag == TreeBuilder.IN_FOREIGN) {
+                                    err("HTML start tag \u201C"
+                                            + name
+                                            + "\u201D in a foreign namespace context.");
+                                    while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
+                                        pop();
+                                    }
+                                    foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+                                }
+                                appendVoidElementToCurrentMayFoster(
+                                        "http://www.w3.org/1999/xhtml",
+                                        elementName,
+                                        HtmlAttributes.EMPTY_ATTRIBUTES);
+                                break endtagloop;
+                            }
+                            generateImpliedEndTagsExceptFor("p");
+                            assert eltPos != TreeBuilder.NOT_FOUND_ON_STACK;
+                            if (eltPos != currentPtr) {
+                                err("End tag for \u201Cp\u201D seen, but there were unclosed elements.");
+                            }
+                            while (currentPtr >= eltPos) {
+                                pop();
+                            }
+                            break endtagloop;
+                        case DD_OR_DT:
+                        case LI:
+                            eltPos = findLastInScope(name);
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("No \u201C"
+                                        + name
+                                        + "\u201D element in scope but a \u201C"
+                                        + name + "\u201D end tag seen.");
+                            } else {
+                                generateImpliedEndTagsExceptFor(name);
+                                if (eltPos != currentPtr) {
+                                    err("End tag for \u201C"
+                                            + name
+                                            + "\u201D seen, but there were unclosed elements.");
+                                }
+                                while (currentPtr >= eltPos) {
+                                    pop();
+                                }
+                            }
+                            break endtagloop;
+                        case H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6:
+                            eltPos = findLastInScopeHn();
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                            } else {
+                                generateImpliedEndTags();
+                                if (!isCurrent(name)) {
+                                    err("End tag \u201C"
+                                            + name
+                                            + "\u201D seen but there were unclosed elements.");
+                                }
+                                while (currentPtr >= eltPos) {
+                                    pop();
+                                }
+                            }
+                            break endtagloop;
+                        case A:
+                        case B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U:
+                        case FONT:
+                        case NOBR:
+                            adoptionAgencyEndTag(name);
+                            break endtagloop;
+                        case BUTTON:
+                        case OBJECT:
+                        case MARQUEE_OR_APPLET:
+                            eltPos = findLastInScope(name);
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                            } else {
+                                generateImpliedEndTags();
+                                if (!isCurrent(name)) {
+                                    err("End tag \u201C"
+                                            + name
+                                            + "\u201D seen but there were unclosed elements.");
+                                }
+                                while (currentPtr >= eltPos) {
+                                    pop();
+                                }
+                                clearTheListOfActiveFormattingElementsUpToTheLastMarker();
+                            }
+                            break endtagloop;
+                        case BR:
+                            err("End tag \u201Cbr\u201D.");
+                            if (foreignFlag == TreeBuilder.IN_FOREIGN) {
+                                err("HTML start tag \u201C"
+                                        + name
+                                        + "\u201D in a foreign namespace context.");
+                                while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
+                                    pop();
+                                }
+                                foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+                            }
+                            reconstructTheActiveFormattingElements();
+                            appendVoidElementToCurrentMayFoster(
+                                    "http://www.w3.org/1999/xhtml",
+                                    elementName,
+                                    HtmlAttributes.EMPTY_ATTRIBUTES);
+                            break endtagloop;
+                        case AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR:
+                        case PARAM_OR_SOURCE:
+                        case EMBED_OR_IMG:
+                        case IMAGE:
+                        case INPUT:
+                        case KEYGEN: // XXX??
+                        case HR:
+                        case ISINDEX:
+                        case IFRAME:
+                        case NOEMBED: // XXX???
+                        case NOFRAMES: // XXX??
+                        case SELECT:
+                        case TABLE:
+                        case TEXTAREA: // XXX??
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                        case NOSCRIPT:
+                            if (scriptingEnabled) {
+                                err("Stray end tag \u201Cnoscript\u201D.");
+                                break endtagloop;
+                            } else {
+                                // fall through
+                            }
+                        default:
+                            if (isCurrent(name)) {
+                                pop();
+                                break endtagloop;
+                            }
+
+                            eltPos = currentPtr;
+                            for (;;) {
+                                StackNode<T> node = stack[eltPos];
+                                if (node.name == name) {
+                                    generateImpliedEndTags();
+                                    if (!isCurrent(name)) {
+                                        err("End tag \u201C"
+                                                + name
+                                                + "\u201D seen but there were unclosed elements.");
+                                    }
+                                    while (currentPtr >= eltPos) {
+                                        pop();
+                                    }
+                                    break endtagloop;
+                                } else if (node.scoping || node.special) {
+                                    err("Stray end tag \u201C" + name
+                                            + "\u201D.");
+                                    break endtagloop;
+                                }
+                                eltPos--;
+                            }
+                    }
+                case IN_COLUMN_GROUP:
+                    switch (group) {
+                        case COLGROUP:
+                            if (currentPtr == 0) {
+                                assert fragment;
+                                err("Garbage in \u201Ccolgroup\u201D fragment.");
+                                break endtagloop;
+                            }
+                            pop();
+                            mode = IN_TABLE;
+                            break endtagloop;
+                        case COL:
+                            err("Stray end tag \u201Ccol\u201D.");
+                            break endtagloop;
+                        default:
+                            if (currentPtr == 0) {
+                                assert fragment;
+                                err("Garbage in \u201Ccolgroup\u201D fragment.");
+                                break endtagloop;
+                            }
+                            pop();
+                            mode = IN_TABLE;
+                            continue;
+                    }
+                case IN_SELECT_IN_TABLE:
+                    switch (group) {
+                        case CAPTION:
+                        case TABLE:
+                        case TBODY_OR_THEAD_OR_TFOOT:
+                        case TR:
+                        case TD_OR_TH:
+                            err("\u201C"
+                                    + name
+                                    + "\u201D end tag with \u201Cselect\u201D open.");
+                            if (findLastInTableScope(name) != TreeBuilder.NOT_FOUND_ON_STACK) {
+                                endSelect();
+                                continue;
+                            } else {
+                                break endtagloop;
+                            }
+                        default:
+                            // fall through to IN_SELECT
+                    }
+                case IN_SELECT:
+                    switch (group) {
+                        case OPTION:
+                            if (isCurrent("option")) {
+                                pop();
+                                break endtagloop;
+                            } else {
+                                err("Stray end tag \u201Coption\u201D");
+                                break endtagloop;
+                            }
+                        case OPTGROUP:
+                            if (isCurrent("option")
+                                    && "optgroup" == stack[currentPtr - 1].name) {
+                                pop();
+                            }
+                            if (isCurrent("optgroup")) {
+                                pop();
+                            } else {
+                                err("Stray end tag \u201Coptgroup\u201D");
+                            }
+                            break endtagloop;
+                        case SELECT:
+                            endSelect();
+                            break endtagloop;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D");
+                            break endtagloop;
+                    }
+                case AFTER_BODY:
+                    switch (group) {
+                        case HTML:
+                            if (fragment) {
+                                err("Stray end tag \u201Chtml\u201D");
+                                break endtagloop;
+                            } else {
+                                mode = AFTER_AFTER_BODY;
+                                break endtagloop;
+                            }
+                        default:
+                            err("Saw an end tag after \u201Cbody\u201D had been closed.");
+                            mode = IN_BODY;
+                            continue;
+                    }
+                case IN_FRAMESET:
+                    switch (group) {
+                        case FRAMESET:
+                            if (currentPtr == 0) {
+                                assert fragment;
+                                err("Stray end tag \u201Cframeset\u201D");
+                                break endtagloop;
+                            }
+                            pop();
+                            if ((!fragment) && !isCurrent("frameset")) {
+                                mode = AFTER_FRAMESET;
+                            }
+                            break endtagloop;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D");
+                            break endtagloop;
+                    }
+                case AFTER_FRAMESET:
+                    switch (group) {
+                        case HTML:
+                            mode = AFTER_AFTER_FRAMESET;
+                            break endtagloop;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D");
+                            break endtagloop;
+                    }
+                case INITIAL:
+                    /*
+                     * Parse error.
+                     */
+                    // [NOCPP[
+                    switch (doctypeExpectation) {
+                        case AUTO:
+                            err("End tag seen without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
+                            break;
+                        case HTML:
+                            err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D.");
+                            break;
+                        case HTML401_STRICT:
+                            err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                            break;
+                        case HTML401_TRANSITIONAL:
+                            err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                            break;
+                        case NO_DOCTYPE_ERRORS:
+                    }
+                    // ]NOCPP]
+                    /*
+                     * 
+                     * Set the document to quirks mode.
+                     */
+                    documentModeInternal(DocumentMode.QUIRKS_MODE, null, null,
+                            false);
+                    /*
+                     * Then, switch to the root element mode of the tree
+                     * construction stage
+                     */
+                    mode = BEFORE_HTML;
+                    /*
+                     * and reprocess the current token.
+                     */
+                    continue;
+                case BEFORE_HTML:
+                    /*
+                     * Create an HTMLElement node with the tag name html, in the
+                     * HTML namespace. Append it to the Document object.
+                     */
+                    appendHtmlElementToDocumentAndPush();
+                    /* Switch to the main mode */
+                    mode = BEFORE_HEAD;
+                    /*
+                     * reprocess the current token.
+                     */
+                    continue;
+                case BEFORE_HEAD:
+                    switch (group) {
+                        case HEAD:
+                        case BR:
+                        case HTML:
+                        case BODY:
+                            appendToCurrentNodeAndPushHeadElement(HtmlAttributes.EMPTY_ATTRIBUTES);
+                            mode = IN_HEAD;
+                            continue;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                    }
+                case IN_HEAD:
+                    switch (group) {
+                        case HEAD:
+                            pop();
+                            mode = AFTER_HEAD;
+                            break endtagloop;
+                        case BR:
+                        case HTML:
+                        case BODY:
+                            pop();
+                            mode = AFTER_HEAD;
+                            continue;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                    }
+                case IN_HEAD_NOSCRIPT:
+                    switch (group) {
+                        case NOSCRIPT:
+                            pop();
+                            mode = IN_HEAD;
+                            break endtagloop;
+                        case BR:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            pop();
+                            mode = IN_HEAD;
+                            continue;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                    }
+                case AFTER_HEAD:
+                    switch (group) {
+                        case HTML:
+                        case BODY:
+                        case BR:
+                            appendToCurrentNodeAndPushBodyElement();
+                            mode = FRAMESET_OK;
+                            continue;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                    }
+                case AFTER_AFTER_BODY:
+                    err("Stray \u201C" + name + "\u201D end tag.");
+                    mode = IN_BODY;
+                    continue;
+                case AFTER_AFTER_FRAMESET:
+                    err("Stray \u201C" + name + "\u201D end tag.");
+                    mode = IN_FRAMESET;
+                    continue;
+                case IN_CDATA_RCDATA:
+                    // XXX need to manage insertion point here
+                    if (originalMode == AFTER_HEAD) {
+                        pop();
+                    }
+                    pop();
+                    mode = originalMode;
+                    break endtagloop;
+            }
+        }
+        if (foreignFlag == TreeBuilder.IN_FOREIGN && !hasForeignInScope()) {
+            /*
+             * If, after doing so, the insertion mode is still "in foreign
+             * content", but there is no element in scope that has a namespace
+             * other than the HTML namespace, switch the insertion mode to the
+             * secondary insertion mode.
+             */
+            foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+        }
+    }
+
+    /**
+     * @throws SAXException
+     */
+    private void endSelect() throws SAXException {
+        int eltPos = findLastInTableScope("select");
+        if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+            assert fragment;
+            err("Stray end tag \u201Cselect\u201D");
+            return;
+        }
+        while (currentPtr >= eltPos) {
+            pop();
+        }
+        resetTheInsertionMode();
+    }
+
+    private int findLastInTableScopeOrRootTbodyTheadTfoot() {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].group == TreeBuilder.TBODY_OR_THEAD_OR_TFOOT) {
+                return i;
+            }
+        }
+        return 0;
+    }
+
+    private int findLast(@Local String name) {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].name == name) {
+                return i;
+            }
+        }
+        return TreeBuilder.NOT_FOUND_ON_STACK;
+    }
+
+    private int findLastInTableScope(@Local String name) {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].name == name) {
+                return i;
+            } else if (stack[i].name == "table") {
+                return TreeBuilder.NOT_FOUND_ON_STACK;
+            }
+        }
+        return TreeBuilder.NOT_FOUND_ON_STACK;
+    }
+
+    private int findLastInScope(@Local String name) {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].name == name) {
+                return i;
+            } else if (stack[i].scoping) {
+                return TreeBuilder.NOT_FOUND_ON_STACK;
+            }
+        }
+        return TreeBuilder.NOT_FOUND_ON_STACK;
+    }
+
+    private int findLastInScopeHn() {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].group == TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6) {
+                return i;
+            } else if (stack[i].scoping) {
+                return TreeBuilder.NOT_FOUND_ON_STACK;
+            }
+        }
+        return TreeBuilder.NOT_FOUND_ON_STACK;
+    }
+
+    private boolean hasForeignInScope() {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].ns != "http://www.w3.org/1999/xhtml") {
+                return true;
+            } else if (stack[i].scoping) {
+                return false;
+            }
+        }
+        return false;
+    }
+
+    private void generateImpliedEndTagsExceptFor(@Local String name)
+            throws SAXException {
+        for (;;) {
+            StackNode<T> node = stack[currentPtr];
+            switch (node.group) {
+                case P:
+                case LI:
+                case DD_OR_DT:
+                case OPTION:
+                case OPTGROUP:
+                case RT_OR_RP:
+                    if (node.name == name) {
+                        return;
+                    }
+                    pop();
+                    continue;
+                default:
+                    return;
+            }
+        }
+    }
+
+    private void generateImpliedEndTags() throws SAXException {
+        for (;;) {
+            switch (stack[currentPtr].group) {
+                case P:
+                case LI:
+                case DD_OR_DT:
+                case OPTION:
+                case OPTGROUP:
+                case RT_OR_RP:
+                    pop();
+                    continue;
+                default:
+                    return;
+            }
+        }
+    }
+
+    private boolean isSecondOnStackBody() {
+        return currentPtr >= 1 && stack[1].group == TreeBuilder.BODY;
+    }
+
+    private void documentModeInternal(DocumentMode m, String publicIdentifier,
+            String systemIdentifier, boolean html4SpecificAdditionalErrorChecks)
+            throws SAXException {
+        quirks = (m == DocumentMode.QUIRKS_MODE);
+        if (documentModeHandler != null) {
+            documentModeHandler.documentMode(
+                    m
+                    // [NOCPP[
+                    , publicIdentifier, systemIdentifier,
+                    html4SpecificAdditionalErrorChecks
+            // ]NOCPP]
+            );
+        }
+        // [NOCPP[
+        documentMode(m, publicIdentifier, systemIdentifier,
+                html4SpecificAdditionalErrorChecks);
+        // ]NOCPP]
+    }
+
+    private boolean isAlmostStandards(String publicIdentifier,
+            String systemIdentifier) {
+        if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                "-//w3c//dtd xhtml 1.0 transitional//en", publicIdentifier)) {
+            return true;
+        }
+        if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                "-//w3c//dtd xhtml 1.0 frameset//en", publicIdentifier)) {
+            return true;
+        }
+        if (systemIdentifier != null) {
+            if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                    "-//w3c//dtd html 4.01 transitional//en", publicIdentifier)) {
+                return true;
+            }
+            if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                    "-//w3c//dtd html 4.01 frameset//en", publicIdentifier)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean isQuirky(@Local String name, String publicIdentifier,
+            String systemIdentifier, boolean forceQuirks) {
+        if (forceQuirks) {
+            return true;
+        }
+        if (name != HTML_LOCAL) {
+            return true;
+        }
+        if (publicIdentifier != null) {
+            for (int i = 0; i < TreeBuilder.QUIRKY_PUBLIC_IDS.length; i++) {
+                if (Portability.lowerCaseLiteralIsPrefixOfIgnoreAsciiCaseString(
+                        TreeBuilder.QUIRKY_PUBLIC_IDS[i], publicIdentifier)) {
+                    return true;
+                }
+            }
+            if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                    "-//w3o//dtd w3 html strict 3.0//en//", publicIdentifier)
+                    || Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                            "-/w3c/dtd html 4.0 transitional/en",
+                            publicIdentifier)
+                    || Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                            "html", publicIdentifier)) {
+                return true;
+            }
+        }
+        if (systemIdentifier == null) {
+            if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                    "-//w3c//dtd html 4.01 transitional//en", publicIdentifier)) {
+                return true;
+            } else if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                    "-//w3c//dtd html 4.01 frameset//en", publicIdentifier)) {
+                return true;
+            }
+        } else if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd",
+                systemIdentifier)) {
+            return true;
+        }
+        return false;
+    }
+
+    private void closeTheCell(int eltPos) throws SAXException {
+        generateImpliedEndTags();
+        if (eltPos != currentPtr) {
+            err("Unclosed elements.");
+        }
+        while (currentPtr >= eltPos) {
+            pop();
+        }
+        clearTheListOfActiveFormattingElementsUpToTheLastMarker();
+        mode = IN_ROW;
+        return;
+    }
+
+    private int findLastInTableScopeTdTh() {
+        for (int i = currentPtr; i > 0; i--) {
+            @Local String name = stack[i].name;
+            if ("td" == name || "th" == name) {
+                return i;
+            } else if (name == "table") {
+                return TreeBuilder.NOT_FOUND_ON_STACK;
+            }
+        }
+        return TreeBuilder.NOT_FOUND_ON_STACK;
+    }
+
+    private void clearStackBackTo(int eltPos) throws SAXException {
+        while (currentPtr > eltPos) { // > not >= intentional
+            pop();
+        }
+    }
+
+    private void resetTheInsertionMode() {
+        foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+        StackNode<T> node;
+        @Local String name;
+        @NsUri String ns;
+        for (int i = currentPtr; i >= 0; i--) {
+            node = stack[i];
+            name = node.name;
+            ns = node.ns;
+            if (i == 0) {
+                if (!(contextNamespace == "http://www.w3.org/1999/xhtml" && (contextName == "td" || contextName == "th"))) {
+                    name = contextName;
+                    ns = contextNamespace;
+                } else {
+                    mode = IN_BODY; // XXX from Hixie's email
+                    return;
+                }
+            }
+            if ("select" == name) {
+                mode = IN_SELECT;
+                return;
+            } else if ("td" == name || "th" == name) {
+                mode = IN_CELL;
+                return;
+            } else if ("tr" == name) {
+                mode = IN_ROW;
+                return;
+            } else if ("tbody" == name || "thead" == name || "tfoot" == name) {
+                mode = IN_TABLE_BODY;
+                return;
+            } else if ("caption" == name) {
+                mode = IN_CAPTION;
+                return;
+            } else if ("colgroup" == name) {
+                mode = IN_COLUMN_GROUP;
+                return;
+            } else if ("table" == name) {
+                mode = IN_TABLE;
+                return;
+            } else if ("http://www.w3.org/1999/xhtml" != node.ns) {
+                foreignFlag = TreeBuilder.IN_FOREIGN;
+                mode = IN_BODY;
+                return;
+            } else if ("head" == name) {
+                mode = IN_BODY; // really
+                return;
+            } else if ("body" == name) {
+                mode = IN_BODY;
+                return;
+            } else if ("frameset" == name) {
+                mode = IN_FRAMESET;
+                return;
+            } else if ("html" == name) {
+                if (headPointer == null) {
+                    mode = BEFORE_HEAD;
+                } else {
+                    mode = AFTER_HEAD;
+                }
+                return;
+            } else if (i == 0) {
+                mode = IN_BODY;
+                return;
+            }
+        }
+    }
+
+    /**
+     * @throws SAXException
+     * 
+     */
+    private void implicitlyCloseP() throws SAXException {
+        int eltPos = findLastInScope("p");
+        if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+            return;
+        }
+        generateImpliedEndTagsExceptFor("p");
+        if (eltPos != currentPtr) {
+            err("Unclosed elements.");
+        }
+        while (currentPtr >= eltPos) {
+            pop();
+        }
+    }
+
+    private boolean clearLastStackSlot() {
+        stack[currentPtr] = null;
+        return true;
+    }
+
+    private boolean clearLastListSlot() {
+        listOfActiveFormattingElements[listPtr] = null;
+        return true;
+    }
+
+    private void push(StackNode<T> node) throws SAXException {
+        currentPtr++;
+        if (currentPtr == stack.length) {
+            StackNode<T>[] newStack = new StackNode[stack.length + 64];
+            System.arraycopy(stack, 0, newStack, 0, stack.length);
+            Portability.releaseArray(stack);
+            stack = newStack;
+        }
+        stack[currentPtr] = node;
+        elementPushed(node.ns, node.popName, node.node);
+    }
+
+    private void append(StackNode<T> node) {
+        listPtr++;
+        if (listPtr == listOfActiveFormattingElements.length) {
+            StackNode<T>[] newList = new StackNode[listOfActiveFormattingElements.length + 64];
+            System.arraycopy(listOfActiveFormattingElements, 0, newList, 0,
+                    listOfActiveFormattingElements.length);
+            Portability.releaseArray(listOfActiveFormattingElements);
+            listOfActiveFormattingElements = newList;
+        }
+        listOfActiveFormattingElements[listPtr] = node;
+    }
+
+    @Inline private void insertMarker() {
+        append(null);
+    }
+
+    private void clearTheListOfActiveFormattingElementsUpToTheLastMarker() {
+        while (listPtr > -1) {
+            if (listOfActiveFormattingElements[listPtr] == null) {
+                --listPtr;
+                return;
+            }
+            listOfActiveFormattingElements[listPtr].release();
+            --listPtr;
+        }
+    }
+
+    @Inline private boolean isCurrent(@Local String name) {
+        return name == stack[currentPtr].name;
+    }
+
+    private void removeFromStack(int pos) throws SAXException {
+        if (currentPtr == pos) {
+            pop();
+        } else {
+            fatal();
+            stack[pos].release();
+            System.arraycopy(stack, pos + 1, stack, pos, currentPtr - pos);
+            assert clearLastStackSlot();
+            currentPtr--;
+        }
+    }
+
+    private void removeFromStack(StackNode<T> node) throws SAXException {
+        if (stack[currentPtr] == node) {
+            pop();
+        } else {
+            int pos = currentPtr - 1;
+            while (pos >= 0 && stack[pos] != node) {
+                pos--;
+            }
+            if (pos == -1) {
+                // dead code?
+                return;
+            }
+            fatal();
+            node.release();
+            System.arraycopy(stack, pos + 1, stack, pos, currentPtr - pos);
+            currentPtr--;
+        }
+    }
+
+    private void removeFromListOfActiveFormattingElements(int pos) {
+        assert listOfActiveFormattingElements[pos] != null;
+        listOfActiveFormattingElements[pos].release();            
+        if (pos == listPtr) {
+            assert clearLastListSlot();
+            listPtr--;
+            return;
+        }
+        assert pos < listPtr;
+        System.arraycopy(listOfActiveFormattingElements, pos + 1,
+                listOfActiveFormattingElements, pos, listPtr - pos);
+        assert clearLastListSlot();
+        listPtr--;
+    }
+
+    private void adoptionAgencyEndTag(@Local String name) throws SAXException {
+        // If you crash around here, perhaps some stack node variable claimed to
+        // be a weak ref isn't.
+        flushCharacters();
+        for (;;) {
+            int formattingEltListPos = listPtr;
+            while (formattingEltListPos > -1) {
+                StackNode<T> listNode = listOfActiveFormattingElements[formattingEltListPos]; // weak ref
+                if (listNode == null) {
+                    formattingEltListPos = -1;
+                    break;
+                } else if (listNode.name == name) {
+                    break;
+                }
+                formattingEltListPos--;
+            }
+            if (formattingEltListPos == -1) {
+                err("No element \u201C" + name + "\u201D to close.");
+                return;
+            }
+            StackNode<T> formattingElt = listOfActiveFormattingElements[formattingEltListPos]; // this
+                                                                                               // *looks*
+                                                                                               // like
+                                                                                               // a
+                                                                                               // weak
+                                                                                               // ref
+                                                                                               // to
+                                                                                               // the
+                                                                                               // list
+                                                                                               // of
+                                                                                               // formatting
+                                                                                               // elements
+            int formattingEltStackPos = currentPtr;
+            boolean inScope = true;
+            while (formattingEltStackPos > -1) {
+                StackNode<T> node = stack[formattingEltStackPos]; // weak ref
+                if (node == formattingElt) {
+                    break;
+                } else if (node.scoping) {
+                    inScope = false;
+                }
+                formattingEltStackPos--;
+            }
+            if (formattingEltStackPos == -1) {
+                err("No element \u201C" + name + "\u201D to close.");
+                removeFromListOfActiveFormattingElements(formattingEltListPos);
+                return;
+            }
+            if (!inScope) {
+                err("No element \u201C" + name + "\u201D to close.");
+                return;
+            }
+            // stackPos now points to the formatting element and it is in scope
+            if (formattingEltStackPos != currentPtr) {
+                err("End tag \u201C" + name + "\u201D violates nesting rules.");
+            }
+            int furthestBlockPos = formattingEltStackPos + 1;
+            while (furthestBlockPos <= currentPtr) {
+                StackNode<T> node = stack[furthestBlockPos]; // weak ref
+                if (node.scoping || node.special) {
+                    break;
+                }
+                furthestBlockPos++;
+            }
+            if (furthestBlockPos > currentPtr) {
+                // no furthest block
+                while (currentPtr >= formattingEltStackPos) {
+                    pop();
+                }
+                removeFromListOfActiveFormattingElements(formattingEltListPos);
+                return;
+            }
+            StackNode<T> commonAncestor = stack[formattingEltStackPos - 1]; // weak
+                                                                            // ref
+            StackNode<T> furthestBlock = stack[furthestBlockPos]; // weak ref
+            // detachFromParent(furthestBlock.node); XXX AAA CHANGE
+            int bookmark = formattingEltListPos;
+            int nodePos = furthestBlockPos;
+            StackNode<T> lastNode = furthestBlock; // weak ref
+            for (;;) {
+                nodePos--;
+                StackNode<T> node = stack[nodePos]; // weak ref
+                int nodeListPos = findInListOfActiveFormattingElements(node);
+                if (nodeListPos == -1) {
+                    assert formattingEltStackPos < nodePos;
+                    assert bookmark < nodePos;
+                    assert furthestBlockPos > nodePos;
+                    removeFromStack(nodePos); // node is now a bad pointer in
+                                              // C++
+                    furthestBlockPos--;
+                    continue;
+                }
+                // now node is both on stack and in the list
+                if (nodePos == formattingEltStackPos) {
+                    break;
+                }
+                if (nodePos == furthestBlockPos) {
+                    bookmark = nodeListPos + 1;
+                }
+                // if (hasChildren(node.node)) { XXX AAA CHANGE
+                assert node == listOfActiveFormattingElements[nodeListPos];
+                assert node == stack[nodePos];
+                T clone = shallowClone(node.node);
+                StackNode<T> newNode = new StackNode<T>(node.group, node.ns,
+                        node.name, clone, node.scoping, node.special,
+                        node.fosterParenting, node.popName); // creation
+                // ownership
+                // goes
+                // to
+                // stack
+                stack[nodePos] = newNode;
+                newNode.retain(); // retain for list
+                listOfActiveFormattingElements[nodeListPos] = newNode;
+                node.release(); // release from stack
+                node.release(); // release from list
+                node = newNode;
+                Portability.releaseElement(clone);
+                // } XXX AAA CHANGE
+                detachFromParent(lastNode.node);
+                appendElement(lastNode.node, node.node);
+                lastNode = node;
+            }
+            if (commonAncestor.fosterParenting) {
+                fatal();
+                detachFromParent(lastNode.node);
+                insertIntoFosterParent(lastNode.node);
+            } else {
+                detachFromParent(lastNode.node);
+                appendElement(lastNode.node, commonAncestor.node);
+            }
+            T clone = shallowClone(formattingElt.node);
+            StackNode<T> formattingClone = new StackNode<T>(
+                    formattingElt.group, formattingElt.ns, formattingElt.name,
+                    clone, formattingElt.scoping, formattingElt.special,
+                    formattingElt.fosterParenting, formattingElt.popName); // Ownership
+                                                                           // transfers
+                                                                           // to
+                                                                           // stack
+                                                                           // below
+            appendChildrenToNewParent(furthestBlock.node, clone);
+            appendElement(clone, furthestBlock.node);
+            removeFromListOfActiveFormattingElements(formattingEltListPos);
+            insertIntoListOfActiveFormattingElements(formattingClone, bookmark);
+            assert formattingEltStackPos < furthestBlockPos;
+            removeFromStack(formattingEltStackPos);
+            // furthestBlockPos is now off by one and points to the slot after
+            // it
+            insertIntoStack(formattingClone, furthestBlockPos);
+            Portability.releaseElement(clone);
+        }
+    }
+
+    private void insertIntoStack(StackNode<T> node, int position)
+            throws SAXException {
+        assert currentPtr + 1 < stack.length;
+        assert position <= currentPtr + 1;
+        if (position == currentPtr + 1) {
+            flushCharacters();
+            push(node);
+        } else {
+            System.arraycopy(stack, position, stack, position + 1,
+                    (currentPtr - position) + 1);
+            currentPtr++;
+            stack[position] = node;
+        }
+    }
+
+    private void insertIntoListOfActiveFormattingElements(
+            StackNode<T> formattingClone, int bookmark) {
+        formattingClone.retain();
+        assert listPtr + 1 < listOfActiveFormattingElements.length;
+        if (bookmark <= listPtr) {
+            System.arraycopy(listOfActiveFormattingElements, bookmark,
+                    listOfActiveFormattingElements, bookmark + 1,
+                    (listPtr - bookmark) + 1);
+        }
+        listPtr++;
+        listOfActiveFormattingElements[bookmark] = formattingClone;
+    }
+
+    private int findInListOfActiveFormattingElements(StackNode<T> node) {
+        for (int i = listPtr; i >= 0; i--) {
+            if (node == listOfActiveFormattingElements[i]) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    private int findInListOfActiveFormattingElementsContainsBetweenEndAndLastMarker(
+            @Local String name) {
+        for (int i = listPtr; i >= 0; i--) {
+            StackNode<T> node = listOfActiveFormattingElements[i];
+            if (node == null) {
+                return -1;
+            } else if (node.name == name) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    private int findLastOrRoot(@Local String name) {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].name == name) {
+                return i;
+            }
+        }
+        return 0;
+    }
+
+    private int findLastOrRoot(int group) {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].group == group) {
+                return i;
+            }
+        }
+        return 0;
+    }
+
+    private void addAttributesToBody(HtmlAttributes attributes)
+            throws SAXException {
+        // [NOCPP[
+        checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
+        // ]NOCPP]
+        if (currentPtr >= 1) {
+            StackNode<T> body = stack[1];
+            if (body.group == TreeBuilder.BODY) {
+                addAttributesToElement(body.node, attributes);
+            }
+        }
+    }
+
+    private void addAttributesToHtml(HtmlAttributes attributes)
+            throws SAXException {
+        // [NOCPP[
+        checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
+        // ]NOCPP]
+        addAttributesToElement(stack[0].node, attributes);
+    }
+    
+    private void pushHeadPointerOntoStack() throws SAXException {
+        flushCharacters();
+        fatal();
+        if (headPointer == null) {
+            assert fragment;
+            push(stack[currentPtr]);
+        } else {
+            push(new StackNode<T>("http://www.w3.org/1999/xhtml",
+                    ElementName.HEAD, headPointer));
+        }
+    }
+
+    /**
+     * @throws SAXException
+     * 
+     */
+    private void reconstructTheActiveFormattingElements() throws SAXException {
+        if (listPtr == -1) {
+            return;
+        }
+        StackNode<T> mostRecent = listOfActiveFormattingElements[listPtr];
+        if (mostRecent == null || isInStack(mostRecent)) {
+            return;
+        }
+        int entryPos = listPtr;
+        for (;;) {
+            entryPos--;
+            if (entryPos == -1) {
+                break;
+            }
+            if (listOfActiveFormattingElements[entryPos] == null) {
+                break;
+            }
+            if (isInStack(listOfActiveFormattingElements[entryPos])) {
+                break;
+            }
+        }
+        if (entryPos < listPtr) {
+            flushCharacters();
+        }
+        while (entryPos < listPtr) {
+            entryPos++;
+            StackNode<T> entry = listOfActiveFormattingElements[entryPos];
+            T clone = shallowClone(entry.node);
+            StackNode<T> entryClone = new StackNode<T>(entry.group, entry.ns,
+                    entry.name, clone, entry.scoping, entry.special,
+                    entry.fosterParenting, entry.popName);
+            StackNode<T> currentNode = stack[currentPtr];
+            if (currentNode.fosterParenting) {
+                insertIntoFosterParent(clone);
+            } else {
+                appendElement(clone, currentNode.node);
+            }
+            push(entryClone);
+            // stack takes ownership of the local variable
+            listOfActiveFormattingElements[entryPos] = entryClone;
+            // overwriting the old entry on the list, so release & retain
+            entry.release();
+            entryClone.retain();
+        }
+    }
+
+    private void insertIntoFosterParent(T child) throws SAXException {
+        int eltPos = findLastOrRoot(TreeBuilder.TABLE);
+        StackNode<T> node = stack[eltPos];
+        T elt = node.node;
+        if (eltPos == 0) {
+            appendElement(child, elt);
+            return;
+        }
+        insertFosterParentedChild(child, elt, stack[eltPos - 1].node);
+    }
+
+    private boolean isInStack(StackNode<T> node) {
+        for (int i = currentPtr; i >= 0; i--) {
+            if (stack[i] == node) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void pop() throws SAXException {
+        flushCharacters();
+        StackNode<T> node = stack[currentPtr];
+        assert clearLastStackSlot();
+        currentPtr--;
+        elementPopped(node.ns, node.popName, node.node);
+        node.release();
+    }
+
+    private void popOnEof() throws SAXException {
+        flushCharacters();
+        StackNode<T> node = stack[currentPtr];
+        assert clearLastStackSlot();
+        currentPtr--;
+        elementPopped(node.ns, node.popName, node.node);
+        markMalformedIfScript(node.node);
+        node.release();
+    }
+    
+    // [NOCPP[
+    private void checkAttributes(HtmlAttributes attributes, @NsUri String ns)
+            throws SAXException {
+        if (errorHandler != null) {
+            int len = attributes.getXmlnsLength();
+            for (int i = 0; i < len; i++) {
+                AttributeName name = attributes.getXmlnsAttributeName(i);
+                if (name == AttributeName.XMLNS) {
+                    if (html4) {
+                        err("Attribute \u201Cxmlns\u201D not allowed here. (HTML4-only error.)");
+                    } else {
+                        String xmlns = attributes.getXmlnsValue(i);
+                        if (!ns.equals(xmlns)) {
+                            err("Bad value \u201C"
+                                    + xmlns
+                                    + "\u201D for the attribute \u201Cxmlns\u201D (only \u201C"
+                                    + ns + "\u201D permitted here).");
+                            switch (namePolicy) {
+                                case ALTER_INFOSET:
+                                    // fall through
+                                case ALLOW:
+                                    warn("Attribute \u201Cxmlns\u201D is not serializable as XML 1.0.");
+                                    break;
+                                case FATAL:
+                                    fatal("Attribute \u201Cxmlns\u201D is not serializable as XML 1.0.");
+                                    break;
+                            }
+                        }
+                    }
+                } else if (ns != "http://www.w3.org/1999/xhtml" && name == AttributeName.XMLNS_XLINK) {
+                    String xmlns = attributes.getXmlnsValue(i);
+                    if (!"http://www.w3org/1999/xlink".equals(xmlns)) {
+                        err("Bad value \u201C"
+                                + xmlns
+                                + "\u201D for the attribute \u201Cxmlns:link\u201D (only \u201Chttp://www.w3org/1999/xlink\u201D permitted here).");
+                        switch (namePolicy) {
+                            case ALTER_INFOSET:
+                                // fall through
+                            case ALLOW:
+                                warn("Attribute \u201Cxmlns:xlink\u201D with the value \u201Chttp://www.w3org/1999/xlink\u201D is not serializable as XML 1.0 without changing document semantics.");
+                                break;
+                            case FATAL:
+                                fatal("Attribute \u201Cxmlns:xlink\u201D with the value \u201Chttp://www.w3org/1999/xlink\u201D is not serializable as XML 1.0 without changing document semantics.");
+                                break;
+                        }
+                    }                    
+                } else {
+                    err("Attribute \u201C" + attributes.getXmlnsLocalName(i) + "\u201D not allowed here.");                    
+                    switch (namePolicy) {
+                        case ALTER_INFOSET:
+                            // fall through
+                        case ALLOW:
+                            warn("Attribute with the local name \u201C" + attributes.getXmlnsLocalName(i) + "\u201D is not serializable as XML 1.0.");
+                            break;
+                        case FATAL:
+                            fatal("Attribute with the local name \u201C" + attributes.getXmlnsLocalName(i) + "\u201D is not serializable as XML 1.0.");
+                            break;
+                    }
+                }
+            }
+        }
+        attributes.processNonNcNames(this, namePolicy);
+    }
+
+    private String checkPopName(@Local String name) throws SAXException {
+        if (NCName.isNCName(name)) {
+            return name;
+        } else {
+            switch (namePolicy) {
+                case ALLOW:
+                    warn("Element name \u201C" + name
+                            + "\u201D cannot be represented as XML 1.0.");
+                    return name;
+                case ALTER_INFOSET:
+                    warn("Element name \u201C" + name
+                            + "\u201D cannot be represented as XML 1.0.");
+                    return NCName.escapeName(name);
+                case FATAL:
+                    fatal("Element name \u201C" + name
+                            + "\u201D cannot be represented as XML 1.0.");
+            }
+        }
+        return null; // keep compiler happy
+    }
+
+    // ]NOCPP]
+
+    private void appendHtmlElementToDocumentAndPush(HtmlAttributes attributes)
+            throws SAXException {
+        // [NOCPP[
+        checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
+        // ]NOCPP]
+        T elt = createHtmlElementSetAsRoot(attributes);
+        StackNode<T> node = new StackNode<T>("http://www.w3.org/1999/xhtml",
+                ElementName.HTML, elt);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    private void appendHtmlElementToDocumentAndPush() throws SAXException {
+        appendHtmlElementToDocumentAndPush(tokenizer.emptyAttributes());
+    }
+
+    private void appendToCurrentNodeAndPushHeadElement(HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        // [NOCPP[
+        checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
+        // ]NOCPP]
+        T elt = createElement("http://www.w3.org/1999/xhtml", "head",
+                attributes);
+        appendElement(elt, stack[currentPtr].node);
+        headPointer = elt;
+        Portability.retainElement(headPointer);
+        StackNode<T> node = new StackNode<T>("http://www.w3.org/1999/xhtml",
+                ElementName.HEAD, elt);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    private void appendToCurrentNodeAndPushBodyElement(HtmlAttributes attributes)
+            throws SAXException {
+        appendToCurrentNodeAndPushElement("http://www.w3.org/1999/xhtml",
+                ElementName.BODY, attributes);
+    }
+
+    private void appendToCurrentNodeAndPushBodyElement() throws SAXException {
+        appendToCurrentNodeAndPushBodyElement(tokenizer.emptyAttributes());
+    }
+
+    private void appendToCurrentNodeAndPushFormElementMayFoster(
+            HtmlAttributes attributes) throws SAXException {
+        flushCharacters();
+        // [NOCPP[
+        checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
+        // ]NOCPP]
+        T elt = createElement("http://www.w3.org/1999/xhtml", "form",
+                attributes);
+        formPointer = elt;
+        Portability.retainElement(formPointer);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        StackNode<T> node = new StackNode<T>("http://www.w3.org/1999/xhtml",
+                ElementName.FORM, elt);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    private void appendToCurrentNodeAndPushFormattingElementMayFoster(
+            @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        // ]NOCPP]
+        // This method can't be called for custom elements
+        T elt = createElement(ns, elementName.name, attributes);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        StackNode<T> node = new StackNode<T>(ns, elementName, elt);
+        push(node);
+        append(node);
+        node.retain(); // append doesn't retain itself
+        Portability.releaseElement(elt);
+    }
+
+    private void appendToCurrentNodeAndPushElement(@NsUri String ns,
+            ElementName elementName, HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        // ]NOCPP]
+        // This method can't be called for custom elements
+        T elt = createElement(ns, elementName.name, attributes);
+        appendElement(elt, stack[currentPtr].node);
+        StackNode<T> node = new StackNode<T>(ns, elementName, elt);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    private void appendToCurrentNodeAndPushElementMayFoster(@NsUri String ns,
+            ElementName elementName, HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        @Local String popName = elementName.name;
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        if (elementName.custom) {
+            popName = checkPopName(popName);
+        }
+        // ]NOCPP]
+        T elt = createElement(ns, popName, attributes);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        StackNode<T> node = new StackNode<T>(ns, elementName, elt, popName);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    private void appendToCurrentNodeAndPushElementMayFosterNoScoping(
+            @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        @Local String popName = elementName.name;
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        if (elementName.custom) {
+            popName = checkPopName(popName);
+        }
+        // ]NOCPP]
+        T elt = createElement(ns, popName, attributes);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        StackNode<T> node = new StackNode<T>(ns, elementName, elt, popName,
+                false);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    private void appendToCurrentNodeAndPushElementMayFosterCamelCase(
+            @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        @Local String popName = elementName.camelCaseName;
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        if (elementName.custom) {
+            popName = checkPopName(popName);
+        }
+        // ]NOCPP]
+        T elt = createElement(ns, popName, attributes);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        StackNode<T> node = new StackNode<T>(ns, elementName, elt, popName,
+                ElementName.FOREIGNOBJECT == elementName);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    private void appendToCurrentNodeAndPushElementMayFoster(@NsUri String ns,
+            ElementName elementName, HtmlAttributes attributes, T form)
+            throws SAXException {
+        flushCharacters();
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        // ]NOCPP]
+        // Can't be called for custom elements
+        T elt = createElement(ns, elementName.name, attributes, form);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        StackNode<T> node = new StackNode<T>(ns, elementName, elt);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    @SuppressWarnings("unchecked") private void appendVoidElementToCurrentMayFoster(
+            @NsUri String ns, @Local String name, HtmlAttributes attributes,
+            T form) throws SAXException {
+        flushCharacters();
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        // ]NOCPP]
+        // Can't be called for custom elements
+        T elt = createElement(ns, name, attributes, form);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        elementPushed(ns, name, elt);
+        elementPopped(ns, name, elt);
+        Portability.releaseElement(elt);
+    }
+
+    @SuppressWarnings("unchecked") private void appendVoidElementToCurrentMayFoster(
+            @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        @Local String popName = elementName.name;
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        if (elementName.custom) {
+            popName = checkPopName(popName);
+        }
+        // ]NOCPP]
+        T elt = createElement(ns, popName, attributes);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        elementPushed(ns, popName, elt);
+        elementPopped(ns, popName, elt);
+        Portability.releaseElement(elt);
+    }
+
+    @SuppressWarnings("unchecked") private void appendVoidElementToCurrentMayFosterCamelCase(
+            @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        @Local String popName = elementName.camelCaseName;
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        if (elementName.custom) {
+            popName = checkPopName(popName);
+        }
+        // ]NOCPP]
+        T elt = createElement(ns, popName, attributes);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        elementPushed(ns, popName, elt);
+        elementPopped(ns, popName, elt);
+        Portability.releaseElement(elt);
+    }
+
+    @SuppressWarnings("unchecked") private void appendVoidElementToCurrent(
+            @NsUri String ns, @Local String name, HtmlAttributes attributes,
+            T form) throws SAXException {
+        flushCharacters();
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        // ]NOCPP]
+        // Can't be called for custom elements
+        T elt = createElement(ns, name, attributes, form);
+        StackNode<T> current = stack[currentPtr];
+        appendElement(elt, current.node);
+        elementPushed(ns, name, elt);
+        elementPopped(ns, name, elt);
+        Portability.releaseElement(elt);
+    }
+
+    protected void accumulateCharacters(@NoLength char[] buf, int start,
+            int length) throws SAXException {
+        appendCharacters(stack[currentPtr].node, buf, start, length);
+    }
+    
+    protected final void accumulateCharacter(char c) throws SAXException {
+            int newLen = charBufferLen + 1;
+            if (newLen > charBuffer.length) {
+                char[] newBuf = new char[newLen];
+                System.arraycopy(charBuffer, 0, newBuf, 0, charBufferLen);
+                Portability.releaseArray(charBuffer);
+                charBuffer = newBuf;
+            }
+            charBuffer[charBufferLen] = c;
+            charBufferLen = newLen;
+    }
+
+
+    // ------------------------------- //
+
+    protected final void requestSuspension() {
+        tokenizer.requestSuspension();
+    }
+
+    protected abstract T createElement(@NsUri String ns, @Local String name,
+            HtmlAttributes attributes) throws SAXException;
+
+    protected T createElement(@NsUri String ns, @Local String name,
+            HtmlAttributes attributes, T form) throws SAXException {
+        return createElement("http://www.w3.org/1999/xhtml", name, attributes);
+    }
+
+    protected abstract T createHtmlElementSetAsRoot(HtmlAttributes attributes)
+            throws SAXException;
+
+    protected abstract void detachFromParent(T element) throws SAXException;
+
+    protected abstract boolean hasChildren(T element) throws SAXException;
+
+    protected abstract T shallowClone(T element) throws SAXException;
+
+    protected abstract void appendElement(T child, T newParent)
+            throws SAXException;
+
+    protected abstract void appendChildrenToNewParent(T oldParent, T newParent)
+            throws SAXException;
+
+    protected abstract void insertFosterParentedChild(T child, T table, T stackParent)
+            throws SAXException;
+
+    protected abstract void insertFosterParentedCharacters(@NoLength char[] buf,
+            int start, int length, T table, T stackParent) throws SAXException;
+
+    protected abstract void appendCharacters(T parent, @NoLength char[] buf,
+            int start, int length) throws SAXException;
+
+    protected abstract void appendComment(T parent, @NoLength char[] buf,
+            int start, int length) throws SAXException;
+
+    protected abstract void appendCommentToDocument(@NoLength char[] buf,
+            int start, int length) throws SAXException;
+
+    protected abstract void addAttributesToElement(T element,
+            HtmlAttributes attributes) throws SAXException;
+    
+    protected void markMalformedIfScript(T elt) throws SAXException {
+
+    }
+    
+    protected void start(boolean fragment) throws SAXException {
+
+    }
+
+    protected void end() throws SAXException {
+
+    }
+
+    protected void appendDoctypeToDocument(@Local String name,
+            String publicIdentifier, String systemIdentifier)
+            throws SAXException {
+
+    }
+
+    protected void elementPushed(@NsUri String ns, @Local String name, T node)
+            throws SAXException {
+
+    }
+
+    protected void elementPopped(@NsUri String ns, @Local String name, T node)
+            throws SAXException {
+
+    }
+
+    // [NOCPP[
+
+    protected void documentMode(DocumentMode m, String publicIdentifier,
+            String systemIdentifier, boolean html4SpecificAdditionalErrorChecks)
+            throws SAXException {
+
+    }
+
+    /**
+     * @see nu.validator.htmlparser.common.TokenHandler#wantsComments()
+     */
+    public boolean wantsComments() {
+        return wantingComments;
+    }
+
+    public void setIgnoringComments(boolean ignoreComments) {
+        wantingComments = !ignoreComments;
+    }
+
+    /**
+     * Sets the errorHandler.
+     * 
+     * @param errorHandler
+     *            the errorHandler to set
+     */
+    public final void setErrorHandler(ErrorHandler errorHandler) {
+        this.errorHandler = errorHandler;
+    }
+
+    /**
+     * Returns the errorHandler.
+     * 
+     * @return the errorHandler
+     */
+    public ErrorHandler getErrorHandler() {
+        return errorHandler;
+    }
+
+    /**
+     * The argument MUST be an interned string or <code>null</code>.
+     * 
+     * @param context
+     */
+    public final void setFragmentContext(@Local String context) {
+        this.contextName = context;
+        this.contextNamespace = "http://www.w3.org/1999/xhtml";
+        this.contextNode = null;
+        this.fragment = (contextName != null);
+        this.quirks = false;
+    }
+
+    // ]NOCPP]
+
+    /**
+     * The argument MUST be an interned string or <code>null</code>.
+     * 
+     * @param context
+     */
+    public final void setFragmentContext(@Local String context, @NsUri String ns, T node, boolean quirks) {
+        this.contextName = context;
+        Portability.retainLocal(context);
+        this.contextNamespace = ns;
+        this.contextNode = node;
+        Portability.retainElement(node);
+        this.fragment = (contextName != null);
+        this.quirks = quirks;
+    }
+
+    protected final T currentNode() {
+        return stack[currentPtr].node;
+    }
+
+    /**
+     * Returns the scriptingEnabled.
+     * 
+     * @return the scriptingEnabled
+     */
+    public boolean isScriptingEnabled() {
+        return scriptingEnabled;
+    }
+
+    /**
+     * Sets the scriptingEnabled.
+     * 
+     * @param scriptingEnabled
+     *            the scriptingEnabled to set
+     */
+    public void setScriptingEnabled(boolean scriptingEnabled) {
+        this.scriptingEnabled = scriptingEnabled;
+    }
+
+    // [NOCPP[
+
+    /**
+     * Sets the doctypeExpectation.
+     * 
+     * @param doctypeExpectation
+     *            the doctypeExpectation to set
+     */
+    public void setDoctypeExpectation(DoctypeExpectation doctypeExpectation) {
+        this.doctypeExpectation = doctypeExpectation;
+    }
+
+    public void setNamePolicy(XmlViolationPolicy namePolicy) {
+        this.namePolicy = namePolicy;
+    }
+
+    /**
+     * Sets the documentModeHandler.
+     * 
+     * @param documentModeHandler
+     *            the documentModeHandler to set
+     */
+    public void setDocumentModeHandler(DocumentModeHandler documentModeHandler) {
+        this.documentModeHandler = documentModeHandler;
+    }
+
+    /**
+     * Sets the reportingDoctype.
+     * 
+     * @param reportingDoctype
+     *            the reportingDoctype to set
+     */
+    public void setReportingDoctype(boolean reportingDoctype) {
+        this.reportingDoctype = reportingDoctype;
+    }
+    
+    // ]NOCPP]
+
+    /**
+     * @see nu.validator.htmlparser.common.TokenHandler#inForeign()
+     */
+    public boolean inForeign() throws SAXException {
+        return foreignFlag == IN_FOREIGN;
+    }
+
+    private final void flushCharacters() throws SAXException {
+        if (charBufferLen > 0) {
+            StackNode<T> current = stack[currentPtr];
+            if (current.fosterParenting && charBufferContainsNonWhitespace()) {
+                err("Misplaced non-space characters insided a table.");
+                int eltPos = findLastOrRoot(TreeBuilder.TABLE);
+                StackNode<T> node = stack[eltPos];
+                T elt = node.node;
+                if (eltPos == 0) {
+                    appendCharacters(elt, charBuffer, 0, charBufferLen);
+                    charBufferLen = 0;
+                    return;
+                }
+                insertFosterParentedCharacters(charBuffer, 0, charBufferLen,
+                        elt, stack[eltPos - 1].node);
+                charBufferLen = 0;
+                return;
+            }
+            appendCharacters(currentNode(), charBuffer, 0, charBufferLen);
+            charBufferLen = 0;
+        }
+    }
+
+    private boolean charBufferContainsNonWhitespace() {
+        for (int i = 0; i < charBufferLen; i++) {
+            switch (charBuffer[i]) {
+                case ' ':
+                case '\t':
+                case '\n':
+                case '\u000C':
+                    continue;
+                default:
+                    return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Creates a comparable snapshot of the tree builder state. Snapshot creation
+     * is only supported immediately after a script end tag has been processed. In 
+     * C++ the caller is responsible for calling <code>delete</code> on the returned
+     * object.
+     * 
+     * @return a snapshot.
+     */
+    @SuppressWarnings("unchecked") public StateSnapshot<T> newSnapshot() {
+        StackNode<T>[] stackCopy = new StackNode[currentPtr + 1];
+        for (int i = 0; i < stackCopy.length; i++) {
+            (stackCopy[i] = stack[i]).retain();
+        }
+        StackNode<T>[] listCopy = new StackNode[listPtr + 1];
+        for (int i = 0; i < listCopy.length; i++) {
+            StackNode<T> node = listOfActiveFormattingElements[i];
+            if (node != null) {
+                node.retain();            
+            }
+            listCopy[i] = node;
+        }
+        Portability.retainElement(formPointer);
+        return new StateSnapshot<T>(stackCopy, listCopy, formPointer);
+    }
+    
+    public boolean snapshotMatches(StateSnapshot<T> snapshot) {
+        StackNode<T>[] stackCopy = snapshot.stack;
+        StackNode<T>[] listCopy = snapshot.listOfActiveFormattingElements;
+        if (stackCopy.length != currentPtr + 1 || listCopy.length != listPtr + 1 || formPointer != snapshot.formPointer) {
+            return false;
+        }
+        for (int i = listCopy.length - 1; i >= 0; i--) {
+            if (listCopy[i] != listOfActiveFormattingElements[i]) {
+                return false;
+            }
+        }
+        for (int i = listCopy.length - 1; i >= 0; i--) {
+            if (listCopy[i] != listOfActiveFormattingElements[i]) {
+                return false;
+            }
+        }
+        return true;
+    }
+    
+}
diff --git a/parser/html/java/htmlparser/src/UTF16Buffer.java b/parser/html/java/htmlparser/src/UTF16Buffer.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/UTF16Buffer.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2008 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.NoLength;
+
+public final class UTF16Buffer {
+    private final @NoLength char[] buffer;
+
+    private int start;
+
+    private int end;
+
+    /**
+     * @param buffer
+     * @param start
+     * @param end
+     */
+    public UTF16Buffer(@NoLength char[] buffer, int start, int end) {
+        this.buffer = buffer;
+        this.start = start;
+        this.end = end;
+    }
+
+    /**
+     * Returns the start.
+     * 
+     * @return the start
+     */
+    public int getStart() {
+        return start;
+    }
+
+    /**
+     * Sets the start.
+     * 
+     * @param start the start to set
+     */
+    public void setStart(int start) {
+        this.start = start;
+    }
+
+    /**
+     * Returns the buffer.
+     * 
+     * @return the buffer
+     */
+    public @NoLength char[] getBuffer() {
+        return buffer;
+    }
+
+    /**
+     * Returns the end.
+     * 
+     * @return the end
+     */
+    public int getEnd() {
+        return end;
+    }
+    
+    public boolean hasMore() {
+        return start < end;
+    }
+    
+    public void adjust(boolean lastWasCR) {
+        if (lastWasCR && buffer[start] == '\n') {
+            start++;
+        }
+    }
+
+    /**
+     * Sets the end.
+     * 
+     * @param end the end to set
+     */
+    public void setEnd(int end) {
+        this.end = end;
+    }
+}
diff --git a/parser/html/java/htmlparser/src/package.html b/parser/html/java/htmlparser/src/package.html
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/package.html
@@ -0,0 +1,30 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head><title>Package Overview</title>
+<!--
+ Copyright (c) 2007 Henri Sivonen
+
+ Permission is hereby granted, free of charge, to any person obtaining a 
+ copy of this software and associated documentation files (the "Software"), 
+ to deal in the Software without restriction, including without limitation 
+ the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ and/or sell copies of the Software, and to permit persons to whom the 
+ Software is furnished to do so, subject to the following conditions:
+
+ The above copyright notice and this permission notice shall be included in 
+ all copies or substantial portions of the Software.
+
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ DEALINGS IN THE SOFTWARE.
+-->
+</head>
+<body bgcolor="white">
+<p>This package contains the bulk of parser internals. Only implementors of 
+additional tree builders or token handlers should look here.</p>
+</body>
+</html>
\ No newline at end of file
diff --git a/parser/html/java/javaparser/Makefile b/parser/html/java/javaparser/Makefile
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/Makefile
@@ -0,0 +1,58 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Makefile.
+#
+# The Initial Developer of the Original Code is
+#   Ben Newman <b{enjam,newma}n@mozilla.com>
+#
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+SVN_BASE=http://javaparser.googlecode.com/svn/trunk/JavaParser
+
+libs:: \
+; mkdir -p bin && \
+  find src -name "*.java" | \
+    xargs javac -g -d bin && \
+  jar cf javaparser.jar -C bin .
+
+sync:: \
+; rm -rf src && \
+  svn co $(SVN_BASE)/src && \
+  find src -name .svn | xargs rm -rf ; \
+  \
+  for file in COPYING COPYING.LESSER readme.txt ; \
+  do \
+    rm -f $$file ; \
+    svn cat $(SVN_BASE)/$$file > $$file ; \
+  done
+
+clean:: \
+; rm -rf bin javaparser.jar
diff --git a/parser/html/java/translator/Makefile b/parser/html/java/translator/Makefile
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/Makefile
@@ -0,0 +1,58 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Makefile.
+#
+# The Initial Developer of the Original Code is
+#   Ben Newman <b{enjam,newma}n@mozilla.com>
+#
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+SVN_BASE=http://svn.versiondude.net/whattf/htmlparser/trunk
+
+libs:: \
+; mkdir -p bin && \
+  find src -name "*.java" | \
+    xargs javac -cp ../javaparser.jar -g -d bin && \
+  jar cfm translator.jar manifest.txt -C bin .
+
+sync:: \
+; rm -rf src && \
+  svn co $(SVN_BASE)/translator-src src && \
+  find src -name .svn | xargs rm -rf ; \
+  \
+  for file in LICENSE.txt README.txt ; \
+  do \
+    rm -f $$file ; \
+    svn cat $(SVN_BASE)/$$file > $$file ; \
+  done
+
+clean:: \
+; rm -rf bin translator.jar
diff --git a/parser/html/java/translator/manifest.txt b/parser/html/java/translator/manifest.txt
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/manifest.txt
@@ -0,0 +1,2 @@
+Main-Class: nu.validator.htmlparser.cpptranslate.Main
+Class-Path: javaparser.jar
diff --git a/parser/html/javasrc b/parser/html/javasrc
new file mode 120000
--- /dev/null
+++ b/parser/html/javasrc
@@ -0,0 +1,1 @@
+java/htmlparser/src
\ No newline at end of file
diff --git a/parser/html/nsHtml5AttributeName.cpp b/parser/html/nsHtml5AttributeName.cpp
--- a/parser/html/nsHtml5AttributeName.cpp
+++ b/parser/html/nsHtml5AttributeName.cpp
@@ -52,67 +52,67 @@
 #include "nsHtml5Portability.h"
 
 #include "nsHtml5AttributeName.h"
 #include "nsHtml5ReleasableAttributeName.h"
 
 nsIAtom** 
 nsHtml5AttributeName::SVG_DIFFERENT(nsIAtom* name, nsIAtom* camel)
 {
-  nsIAtom** rv = new nsIAtom*[4];
-  rv[0] = name;
-  rv[1] = name;
-  rv[2] = camel;
-  return rv;
+  nsIAtom** arr = new nsIAtom*[4];
+  arr[0] = name;
+  arr[1] = name;
+  arr[2] = camel;
+  return arr;
 }
 
 nsIAtom** 
 nsHtml5AttributeName::MATH_DIFFERENT(nsIAtom* name, nsIAtom* camel)
 {
-  nsIAtom** rv = new nsIAtom*[4];
-  rv[0] = name;
-  rv[1] = camel;
-  rv[2] = name;
-  return rv;
+  nsIAtom** arr = new nsIAtom*[4];
+  arr[0] = name;
+  arr[1] = camel;
+  arr[2] = name;
+  return arr;
 }
 
 nsIAtom** 
 nsHtml5AttributeName::COLONIFIED_LOCAL(nsIAtom* name, nsIAtom* suffix)
 {
-  nsIAtom** rv = new nsIAtom*[4];
-  rv[0] = name;
-  rv[1] = suffix;
-  rv[2] = suffix;
-  return rv;
+  nsIAtom** arr = new nsIAtom*[4];
+  arr[0] = name;
+  arr[1] = suffix;
+  arr[2] = suffix;
+  return arr;
 }
 
 nsIAtom** 
 nsHtml5AttributeName::SAME_LOCAL(nsIAtom* name)
 {
-  nsIAtom** rv = new nsIAtom*[4];
-  rv[0] = name;
-  rv[1] = name;
-  rv[2] = name;
-  return rv;
+  nsIAtom** arr = new nsIAtom*[4];
+  arr[0] = name;
+  arr[1] = name;
+  arr[2] = name;
+  return arr;
 }
 
 nsHtml5AttributeName* 
 nsHtml5AttributeName::nameByBuffer(PRUnichar* buf, PRInt32 offset, PRInt32 length)
 {
   PRInt32 hash = nsHtml5AttributeName::bufToHash(buf, length);
   PRInt32 index = nsHtml5AttributeName::ATTRIBUTE_HASHES.binarySearch(hash);
   if (index < 0) {
     return nsHtml5AttributeName::createAttributeName(nsHtml5Portability::newLocalNameFromBuffer(buf, offset, length));
   } else {
-    nsHtml5AttributeName* rv = nsHtml5AttributeName::ATTRIBUTE_NAMES[index];
-    nsIAtom* name = rv->getLocal(NS_HTML5ATTRIBUTE_NAME_HTML);
+    nsHtml5AttributeName* attributeName = nsHtml5AttributeName::ATTRIBUTE_NAMES[index];
+    nsIAtom* name = attributeName->getLocal(NS_HTML5ATTRIBUTE_NAME_HTML);
     if (!nsHtml5Portability::localEqualsBuffer(name, buf, offset, length)) {
       return nsHtml5AttributeName::createAttributeName(nsHtml5Portability::newLocalNameFromBuffer(buf, offset, length));
     }
-    return rv;
+    return attributeName;
   }
 }
 
 PRInt32 
 nsHtml5AttributeName::bufToHash(PRUnichar* buf, PRInt32 len)
 {
   PRInt32 hash2 = 0;
   PRInt32 hash = len;
diff --git a/parser/html/nsHtml5ElementName.cpp b/parser/html/nsHtml5ElementName.cpp
--- a/parser/html/nsHtml5ElementName.cpp
+++ b/parser/html/nsHtml5ElementName.cpp
@@ -57,22 +57,22 @@
 nsHtml5ElementName* 
 nsHtml5ElementName::elementNameByBuffer(jArray<PRUnichar,PRInt32> buf, PRInt32 offset, PRInt32 length)
 {
   PRInt32 hash = nsHtml5ElementName::bufToHash(buf, length);
   PRInt32 index = nsHtml5ElementName::ELEMENT_HASHES.binarySearch(hash);
   if (index < 0) {
     return new nsHtml5ReleasableElementName(nsHtml5Portability::newLocalNameFromBuffer(buf, offset, length));
   } else {
-    nsHtml5ElementName* rv = nsHtml5ElementName::ELEMENT_NAMES[index];
-    nsIAtom* name = rv->name;
+    nsHtml5ElementName* elementName = nsHtml5ElementName::ELEMENT_NAMES[index];
+    nsIAtom* name = elementName->name;
     if (!nsHtml5Portability::localEqualsBuffer(name, buf, offset, length)) {
       return new nsHtml5ReleasableElementName(nsHtml5Portability::newLocalNameFromBuffer(buf, offset, length));
     }
-    return rv;
+    return elementName;
   }
 }
 
 PRInt32 
 nsHtml5ElementName::bufToHash(jArray<PRUnichar,PRInt32> buf, PRInt32 len)
 {
   PRInt32 hash = len;
   hash <<= 5;
diff --git a/parser/html/nsHtml5MetaScanner.cpp b/parser/html/nsHtml5MetaScanner.cpp
--- a/parser/html/nsHtml5MetaScanner.cpp
+++ b/parser/html/nsHtml5MetaScanner.cpp
@@ -686,21 +686,21 @@ nsHtml5MetaScanner::tryCharset()
     candidateEncoding = nsHtml5TreeBuilder::extractCharsetFromContent(attVal);
     nsHtml5Portability::releaseString(attVal);
   } else {
     candidateEncoding = attVal;
   }
   if (!candidateEncoding) {
     return PR_FALSE;
   }
-  PRBool rv = tryCharset(candidateEncoding);
+  PRBool success = tryCharset(candidateEncoding);
   nsHtml5Portability::releaseString(candidateEncoding);
   contentIndex = -1;
   charsetIndex = -1;
-  return rv;
+  return success;
 }
 
 void
 nsHtml5MetaScanner::initializeStatics()
 {
 }
 
 void
diff --git a/parser/html/nsHtml5Tokenizer.cpp b/parser/html/nsHtml5Tokenizer.cpp
--- a/parser/html/nsHtml5Tokenizer.cpp
+++ b/parser/html/nsHtml5Tokenizer.cpp
@@ -279,17 +279,17 @@ nsHtml5Tokenizer::appendLongStrBuf(PRUni
 
 void 
 nsHtml5Tokenizer::appendSecondHyphenToBogusComment()
 {
   appendLongStrBuf('-');
 }
 
 void 
-nsHtml5Tokenizer::adjustDoubleHyphenAndAppendToLongStrBuf(PRUnichar c)
+nsHtml5Tokenizer::adjustDoubleHyphenAndAppendToLongStrBufAndErr(PRUnichar c)
 {
 
   appendLongStrBuf(c);
 }
 
 void 
 nsHtml5Tokenizer::appendLongStrBuf(jArray<PRUnichar,PRInt32> buffer, PRInt32 offset, PRInt32 length)
 {
@@ -647,16 +647,17 @@ nsHtml5Tokenizer::stateLoop(PRInt32 stat
               }
               goto stateloop;
             }
             case '\0': {
               c = 0xfffd;
             }
             case '\"':
             case '\'':
+            case '<':
             case '=':
             default: {
               if (c >= 'A' && c <= 'Z') {
                 c += 0x20;
               }
               clearStrBufAndAppendCurrentC(c);
               state = NS_HTML5TOKENIZER_ATTRIBUTE_NAME;
               goto beforeattributenameloop_end;
@@ -708,16 +709,17 @@ nsHtml5Tokenizer::stateLoop(PRInt32 stat
               }
               goto stateloop;
             }
             case '\0': {
               c = 0xfffd;
             }
             case '\"':
             case '\'':
+            case '<':
             default: {
               if (c >= 'A' && c <= 'Z') {
                 c += 0x20;
               }
               appendStrBuf(c);
               continue;
             }
           }
@@ -766,16 +768,17 @@ nsHtml5Tokenizer::stateLoop(PRInt32 stat
               if (shouldSuspend) {
                 goto stateloop_end;
               }
               goto stateloop;
             }
             case '\0': {
               c = 0xfffd;
             }
+            case '<':
             case '=':
             default: {
               clearLongStrBufAndAppendCurrentC(c);
               state = NS_HTML5TOKENIZER_ATTRIBUTE_VALUE_UNQUOTED;
               goto stateloop;
             }
           }
         }
@@ -979,16 +982,17 @@ nsHtml5Tokenizer::stateLoop(PRInt32 stat
               }
               goto stateloop;
             }
             case '\0': {
               c = 0xfffd;
             }
             case '\"':
             case '\'':
+            case '<':
             default: {
               addAttributeWithoutValue();
               if (c >= 'A' && c <= 'Z') {
                 c += 0x20;
               }
               clearStrBufAndAppendCurrentC(c);
               state = NS_HTML5TOKENIZER_ATTRIBUTE_NAME;
               goto stateloop;
@@ -1251,34 +1255,126 @@ nsHtml5Tokenizer::stateLoop(PRInt32 stat
           c = checkChar(buf, pos);
           switch(c) {
             case '>': {
               emitComment(2, pos);
               state = NS_HTML5TOKENIZER_DATA;
               goto stateloop;
             }
             case '-': {
-              adjustDoubleHyphenAndAppendToLongStrBuf(c);
+              adjustDoubleHyphenAndAppendToLongStrBufAndErr(c);
               continue;
             }
+            case ' ':
+            case '\t':
+            case '\f': {
+              adjustDoubleHyphenAndAppendToLongStrBufAndErr(c);
+              state = NS_HTML5TOKENIZER_COMMENT_END_SPACE;
+              goto commentendloop_end;
+            }
             case '\r': {
               adjustDoubleHyphenAndAppendToLongStrBufCarriageReturn();
-              state = NS_HTML5TOKENIZER_COMMENT;
+              state = NS_HTML5TOKENIZER_COMMENT_END_SPACE;
               goto stateloop_end;
             }
             case '\n': {
               adjustDoubleHyphenAndAppendToLongStrBufLineFeed();
-              state = NS_HTML5TOKENIZER_COMMENT;
+              state = NS_HTML5TOKENIZER_COMMENT_END_SPACE;
+              goto commentendloop_end;
+            }
+            case '!': {
+
+              appendLongStrBuf(c);
+              state = NS_HTML5TOKENIZER_COMMENT_END_BANG;
               goto stateloop;
             }
             case '\0': {
               c = 0xfffd;
             }
             default: {
-              adjustDoubleHyphenAndAppendToLongStrBuf(c);
+              adjustDoubleHyphenAndAppendToLongStrBufAndErr(c);
+              state = NS_HTML5TOKENIZER_COMMENT;
+              goto stateloop;
+            }
+          }
+        }
+        commentendloop_end: ;
+      }
+      case NS_HTML5TOKENIZER_COMMENT_END_SPACE: {
+        for (; ; ) {
+          if (++pos == endPos) {
+            goto stateloop_end;
+          }
+          c = checkChar(buf, pos);
+          switch(c) {
+            case '>': {
+              emitComment(0, pos);
+              state = NS_HTML5TOKENIZER_DATA;
+              goto stateloop;
+            }
+            case '-': {
+              appendLongStrBuf(c);
+              state = NS_HTML5TOKENIZER_COMMENT_END_DASH;
+              goto stateloop;
+            }
+            case ' ':
+            case '\t':
+            case '\f': {
+              appendLongStrBuf(c);
+              continue;
+            }
+            case '\r': {
+              appendLongStrBufCarriageReturn();
+              goto stateloop_end;
+            }
+            case '\n': {
+              appendLongStrBufLineFeed();
+              continue;
+            }
+            case '\0': {
+              c = 0xfffd;
+            }
+            default: {
+              appendLongStrBuf(c);
+              state = NS_HTML5TOKENIZER_COMMENT;
+              goto stateloop;
+            }
+          }
+        }
+      }
+      case NS_HTML5TOKENIZER_COMMENT_END_BANG: {
+        for (; ; ) {
+          if (++pos == endPos) {
+            goto stateloop_end;
+          }
+          c = checkChar(buf, pos);
+          switch(c) {
+            case '>': {
+              emitComment(3, pos);
+              state = NS_HTML5TOKENIZER_DATA;
+              goto stateloop;
+            }
+            case '-': {
+              appendLongStrBuf(c);
+              state = NS_HTML5TOKENIZER_COMMENT_END_DASH;
+              goto stateloop;
+            }
+            case '\r': {
+              appendLongStrBufCarriageReturn();
+              goto stateloop_end;
+            }
+            case '\n': {
+              appendLongStrBufLineFeed();
+              continue;
+            }
+            case '\0': {
+              c = 0xfffd;
+            }
+            default: {
+              appendLongStrBuf(c);
               state = NS_HTML5TOKENIZER_COMMENT;
               goto stateloop;
             }
           }
         }
       }
       case NS_HTML5TOKENIZER_COMMENT_START_DASH: {
         if (++pos == endPos) {
@@ -2936,32 +3032,38 @@ nsHtml5Tokenizer::eof()
           systemIdentifier = nsnull;
           forceQuirks = PR_TRUE;
           emitDoctypeToken(0);
           goto eofloop_end;
         }
         goto eofloop_end;
       }
       case NS_HTML5TOKENIZER_COMMENT_START:
-      case NS_HTML5TOKENIZER_COMMENT: {
+      case NS_HTML5TOKENIZER_COMMENT:
+      case NS_HTML5TOKENIZER_COMMENT_END_SPACE: {
 
         emitComment(0, 0);
         goto eofloop_end;
       }
       case NS_HTML5TOKENIZER_COMMENT_END: {
 
         emitComment(2, 0);
         goto eofloop_end;
       }
       case NS_HTML5TOKENIZER_COMMENT_END_DASH:
       case NS_HTML5TOKENIZER_COMMENT_START_DASH: {
 
         emitComment(1, 0);
         goto eofloop_end;
       }
+      case NS_HTML5TOKENIZER_COMMENT_END_BANG: {
+
+        emitComment(3, 0);
+        goto eofloop_end;
+      }
       case NS_HTML5TOKENIZER_DOCTYPE:
       case NS_HTML5TOKENIZER_BEFORE_DOCTYPE_NAME: {
 
         forceQuirks = PR_TRUE;
         emitDoctypeToken(0);
         goto eofloop_end;
       }
       case NS_HTML5TOKENIZER_DOCTYPE_NAME: {
diff --git a/parser/html/nsHtml5Tokenizer.h b/parser/html/nsHtml5Tokenizer.h
--- a/parser/html/nsHtml5Tokenizer.h
+++ b/parser/html/nsHtml5Tokenizer.h
@@ -161,17 +161,17 @@ class nsHtml5Tokenizer
     void strBufToDoctypeName();
     void emitStrBuf();
     void clearLongStrBufForNextState();
     void clearLongStrBuf();
     void clearLongStrBufAndAppendCurrentC(PRUnichar c);
     void clearLongStrBufAndAppendToComment(PRUnichar c);
     void appendLongStrBuf(PRUnichar c);
     void appendSecondHyphenToBogusComment();
-    void adjustDoubleHyphenAndAppendToLongStrBuf(PRUnichar c);
+    void adjustDoubleHyphenAndAppendToLongStrBufAndErr(PRUnichar c);
     void appendLongStrBuf(jArray<PRUnichar,PRInt32> buffer, PRInt32 offset, PRInt32 length);
     void appendLongStrBuf(jArray<PRUnichar,PRInt32> arr);
     void appendStrBufToLongStrBuf();
     nsString* longStrBufToString();
     void emitComment(PRInt32 provisionalHyphens, PRInt32 pos);
   protected:
     void flushChars(PRUnichar* buf, PRInt32 pos);
   private:
@@ -194,23 +194,23 @@ class nsHtml5Tokenizer
       systemIdentifier = nsnull;
       publicIdentifier = nsnull;
       forceQuirks = PR_FALSE;
     }
 
     inline void adjustDoubleHyphenAndAppendToLongStrBufCarriageReturn()
     {
       silentCarriageReturn();
-      adjustDoubleHyphenAndAppendToLongStrBuf('\n');
+      adjustDoubleHyphenAndAppendToLongStrBufAndErr('\n');
     }
 
     inline void adjustDoubleHyphenAndAppendToLongStrBufLineFeed()
     {
       silentLineFeed();
-      adjustDoubleHyphenAndAppendToLongStrBuf('\n');
+      adjustDoubleHyphenAndAppendToLongStrBufAndErr('\n');
     }
 
     inline void appendLongStrBufLineFeed()
     {
       silentLineFeed();
       appendLongStrBuf('\n');
     }
 
@@ -290,68 +290,70 @@ jArray<PRUnichar,PRInt32> nsHtml5Tokeniz
 jArray<PRUnichar,PRInt32> nsHtml5Tokenizer::NOSCRIPT_ARR = 0;
 jArray<PRUnichar,PRInt32> nsHtml5Tokenizer::NOFRAMES_ARR = 0;
 #endif
 
 #define NS_HTML5TOKENIZER_DATA 0
 #define NS_HTML5TOKENIZER_RCDATA 1
 #define NS_HTML5TOKENIZER_CDATA 2
 #define NS_HTML5TOKENIZER_PLAINTEXT 3
-#define NS_HTML5TOKENIZER_TAG_OPEN 49
-#define NS_HTML5TOKENIZER_CLOSE_TAG_OPEN_PCDATA 50
-#define NS_HTML5TOKENIZER_TAG_NAME 58
-#define NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_NAME 4
-#define NS_HTML5TOKENIZER_ATTRIBUTE_NAME 5
-#define NS_HTML5TOKENIZER_AFTER_ATTRIBUTE_NAME 6
-#define NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_VALUE 7
-#define NS_HTML5TOKENIZER_ATTRIBUTE_VALUE_DOUBLE_QUOTED 8
-#define NS_HTML5TOKENIZER_ATTRIBUTE_VALUE_SINGLE_QUOTED 9
-#define NS_HTML5TOKENIZER_ATTRIBUTE_VALUE_UNQUOTED 10
-#define NS_HTML5TOKENIZER_AFTER_ATTRIBUTE_VALUE_QUOTED 11
-#define NS_HTML5TOKENIZER_BOGUS_COMMENT 12
-#define NS_HTML5TOKENIZER_MARKUP_DECLARATION_OPEN 13
-#define NS_HTML5TOKENIZER_DOCTYPE 14
-#define NS_HTML5TOKENIZER_BEFORE_DOCTYPE_NAME 15
-#define NS_HTML5TOKENIZER_DOCTYPE_NAME 16
-#define NS_HTML5TOKENIZER_AFTER_DOCTYPE_NAME 17
-#define NS_HTML5TOKENIZER_BEFORE_DOCTYPE_PUBLIC_IDENTIFIER 18
-#define NS_HTML5TOKENIZER_DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED 19
-#define NS_HTML5TOKENIZER_DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED 20
-#define NS_HTML5TOKENIZER_AFTER_DOCTYPE_PUBLIC_IDENTIFIER 21
-#define NS_HTML5TOKENIZER_BEFORE_DOCTYPE_SYSTEM_IDENTIFIER 22
-#define NS_HTML5TOKENIZER_DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED 23
-#define NS_HTML5TOKENIZER_DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED 24
-#define NS_HTML5TOKENIZER_AFTER_DOCTYPE_SYSTEM_IDENTIFIER 25
-#define NS_HTML5TOKENIZER_BOGUS_DOCTYPE 26
-#define NS_HTML5TOKENIZER_COMMENT_START 27
-#define NS_HTML5TOKENIZER_COMMENT_START_DASH 28
-#define NS_HTML5TOKENIZER_COMMENT 29
-#define NS_HTML5TOKENIZER_COMMENT_END_DASH 30
-#define NS_HTML5TOKENIZER_COMMENT_END 31
-#define NS_HTML5TOKENIZER_CLOSE_TAG_OPEN_NOT_PCDATA 32
-#define NS_HTML5TOKENIZER_MARKUP_DECLARATION_HYPHEN 33
-#define NS_HTML5TOKENIZER_MARKUP_DECLARATION_OCTYPE 34
-#define NS_HTML5TOKENIZER_DOCTYPE_UBLIC 35
-#define NS_HTML5TOKENIZER_DOCTYPE_YSTEM 36
-#define NS_HTML5TOKENIZER_CONSUME_CHARACTER_REFERENCE 37
-#define NS_HTML5TOKENIZER_CONSUME_NCR 38
-#define NS_HTML5TOKENIZER_CHARACTER_REFERENCE_LOOP 39
-#define NS_HTML5TOKENIZER_HEX_NCR_LOOP 41
-#define NS_HTML5TOKENIZER_DECIMAL_NRC_LOOP 42
-#define NS_HTML5TOKENIZER_HANDLE_NCR_VALUE 43
-#define NS_HTML5TOKENIZER_SELF_CLOSING_START_TAG 44
-#define NS_HTML5TOKENIZER_CDATA_START 45
-#define NS_HTML5TOKENIZER_CDATA_SECTION 46
-#define NS_HTML5TOKENIZER_CDATA_RSQB 47
-#define NS_HTML5TOKENIZER_CDATA_RSQB_RSQB 48
-#define NS_HTML5TOKENIZER_TAG_OPEN_NON_PCDATA 51
-#define NS_HTML5TOKENIZER_ESCAPE_EXCLAMATION 52
-#define NS_HTML5TOKENIZER_ESCAPE_EXCLAMATION_HYPHEN 53
-#define NS_HTML5TOKENIZER_ESCAPE 54
-#define NS_HTML5TOKENIZER_ESCAPE_HYPHEN 55
-#define NS_HTML5TOKENIZER_ESCAPE_HYPHEN_HYPHEN 56
-#define NS_HTML5TOKENIZER_BOGUS_COMMENT_HYPHEN 57
+#define NS_HTML5TOKENIZER_TAG_OPEN 4
+#define NS_HTML5TOKENIZER_CLOSE_TAG_OPEN_PCDATA 5
+#define NS_HTML5TOKENIZER_TAG_NAME 6
+#define NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_NAME 7
+#define NS_HTML5TOKENIZER_ATTRIBUTE_NAME 8
+#define NS_HTML5TOKENIZER_AFTER_ATTRIBUTE_NAME 9
+#define NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_VALUE 10
+#define NS_HTML5TOKENIZER_ATTRIBUTE_VALUE_DOUBLE_QUOTED 11
+#define NS_HTML5TOKENIZER_ATTRIBUTE_VALUE_SINGLE_QUOTED 12
+#define NS_HTML5TOKENIZER_ATTRIBUTE_VALUE_UNQUOTED 13
+#define NS_HTML5TOKENIZER_AFTER_ATTRIBUTE_VALUE_QUOTED 14
+#define NS_HTML5TOKENIZER_BOGUS_COMMENT 15
+#define NS_HTML5TOKENIZER_MARKUP_DECLARATION_OPEN 16
+#define NS_HTML5TOKENIZER_DOCTYPE 17
+#define NS_HTML5TOKENIZER_BEFORE_DOCTYPE_NAME 18
+#define NS_HTML5TOKENIZER_DOCTYPE_NAME 19
+#define NS_HTML5TOKENIZER_AFTER_DOCTYPE_NAME 20
+#define NS_HTML5TOKENIZER_BEFORE_DOCTYPE_PUBLIC_IDENTIFIER 21
+#define NS_HTML5TOKENIZER_DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED 22
+#define NS_HTML5TOKENIZER_DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED 23
+#define NS_HTML5TOKENIZER_AFTER_DOCTYPE_PUBLIC_IDENTIFIER 24
+#define NS_HTML5TOKENIZER_BEFORE_DOCTYPE_SYSTEM_IDENTIFIER 25
+#define NS_HTML5TOKENIZER_DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED 26
+#define NS_HTML5TOKENIZER_DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED 27
+#define NS_HTML5TOKENIZER_AFTER_DOCTYPE_SYSTEM_IDENTIFIER 28
+#define NS_HTML5TOKENIZER_BOGUS_DOCTYPE 29
+#define NS_HTML5TOKENIZER_COMMENT_START 30
+#define NS_HTML5TOKENIZER_COMMENT_START_DASH 31
+#define NS_HTML5TOKENIZER_COMMENT 32
+#define NS_HTML5TOKENIZER_COMMENT_END_DASH 33
+#define NS_HTML5TOKENIZER_COMMENT_END 34
+#define NS_HTML5TOKENIZER_COMMENT_END_SPACE 35
+#define NS_HTML5TOKENIZER_COMMENT_END_BANG 36
+#define NS_HTML5TOKENIZER_CLOSE_TAG_OPEN_NOT_PCDATA 37
+#define NS_HTML5TOKENIZER_MARKUP_DECLARATION_HYPHEN 38
+#define NS_HTML5TOKENIZER_MARKUP_DECLARATION_OCTYPE 39
+#define NS_HTML5TOKENIZER_DOCTYPE_UBLIC 40
+#define NS_HTML5TOKENIZER_DOCTYPE_YSTEM 41
+#define NS_HTML5TOKENIZER_CONSUME_CHARACTER_REFERENCE 42
+#define NS_HTML5TOKENIZER_CONSUME_NCR 43
+#define NS_HTML5TOKENIZER_CHARACTER_REFERENCE_LOOP 44
+#define NS_HTML5TOKENIZER_HEX_NCR_LOOP 45
+#define NS_HTML5TOKENIZER_DECIMAL_NRC_LOOP 46
+#define NS_HTML5TOKENIZER_HANDLE_NCR_VALUE 47
+#define NS_HTML5TOKENIZER_SELF_CLOSING_START_TAG 48
+#define NS_HTML5TOKENIZER_CDATA_START 49
+#define NS_HTML5TOKENIZER_CDATA_SECTION 50
+#define NS_HTML5TOKENIZER_CDATA_RSQB 51
+#define NS_HTML5TOKENIZER_CDATA_RSQB_RSQB 52
+#define NS_HTML5TOKENIZER_TAG_OPEN_NON_PCDATA 53
+#define NS_HTML5TOKENIZER_ESCAPE_EXCLAMATION 54
+#define NS_HTML5TOKENIZER_ESCAPE_EXCLAMATION_HYPHEN 55
+#define NS_HTML5TOKENIZER_ESCAPE 56
+#define NS_HTML5TOKENIZER_ESCAPE_HYPHEN 57
+#define NS_HTML5TOKENIZER_ESCAPE_HYPHEN_HYPHEN 58
+#define NS_HTML5TOKENIZER_BOGUS_COMMENT_HYPHEN 59
 #define NS_HTML5TOKENIZER_LEAD_OFFSET (0xD800 - (0x10000 >> 10))
 #define NS_HTML5TOKENIZER_BUFFER_GROW_BY 1024
 
 
 #endif
 
diff --git a/parser/html/nsHtml5TreeBuilder.cpp b/parser/html/nsHtml5TreeBuilder.cpp
--- a/parser/html/nsHtml5TreeBuilder.cpp
+++ b/parser/html/nsHtml5TreeBuilder.cpp
@@ -1846,25 +1846,25 @@ nsHtml5TreeBuilder::extractCharsetFromCo
           default: {
             continue;
           }
         }
       }
     }
   }
   charsetloop_end: ;
-  nsString* rv = nsnull;
+  nsString* charset = nsnull;
   if (start != -1) {
     if (end == -1) {
       end = buffer.length;
     }
-    rv = nsHtml5Portability::newStringFromBuffer(buffer, start, end - start);
+    charset = nsHtml5Portability::newStringFromBuffer(buffer, start, end - start);
   }
   buffer.release();
-  return rv;
+  return charset;
 }
 
 void 
 nsHtml5TreeBuilder::checkMetaCharset(nsHtml5HtmlAttributes* attributes)
 {
   nsString* content = attributes->getValue(nsHtml5AttributeName::ATTR_CONTENT);
   nsString* internalCharsetLegacy = nsnull;
   if (!!content) {
