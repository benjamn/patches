diff --git a/parser/html/java/Makefile b/parser/html/java/Makefile
new file mode 100644
--- /dev/null
+++ b/parser/html/java/Makefile
@@ -0,0 +1,56 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Makefile.
+#
+# The Initial Developer of the Original Code is
+#   Ben Newman <b{enjam,newma}n@mozilla.com>
+#
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+libs:: clean \
+; cd javaparser && \
+    make libs && mv javaparser.jar ../ && \
+  cd ../translator && \
+    make libs && mv translator.jar ../ && \
+  cd ..
+
+sync:: clean \
+; cd javaparser ; make sync ; cd .. ; \
+  cd translator ; make sync ; cd .. ; \
+  cd htmlparser ; make sync ; cd ..
+
+translate:: \
+; java -jar translator.jar htmlparser/src .. ../nsHtml5AtomList.h
+
+clean:: \
+; cd javaparser ; make clean ; cd .. ; \
+  cd translator ; make clean ; cd .. ; \
+  rm -rf *.jar
diff --git a/parser/html/java/README.txt b/parser/html/java/README.txt
new file mode 100644
--- /dev/null
+++ b/parser/html/java/README.txt
@@ -0,0 +1,13 @@
+If this is your first time building the HTML5 parser, you need to execute the
+following commands (from this directory) to bootstrap the translation:
+
+  make sync      # fetch remote source files and licenses
+  make           # build javaparser.jar and translator.jar
+  make translate # perform the Java-to-C++ translation
+
+If you make changes to the translator or the javaparser, you can rebuild by
+retyping 'make' in this directory.  If you make changes to the HTML5 java
+implementation, you can retranslate the java sources by retyping 'make
+translate' in this directory.
+
+Ben Newman (8 July 2009)
diff --git a/parser/html/java/htmlparser/Makefile b/parser/html/java/htmlparser/Makefile
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/Makefile
@@ -0,0 +1,41 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Makefile.
+#
+# The Initial Developer of the Original Code is
+#   Ben Newman <b{enjam,newma}n@mozilla.com>
+#
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+sync:: \
+; rm -rf src && \
+  svn co http://svn.versiondude.net/whattf/htmlparser/trunk/src/nu/validator/htmlparser/impl src && \
+  find src -name .svn | xargs rm -rf
diff --git a/parser/html/java/htmlparser/src/AttributeName.java b/parser/html/java/htmlparser/src/AttributeName.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/AttributeName.java
@@ -0,0 +1,2789 @@
+/*
+ * Copyright (c) 2008-2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import java.util.Arrays;
+
+import nu.validator.htmlparser.annotation.IdType;
+import nu.validator.htmlparser.annotation.Local;
+import nu.validator.htmlparser.annotation.NoLength;
+import nu.validator.htmlparser.annotation.NsUri;
+import nu.validator.htmlparser.annotation.Prefix;
+import nu.validator.htmlparser.annotation.QName;
+import nu.validator.htmlparser.annotation.Virtual;
+
+public final class AttributeName
+// Uncomment to regenerate
+//        implements Comparable<AttributeName> 
+{
+
+    private static final @NoLength @NsUri String[] ALL_NO_NS = { "", "", "",
+    // [NOCPP[
+            ""
+    // ]NOCPP]
+    };
+
+    private static final @NoLength @NsUri String[] XMLNS_NS = { "",
+            "http://www.w3.org/2000/xmlns/", "http://www.w3.org/2000/xmlns/",
+            // [NOCPP[
+            ""
+    // ]NOCPP]
+    };
+
+    private static final @NoLength @NsUri String[] XML_NS = { "",
+            "http://www.w3.org/XML/1998/namespace",
+            "http://www.w3.org/XML/1998/namespace",
+            // [NOCPP[
+            ""
+    // ]NOCPP]
+    };
+
+    private static final @NoLength @NsUri String[] XLINK_NS = { "",
+            "http://www.w3.org/1999/xlink", "http://www.w3.org/1999/xlink",
+            // [NOCPP[
+            ""
+    // ]NOCPP]
+    };
+
+    // [NOCPP[
+    private static final @NoLength @NsUri String[] LANG_NS = { "", "", "",
+            "http://www.w3.org/XML/1998/namespace" };
+
+    // ]NOCPP]
+
+    private static final @NoLength @Prefix String[] ALL_NO_PREFIX = { null,
+            null, null,
+            // [NOCPP[
+            null
+    // ]NOCPP]
+    };
+
+    private static final @NoLength @Prefix String[] XMLNS_PREFIX = { null,
+            "xmlns", "xmlns",
+            // [NOCPP[
+            null
+    // ]NOCPP]
+    };
+
+    private static final @NoLength @Prefix String[] XLINK_PREFIX = { null,
+            "xlink", "xlink",
+            // [NOCPP[
+            null
+    // ]NOCPP]
+    };
+
+    private static final @NoLength @Prefix String[] XML_PREFIX = { null, "xml",
+            "xml",
+            // [NOCPP[
+            null
+    // ]NOCPP]
+    };
+
+    // [NOCPP[
+
+    private static final @NoLength @Prefix String[] LANG_PREFIX = { null, null,
+            null, "xml" };
+
+    private static final boolean[] ALL_NCNAME = { true, true, true, true };
+
+    private static final boolean[] ALL_NO_NCNAME = { false, false, false, false };
+
+    private static @QName String[] COMPUTE_QNAME(String[] local, String[] prefix) {
+        @QName String[] arr = new String[4];
+        for (int i = 0; i < arr.length; i++) {
+            if (prefix[i] == null) {
+                arr[i] = local[i];
+            } else {
+                arr[i] = (prefix[i] + ':' + local[i]).intern();
+            }
+        }
+        return arr;
+    }
+
+    // ]NOCPP]
+
+    private static @NoLength @Local String[] SVG_DIFFERENT(@Local String name,
+            @Local String camel) {
+        @NoLength @Local String[] arr = new String[4];
+        arr[0] = name;
+        arr[1] = name;
+        arr[2] = camel;
+        // [NOCPP[
+        arr[3] = name;
+        // ]NOCPP]
+        return arr;
+    }
+
+    private static @NoLength @Local String[] MATH_DIFFERENT(@Local String name,
+            @Local String camel) {
+        @NoLength @Local String[] arr = new String[4];
+        arr[0] = name;
+        arr[1] = camel;
+        arr[2] = name;
+        // [NOCPP[
+        arr[3] = name;
+        // ]NOCPP]
+        return arr;
+    }
+
+    private static @NoLength @Local String[] COLONIFIED_LOCAL(
+            @Local String name, @Local String suffix) {
+        @NoLength @Local String[] arr = new String[4];
+        arr[0] = name;
+        arr[1] = suffix;
+        arr[2] = suffix;
+        // [NOCPP[
+        arr[3] = name;
+        // ]NOCPP]
+        return arr;
+    }
+
+    private static @NoLength @Local String[] SAME_LOCAL(@Local String name) {
+        @NoLength @Local String[] arr = new String[4];
+        arr[0] = name;
+        arr[1] = name;
+        arr[2] = name;
+        // [NOCPP[
+        arr[3] = name;
+        // ]NOCPP]
+        return arr;
+    }
+
+    /**
+     * Returns an attribute name by buffer.
+     * 
+     * <p>
+     * C++ ownership: The return value is either released by the caller if the
+     * attribute is a duplicate or the ownership is transferred to
+     * HtmlAttributes and released upon clearing or destroying that object.
+     * 
+     * @param buf
+     * @param offset
+     * @param length
+     * @param checkNcName
+     * @return
+     */
+    static AttributeName nameByBuffer(@NoLength char[] buf, int offset,
+            int length
+            // [NOCPP[
+            , boolean checkNcName
+    // ]NOCPP]
+    ) {
+        // XXX deal with offset
+        int hash = AttributeName.bufToHash(buf, length);
+        int index = Arrays.binarySearch(AttributeName.ATTRIBUTE_HASHES, hash);
+        if (index < 0) {
+            return AttributeName.createAttributeName(
+                    Portability.newLocalNameFromBuffer(buf, offset, length)
+                    // [NOCPP[
+                    , checkNcName
+            // ]NOCPP]
+            );
+        } else {
+            AttributeName attributeName = AttributeName.ATTRIBUTE_NAMES[index];
+            @Local String name = attributeName.getLocal(AttributeName.HTML);
+            if (!Portability.localEqualsBuffer(name, buf, offset, length)) {
+                return AttributeName.createAttributeName(
+                        Portability.newLocalNameFromBuffer(buf, offset, length)
+                        // [NOCPP[
+                        , checkNcName
+                // ]NOCPP]
+                );
+            }
+            return attributeName;
+        }
+    }
+
+    /**
+     * This method has to return a unique integer for each well-known
+     * lower-cased attribute name.
+     * 
+     * @param buf
+     * @param len
+     * @return
+     */
+    private static int bufToHash(@NoLength char[] buf, int len) {
+        int hash2 = 0;
+        int hash = len;
+        hash <<= 5;
+        hash += buf[0] - 0x60;
+        int j = len;
+        for (int i = 0; i < 4 && j > 0; i++) {
+            j--;
+            hash <<= 5;
+            hash += buf[j] - 0x60;
+            hash2 <<= 6;
+            hash2 += buf[i] - 0x5F;
+        }
+        return hash ^ hash2;
+    }
+
+    public static final int HTML = 0;
+
+    public static final int MATHML = 1;
+
+    public static final int SVG = 2;
+
+    // [NOCPP[
+
+    public static final int HTML_LANG = 3;
+
+    private final @IdType String type;
+
+    // ]NOCPP]
+
+    private final @NsUri @NoLength String[] uri;
+
+    private final @Local @NoLength String[] local;
+
+    private final @Prefix @NoLength String[] prefix;
+
+    // [NOCPP[
+
+    private final @QName @NoLength String[] qName;
+
+    // XXX convert to bitfield
+    private final @NoLength boolean[] ncname;
+
+    private final boolean xmlns;
+
+    /**
+     * @param type
+     * @param uri
+     * @param local
+     * @param name
+     * @param ncname
+     * @param xmlns
+     */
+    private AttributeName(@NsUri @NoLength String[] uri,
+            @Local @NoLength String[] local, @Prefix @NoLength String[] prefix,
+            @NoLength boolean[] ncname, boolean xmlns, @IdType String type) {
+        this.type = type;
+        this.uri = uri;
+        this.local = local;
+        this.prefix = prefix;
+
+        this.qName = COMPUTE_QNAME(local, prefix);
+        this.ncname = ncname;
+        this.xmlns = xmlns;
+    }
+
+    // ]NOCPP]
+
+    protected AttributeName(@NsUri @NoLength String[] uri,
+            @Local @NoLength String[] local, @Prefix @NoLength String[] prefix
+            // [NOCPP[
+            , @NoLength boolean[] ncname, boolean xmlns
+    // ]NOCPP]
+    ) {
+        // [NOCPP[
+        this.type = "CDATA";
+        // ]NOCPP]
+        this.uri = uri;
+        this.local = local;
+        this.prefix = prefix;
+        // [NOCPP[
+        this.qName = COMPUTE_QNAME(local, prefix);
+        this.ncname = ncname;
+        this.xmlns = xmlns;
+        // ]NOCPP]
+    }
+
+    private static AttributeName createAttributeName(@Local String name
+    // [NOCPP[
+            , boolean checkNcName
+    // ]NOCPP]
+    ) {
+        // [NOCPP[
+        boolean ncName = true;
+        boolean xmlns = name.startsWith("xmlns:");
+        if (checkNcName) {
+            if (xmlns) {
+                ncName = false;
+            } else {
+                ncName = NCName.isNCName(name);
+            }
+        }
+        // ]NOCPP]
+        return new AttributeName(AttributeName.ALL_NO_NS,
+                AttributeName.SAME_LOCAL(name), ALL_NO_PREFIX
+                // ]NOCPP]
+                , (ncName ? AttributeName.ALL_NCNAME
+                        : AttributeName.ALL_NO_NCNAME), xmlns
+        // ]NOCPP]
+        );
+    }
+
+    @Virtual void release() {
+        // No-op in Java.
+        // Implement as |delete this;| in subclass.
+    }
+
+    @SuppressWarnings("unused") private void destructor() {
+        Portability.releaseLocal(local[0]); // this must be a no-op for static
+        // locals
+        // for non-static cases the other array slots contain the same pointer
+        // as weak references.
+        Portability.deleteArray(local);
+    }
+
+    // [NOCPP[
+    static AttributeName create(@Local String name) {
+        return new AttributeName(AttributeName.ALL_NO_NS,
+                AttributeName.SAME_LOCAL(name), ALL_NO_PREFIX,
+                AttributeName.ALL_NCNAME, false);
+    }
+
+    public boolean isNcName(int mode) {
+        return ncname[mode];
+    }
+
+    public boolean isXmlns() {
+        return xmlns;
+    }
+
+    boolean isCaseFolded() {
+        return this == AttributeName.ACTIVE || this == AttributeName.ALIGN
+                || this == AttributeName.ASYNC
+                || this == AttributeName.AUTOCOMPLETE
+                || this == AttributeName.AUTOFOCUS
+                || this == AttributeName.AUTOSUBMIT
+                || this == AttributeName.CHECKED || this == AttributeName.CLEAR
+                || this == AttributeName.COMPACT
+                || this == AttributeName.DATAFORMATAS
+                || this == AttributeName.DECLARE
+                || this == AttributeName.DEFAULT || this == AttributeName.DEFER
+                || this == AttributeName.DIR || this == AttributeName.DISABLED
+                || this == AttributeName.ENCTYPE || this == AttributeName.FRAME
+                || this == AttributeName.ISMAP || this == AttributeName.METHOD
+                || this == AttributeName.MULTIPLE
+                || this == AttributeName.NOHREF
+                || this == AttributeName.NORESIZE
+                || this == AttributeName.NOSHADE
+                || this == AttributeName.NOWRAP
+                || this == AttributeName.READONLY
+                || this == AttributeName.REPLACE
+                || this == AttributeName.REQUIRED
+                || this == AttributeName.RULES || this == AttributeName.SCOPE
+                || this == AttributeName.SCROLLING
+                || this == AttributeName.SELECTED
+                || this == AttributeName.SHAPE || this == AttributeName.STEP
+                || this == AttributeName.TYPE || this == AttributeName.VALIGN
+                || this == AttributeName.VALUETYPE;
+    }
+
+    boolean isBoolean() {
+        return this == AttributeName.ACTIVE || this == AttributeName.ASYNC
+                || this == AttributeName.AUTOFOCUS
+                || this == AttributeName.AUTOSUBMIT
+                || this == AttributeName.CHECKED
+                || this == AttributeName.COMPACT
+                || this == AttributeName.DECLARE
+                || this == AttributeName.DEFAULT || this == AttributeName.DEFER
+                || this == AttributeName.DISABLED
+                || this == AttributeName.ISMAP
+                || this == AttributeName.MULTIPLE
+                || this == AttributeName.NOHREF
+                || this == AttributeName.NORESIZE
+                || this == AttributeName.NOSHADE
+                || this == AttributeName.NOWRAP
+                || this == AttributeName.READONLY
+                || this == AttributeName.REQUIRED
+                || this == AttributeName.SELECTED;
+    }
+
+    public @QName String getQName(int mode) {
+        return qName[mode];
+    }
+
+    public @IdType String getType(int mode) {
+        return type;
+    }
+
+    // ]NOCPP]
+
+    public @NsUri String getUri(int mode) {
+        return uri[mode];
+    }
+
+    public @Local String getLocal(int mode) {
+        return local[mode];
+    }
+
+    public @Prefix String getPrefix(int mode) {
+        return prefix[mode];
+    }
+
+    boolean equalsAnother(AttributeName another) {
+        return this.getLocal(AttributeName.HTML) == another.getLocal(AttributeName.HTML);
+    }
+
+    // START CODE ONLY USED FOR GENERATING CODE uncomment to regenerate
+
+//    /**
+//     * @see java.lang.Object#toString()
+//     */
+//    @Override public String toString() {
+//        return "(" + formatNs() + ", " + formatLocal() + ", " + formatPrefix()
+//                + ", " + formatNcname() + ", " + (xmlns ? "true" : "false")
+//                + ("ID" == type ? ", \"ID\"" : "") + ")";
+//    }
+//
+//    public int compareTo(AttributeName other) {
+//        int thisHash = this.hash();
+//        int otherHash = other.hash();
+//        if (thisHash < otherHash) {
+//            return -1;
+//        } else if (thisHash == otherHash) {
+//            return 0;
+//        } else {
+//            return 1;
+//        }
+//    }
+//
+//    private String formatPrefix() {
+//        if (prefix[0] == null && prefix[1] == null && prefix[2] == null
+//                && prefix[3] == null) {
+//            return "ALL_NO_PREFIX";
+//        } else if (prefix[0] == null && prefix[1] == prefix[2]
+//                && prefix[3] == null) {
+//            if ("xmlns".equals(prefix[1])) {
+//                return "XMLNS_PREFIX";
+//            } else if ("xml".equals(prefix[1])) {
+//                return "XML_PREFIX";
+//            } else if ("xlink".equals(prefix[1])) {
+//                return "XLINK_PREFIX";
+//            } else {
+//                throw new IllegalStateException();
+//            }
+//        } else if (prefix[0] == null && prefix[1] == null && prefix[2] == null
+//                && prefix[3] == "xml") {
+//            return "LANG_PREFIX";
+//        } else {
+//            throw new IllegalStateException();
+//        }
+//    }
+//
+//    private String formatLocal() {
+//        if (local[0] == local[1] && local[0] == local[3]
+//                && local[0] != local[2]) {
+//            return "SVG_DIFFERENT(\"" + local[0] + "\", \"" + local[2] + "\")";
+//        }
+//        if (local[0] == local[2] && local[0] == local[3]
+//                && local[0] != local[1]) {
+//            return "MATH_DIFFERENT(\"" + local[0] + "\", \"" + local[1] + "\")";
+//        }
+//        if (local[0] == local[3] && local[1] == local[2]
+//                && local[0] != local[1]) {
+//            return "COLONIFIED_LOCAL(\"" + local[0] + "\", \"" + local[1]
+//                    + "\")";
+//        }
+//        for (int i = 1; i < local.length; i++) {
+//            if (local[0] != local[i]) {
+//                throw new IllegalStateException();
+//            }
+//        }
+//        return "SAME_LOCAL(\"" + local[0] + "\")";
+//    }
+//
+//    private String formatNs() {
+//        if (uri[0] == "" && uri[1] == "" && uri[2] == "" && uri[3] == "") {
+//            return "ALL_NO_NS";
+//        } else if (uri[0] == "" && uri[1] == uri[2] && uri[3] == "") {
+//            if ("http://www.w3.org/2000/xmlns/".equals(uri[1])) {
+//                return "XMLNS_NS";
+//            } else if ("http://www.w3.org/XML/1998/namespace".equals(uri[1])) {
+//                return "XML_NS";
+//            } else if ("http://www.w3.org/1999/xlink".equals(uri[1])) {
+//                return "XLINK_NS";
+//            } else {
+//                throw new IllegalStateException();
+//            }
+//        } else if (uri[0] == "" && uri[1] == "" && uri[2] == ""
+//                && uri[3] == "http://www.w3.org/XML/1998/namespace") {
+//            return "LANG_NS";
+//        } else {
+//            throw new IllegalStateException();
+//        }
+//    }
+//
+//    private String formatNcname() {
+//        for (int i = 0; i < ncname.length; i++) {
+//            if (!ncname[i]) {
+//                return "new boolean[]{" + ncname[0] + ", " + ncname[1] + ", "
+//                        + ncname[2] + ", " + ncname[3] + "}";
+//            }
+//        }
+//        return "ALL_NCNAME";
+//    }
+//
+//    private String constName() {
+//        String name = getLocal(HTML);
+//        char[] buf = new char[name.length()];
+//        for (int i = 0; i < name.length(); i++) {
+//            char c = name.charAt(i);
+//            if (c == '-' || c == ':') {
+//                buf[i] = '_';
+//            } else if (c >= 'a' && c <= 'z') {
+//                buf[i] = (char) (c - 0x20);
+//            } else {
+//                buf[i] = c;
+//            }
+//        }
+//        return new String(buf);
+//    }
+//
+//    private int hash() {
+//        String name = getLocal(HTML);
+//        return bufToHash(name.toCharArray(), name.length());
+//    }
+//
+//    /**
+//     * Regenerate self
+//     * 
+//     * @param args
+//     */
+//    public static void main(String[] args) {
+//        Arrays.sort(ATTRIBUTE_NAMES);
+//        for (int i = 1; i < ATTRIBUTE_NAMES.length; i++) {
+//            if (ATTRIBUTE_NAMES[i].hash() == ATTRIBUTE_NAMES[i - 1].hash()) {
+//                System.err.println("Hash collision: "
+//                        + ATTRIBUTE_NAMES[i].getLocal(HTML) + ", "
+//                        + ATTRIBUTE_NAMES[i - 1].getLocal(HTML));
+//                return;
+//            }
+//        }
+//        for (int i = 0; i < ATTRIBUTE_NAMES.length; i++) {
+//            AttributeName att = ATTRIBUTE_NAMES[i];
+//            System.out.println("public static final AttributeName "
+//                    + att.constName() + " = new AttributeName" + att.toString()
+//                    + ";");
+//        }
+//        System.out.println("private final static @NoLength AttributeName[] ATTRIBUTE_NAMES = {");
+//        for (int i = 0; i < ATTRIBUTE_NAMES.length; i++) {
+//            AttributeName att = ATTRIBUTE_NAMES[i];
+//            System.out.println(att.constName() + ",");
+//        }
+//        System.out.println("};");
+//        System.out.println("private final static int[] ATTRIBUTE_HASHES = {");
+//        for (int i = 0; i < ATTRIBUTE_NAMES.length; i++) {
+//            AttributeName att = ATTRIBUTE_NAMES[i];
+//            System.out.println(Integer.toString(att.hash()) + ",");
+//        }
+//        System.out.println("};");
+//    }
+
+    // START GENERATED CODE
+    public static final AttributeName D = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("d"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName K = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("k"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName R = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("r"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName X = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("x"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName Y = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("y"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName Z = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("z"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("by"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("cx"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("cy"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("dx"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("dy"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName G2 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("g2"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName G1 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("g1"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fx"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fy"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName K4 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("k4"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName K2 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("k2"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName K3 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("k3"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName K1 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("k1"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ID = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("id"), ALL_NO_PREFIX, ALL_NCNAME, false, "ID");
+
+    public static final AttributeName IN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("in"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName U2 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("u2"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName U1 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("u1"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rt"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rx"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ry"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TO = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("to"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName Y2 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("y2"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName Y1 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("y1"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName X1 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("x1"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName X2 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("x2"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ALT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("alt"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DIR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("dir"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DUR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("dur"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName END = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("end"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("for"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName IN2 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("in2"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MAX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("max"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MIN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("min"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LOW = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("low"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REL = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rel"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REV = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rev"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SRC = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("src"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName AXIS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("axis"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ABBR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("abbr"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BBOX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("bbox"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CITE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("cite"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CODE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("code"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BIAS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("bias"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COLS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("cols"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLIP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("clip"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CHAR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("char"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BASE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("base"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName EDGE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("edge"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DATA = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("data"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FILL = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fill"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FROM = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("from"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FORM = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("form"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FACE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("face"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HIGH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("high"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HREF = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("href"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OPEN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("open"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ICON = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("icon"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NAME = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("name"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MODE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("mode"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MASK = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("mask"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LINK = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("link"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LANG = new AttributeName(LANG_NS,
+            SAME_LOCAL("lang"), LANG_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LIST = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("list"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TYPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("type"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName WHEN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("when"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName WRAP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("wrap"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TEXT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("text"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PATH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("path"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ping"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REFX = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("refx", "refX"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REFY = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("refy", "refY"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("size"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SEED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("seed"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ROWS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rows"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SPAN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("span"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STEP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("step"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ROLE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("role"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName XREF = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("xref"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ASYNC = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("async"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ALINK = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("alink"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ALIGN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("align"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLOSE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("close"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COLOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("color"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLASS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("class"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLEAR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("clear"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BEGIN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("begin"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DEPTH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("depth"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DEFER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("defer"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FENCE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fence"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FRAME = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("frame"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ISMAP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ismap"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONEND = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onend"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName INDEX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("index"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ORDER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("order"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OTHER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("other"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONCUT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("oncut"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NARGS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("nargs"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MEDIA = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("media"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LABEL = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("label"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LOCAL = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("local"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName WIDTH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("width"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TITLE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("title"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VLINK = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("vlink"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VALUE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("value"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SLOPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("slope"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SHAPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("shape"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCOPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("scope"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCALE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("scale"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SPEED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("speed"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STYLE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("style"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RULES = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rules"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STEMH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("stemh"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STEMV = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("stemv"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName START = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("start"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName XMLNS = new AttributeName(XMLNS_NS,
+            SAME_LOCAL("xmlns"), ALL_NO_PREFIX, new boolean[] { false, false,
+                    false, false }, true);
+
+    public static final AttributeName ACCEPT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("accept"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ACCENT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("accent"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ASCENT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ascent"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ACTIVE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("active"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ALTIMG = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("altimg"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ACTION = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("action"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BORDER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("border"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CURSOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("cursor"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COORDS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("coords"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FILTER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("filter"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FORMAT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("format"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HIDDEN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("hidden"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HSPACE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("hspace"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HEIGHT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("height"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONMOVE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onmove"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONLOAD = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onload"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDRAG = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ondrag"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ORIGIN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("origin"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONZOOM = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onzoom"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONHELP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onhelp"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONSTOP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onstop"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDROP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ondrop"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONBLUR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onblur"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OBJECT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("object"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OFFSET = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("offset"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ORIENT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("orient"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONCOPY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("oncopy"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NOWRAP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("nowrap"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NOHREF = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("nohref"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MACROS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("macros"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName METHOD = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("method"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LOWSRC = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("lowsrc"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LSPACE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("lspace"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LQUOTE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("lquote"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName USEMAP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("usemap"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName WIDTHS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("widths"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TARGET = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("target"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VALUES = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("values"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VALIGN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("valign"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VSPACE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("vspace"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName POSTER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("poster"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName POINTS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("points"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PROMPT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("prompt"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCOPED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("scoped"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STRING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("string"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCHEME = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("scheme"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STROKE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("stroke"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RADIUS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("radius"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RESULT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("result"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REPEAT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("repeat"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RSPACE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rspace"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ROTATE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rotate"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RQUOTE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rquote"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ALTTEXT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("alttext"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARCHIVE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("archive"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName AZIMUTH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("azimuth"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLOSURE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("closure"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CHECKED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("checked"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLASSID = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("classid"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CHAROFF = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("charoff"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BGCOLOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("bgcolor"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COLSPAN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("colspan"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CHARSET = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("charset"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COMPACT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("compact"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CONTENT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("content"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ENCTYPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("enctype"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DATASRC = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("datasrc"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DATAFLD = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("datafld"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DECLARE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("declare"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DISPLAY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("display"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DIVISOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("divisor"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DEFAULT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("default"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DESCENT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("descent"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName KERNING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("kerning"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HANGING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("hanging"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HEADERS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("headers"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONPASTE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onpaste"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONCLICK = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onclick"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OPTIMUM = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("optimum"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONBEGIN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onbegin"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONKEYUP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onkeyup"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONFOCUS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onfocus"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONERROR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onerror"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONINPUT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("oninput"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONABORT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onabort"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONSTART = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onstart"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONRESET = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onreset"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OPACITY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("opacity"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NOSHADE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("noshade"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MINSIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("minsize"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MAXSIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("maxsize"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LOOPEND = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("loopend"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LARGEOP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("largeop"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName UNICODE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("unicode"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TARGETX = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("targetx", "targetX"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName TARGETY = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("targety", "targetY"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName VIEWBOX = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("viewbox", "viewBox"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName VERSION = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("version"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PATTERN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("pattern"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PROFILE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("profile"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SPACING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("spacing"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RESTART = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("restart"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ROWSPAN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rowspan"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SANDBOX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("sandbox"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SUMMARY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("summary"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STANDBY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("standby"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REPLACE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("replace"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName AUTOPLAY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("autoplay"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ADDITIVE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("additive"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CALCMODE = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("calcmode", "calcMode"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName CODETYPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("codetype"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CODEBASE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("codebase"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CONTROLS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("controls"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BEVELLED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("bevelled"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BASELINE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("baseline"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName EXPONENT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("exponent"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName EDGEMODE = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("edgemode", "edgeMode"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ENCODING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("encoding"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName GLYPHREF = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("glyphref", "glyphRef"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName DATETIME = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("datetime"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DISABLED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("disabled"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONTSIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fontsize"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName KEYTIMES = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("keytimes", "keyTimes"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName PANOSE_1 = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("panose-1"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName HREFLANG = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("hreflang"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONRESIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onresize"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONCHANGE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onchange"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONBOUNCE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onbounce"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONUNLOAD = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onunload"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONFINISH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onfinish"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONSCROLL = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onscroll"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OPERATOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("operator"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OVERFLOW = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("overflow"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONSUBMIT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onsubmit"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONREPEAT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onrepeat"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONSELECT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onselect"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NOTATION = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("notation"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NORESIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("noresize"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MANIFEST = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("manifest"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MATHSIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("mathsize"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MULTIPLE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("multiple"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LONGDESC = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("longdesc"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LANGUAGE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("language"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TEMPLATE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("template"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TABINDEX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("tabindex"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName READONLY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("readonly"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SELECTED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("selected"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ROWLINES = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rowlines"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SEAMLESS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("seamless"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ROWALIGN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rowalign"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STRETCHY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("stretchy"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REQUIRED = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("required"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName XML_BASE = new AttributeName(XML_NS,
+            COLONIFIED_LOCAL("xml:base", "base"), XML_PREFIX, new boolean[] {
+                    false, true, true, false }, false);
+
+    public static final AttributeName XML_LANG = new AttributeName(XML_NS,
+            COLONIFIED_LOCAL("xml:lang", "lang"), XML_PREFIX, new boolean[] {
+                    false, true, true, false }, false);
+
+    public static final AttributeName X_HEIGHT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("x-height"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_OWNS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("aria-owns"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName AUTOFOCUS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("autofocus"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_SORT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("aria-sort"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ACCESSKEY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("accesskey"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_BUSY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("aria-busy"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_GRAB = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("aria-grab"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName AMPLITUDE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("amplitude"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_LIVE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("aria-live"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLIP_RULE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("clip-rule"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CLIP_PATH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("clip-path"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName EQUALROWS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("equalrows"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ELEVATION = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("elevation"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DIRECTION = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("direction"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DRAGGABLE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("draggable"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FILTERRES = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("filterres", "filterRes"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FILL_RULE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fill-rule"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONTSTYLE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fontstyle"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONT_SIZE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("font-size"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName KEYPOINTS = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("keypoints", "keyPoints"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName HIDEFOCUS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("hidefocus"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONMESSAGE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onmessage"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName INTERCEPT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("intercept"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDRAGEND = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ondragend"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONMOVEEND = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onmoveend"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONINVALID = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("oninvalid"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONKEYDOWN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onkeydown"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONFOCUSIN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onfocusin"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONMOUSEUP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onmouseup"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName INPUTMODE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("inputmode"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONROWEXIT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onrowexit"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MATHCOLOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("mathcolor"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MASKUNITS = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("maskunits", "maskUnits"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MAXLENGTH = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("maxlength"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LINEBREAK = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("linebreak"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName LOOPSTART = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("loopstart"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TRANSFORM = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("transform"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName V_HANGING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("v-hanging"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VALUETYPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("valuetype"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName POINTSATZ = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("pointsatz", "pointsAtZ"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName POINTSATX = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("pointsatx", "pointsAtX"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName POINTSATY = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("pointsaty", "pointsAtY"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName PLAYCOUNT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("playcount"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SYMMETRIC = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("symmetric"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCROLLING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("scrolling"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REPEATDUR = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("repeatdur", "repeatDur"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName SELECTION = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("selection"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SEPARATOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("separator"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName XML_SPACE = new AttributeName(XML_NS,
+            COLONIFIED_LOCAL("xml:space", "space"), XML_PREFIX, new boolean[] {
+                    false, true, true, false }, false);
+
+    public static final AttributeName AUTOSUBMIT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("autosubmit"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ALPHABETIC = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("alphabetic"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ACTIONTYPE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("actiontype"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ACCUMULATE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("accumulate"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_LEVEL = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("aria-level"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COLUMNSPAN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("columnspan"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName CAP_HEIGHT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("cap-height"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName BACKGROUND = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("background"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName GLYPH_NAME = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("glyph-name"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName GROUPALIGN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("groupalign"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONTFAMILY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fontfamily"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONTWEIGHT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("fontweight"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONT_STYLE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("font-style"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName KEYSPLINES = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("keysplines", "keySplines"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName HTTP_EQUIV = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("http-equiv"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONACTIVATE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onactivate"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName OCCURRENCE = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("occurrence"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName IRRELEVANT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("irrelevant"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDBLCLICK = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ondblclick"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDRAGDROP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ondragdrop"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONKEYPRESS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onkeypress"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONROWENTER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onrowenter"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDRAGOVER = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("ondragover"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONFOCUSOUT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onfocusout"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONMOUSEOUT = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("onmouseout"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName NUMOCTAVES = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("numoctaves", "numOctaves"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName MARKER_MID = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("marker-mid"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MARKER_END = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("marker-end"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TEXTLENGTH = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("textlength", "textLength"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName VISIBILITY = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("visibility"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VIEWTARGET = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("viewtarget", "viewTarget"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName VERT_ADV_Y = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("vert-adv-y"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PATHLENGTH = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("pathlength", "pathLength"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName REPEAT_MAX = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("repeat-max"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RADIOGROUP = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("radiogroup"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STOP_COLOR = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("stop-color"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SEPARATORS = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("separators"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REPEAT_MIN = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("repeat-min"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ROWSPACING = new AttributeName(ALL_NO_NS,
+            SAME_LOCAL("rowspacing"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ZOOMANDPAN = new AttributeName(ALL_NO_NS,
+            SVG_DIFFERENT("zoomandpan", "zoomAndPan"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName XLINK_TYPE = new AttributeName(XLINK_NS,
+            COLONIFIED_LOCAL("xlink:type", "type"), XLINK_PREFIX,
+            new boolean[] { false, true, true, false }, false);
+
+    public static final AttributeName XLINK_ROLE = new AttributeName(XLINK_NS,
+            COLONIFIED_LOCAL("xlink:role", "role"), XLINK_PREFIX,
+            new boolean[] { false, true, true, false }, false);
+
+    public static final AttributeName XLINK_HREF = new AttributeName(XLINK_NS,
+            COLONIFIED_LOCAL("xlink:href", "href"), XLINK_PREFIX,
+            new boolean[] { false, true, true, false }, false);
+
+    public static final AttributeName XLINK_SHOW = new AttributeName(XLINK_NS,
+            COLONIFIED_LOCAL("xlink:show", "show"), XLINK_PREFIX,
+            new boolean[] { false, true, true, false }, false);
+
+    public static final AttributeName ACCENTUNDER = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("accentunder"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_SECRET = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-secret"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_ATOMIC = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-atomic"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_HIDDEN = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-hidden"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_FLOWTO = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-flowto"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARABIC_FORM = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("arabic-form"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName CELLPADDING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("cellpadding"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName CELLSPACING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("cellspacing"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName COLUMNWIDTH = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("columnwidth"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName COLUMNALIGN = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("columnalign"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName COLUMNLINES = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("columnlines"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName CONTEXTMENU = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("contextmenu"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName BASEPROFILE = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("baseprofile", "baseProfile"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONT_FAMILY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("font-family"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FRAMEBORDER = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("frameborder"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FILTERUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("filterunits", "filterUnits"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FLOOD_COLOR = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("flood-color"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FONT_WEIGHT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("font-weight"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName HORIZ_ADV_X = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("horiz-adv-x"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONDRAGLEAVE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ondragleave"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONMOUSEMOVE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onmousemove"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ORIENTATION = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("orientation"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONMOUSEDOWN = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onmousedown"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONMOUSEOVER = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onmouseover"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONDRAGENTER = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ondragenter"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName IDEOGRAPHIC = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ideographic"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONBEFORECUT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforecut"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONFORMINPUT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onforminput"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONDRAGSTART = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ondragstart"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONMOVESTART = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onmovestart"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MARKERUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("markerunits", "markerUnits"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MATHVARIANT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("mathvariant"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MARGINWIDTH = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("marginwidth"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MARKERWIDTH = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("markerwidth", "markerWidth"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName TEXT_ANCHOR = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("text-anchor"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName TABLEVALUES = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("tablevalues", "tableValues"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCRIPTLEVEL = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("scriptlevel"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName REPEATCOUNT = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("repeatcount", "repeatCount"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STITCHTILES = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("stitchtiles", "stitchTiles"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STARTOFFSET = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("startoffset", "startOffset"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCROLLDELAY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("scrolldelay"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName XMLNS_XLINK = new AttributeName(XMLNS_NS,
+            COLONIFIED_LOCAL("xmlns:xlink", "xlink"), XMLNS_PREFIX,
+            new boolean[] { false, false, false, false }, true);
+
+    public static final AttributeName XLINK_TITLE = new AttributeName(XLINK_NS,
+            COLONIFIED_LOCAL("xlink:title", "title"), XLINK_PREFIX,
+            new boolean[] { false, true, true, false }, false);
+
+    public static final AttributeName ARIA_INVALID = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-invalid"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_PRESSED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-pressed"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_CHECKED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-checked"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName AUTOCOMPLETE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("autocomplete"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_SETSIZE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-setsize"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_CHANNEL = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-channel"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName EQUALCOLUMNS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("equalcolumns"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName DISPLAYSTYLE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("displaystyle"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName DATAFORMATAS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("dataformatas"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FILL_OPACITY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("fill-opacity"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FONT_VARIANT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("font-variant"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FONT_STRETCH = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("font-stretch"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName FRAMESPACING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("framespacing"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName KERNELMATRIX = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("kernelmatrix", "kernelMatrix"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDEACTIVATE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ondeactivate"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONROWSDELETE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onrowsdelete"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONMOUSELEAVE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onmouseleave"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONFORMCHANGE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onformchange"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONCELLCHANGE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("oncellchange"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONMOUSEWHEEL = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onmousewheel"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONMOUSEENTER = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onmouseenter"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONAFTERPRINT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onafterprint"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONBEFORECOPY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforecopy"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MARGINHEIGHT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("marginheight"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MARKERHEIGHT = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("markerheight", "markerHeight"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName MARKER_START = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("marker-start"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MATHEMATICAL = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("mathematical"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName LENGTHADJUST = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("lengthadjust", "lengthAdjust"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName UNSELECTABLE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("unselectable"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName UNICODE_BIDI = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("unicode-bidi"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName UNITS_PER_EM = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("units-per-em"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName WORD_SPACING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("word-spacing"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName WRITING_MODE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("writing-mode"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName V_ALPHABETIC = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("v-alphabetic"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName PATTERNUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("patternunits", "patternUnits"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SPREADMETHOD = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("spreadmethod", "spreadMethod"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SURFACESCALE = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("surfacescale", "surfaceScale"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STROKE_WIDTH = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stroke-width"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName REPEAT_START = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("repeat-start"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName STDDEVIATION = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("stddeviation", "stdDeviation"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STOP_OPACITY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stop-opacity"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_CONTROLS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-controls"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_HASPOPUP = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-haspopup"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ACCENT_HEIGHT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("accent-height"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_VALUENOW = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-valuenow"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_RELEVANT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-relevant"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_POSINSET = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-posinset"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_VALUEMAX = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-valuemax"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_READONLY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-readonly"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_SELECTED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-selected"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_REQUIRED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-required"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_EXPANDED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-expanded"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_DISABLED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-disabled"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ATTRIBUTETYPE = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("attributetype", "attributeType"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ATTRIBUTENAME = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("attributename", "attributeName"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_DATATYPE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-datatype"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_VALUEMIN = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-valuemin"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName BASEFREQUENCY = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("basefrequency", "baseFrequency"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COLUMNSPACING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("columnspacing"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName COLOR_PROFILE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("color-profile"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName CLIPPATHUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("clippathunits", "clipPathUnits"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName DEFINITIONURL = new AttributeName(
+            ALL_NO_NS, MATH_DIFFERENT("definitionurl", "definitionURL"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName GRADIENTUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("gradientunits", "gradientUnits"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FLOOD_OPACITY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("flood-opacity"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONAFTERUPDATE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onafterupdate"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONERRORUPDATE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onerrorupdate"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONBEFOREPASTE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforepaste"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONLOSECAPTURE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onlosecapture"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONCONTEXTMENU = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("oncontextmenu"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONSELECTSTART = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onselectstart"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONBEFOREPRINT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforeprint"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MOVABLELIMITS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("movablelimits"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName LINETHICKNESS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("linethickness"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName UNICODE_RANGE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("unicode-range"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName THINMATHSPACE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("thinmathspace"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName VERT_ORIGIN_X = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("vert-origin-x"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName VERT_ORIGIN_Y = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("vert-origin-y"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName V_IDEOGRAPHIC = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("v-ideographic"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName PRESERVEALPHA = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("preservealpha", "preserveAlpha"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SCRIPTMINSIZE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("scriptminsize"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName SPECIFICATION = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("specification"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName XLINK_ACTUATE = new AttributeName(
+            XLINK_NS, COLONIFIED_LOCAL("xlink:actuate", "actuate"),
+            XLINK_PREFIX, new boolean[] { false, true, true, false }, false);
+
+    public static final AttributeName XLINK_ARCROLE = new AttributeName(
+            XLINK_NS, COLONIFIED_LOCAL("xlink:arcrole", "arcrole"),
+            XLINK_PREFIX, new boolean[] { false, true, true, false }, false);
+
+    public static final AttributeName ACCEPT_CHARSET = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("accept-charset"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ALIGNMENTSCOPE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("alignmentscope"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_MULTILINE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-multiline"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName BASELINE_SHIFT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("baseline-shift"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName HORIZ_ORIGIN_X = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("horiz-origin-x"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName HORIZ_ORIGIN_Y = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("horiz-origin-y"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONBEFOREUPDATE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforeupdate"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONFILTERCHANGE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onfilterchange"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONROWSINSERTED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onrowsinserted"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ONBEFOREUNLOAD = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforeunload"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName MATHBACKGROUND = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("mathbackground"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName LETTER_SPACING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("letter-spacing"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName LIGHTING_COLOR = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("lighting-color"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName THICKMATHSPACE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("thickmathspace"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName TEXT_RENDERING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("text-rendering"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName V_MATHEMATICAL = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("v-mathematical"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName POINTER_EVENTS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("pointer-events"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName PRIMITIVEUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("primitiveunits", "primitiveUnits"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SYSTEMLANGUAGE = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("systemlanguage", "systemLanguage"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName STROKE_LINECAP = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stroke-linecap"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName SUBSCRIPTSHIFT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("subscriptshift"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName STROKE_OPACITY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stroke-opacity"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName ARIA_DROPEFFECT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-dropeffect"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_LABELLEDBY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-labelledby"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_TEMPLATEID = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-templateid"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName COLOR_RENDERING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("color-rendering"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName CONTENTEDITABLE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("contenteditable"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName DIFFUSECONSTANT = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("diffuseconstant", "diffuseConstant"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONDATAAVAILABLE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ondataavailable"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ONCONTROLSELECT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("oncontrolselect"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName IMAGE_RENDERING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("image-rendering"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName MEDIUMMATHSPACE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("mediummathspace"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName TEXT_DECORATION = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("text-decoration"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName SHAPE_RENDERING = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("shape-rendering"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName STROKE_LINEJOIN = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stroke-linejoin"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName REPEAT_TEMPLATE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("repeat-template"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_DESCRIBEDBY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-describedby"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName CONTENTSTYLETYPE = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("contentstyletype", "contentStyleType"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName FONT_SIZE_ADJUST = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("font-size-adjust"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName KERNELUNITLENGTH = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("kernelunitlength", "kernelUnitLength"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONBEFOREACTIVATE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforeactivate"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ONPROPERTYCHANGE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onpropertychange"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ONDATASETCHANGED = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ondatasetchanged"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName MASKCONTENTUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("maskcontentunits", "maskContentUnits"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PATTERNTRANSFORM = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("patterntransform", "patternTransform"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName REQUIREDFEATURES = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("requiredfeatures", "requiredFeatures"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName RENDERING_INTENT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("rendering-intent"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName SPECULAREXPONENT = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("specularexponent", "specularExponent"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SPECULARCONSTANT = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("specularconstant", "specularConstant"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName SUPERSCRIPTSHIFT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("superscriptshift"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName STROKE_DASHARRAY = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stroke-dasharray"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName XCHANNELSELECTOR = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("xchannelselector", "xChannelSelector"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName YCHANNELSELECTOR = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("ychannelselector", "yChannelSelector"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_AUTOCOMPLETE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-autocomplete"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName CONTENTSCRIPTTYPE = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("contentscripttype", "contentScriptType"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ENABLE_BACKGROUND = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("enable-background"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName DOMINANT_BASELINE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("dominant-baseline"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName GRADIENTTRANSFORM = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("gradienttransform", "gradientTransform"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ONBEFORDEACTIVATE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbefordeactivate"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ONDATASETCOMPLETE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("ondatasetcomplete"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName OVERLINE_POSITION = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("overline-position"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ONBEFOREEDITFOCUS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onbeforeeditfocus"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName LIMITINGCONEANGLE = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("limitingconeangle", "limitingConeAngle"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName VERYTHINMATHSPACE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("verythinmathspace"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName STROKE_DASHOFFSET = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stroke-dashoffset"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName STROKE_MITERLIMIT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("stroke-miterlimit"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ALIGNMENT_BASELINE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("alignment-baseline"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ONREADYSTATECHANGE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("onreadystatechange"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName OVERLINE_THICKNESS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("overline-thickness"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName UNDERLINE_POSITION = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("underline-position"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName VERYTHICKMATHSPACE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("verythickmathspace"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName REQUIREDEXTENSIONS = new AttributeName(
+            ALL_NO_NS,
+            SVG_DIFFERENT("requiredextensions", "requiredExtensions"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName COLOR_INTERPOLATION = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("color-interpolation"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName UNDERLINE_THICKNESS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("underline-thickness"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName PRESERVEASPECTRATIO = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("preserveaspectratio",
+                    "preserveAspectRatio"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName PATTERNCONTENTUNITS = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("patterncontentunits",
+                    "patternContentUnits"), ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_MULTISELECTABLE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-multiselectable"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName SCRIPTSIZEMULTIPLIER = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("scriptsizemultiplier"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName ARIA_ACTIVEDESCENDANT = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("aria-activedescendant"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName VERYVERYTHINMATHSPACE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("veryverythinmathspace"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName VERYVERYTHICKMATHSPACE = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("veryverythickmathspace"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName STRIKETHROUGH_POSITION = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("strikethrough-position"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName STRIKETHROUGH_THICKNESS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("strikethrough-thickness"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName EXTERNALRESOURCESREQUIRED = new AttributeName(
+            ALL_NO_NS, SVG_DIFFERENT("externalresourcesrequired",
+                    "externalResourcesRequired"), ALL_NO_PREFIX, ALL_NCNAME,
+            false);
+
+    public static final AttributeName GLYPH_ORIENTATION_VERTICAL = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("glyph-orientation-vertical"), ALL_NO_PREFIX,
+            ALL_NCNAME, false);
+
+    public static final AttributeName COLOR_INTERPOLATION_FILTERS = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("color-interpolation-filters"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    public static final AttributeName GLYPH_ORIENTATION_HORIZONTAL = new AttributeName(
+            ALL_NO_NS, SAME_LOCAL("glyph-orientation-horizontal"),
+            ALL_NO_PREFIX, ALL_NCNAME, false);
+
+    private final static @NoLength AttributeName[] ATTRIBUTE_NAMES = { D, K, R,
+            X, Y, Z, BY, CX, CY, DX, DY, G2, G1, FX, FY, K4, K2, K3, K1, ID,
+            IN, U2, U1, RT, RX, RY, TO, Y2, Y1, X1, X2, ALT, DIR, DUR, END,
+            FOR, IN2, MAX, MIN, LOW, REL, REV, SRC, AXIS, ABBR, BBOX, CITE,
+            CODE, BIAS, COLS, CLIP, CHAR, BASE, EDGE, DATA, FILL, FROM, FORM,
+            FACE, HIGH, HREF, OPEN, ICON, NAME, MODE, MASK, LINK, LANG, LIST,
+            TYPE, WHEN, WRAP, TEXT, PATH, PING, REFX, REFY, SIZE, SEED, ROWS,
+            SPAN, STEP, ROLE, XREF, ASYNC, ALINK, ALIGN, CLOSE, COLOR, CLASS,
+            CLEAR, BEGIN, DEPTH, DEFER, FENCE, FRAME, ISMAP, ONEND, INDEX,
+            ORDER, OTHER, ONCUT, NARGS, MEDIA, LABEL, LOCAL, WIDTH, TITLE,
+            VLINK, VALUE, SLOPE, SHAPE, SCOPE, SCALE, SPEED, STYLE, RULES,
+            STEMH, STEMV, START, XMLNS, ACCEPT, ACCENT, ASCENT, ACTIVE, ALTIMG,
+            ACTION, BORDER, CURSOR, COORDS, FILTER, FORMAT, HIDDEN, HSPACE,
+            HEIGHT, ONMOVE, ONLOAD, ONDRAG, ORIGIN, ONZOOM, ONHELP, ONSTOP,
+            ONDROP, ONBLUR, OBJECT, OFFSET, ORIENT, ONCOPY, NOWRAP, NOHREF,
+            MACROS, METHOD, LOWSRC, LSPACE, LQUOTE, USEMAP, WIDTHS, TARGET,
+            VALUES, VALIGN, VSPACE, POSTER, POINTS, PROMPT, SCOPED, STRING,
+            SCHEME, STROKE, RADIUS, RESULT, REPEAT, RSPACE, ROTATE, RQUOTE,
+            ALTTEXT, ARCHIVE, AZIMUTH, CLOSURE, CHECKED, CLASSID, CHAROFF,
+            BGCOLOR, COLSPAN, CHARSET, COMPACT, CONTENT, ENCTYPE, DATASRC,
+            DATAFLD, DECLARE, DISPLAY, DIVISOR, DEFAULT, DESCENT, KERNING,
+            HANGING, HEADERS, ONPASTE, ONCLICK, OPTIMUM, ONBEGIN, ONKEYUP,
+            ONFOCUS, ONERROR, ONINPUT, ONABORT, ONSTART, ONRESET, OPACITY,
+            NOSHADE, MINSIZE, MAXSIZE, LOOPEND, LARGEOP, UNICODE, TARGETX,
+            TARGETY, VIEWBOX, VERSION, PATTERN, PROFILE, SPACING, RESTART,
+            ROWSPAN, SANDBOX, SUMMARY, STANDBY, REPLACE, AUTOPLAY, ADDITIVE,
+            CALCMODE, CODETYPE, CODEBASE, CONTROLS, BEVELLED, BASELINE,
+            EXPONENT, EDGEMODE, ENCODING, GLYPHREF, DATETIME, DISABLED,
+            FONTSIZE, KEYTIMES, PANOSE_1, HREFLANG, ONRESIZE, ONCHANGE,
+            ONBOUNCE, ONUNLOAD, ONFINISH, ONSCROLL, OPERATOR, OVERFLOW,
+            ONSUBMIT, ONREPEAT, ONSELECT, NOTATION, NORESIZE, MANIFEST,
+            MATHSIZE, MULTIPLE, LONGDESC, LANGUAGE, TEMPLATE, TABINDEX,
+            READONLY, SELECTED, ROWLINES, SEAMLESS, ROWALIGN, STRETCHY,
+            REQUIRED, XML_BASE, XML_LANG, X_HEIGHT, ARIA_OWNS, AUTOFOCUS,
+            ARIA_SORT, ACCESSKEY, ARIA_BUSY, ARIA_GRAB, AMPLITUDE, ARIA_LIVE,
+            CLIP_RULE, CLIP_PATH, EQUALROWS, ELEVATION, DIRECTION, DRAGGABLE,
+            FILTERRES, FILL_RULE, FONTSTYLE, FONT_SIZE, KEYPOINTS, HIDEFOCUS,
+            ONMESSAGE, INTERCEPT, ONDRAGEND, ONMOVEEND, ONINVALID, ONKEYDOWN,
+            ONFOCUSIN, ONMOUSEUP, INPUTMODE, ONROWEXIT, MATHCOLOR, MASKUNITS,
+            MAXLENGTH, LINEBREAK, LOOPSTART, TRANSFORM, V_HANGING, VALUETYPE,
+            POINTSATZ, POINTSATX, POINTSATY, PLAYCOUNT, SYMMETRIC, SCROLLING,
+            REPEATDUR, SELECTION, SEPARATOR, XML_SPACE, AUTOSUBMIT, ALPHABETIC,
+            ACTIONTYPE, ACCUMULATE, ARIA_LEVEL, COLUMNSPAN, CAP_HEIGHT,
+            BACKGROUND, GLYPH_NAME, GROUPALIGN, FONTFAMILY, FONTWEIGHT,
+            FONT_STYLE, KEYSPLINES, HTTP_EQUIV, ONACTIVATE, OCCURRENCE,
+            IRRELEVANT, ONDBLCLICK, ONDRAGDROP, ONKEYPRESS, ONROWENTER,
+            ONDRAGOVER, ONFOCUSOUT, ONMOUSEOUT, NUMOCTAVES, MARKER_MID,
+            MARKER_END, TEXTLENGTH, VISIBILITY, VIEWTARGET, VERT_ADV_Y,
+            PATHLENGTH, REPEAT_MAX, RADIOGROUP, STOP_COLOR, SEPARATORS,
+            REPEAT_MIN, ROWSPACING, ZOOMANDPAN, XLINK_TYPE, XLINK_ROLE,
+            XLINK_HREF, XLINK_SHOW, ACCENTUNDER, ARIA_SECRET, ARIA_ATOMIC,
+            ARIA_HIDDEN, ARIA_FLOWTO, ARABIC_FORM, CELLPADDING, CELLSPACING,
+            COLUMNWIDTH, COLUMNALIGN, COLUMNLINES, CONTEXTMENU, BASEPROFILE,
+            FONT_FAMILY, FRAMEBORDER, FILTERUNITS, FLOOD_COLOR, FONT_WEIGHT,
+            HORIZ_ADV_X, ONDRAGLEAVE, ONMOUSEMOVE, ORIENTATION, ONMOUSEDOWN,
+            ONMOUSEOVER, ONDRAGENTER, IDEOGRAPHIC, ONBEFORECUT, ONFORMINPUT,
+            ONDRAGSTART, ONMOVESTART, MARKERUNITS, MATHVARIANT, MARGINWIDTH,
+            MARKERWIDTH, TEXT_ANCHOR, TABLEVALUES, SCRIPTLEVEL, REPEATCOUNT,
+            STITCHTILES, STARTOFFSET, SCROLLDELAY, XMLNS_XLINK, XLINK_TITLE,
+            ARIA_INVALID, ARIA_PRESSED, ARIA_CHECKED, AUTOCOMPLETE,
+            ARIA_SETSIZE, ARIA_CHANNEL, EQUALCOLUMNS, DISPLAYSTYLE,
+            DATAFORMATAS, FILL_OPACITY, FONT_VARIANT, FONT_STRETCH,
+            FRAMESPACING, KERNELMATRIX, ONDEACTIVATE, ONROWSDELETE,
+            ONMOUSELEAVE, ONFORMCHANGE, ONCELLCHANGE, ONMOUSEWHEEL,
+            ONMOUSEENTER, ONAFTERPRINT, ONBEFORECOPY, MARGINHEIGHT,
+            MARKERHEIGHT, MARKER_START, MATHEMATICAL, LENGTHADJUST,
+            UNSELECTABLE, UNICODE_BIDI, UNITS_PER_EM, WORD_SPACING,
+            WRITING_MODE, V_ALPHABETIC, PATTERNUNITS, SPREADMETHOD,
+            SURFACESCALE, STROKE_WIDTH, REPEAT_START, STDDEVIATION,
+            STOP_OPACITY, ARIA_CONTROLS, ARIA_HASPOPUP, ACCENT_HEIGHT,
+            ARIA_VALUENOW, ARIA_RELEVANT, ARIA_POSINSET, ARIA_VALUEMAX,
+            ARIA_READONLY, ARIA_SELECTED, ARIA_REQUIRED, ARIA_EXPANDED,
+            ARIA_DISABLED, ATTRIBUTETYPE, ATTRIBUTENAME, ARIA_DATATYPE,
+            ARIA_VALUEMIN, BASEFREQUENCY, COLUMNSPACING, COLOR_PROFILE,
+            CLIPPATHUNITS, DEFINITIONURL, GRADIENTUNITS, FLOOD_OPACITY,
+            ONAFTERUPDATE, ONERRORUPDATE, ONBEFOREPASTE, ONLOSECAPTURE,
+            ONCONTEXTMENU, ONSELECTSTART, ONBEFOREPRINT, MOVABLELIMITS,
+            LINETHICKNESS, UNICODE_RANGE, THINMATHSPACE, VERT_ORIGIN_X,
+            VERT_ORIGIN_Y, V_IDEOGRAPHIC, PRESERVEALPHA, SCRIPTMINSIZE,
+            SPECIFICATION, XLINK_ACTUATE, XLINK_ARCROLE, ACCEPT_CHARSET,
+            ALIGNMENTSCOPE, ARIA_MULTILINE, BASELINE_SHIFT, HORIZ_ORIGIN_X,
+            HORIZ_ORIGIN_Y, ONBEFOREUPDATE, ONFILTERCHANGE, ONROWSINSERTED,
+            ONBEFOREUNLOAD, MATHBACKGROUND, LETTER_SPACING, LIGHTING_COLOR,
+            THICKMATHSPACE, TEXT_RENDERING, V_MATHEMATICAL, POINTER_EVENTS,
+            PRIMITIVEUNITS, SYSTEMLANGUAGE, STROKE_LINECAP, SUBSCRIPTSHIFT,
+            STROKE_OPACITY, ARIA_DROPEFFECT, ARIA_LABELLEDBY, ARIA_TEMPLATEID,
+            COLOR_RENDERING, CONTENTEDITABLE, DIFFUSECONSTANT, ONDATAAVAILABLE,
+            ONCONTROLSELECT, IMAGE_RENDERING, MEDIUMMATHSPACE, TEXT_DECORATION,
+            SHAPE_RENDERING, STROKE_LINEJOIN, REPEAT_TEMPLATE,
+            ARIA_DESCRIBEDBY, CONTENTSTYLETYPE, FONT_SIZE_ADJUST,
+            KERNELUNITLENGTH, ONBEFOREACTIVATE, ONPROPERTYCHANGE,
+            ONDATASETCHANGED, MASKCONTENTUNITS, PATTERNTRANSFORM,
+            REQUIREDFEATURES, RENDERING_INTENT, SPECULAREXPONENT,
+            SPECULARCONSTANT, SUPERSCRIPTSHIFT, STROKE_DASHARRAY,
+            XCHANNELSELECTOR, YCHANNELSELECTOR, ARIA_AUTOCOMPLETE,
+            CONTENTSCRIPTTYPE, ENABLE_BACKGROUND, DOMINANT_BASELINE,
+            GRADIENTTRANSFORM, ONBEFORDEACTIVATE, ONDATASETCOMPLETE,
+            OVERLINE_POSITION, ONBEFOREEDITFOCUS, LIMITINGCONEANGLE,
+            VERYTHINMATHSPACE, STROKE_DASHOFFSET, STROKE_MITERLIMIT,
+            ALIGNMENT_BASELINE, ONREADYSTATECHANGE, OVERLINE_THICKNESS,
+            UNDERLINE_POSITION, VERYTHICKMATHSPACE, REQUIREDEXTENSIONS,
+            COLOR_INTERPOLATION, UNDERLINE_THICKNESS, PRESERVEASPECTRATIO,
+            PATTERNCONTENTUNITS, ARIA_MULTISELECTABLE, SCRIPTSIZEMULTIPLIER,
+            ARIA_ACTIVEDESCENDANT, VERYVERYTHINMATHSPACE,
+            VERYVERYTHICKMATHSPACE, STRIKETHROUGH_POSITION,
+            STRIKETHROUGH_THICKNESS, EXTERNALRESOURCESREQUIRED,
+            GLYPH_ORIENTATION_VERTICAL, COLOR_INTERPOLATION_FILTERS,
+            GLYPH_ORIENTATION_HORIZONTAL, };
+
+    private final static int[] ATTRIBUTE_HASHES = { 1153, 1383, 1601, 1793,
+            1827, 1857, 68600, 69146, 69177, 70237, 70270, 71572, 71669, 72415,
+            72444, 74846, 74904, 74943, 75001, 75276, 75590, 84742, 84839,
+            85575, 85963, 85992, 87204, 88074, 88171, 89130, 89163, 3207892,
+            3283895, 3284791, 3338752, 3358197, 3369562, 3539124, 3562402,
+            3574260, 3670335, 3696933, 3721879, 135280021, 135346322,
+            136317019, 136475749, 136548517, 136652214, 136884919, 136902418,
+            136942992, 137292068, 139120259, 139785574, 142250603, 142314056,
+            142331176, 142519584, 144752417, 145106895, 146147200, 146765926,
+            148805544, 149655723, 149809441, 150018784, 150445028, 150923321,
+            152528754, 152536216, 152647366, 152962785, 155219321, 155654904,
+            157317483, 157350248, 157437941, 157447478, 157604838, 157685404,
+            157894402, 158315188, 166078431, 169409980, 169700259, 169856932,
+            170007032, 170409695, 170466488, 170513710, 170608367, 173028944,
+            173896963, 176090625, 176129212, 179390001, 179489057, 179627464,
+            179840468, 179849042, 180004216, 181779081, 183027151, 183645319,
+            183698797, 185922012, 185997252, 188312483, 188675799, 190977533,
+            190992569, 191006194, 191033518, 191038774, 191096249, 191166163,
+            191194426, 191522106, 191568039, 200104642, 202506661, 202537381,
+            202602917, 203070590, 203120766, 203389054, 203690071, 203971238,
+            203986524, 209040857, 209125756, 212055489, 212322418, 212746849,
+            213002877, 213055164, 213088023, 213259873, 213273386, 213435118,
+            213437318, 213438231, 213493071, 213532268, 213542834, 213584431,
+            213659891, 215285828, 215880731, 216112976, 216684637, 217369699,
+            217565298, 217576549, 218186795, 219743185, 220082234, 221623802,
+            221986406, 222283890, 223089542, 223138630, 223311265, 224547358,
+            224587256, 224589550, 224655650, 224785518, 224810917, 224813302,
+            225429618, 225432950, 225440869, 236107233, 236709921, 236838947,
+            237117095, 237143271, 237172455, 237209953, 237354143, 237372743,
+            237668065, 237703073, 237714273, 239743521, 240512803, 240522627,
+            240560417, 240656513, 241015715, 241062755, 241065383, 243523041,
+            245865199, 246261793, 246556195, 246774817, 246923491, 246928419,
+            246981667, 247014847, 247058369, 247112833, 247118177, 247119137,
+            247128739, 247316903, 249533729, 250235623, 250269543, 251083937,
+            251402351, 252339047, 253260911, 253293679, 254844367, 255547879,
+            256077281, 256345377, 258124199, 258354465, 258605063, 258744193,
+            258845603, 258856961, 258926689, 269869248, 270174334, 270709417,
+            270778994, 270781796, 271102503, 271478858, 271490090, 272870654,
+            273335275, 273369140, 273924313, 274108530, 274116736, 276818662,
+            277476156, 279156579, 279349675, 280108533, 280128712, 280132869,
+            280162403, 280280292, 280413430, 280506130, 280677397, 280678580,
+            280686710, 280689066, 282736758, 283110901, 283275116, 283823226,
+            283890012, 284479340, 284606461, 286700477, 286798916, 291557706,
+            291665349, 291804100, 292138018, 292166446, 292418738, 292451039,
+            300298041, 300374839, 300597935, 303073389, 303083839, 303266673,
+            303354997, 303430688, 303576261, 303724281, 303819694, 304242723,
+            304382625, 306247792, 307227811, 307468786, 307724489, 309671175,
+            310252031, 310358241, 310373094, 311015256, 313357609, 313683893,
+            313701861, 313706996, 313707317, 313710350, 314027746, 314038181,
+            314091299, 314205627, 314233813, 316741830, 316797986, 317486755,
+            317794164, 318721061, 320076137, 322657125, 322887778, 323506876,
+            323572412, 323605180, 323938869, 325060058, 325320188, 325398738,
+            325541490, 325671619, 333868843, 336806130, 337212108, 337282686,
+            337285434, 337585223, 338036037, 338298087, 338566051, 340943551,
+            341190970, 342995704, 343352124, 343912673, 344585053, 346977248,
+            347218098, 347262163, 347278576, 347438191, 347655959, 347684788,
+            347726430, 347727772, 347776035, 347776629, 349500753, 350880161,
+            350887073, 353384123, 355496998, 355906922, 355979793, 356545959,
+            358637867, 358905016, 359164318, 359247286, 359350571, 359579447,
+            365560330, 367399355, 367420285, 367510727, 368013212, 370234760,
+            370353345, 370710317, 371074566, 371122285, 371194213, 371448425,
+            371448430, 371545055, 371596922, 371758751, 371964792, 372151328,
+            376550136, 376710172, 376795771, 376826271, 376906556, 380514830,
+            380774774, 380775037, 381030322, 381136500, 381281631, 381282269,
+            381285504, 381330595, 381331422, 381335911, 381336484, 383907298,
+            383917408, 384595009, 384595013, 387799894, 387823201, 392581647,
+            392584937, 392742684, 392906485, 393003349, 400644707, 400973830,
+            404428547, 404432113, 404432865, 404469244, 404478897, 404694860,
+            406887479, 408294949, 408789955, 410022510, 410467324, 410586448,
+            410945965, 411845275, 414327152, 414327932, 414329781, 414346257,
+            414346439, 414639928, 414835998, 414894517, 414986533, 417465377,
+            417465381, 417492216, 418259232, 419310946, 420103495, 420242342,
+            420380455, 420658662, 420717432, 423183880, 424539259, 425929170,
+            425972964, 426050649, 426126450, 426142833, 426607922, 437289840,
+            437347469, 437412335, 437423943, 437455540, 437462252, 437597991,
+            437617485, 437986305, 437986507, 437986828, 437987072, 438015591,
+            438034813, 438038966, 438179623, 438347971, 438483573, 438547062,
+            438895551, 441592676, 442032555, 443548979, 447881379, 447881655,
+            447881895, 447887844, 448416189, 448445746, 448449012, 450942191,
+            452816744, 453668677, 454434495, 456610076, 456642844, 456738709,
+            457544600, 459451897, 459680944, 468058810, 468083581, 470964084,
+            471470955, 471567278, 472267822, 481177859, 481210627, 481435874,
+            481455115, 481485378, 481490218, 485105638, 486005878, 486383494,
+            487988916, 488103783, 490661867, 491574090, 491578272, 493041952,
+            493441205, 493582844, 493716979, 504577572, 504740359, 505091638,
+            505592418, 505656212, 509516275, 514998531, 515571132, 515594682,
+            518712698, 521362273, 526592419, 526807354, 527348842, 538294791,
+            539214049, 544689535, 545535009, 548544752, 548563346, 548595116,
+            551679010, 558034099, 560329411, 560356209, 560671018, 560671152,
+            560692590, 560845442, 569212097, 569474241, 572252718, 572768481,
+            575326764, 576174758, 576190819, 582099184, 582099438, 582372519,
+            582558889, 586552164, 591325418, 594231990, 594243961, 605711268,
+            615672071, 616086845, 621792370, 624879850, 627432831, 640040548,
+            654392808, 658675477, 659420283, 672891587, 694768102, 705890982,
+            725543146, 759097578, 761686526, 795383908, 843809551, 878105336,
+            908643300, 945213471, };
+
+}
diff --git a/parser/html/java/htmlparser/src/CoalescingTreeBuilder.java b/parser/html/java/htmlparser/src/CoalescingTreeBuilder.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/CoalescingTreeBuilder.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2008-2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.NoLength;
+
+import org.xml.sax.SAXException;
+
+public abstract class CoalescingTreeBuilder<T> extends TreeBuilder<T> {
+
+    protected final void accumulateCharacters(@NoLength char[] buf, int start,
+            int length) throws SAXException {
+        int newLen = charBufferLen + length;
+        if (newLen > charBuffer.length) {
+            char[] newBuf = new char[newLen];
+            System.arraycopy(charBuffer, 0, newBuf, 0, charBufferLen);
+            Portability.releaseArray(charBuffer);
+            charBuffer = newBuf;
+        }
+        System.arraycopy(buf, start, charBuffer, charBufferLen, length);
+        charBufferLen = newLen;
+    }
+
+    /**
+     * @see nu.validator.htmlparser.impl.TreeBuilder#appendCharacters(java.lang.Object, char[], int, int)
+     */
+    @Override protected final void appendCharacters(T parent, char[] buf, int start,
+            int length) throws SAXException {
+        appendCharacters(parent, new String(buf, start, length));
+    }
+
+    protected abstract void appendCharacters(T parent, String text) throws SAXException;
+
+    /**
+     * @see nu.validator.htmlparser.impl.TreeBuilder#appendComment(java.lang.Object, char[], int, int)
+     */
+    @Override final protected void appendComment(T parent, char[] buf, int start,
+            int length) throws SAXException {
+        appendComment(parent, new String(buf, start, length));
+    }
+
+    protected abstract void appendComment(T parent, String comment) throws SAXException;
+    
+    /**
+     * @see nu.validator.htmlparser.impl.TreeBuilder#appendCommentToDocument(char[], int, int)
+     */
+    @Override protected final void appendCommentToDocument(char[] buf, int start,
+            int length) throws SAXException {
+        // TODO Auto-generated method stub
+        appendCommentToDocument(new String(buf, start, length));
+    }
+
+    protected abstract void appendCommentToDocument(String comment) throws SAXException;
+    
+    /**
+     * @see nu.validator.htmlparser.impl.TreeBuilder#insertFosterParentedCharacters(char[], int, int, java.lang.Object, java.lang.Object)
+     */
+    @Override protected final void insertFosterParentedCharacters(char[] buf, int start,
+            int length, T table, T stackParent) throws SAXException {
+        insertFosterParentedCharacters(new String(buf, start, length), table, stackParent);
+    }
+    
+    protected abstract void insertFosterParentedCharacters(String text, T table, T stackParent) throws SAXException;
+}
diff --git a/parser/html/java/htmlparser/src/ElementName.java b/parser/html/java/htmlparser/src/ElementName.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/ElementName.java
@@ -0,0 +1,1513 @@
+/*
+ * Copyright (c) 2008 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import java.util.Arrays;
+
+import nu.validator.htmlparser.annotation.Local;
+import nu.validator.htmlparser.annotation.NoLength;
+import nu.validator.htmlparser.annotation.Virtual;
+
+public final class ElementName
+// uncomment when regenerating self
+//        implements Comparable<ElementName> 
+{
+
+    public final static ElementName NULL_ELEMENT_NAME = new ElementName(null);
+
+    public final @Local String name;
+
+    public final @Local String camelCaseName;
+    
+    public final int group;
+
+    public final boolean special;
+
+    public final boolean scoping;
+
+    public final boolean fosterParenting;
+
+    // [NOCPP[
+    
+    public final boolean custom;
+
+    // ]NOCPP]
+    
+    static ElementName elementNameByBuffer(char[] buf, int offset, int length) {
+        int hash = ElementName.bufToHash(buf, length);
+        int index = Arrays.binarySearch(ElementName.ELEMENT_HASHES, hash);
+        if (index < 0) {
+            return new ElementName(Portability.newLocalNameFromBuffer(buf, offset, length));
+        } else {
+            ElementName elementName = ElementName.ELEMENT_NAMES[index];
+            @Local String name = elementName.name;
+            if (!Portability.localEqualsBuffer(name, buf, offset, length)) {
+                return new ElementName(Portability.newLocalNameFromBuffer(buf,
+                        offset, length));                
+            }
+            return elementName;
+        }
+    }
+
+    /**
+     * This method has to return a unique integer for each well-known
+     * lower-cased element name.
+     * 
+     * @param buf
+     * @param len
+     * @return
+     */
+    private static int bufToHash(char[] buf, int len) {
+        int hash = len;
+        hash <<= 5;
+        hash += buf[0] - 0x60;
+        int j = len;
+        for (int i = 0; i < 4 && j > 0; i++) {
+            j--;
+            hash <<= 5;
+            hash += buf[j] - 0x60;
+        }
+        return hash;
+    }
+
+    private ElementName(@Local String name, @Local String camelCaseName,
+            int group, boolean special, boolean scoping, boolean fosterParenting) {
+        this.name = name;
+        this.camelCaseName = camelCaseName;
+        this.group = group;
+        this.special = special;
+        this.scoping = scoping;
+        this.fosterParenting = fosterParenting;
+        // [NOCPP[
+        this.custom = false;
+        // ]NOCPP]
+    }
+
+    protected ElementName(@Local String name) {
+        this.name = name;
+        this.camelCaseName = name;
+        this.group = TreeBuilder.OTHER;
+        this.special = false;
+        this.scoping = false;
+        this.fosterParenting = false;
+        // [NOCPP[
+        this.custom = true;
+        // ]NOCPP]
+    }
+    
+    @Virtual void release() {
+        // No-op in Java. 
+        // Implement as delete this in subclass.
+        // Be sure to release the local name
+    }
+    
+    @SuppressWarnings("unused") private void destructor() {
+        Portability.releaseLocal(name); // this must be a no-op for static locals
+        // for non-static cases the camel case contains the same pointer as a weak reference.
+    }
+
+    // START CODE ONLY USED FOR GENERATING CODE uncomment and run to regenerate
+
+//    /**
+//     * @see java.lang.Object#toString()
+//     */
+//    @Override public String toString() {
+//        return "(\"" + name + "\", \"" + camelCaseName + "\", TreeBuilder."
+//                + treeBuilderGroupToName() + ", "
+//                + (special ? "true" : "false") + ", "
+//                + (scoping ? "true" : "false") + ", "
+//                + (fosterParenting ? "true" : "false") + ")";
+//    }
+//
+//    private String constName() {
+//        char[] buf = new char[name.length()];
+//        for (int i = 0; i < name.length(); i++) {
+//            char c = name.charAt(i);
+//            if (c == '-') {
+//                buf[i] = '_';
+//            } else if (c >= '0' && c <= '9') {
+//                buf[i] = c;
+//            } else {
+//                buf[i] = (char) (c - 0x20);
+//            }
+//        }
+//        return new String(buf);
+//    }
+//
+//    private int hash() {
+//        return bufToHash(name.toCharArray(), name.length());
+//    }
+//
+//    public int compareTo(ElementName other) {
+//        int thisHash = this.hash();
+//        int otherHash = other.hash();
+//        if (thisHash < otherHash) {
+//            return -1;
+//        } else if (thisHash == otherHash) {
+//            return 0;
+//        } else {
+//            return 1;
+//        }
+//    }
+//
+//    private String treeBuilderGroupToName() {
+//        switch (group) {
+//            case TreeBuilder.OTHER:
+//                return "OTHER";
+//            case TreeBuilder.A:
+//                return "A";
+//            case TreeBuilder.BASE:
+//                return "BASE";
+//            case TreeBuilder.BODY:
+//                return "BODY";
+//            case TreeBuilder.BR:
+//                return "BR";
+//            case TreeBuilder.BUTTON:
+//                return "BUTTON";
+//            case TreeBuilder.CAPTION:
+//                return "CAPTION";
+//            case TreeBuilder.COL:
+//                return "COL";
+//            case TreeBuilder.COLGROUP:
+//                return "COLGROUP";
+//            case TreeBuilder.FORM:
+//                return "FORM";
+//            case TreeBuilder.FRAME:
+//                return "FRAME";
+//            case TreeBuilder.FRAMESET:
+//                return "FRAMESET";
+//            case TreeBuilder.IMAGE:
+//                return "IMAGE";
+//            case TreeBuilder.INPUT:
+//                return "INPUT";
+//            case TreeBuilder.ISINDEX:
+//                return "ISINDEX";
+//            case TreeBuilder.LI:
+//                return "LI";
+//            case TreeBuilder.LINK:
+//                return "LINK";
+//            case TreeBuilder.MATH:
+//                return "MATH";
+//            case TreeBuilder.META:
+//                return "META";
+//            case TreeBuilder.SVG:
+//                return "SVG";
+//            case TreeBuilder.HEAD:
+//                return "HEAD";
+//            case TreeBuilder.HR:
+//                return "HR";
+//            case TreeBuilder.HTML:
+//                return "HTML";
+//            case TreeBuilder.NOBR:
+//                return "NOBR";
+//            case TreeBuilder.NOFRAMES:
+//                return "NOFRAMES";
+//            case TreeBuilder.NOSCRIPT:
+//                return "NOSCRIPT";
+//            case TreeBuilder.OPTGROUP:
+//                return "OPTGROUP";
+//            case TreeBuilder.OPTION:
+//                return "OPTION";
+//            case TreeBuilder.P:
+//                return "P";
+//            case TreeBuilder.PLAINTEXT:
+//                return "PLAINTEXT";
+//            case TreeBuilder.SCRIPT:
+//                return "SCRIPT";
+//            case TreeBuilder.SELECT:
+//                return "SELECT";
+//            case TreeBuilder.STYLE:
+//                return "STYLE";
+//            case TreeBuilder.TABLE:
+//                return "TABLE";
+//            case TreeBuilder.TEXTAREA:
+//                return "TEXTAREA";
+//            case TreeBuilder.TITLE:
+//                return "TITLE";
+//            case TreeBuilder.TR:
+//                return "TR";
+//            case TreeBuilder.XMP:
+//                return "XMP";
+//            case TreeBuilder.TBODY_OR_THEAD_OR_TFOOT:
+//                return "TBODY_OR_THEAD_OR_TFOOT";
+//            case TreeBuilder.TD_OR_TH:
+//                return "TD_OR_TH";
+//            case TreeBuilder.DD_OR_DT:
+//                return "DD_OR_DT";
+//            case TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6:
+//                return "H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6";
+//            case TreeBuilder.OBJECT_OR_MARQUEE_OR_APPLET:
+//                return "OBJECT_OR_MARQUEE_OR_APPLET";
+//            case TreeBuilder.PRE_OR_LISTING:
+//                return "PRE_OR_LISTING";
+//            case TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U:
+//                return "B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U";
+//            case TreeBuilder.UL_OR_OL_OR_DL:
+//                return "UL_OR_OL_OR_DL";
+//            case TreeBuilder.IFRAME:
+//                return "IFRAME";
+//            case TreeBuilder.NOEMBED:
+//                return "NOEMBED";
+//            case TreeBuilder.EMBED_OR_IMG:
+//                return "EMBED_OR_IMG";
+//            case TreeBuilder.AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR:
+//                return "AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR";
+//            case TreeBuilder.DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU:
+//                return "DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU";
+//            case TreeBuilder.FIELDSET_OR_ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION:
+//                return "FIELDSET_OR_ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION";
+//            case TreeBuilder.CODE_OR_RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR:
+//                return "CODE_OR_RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR";
+//            case TreeBuilder.RT_OR_RP:
+//                return "RT_OR_RP";
+//            case TreeBuilder.COMMAND_OR_EVENT_SOURCE:
+//                return "COMMAND_OR_EVENT_SOURCE";
+//            case TreeBuilder.PARAM_OR_SOURCE:
+//                return "PARAM_OR_SOURCE";
+//            case TreeBuilder.MGLYPH_OR_MALIGNMARK:
+//                return "MGLYPH_OR_MALIGNMARK";
+//            case TreeBuilder.MI_MO_MN_MS_MTEXT:
+//                return "MI_MO_MN_MS_MTEXT";
+//            case TreeBuilder.ANNOTATION_XML:
+//                return "ANNOTATION_XML";
+//            case TreeBuilder.FOREIGNOBJECT_OR_DESC:
+//                return "FOREIGNOBJECT_OR_DESC";
+//        }
+//        return null;
+//    }
+//
+//    /**
+//     * Regenerate self
+//     * 
+//     * @param args
+//     */
+//    public static void main(String[] args) {
+//        Arrays.sort(ELEMENT_NAMES);
+//        for (int i = 1; i < ELEMENT_NAMES.length; i++) {
+//            if (ELEMENT_NAMES[i].hash() == ELEMENT_NAMES[i - 1].hash()) {
+//                System.err.println("Hash collision: " + ELEMENT_NAMES[i].name
+//                        + ", " + ELEMENT_NAMES[i - 1].name);
+//                return;
+//            }
+//        }
+//        for (int i = 0; i < ELEMENT_NAMES.length; i++) {
+//            ElementName el = ELEMENT_NAMES[i];
+//            System.out.println("public static final ElementName "
+//                    + el.constName() + " = new ElementName" + el.toString()
+//                    + ";");
+//        }
+//        System.out.println("private final static @NoLength ElementName[] ELEMENT_NAMES = {");
+//        for (int i = 0; i < ELEMENT_NAMES.length; i++) {
+//            ElementName el = ELEMENT_NAMES[i];
+//            System.out.println(el.constName() + ",");
+//        }
+//        System.out.println("};");
+//        System.out.println("private final static int[] ELEMENT_HASHES = {");
+//        for (int i = 0; i < ELEMENT_NAMES.length; i++) {
+//            ElementName el = ELEMENT_NAMES[i];
+//            System.out.println(Integer.toString(el.hash()) + ",");
+//        }
+//        System.out.println("};");
+//    }
+
+    // START GENERATED CODE
+    public static final ElementName A = new ElementName("a", "a", TreeBuilder.A, false, false, false);
+    public static final ElementName B = new ElementName("b", "b", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName G = new ElementName("g", "g", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName I = new ElementName("i", "i", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName P = new ElementName("p", "p", TreeBuilder.P, true, false, false);
+    public static final ElementName Q = new ElementName("q", "q", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName S = new ElementName("s", "s", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName U = new ElementName("u", "u", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName BR = new ElementName("br", "br", TreeBuilder.BR, true, false, false);
+    public static final ElementName CI = new ElementName("ci", "ci", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CN = new ElementName("cn", "cn", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DD = new ElementName("dd", "dd", TreeBuilder.DD_OR_DT, true, false, false);
+    public static final ElementName DL = new ElementName("dl", "dl", TreeBuilder.UL_OR_OL_OR_DL, true, false, false);
+    public static final ElementName DT = new ElementName("dt", "dt", TreeBuilder.DD_OR_DT, true, false, false);
+    public static final ElementName EM = new ElementName("em", "em", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName EQ = new ElementName("eq", "eq", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FN = new ElementName("fn", "fn", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName H1 = new ElementName("h1", "h1", TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6, true, false, false);
+    public static final ElementName H2 = new ElementName("h2", "h2", TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6, true, false, false);
+    public static final ElementName H3 = new ElementName("h3", "h3", TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6, true, false, false);
+    public static final ElementName H4 = new ElementName("h4", "h4", TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6, true, false, false);
+    public static final ElementName H5 = new ElementName("h5", "h5", TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6, true, false, false);
+    public static final ElementName H6 = new ElementName("h6", "h6", TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6, true, false, false);
+    public static final ElementName GT = new ElementName("gt", "gt", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName HR = new ElementName("hr", "hr", TreeBuilder.HR, true, false, false);
+    public static final ElementName IN = new ElementName("in", "in", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LI = new ElementName("li", "li", TreeBuilder.LI, true, false, false);
+    public static final ElementName LN = new ElementName("ln", "ln", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LT = new ElementName("lt", "lt", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MI = new ElementName("mi", "mi", TreeBuilder.MI_MO_MN_MS_MTEXT, false, false, false);
+    public static final ElementName MN = new ElementName("mn", "mn", TreeBuilder.MI_MO_MN_MS_MTEXT, false, false, false);
+    public static final ElementName MO = new ElementName("mo", "mo", TreeBuilder.MI_MO_MN_MS_MTEXT, false, false, false);
+    public static final ElementName MS = new ElementName("ms", "ms", TreeBuilder.MI_MO_MN_MS_MTEXT, false, false, false);
+    public static final ElementName OL = new ElementName("ol", "ol", TreeBuilder.UL_OR_OL_OR_DL, true, false, false);
+    public static final ElementName OR = new ElementName("or", "or", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PI = new ElementName("pi", "pi", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName RP = new ElementName("rp", "rp", TreeBuilder.RT_OR_RP, false, false, false);
+    public static final ElementName RT = new ElementName("rt", "rt", TreeBuilder.RT_OR_RP, false, false, false);
+    public static final ElementName TD = new ElementName("td", "td", TreeBuilder.TD_OR_TH, false, true, false);
+    public static final ElementName TH = new ElementName("th", "th", TreeBuilder.TD_OR_TH, false, true, false);
+    public static final ElementName TR = new ElementName("tr", "tr", TreeBuilder.TR, true, false, true);
+    public static final ElementName TT = new ElementName("tt", "tt", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName UL = new ElementName("ul", "ul", TreeBuilder.UL_OR_OL_OR_DL, true, false, false);
+    public static final ElementName AND = new ElementName("and", "and", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARG = new ElementName("arg", "arg", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ABS = new ElementName("abs", "abs", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName BIG = new ElementName("big", "big", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName BDO = new ElementName("bdo", "bdo", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CSC = new ElementName("csc", "csc", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName COL = new ElementName("col", "col", TreeBuilder.COL, true, false, false);
+    public static final ElementName COS = new ElementName("cos", "cos", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName COT = new ElementName("cot", "cot", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DEL = new ElementName("del", "del", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DFN = new ElementName("dfn", "dfn", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DIR = new ElementName("dir", "dir", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName DIV = new ElementName("div", "div", TreeBuilder.DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU, true, false, false);
+    public static final ElementName EXP = new ElementName("exp", "exp", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName GCD = new ElementName("gcd", "gcd", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName GEQ = new ElementName("geq", "geq", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName IMG = new ElementName("img", "img", TreeBuilder.EMBED_OR_IMG, true, false, false);
+    public static final ElementName INS = new ElementName("ins", "ins", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName INT = new ElementName("int", "int", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName KBD = new ElementName("kbd", "kbd", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LOG = new ElementName("log", "log", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LCM = new ElementName("lcm", "lcm", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LEQ = new ElementName("leq", "leq", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MTD = new ElementName("mtd", "mtd", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MIN = new ElementName("min", "min", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MAP = new ElementName("map", "map", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MTR = new ElementName("mtr", "mtr", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MAX = new ElementName("max", "max", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NEQ = new ElementName("neq", "neq", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NOT = new ElementName("not", "not", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NAV = new ElementName("nav", "nav", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName PRE = new ElementName("pre", "pre", TreeBuilder.PRE_OR_LISTING, true, false, false);
+    public static final ElementName REM = new ElementName("rem", "rem", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SUB = new ElementName("sub", "sub", TreeBuilder.RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR, false, false, false);
+    public static final ElementName SEC = new ElementName("sec", "sec", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SVG = new ElementName("svg", "svg", TreeBuilder.SVG, false, false, false);
+    public static final ElementName SUM = new ElementName("sum", "sum", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SIN = new ElementName("sin", "sin", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SEP = new ElementName("sep", "sep", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SUP = new ElementName("sup", "sup", TreeBuilder.RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR, false, false, false);
+    public static final ElementName SET = new ElementName("set", "set", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TAN = new ElementName("tan", "tan", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName USE = new ElementName("use", "use", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName VAR = new ElementName("var", "var", TreeBuilder.RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR, false, false, false);
+    public static final ElementName WBR = new ElementName("wbr", "wbr", TreeBuilder.AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR, true, false, false);
+    public static final ElementName XMP = new ElementName("xmp", "xmp", TreeBuilder.XMP, false, false, false);
+    public static final ElementName XOR = new ElementName("xor", "xor", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName AREA = new ElementName("area", "area", TreeBuilder.AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR, true, false, false);
+    public static final ElementName ABBR = new ElementName("abbr", "abbr", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName BASE = new ElementName("base", "base", TreeBuilder.BASE, true, false, false);
+    public static final ElementName BVAR = new ElementName("bvar", "bvar", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName BODY = new ElementName("body", "body", TreeBuilder.BODY, true, false, false);
+    public static final ElementName CARD = new ElementName("card", "card", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CODE = new ElementName("code", "code", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName CITE = new ElementName("cite", "cite", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CSCH = new ElementName("csch", "csch", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName COSH = new ElementName("cosh", "cosh", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName COTH = new ElementName("coth", "coth", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CURL = new ElementName("curl", "curl", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DESC = new ElementName("desc", "desc", TreeBuilder.FOREIGNOBJECT_OR_DESC, false, false, false);
+    public static final ElementName DIFF = new ElementName("diff", "diff", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DEFS = new ElementName("defs", "defs", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FORM = new ElementName("form", "form", TreeBuilder.FORM, true, false, false);
+    public static final ElementName FONT = new ElementName("font", "font", TreeBuilder.FONT, false, false, false);
+    public static final ElementName GRAD = new ElementName("grad", "grad", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName HEAD = new ElementName("head", "head", TreeBuilder.HEAD, true, false, false);
+    public static final ElementName HTML = new ElementName("html", "html", TreeBuilder.HTML, false, true, false);
+    public static final ElementName LINE = new ElementName("line", "line", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LINK = new ElementName("link", "link", TreeBuilder.LINK, true, false, false);
+    public static final ElementName LIST = new ElementName("list", "list", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName META = new ElementName("meta", "meta", TreeBuilder.META, true, false, false);
+    public static final ElementName MSUB = new ElementName("msub", "msub", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MODE = new ElementName("mode", "mode", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MATH = new ElementName("math", "math", TreeBuilder.MATH, false, false, false);
+    public static final ElementName MARK = new ElementName("mark", "mark", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MASK = new ElementName("mask", "mask", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MEAN = new ElementName("mean", "mean", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MSUP = new ElementName("msup", "msup", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MENU = new ElementName("menu", "menu", TreeBuilder.DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU, true, false, false);
+    public static final ElementName MROW = new ElementName("mrow", "mrow", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NONE = new ElementName("none", "none", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NOBR = new ElementName("nobr", "nobr", TreeBuilder.NOBR, false, false, false);
+    public static final ElementName NEST = new ElementName("nest", "nest", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PATH = new ElementName("path", "path", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PLUS = new ElementName("plus", "plus", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName RULE = new ElementName("rule", "rule", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName REAL = new ElementName("real", "real", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName RELN = new ElementName("reln", "reln", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName RECT = new ElementName("rect", "rect", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ROOT = new ElementName("root", "root", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName RUBY = new ElementName("ruby", "ruby", TreeBuilder.RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR, false, false, false);
+    public static final ElementName SECH = new ElementName("sech", "sech", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SINH = new ElementName("sinh", "sinh", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SPAN = new ElementName("span", "span", TreeBuilder.RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR, false, false, false);
+    public static final ElementName SAMP = new ElementName("samp", "samp", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName STOP = new ElementName("stop", "stop", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SDEV = new ElementName("sdev", "sdev", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TIME = new ElementName("time", "time", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TRUE = new ElementName("true", "true", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TREF = new ElementName("tref", "tref", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TANH = new ElementName("tanh", "tanh", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TEXT = new ElementName("text", "text", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName VIEW = new ElementName("view", "view", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ASIDE = new ElementName("aside", "aside", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName AUDIO = new ElementName("audio", "audio", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName APPLY = new ElementName("apply", "apply", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName EMBED = new ElementName("embed", "embed", TreeBuilder.EMBED_OR_IMG, true, false, false);
+    public static final ElementName FRAME = new ElementName("frame", "frame", TreeBuilder.FRAME, true, false, false);
+    public static final ElementName FALSE = new ElementName("false", "false", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FLOOR = new ElementName("floor", "floor", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName GLYPH = new ElementName("glyph", "glyph", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName HKERN = new ElementName("hkern", "hkern", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName IMAGE = new ElementName("image", "image", TreeBuilder.IMAGE, true, false, false);
+    public static final ElementName IDENT = new ElementName("ident", "ident", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName INPUT = new ElementName("input", "input", TreeBuilder.INPUT, true, false, false);
+    public static final ElementName LABEL = new ElementName("label", "label", TreeBuilder.OUTPUT_OR_LABEL, false, false, false);
+    public static final ElementName LIMIT = new ElementName("limit", "limit", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MFRAC = new ElementName("mfrac", "mfrac", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MPATH = new ElementName("mpath", "mpath", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName METER = new ElementName("meter", "meter", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MOVER = new ElementName("mover", "mover", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MINUS = new ElementName("minus", "minus", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MROOT = new ElementName("mroot", "mroot", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MSQRT = new ElementName("msqrt", "msqrt", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MTEXT = new ElementName("mtext", "mtext", TreeBuilder.MI_MO_MN_MS_MTEXT, false, false, false);
+    public static final ElementName NOTIN = new ElementName("notin", "notin", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PIECE = new ElementName("piece", "piece", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PARAM = new ElementName("param", "param", TreeBuilder.PARAM_OR_SOURCE, true, false, false);
+    public static final ElementName POWER = new ElementName("power", "power", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName REALS = new ElementName("reals", "reals", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName STYLE = new ElementName("style", "style", TreeBuilder.STYLE, true, false, false);
+    public static final ElementName SMALL = new ElementName("small", "small", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName THEAD = new ElementName("thead", "thead", TreeBuilder.TBODY_OR_THEAD_OR_TFOOT, true, false, true);
+    public static final ElementName TABLE = new ElementName("table", "table", TreeBuilder.TABLE, false, true, true);
+    public static final ElementName TITLE = new ElementName("title", "title", TreeBuilder.TITLE, true, false, false);
+    public static final ElementName TSPAN = new ElementName("tspan", "tspan", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TIMES = new ElementName("times", "times", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TFOOT = new ElementName("tfoot", "tfoot", TreeBuilder.TBODY_OR_THEAD_OR_TFOOT, true, false, true);
+    public static final ElementName TBODY = new ElementName("tbody", "tbody", TreeBuilder.TBODY_OR_THEAD_OR_TFOOT, true, false, true);
+    public static final ElementName UNION = new ElementName("union", "union", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName VKERN = new ElementName("vkern", "vkern", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName VIDEO = new ElementName("video", "video", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCSEC = new ElementName("arcsec", "arcsec", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCCSC = new ElementName("arccsc", "arccsc", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCTAN = new ElementName("arctan", "arctan", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCSIN = new ElementName("arcsin", "arcsin", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCCOS = new ElementName("arccos", "arccos", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName APPLET = new ElementName("applet", "applet", TreeBuilder.MARQUEE_OR_APPLET, false, true, false);
+    public static final ElementName ARCCOT = new ElementName("arccot", "arccot", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName APPROX = new ElementName("approx", "approx", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName BUTTON = new ElementName("button", "button", TreeBuilder.BUTTON, false, true, false);
+    public static final ElementName CIRCLE = new ElementName("circle", "circle", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CENTER = new ElementName("center", "center", TreeBuilder.DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU, true, false, false);
+    public static final ElementName CURSOR = new ElementName("cursor", "cursor", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CANVAS = new ElementName("canvas", "canvas", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DIVIDE = new ElementName("divide", "divide", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DEGREE = new ElementName("degree", "degree", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DIALOG = new ElementName("dialog", "dialog", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName DOMAIN = new ElementName("domain", "domain", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName EXISTS = new ElementName("exists", "exists", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FETILE = new ElementName("fetile", "feTile", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FIGURE = new ElementName("figure", "figure", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName FORALL = new ElementName("forall", "forall", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FILTER = new ElementName("filter", "filter", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FOOTER = new ElementName("footer", "footer", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName HEADER = new ElementName("header", "header", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName IFRAME = new ElementName("iframe", "iframe", TreeBuilder.IFRAME, true, false, false);
+    public static final ElementName KEYGEN = new ElementName("keygen", "keygen", TreeBuilder.KEYGEN, true, false, false);
+    public static final ElementName LAMBDA = new ElementName("lambda", "lambda", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LEGEND = new ElementName("legend", "legend", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MSPACE = new ElementName("mspace", "mspace", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MTABLE = new ElementName("mtable", "mtable", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MSTYLE = new ElementName("mstyle", "mstyle", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MGLYPH = new ElementName("mglyph", "mglyph", TreeBuilder.MGLYPH_OR_MALIGNMARK, false, false, false);
+    public static final ElementName MEDIAN = new ElementName("median", "median", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MUNDER = new ElementName("munder", "munder", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MARKER = new ElementName("marker", "marker", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MERROR = new ElementName("merror", "merror", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MOMENT = new ElementName("moment", "moment", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MATRIX = new ElementName("matrix", "matrix", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName OPTION = new ElementName("option", "option", TreeBuilder.OPTION, true, false, false);
+    public static final ElementName OBJECT = new ElementName("object", "object", TreeBuilder.OBJECT, false, true, false);
+    public static final ElementName OUTPUT = new ElementName("output", "output", TreeBuilder.OUTPUT_OR_LABEL, false, false, false);
+    public static final ElementName PRIMES = new ElementName("primes", "primes", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SOURCE = new ElementName("source", "source", TreeBuilder.PARAM_OR_SOURCE, false, false, false);
+    public static final ElementName STRIKE = new ElementName("strike", "strike", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName STRONG = new ElementName("strong", "strong", TreeBuilder.B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U, false, false, false);
+    public static final ElementName SWITCH = new ElementName("switch", "switch", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SYMBOL = new ElementName("symbol", "symbol", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SPACER = new ElementName("spacer", "spacer", TreeBuilder.AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR, true, false, false);
+    public static final ElementName SELECT = new ElementName("select", "select", TreeBuilder.SELECT, true, false, false);
+    public static final ElementName SUBSET = new ElementName("subset", "subset", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SCRIPT = new ElementName("script", "script", TreeBuilder.SCRIPT, true, false, false);
+    public static final ElementName TBREAK = new ElementName("tbreak", "tbreak", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName VECTOR = new ElementName("vector", "vector", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARTICLE = new ElementName("article", "article", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName ANIMATE = new ElementName("animate", "animate", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCSECH = new ElementName("arcsech", "arcsech", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCCSCH = new ElementName("arccsch", "arccsch", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCTANH = new ElementName("arctanh", "arctanh", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCSINH = new ElementName("arcsinh", "arcsinh", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCCOSH = new ElementName("arccosh", "arccosh", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ARCCOTH = new ElementName("arccoth", "arccoth", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ACRONYM = new ElementName("acronym", "acronym", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ADDRESS = new ElementName("address", "address", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName BGSOUND = new ElementName("bgsound", "bgsound", TreeBuilder.AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR, true, false, false);
+    public static final ElementName COMMAND = new ElementName("command", "command", TreeBuilder.COMMAND_OR_EVENT_SOURCE, true, false, false);
+    public static final ElementName COMPOSE = new ElementName("compose", "compose", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CEILING = new ElementName("ceiling", "ceiling", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CSYMBOL = new ElementName("csymbol", "csymbol", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CAPTION = new ElementName("caption", "caption", TreeBuilder.CAPTION, false, true, false);
+    public static final ElementName DISCARD = new ElementName("discard", "discard", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DECLARE = new ElementName("declare", "declare", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DETAILS = new ElementName("details", "details", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName ELLIPSE = new ElementName("ellipse", "ellipse", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEFUNCA = new ElementName("fefunca", "feFuncA", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEFUNCB = new ElementName("fefuncb", "feFuncB", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEBLEND = new ElementName("feblend", "feBlend", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEFLOOD = new ElementName("feflood", "feFlood", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEIMAGE = new ElementName("feimage", "feImage", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEMERGE = new ElementName("femerge", "feMerge", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEFUNCG = new ElementName("fefuncg", "feFuncG", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEFUNCR = new ElementName("fefuncr", "feFuncR", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName HANDLER = new ElementName("handler", "handler", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName INVERSE = new ElementName("inverse", "inverse", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName IMPLIES = new ElementName("implies", "implies", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ISINDEX = new ElementName("isindex", "isindex", TreeBuilder.ISINDEX, true, false, false);
+    public static final ElementName LOGBASE = new ElementName("logbase", "logbase", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LISTING = new ElementName("listing", "listing", TreeBuilder.PRE_OR_LISTING, true, false, false);
+    public static final ElementName MFENCED = new ElementName("mfenced", "mfenced", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MPADDED = new ElementName("mpadded", "mpadded", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MARQUEE = new ElementName("marquee", "marquee", TreeBuilder.MARQUEE_OR_APPLET, false, true, false);
+    public static final ElementName MACTION = new ElementName("maction", "maction", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MSUBSUP = new ElementName("msubsup", "msubsup", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NOEMBED = new ElementName("noembed", "noembed", TreeBuilder.NOEMBED, true, false, false);
+    public static final ElementName POLYGON = new ElementName("polygon", "polygon", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PATTERN = new ElementName("pattern", "pattern", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PRODUCT = new ElementName("product", "product", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SETDIFF = new ElementName("setdiff", "setdiff", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SECTION = new ElementName("section", "section", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName TENDSTO = new ElementName("tendsto", "tendsto", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName UPLIMIT = new ElementName("uplimit", "uplimit", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ALTGLYPH = new ElementName("altglyph", "altGlyph", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName BASEFONT = new ElementName("basefont", "basefont", TreeBuilder.AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR, true, false, false);
+    public static final ElementName CLIPPATH = new ElementName("clippath", "clipPath", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CODOMAIN = new ElementName("codomain", "codomain", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName COLGROUP = new ElementName("colgroup", "colgroup", TreeBuilder.COLGROUP, true, false, false);
+    public static final ElementName DATAGRID = new ElementName("datagrid", "datagrid", TreeBuilder.ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION, true, false, false);
+    public static final ElementName EMPTYSET = new ElementName("emptyset", "emptyset", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FACTOROF = new ElementName("factorof", "factorof", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FIELDSET = new ElementName("fieldset", "fieldset", TreeBuilder.FIELDSET, true, false, false);
+    public static final ElementName FRAMESET = new ElementName("frameset", "frameset", TreeBuilder.FRAMESET, true, false, false);
+    public static final ElementName FEOFFSET = new ElementName("feoffset", "feOffset", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName GLYPHREF = new ElementName("glyphref", "glyphRef", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName INTERVAL = new ElementName("interval", "interval", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName INTEGERS = new ElementName("integers", "integers", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName INFINITY = new ElementName("infinity", "infinity", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LISTENER = new ElementName("listener", "listener", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LOWLIMIT = new ElementName("lowlimit", "lowlimit", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName METADATA = new ElementName("metadata", "metadata", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MENCLOSE = new ElementName("menclose", "menclose", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MPHANTOM = new ElementName("mphantom", "mphantom", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NOFRAMES = new ElementName("noframes", "noframes", TreeBuilder.NOFRAMES, true, false, false);
+    public static final ElementName NOSCRIPT = new ElementName("noscript", "noscript", TreeBuilder.NOSCRIPT, true, false, false);
+    public static final ElementName OPTGROUP = new ElementName("optgroup", "optgroup", TreeBuilder.OPTGROUP, true, false, false);
+    public static final ElementName POLYLINE = new ElementName("polyline", "polyline", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PREFETCH = new ElementName("prefetch", "prefetch", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PROGRESS = new ElementName("progress", "progress", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PRSUBSET = new ElementName("prsubset", "prsubset", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName QUOTIENT = new ElementName("quotient", "quotient", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SELECTOR = new ElementName("selector", "selector", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TEXTAREA = new ElementName("textarea", "textarea", TreeBuilder.TEXTAREA, true, false, false);
+    public static final ElementName TEXTPATH = new ElementName("textpath", "textPath", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName VARIANCE = new ElementName("variance", "variance", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ANIMATION = new ElementName("animation", "animation", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CONJUGATE = new ElementName("conjugate", "conjugate", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CONDITION = new ElementName("condition", "condition", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName COMPLEXES = new ElementName("complexes", "complexes", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FONT_FACE = new ElementName("font-face", "font-face", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FACTORIAL = new ElementName("factorial", "factorial", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName INTERSECT = new ElementName("intersect", "intersect", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName IMAGINARY = new ElementName("imaginary", "imaginary", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LAPLACIAN = new ElementName("laplacian", "laplacian", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MATRIXROW = new ElementName("matrixrow", "matrixrow", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NOTSUBSET = new ElementName("notsubset", "notsubset", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName OTHERWISE = new ElementName("otherwise", "otherwise", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PIECEWISE = new ElementName("piecewise", "piecewise", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PLAINTEXT = new ElementName("plaintext", "plaintext", TreeBuilder.PLAINTEXT, true, false, false);
+    public static final ElementName RATIONALS = new ElementName("rationals", "rationals", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SEMANTICS = new ElementName("semantics", "semantics", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName TRANSPOSE = new ElementName("transpose", "transpose", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ANNOTATION = new ElementName("annotation", "annotation", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName BLOCKQUOTE = new ElementName("blockquote", "blockquote", TreeBuilder.DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU, true, false, false);
+    public static final ElementName DIVERGENCE = new ElementName("divergence", "divergence", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName EULERGAMMA = new ElementName("eulergamma", "eulergamma", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName EQUIVALENT = new ElementName("equivalent", "equivalent", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName IMAGINARYI = new ElementName("imaginaryi", "imaginaryi", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MALIGNMARK = new ElementName("malignmark", "malignmark", TreeBuilder.MGLYPH_OR_MALIGNMARK, false, false, false);
+    public static final ElementName MUNDEROVER = new ElementName("munderover", "munderover", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MLABELEDTR = new ElementName("mlabeledtr", "mlabeledtr", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NOTANUMBER = new ElementName("notanumber", "notanumber", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SOLIDCOLOR = new ElementName("solidcolor", "solidcolor", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ALTGLYPHDEF = new ElementName("altglyphdef", "altGlyphDef", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DETERMINANT = new ElementName("determinant", "determinant", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName EVENTSOURCE = new ElementName("eventsource", "eventsource", TreeBuilder.COMMAND_OR_EVENT_SOURCE, true, false, false);
+    public static final ElementName FEMERGENODE = new ElementName("femergenode", "feMergeNode", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FECOMPOSITE = new ElementName("fecomposite", "feComposite", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FESPOTLIGHT = new ElementName("fespotlight", "feSpotLight", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MALIGNGROUP = new ElementName("maligngroup", "maligngroup", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MPRESCRIPTS = new ElementName("mprescripts", "mprescripts", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MOMENTABOUT = new ElementName("momentabout", "momentabout", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NOTPRSUBSET = new ElementName("notprsubset", "notprsubset", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName PARTIALDIFF = new ElementName("partialdiff", "partialdiff", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ALTGLYPHITEM = new ElementName("altglyphitem", "altGlyphItem", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ANIMATECOLOR = new ElementName("animatecolor", "animateColor", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DATATEMPLATE = new ElementName("datatemplate", "datatemplate", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName EXPONENTIALE = new ElementName("exponentiale", "exponentiale", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FETURBULENCE = new ElementName("feturbulence", "feTurbulence", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEPOINTLIGHT = new ElementName("fepointlight", "fePointLight", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEMORPHOLOGY = new ElementName("femorphology", "feMorphology", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName OUTERPRODUCT = new ElementName("outerproduct", "outerproduct", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ANIMATEMOTION = new ElementName("animatemotion", "animateMotion", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName COLOR_PROFILE = new ElementName("color-profile", "color-profile", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FONT_FACE_SRC = new ElementName("font-face-src", "font-face-src", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FONT_FACE_URI = new ElementName("font-face-uri", "font-face-uri", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FOREIGNOBJECT = new ElementName("foreignobject", "foreignObject", TreeBuilder.FOREIGNOBJECT_OR_DESC, false, false, false);
+    public static final ElementName FECOLORMATRIX = new ElementName("fecolormatrix", "feColorMatrix", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MISSING_GLYPH = new ElementName("missing-glyph", "missing-glyph", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName MMULTISCRIPTS = new ElementName("mmultiscripts", "mmultiscripts", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName SCALARPRODUCT = new ElementName("scalarproduct", "scalarproduct", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName VECTORPRODUCT = new ElementName("vectorproduct", "vectorproduct", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ANNOTATION_XML = new ElementName("annotation-xml", "annotation-xml", TreeBuilder.ANNOTATION_XML, false, false, false);
+    public static final ElementName DEFINITION_SRC = new ElementName("definition-src", "definition-src", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FONT_FACE_NAME = new ElementName("font-face-name", "font-face-name", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEGAUSSIANBLUR = new ElementName("fegaussianblur", "feGaussianBlur", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEDISTANTLIGHT = new ElementName("fedistantlight", "feDistantLight", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName LINEARGRADIENT = new ElementName("lineargradient", "linearGradient", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName NATURALNUMBERS = new ElementName("naturalnumbers", "naturalnumbers", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName RADIALGRADIENT = new ElementName("radialgradient", "radialGradient", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName ANIMATETRANSFORM = new ElementName("animatetransform", "animateTransform", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName CARTESIANPRODUCT = new ElementName("cartesianproduct", "cartesianproduct", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FONT_FACE_FORMAT = new ElementName("font-face-format", "font-face-format", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FECONVOLVEMATRIX = new ElementName("feconvolvematrix", "feConvolveMatrix", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEDIFFUSELIGHTING = new ElementName("fediffuselighting", "feDiffuseLighting", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FEDISPLACEMENTMAP = new ElementName("fedisplacementmap", "feDisplacementMap", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FESPECULARLIGHTING = new ElementName("fespecularlighting", "feSpecularLighting", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName DOMAINOFAPPLICATION = new ElementName("domainofapplication", "domainofapplication", TreeBuilder.OTHER, false, false, false);
+    public static final ElementName FECOMPONENTTRANSFER = new ElementName("fecomponenttransfer", "feComponentTransfer", TreeBuilder.OTHER, false, false, false);
+    private final static @NoLength ElementName[] ELEMENT_NAMES = {
+    A,
+    B,
+    G,
+    I,
+    P,
+    Q,
+    S,
+    U,
+    BR,
+    CI,
+    CN,
+    DD,
+    DL,
+    DT,
+    EM,
+    EQ,
+    FN,
+    H1,
+    H2,
+    H3,
+    H4,
+    H5,
+    H6,
+    GT,
+    HR,
+    IN,
+    LI,
+    LN,
+    LT,
+    MI,
+    MN,
+    MO,
+    MS,
+    OL,
+    OR,
+    PI,
+    RP,
+    RT,
+    TD,
+    TH,
+    TR,
+    TT,
+    UL,
+    AND,
+    ARG,
+    ABS,
+    BIG,
+    BDO,
+    CSC,
+    COL,
+    COS,
+    COT,
+    DEL,
+    DFN,
+    DIR,
+    DIV,
+    EXP,
+    GCD,
+    GEQ,
+    IMG,
+    INS,
+    INT,
+    KBD,
+    LOG,
+    LCM,
+    LEQ,
+    MTD,
+    MIN,
+    MAP,
+    MTR,
+    MAX,
+    NEQ,
+    NOT,
+    NAV,
+    PRE,
+    REM,
+    SUB,
+    SEC,
+    SVG,
+    SUM,
+    SIN,
+    SEP,
+    SUP,
+    SET,
+    TAN,
+    USE,
+    VAR,
+    WBR,
+    XMP,
+    XOR,
+    AREA,
+    ABBR,
+    BASE,
+    BVAR,
+    BODY,
+    CARD,
+    CODE,
+    CITE,
+    CSCH,
+    COSH,
+    COTH,
+    CURL,
+    DESC,
+    DIFF,
+    DEFS,
+    FORM,
+    FONT,
+    GRAD,
+    HEAD,
+    HTML,
+    LINE,
+    LINK,
+    LIST,
+    META,
+    MSUB,
+    MODE,
+    MATH,
+    MARK,
+    MASK,
+    MEAN,
+    MSUP,
+    MENU,
+    MROW,
+    NONE,
+    NOBR,
+    NEST,
+    PATH,
+    PLUS,
+    RULE,
+    REAL,
+    RELN,
+    RECT,
+    ROOT,
+    RUBY,
+    SECH,
+    SINH,
+    SPAN,
+    SAMP,
+    STOP,
+    SDEV,
+    TIME,
+    TRUE,
+    TREF,
+    TANH,
+    TEXT,
+    VIEW,
+    ASIDE,
+    AUDIO,
+    APPLY,
+    EMBED,
+    FRAME,
+    FALSE,
+    FLOOR,
+    GLYPH,
+    HKERN,
+    IMAGE,
+    IDENT,
+    INPUT,
+    LABEL,
+    LIMIT,
+    MFRAC,
+    MPATH,
+    METER,
+    MOVER,
+    MINUS,
+    MROOT,
+    MSQRT,
+    MTEXT,
+    NOTIN,
+    PIECE,
+    PARAM,
+    POWER,
+    REALS,
+    STYLE,
+    SMALL,
+    THEAD,
+    TABLE,
+    TITLE,
+    TSPAN,
+    TIMES,
+    TFOOT,
+    TBODY,
+    UNION,
+    VKERN,
+    VIDEO,
+    ARCSEC,
+    ARCCSC,
+    ARCTAN,
+    ARCSIN,
+    ARCCOS,
+    APPLET,
+    ARCCOT,
+    APPROX,
+    BUTTON,
+    CIRCLE,
+    CENTER,
+    CURSOR,
+    CANVAS,
+    DIVIDE,
+    DEGREE,
+    DIALOG,
+    DOMAIN,
+    EXISTS,
+    FETILE,
+    FIGURE,
+    FORALL,
+    FILTER,
+    FOOTER,
+    HEADER,
+    IFRAME,
+    KEYGEN,
+    LAMBDA,
+    LEGEND,
+    MSPACE,
+    MTABLE,
+    MSTYLE,
+    MGLYPH,
+    MEDIAN,
+    MUNDER,
+    MARKER,
+    MERROR,
+    MOMENT,
+    MATRIX,
+    OPTION,
+    OBJECT,
+    OUTPUT,
+    PRIMES,
+    SOURCE,
+    STRIKE,
+    STRONG,
+    SWITCH,
+    SYMBOL,
+    SPACER,
+    SELECT,
+    SUBSET,
+    SCRIPT,
+    TBREAK,
+    VECTOR,
+    ARTICLE,
+    ANIMATE,
+    ARCSECH,
+    ARCCSCH,
+    ARCTANH,
+    ARCSINH,
+    ARCCOSH,
+    ARCCOTH,
+    ACRONYM,
+    ADDRESS,
+    BGSOUND,
+    COMMAND,
+    COMPOSE,
+    CEILING,
+    CSYMBOL,
+    CAPTION,
+    DISCARD,
+    DECLARE,
+    DETAILS,
+    ELLIPSE,
+    FEFUNCA,
+    FEFUNCB,
+    FEBLEND,
+    FEFLOOD,
+    FEIMAGE,
+    FEMERGE,
+    FEFUNCG,
+    FEFUNCR,
+    HANDLER,
+    INVERSE,
+    IMPLIES,
+    ISINDEX,
+    LOGBASE,
+    LISTING,
+    MFENCED,
+    MPADDED,
+    MARQUEE,
+    MACTION,
+    MSUBSUP,
+    NOEMBED,
+    POLYGON,
+    PATTERN,
+    PRODUCT,
+    SETDIFF,
+    SECTION,
+    TENDSTO,
+    UPLIMIT,
+    ALTGLYPH,
+    BASEFONT,
+    CLIPPATH,
+    CODOMAIN,
+    COLGROUP,
+    DATAGRID,
+    EMPTYSET,
+    FACTOROF,
+    FIELDSET,
+    FRAMESET,
+    FEOFFSET,
+    GLYPHREF,
+    INTERVAL,
+    INTEGERS,
+    INFINITY,
+    LISTENER,
+    LOWLIMIT,
+    METADATA,
+    MENCLOSE,
+    MPHANTOM,
+    NOFRAMES,
+    NOSCRIPT,
+    OPTGROUP,
+    POLYLINE,
+    PREFETCH,
+    PROGRESS,
+    PRSUBSET,
+    QUOTIENT,
+    SELECTOR,
+    TEXTAREA,
+    TEXTPATH,
+    VARIANCE,
+    ANIMATION,
+    CONJUGATE,
+    CONDITION,
+    COMPLEXES,
+    FONT_FACE,
+    FACTORIAL,
+    INTERSECT,
+    IMAGINARY,
+    LAPLACIAN,
+    MATRIXROW,
+    NOTSUBSET,
+    OTHERWISE,
+    PIECEWISE,
+    PLAINTEXT,
+    RATIONALS,
+    SEMANTICS,
+    TRANSPOSE,
+    ANNOTATION,
+    BLOCKQUOTE,
+    DIVERGENCE,
+    EULERGAMMA,
+    EQUIVALENT,
+    IMAGINARYI,
+    MALIGNMARK,
+    MUNDEROVER,
+    MLABELEDTR,
+    NOTANUMBER,
+    SOLIDCOLOR,
+    ALTGLYPHDEF,
+    DETERMINANT,
+    EVENTSOURCE,
+    FEMERGENODE,
+    FECOMPOSITE,
+    FESPOTLIGHT,
+    MALIGNGROUP,
+    MPRESCRIPTS,
+    MOMENTABOUT,
+    NOTPRSUBSET,
+    PARTIALDIFF,
+    ALTGLYPHITEM,
+    ANIMATECOLOR,
+    DATATEMPLATE,
+    EXPONENTIALE,
+    FETURBULENCE,
+    FEPOINTLIGHT,
+    FEMORPHOLOGY,
+    OUTERPRODUCT,
+    ANIMATEMOTION,
+    COLOR_PROFILE,
+    FONT_FACE_SRC,
+    FONT_FACE_URI,
+    FOREIGNOBJECT,
+    FECOLORMATRIX,
+    MISSING_GLYPH,
+    MMULTISCRIPTS,
+    SCALARPRODUCT,
+    VECTORPRODUCT,
+    ANNOTATION_XML,
+    DEFINITION_SRC,
+    FONT_FACE_NAME,
+    FEGAUSSIANBLUR,
+    FEDISTANTLIGHT,
+    LINEARGRADIENT,
+    NATURALNUMBERS,
+    RADIALGRADIENT,
+    ANIMATETRANSFORM,
+    CARTESIANPRODUCT,
+    FONT_FACE_FORMAT,
+    FECONVOLVEMATRIX,
+    FEDIFFUSELIGHTING,
+    FEDISPLACEMENTMAP,
+    FESPECULARLIGHTING,
+    DOMAINOFAPPLICATION,
+    FECOMPONENTTRANSFER,
+    };
+    private final static int[] ELEMENT_HASHES = {
+    1057,
+    1090,
+    1255,
+    1321,
+    1552,
+    1585,
+    1651,
+    1717,
+    68162,
+    68899,
+    69059,
+    69764,
+    70020,
+    70276,
+    71077,
+    71205,
+    72134,
+    72232,
+    72264,
+    72296,
+    72328,
+    72360,
+    72392,
+    73351,
+    74312,
+    75209,
+    78124,
+    78284,
+    78476,
+    79149,
+    79309,
+    79341,
+    79469,
+    81295,
+    81487,
+    82224,
+    84498,
+    84626,
+    86164,
+    86292,
+    86612,
+    86676,
+    87445,
+    3183041,
+    3186241,
+    3198017,
+    3218722,
+    3226754,
+    3247715,
+    3256803,
+    3263971,
+    3264995,
+    3289252,
+    3291332,
+    3295524,
+    3299620,
+    3326725,
+    3379303,
+    3392679,
+    3448233,
+    3460553,
+    3461577,
+    3510347,
+    3546604,
+    3552364,
+    3556524,
+    3576461,
+    3586349,
+    3588141,
+    3590797,
+    3596333,
+    3622062,
+    3625454,
+    3627054,
+    3675728,
+    3749042,
+    3771059,
+    3771571,
+    3776211,
+    3782323,
+    3782963,
+    3784883,
+    3785395,
+    3788979,
+    3815476,
+    3839605,
+    3885110,
+    3917911,
+    3948984,
+    3951096,
+    135304769,
+    135858241,
+    136498210,
+    136906434,
+    137138658,
+    137512995,
+    137531875,
+    137548067,
+    137629283,
+    137645539,
+    137646563,
+    137775779,
+    138529956,
+    138615076,
+    139040932,
+    140954086,
+    141179366,
+    141690439,
+    142738600,
+    143013512,
+    146979116,
+    147175724,
+    147475756,
+    147902637,
+    147936877,
+    148017645,
+    148131885,
+    148228141,
+    148229165,
+    148309165,
+    148395629,
+    148551853,
+    148618829,
+    149076462,
+    149490158,
+    149572782,
+    151277616,
+    151639440,
+    153268914,
+    153486514,
+    153563314,
+    153750706,
+    153763314,
+    153914034,
+    154406067,
+    154417459,
+    154600979,
+    154678323,
+    154680979,
+    154866835,
+    155366708,
+    155375188,
+    155391572,
+    155465780,
+    155869364,
+    158045494,
+    168988979,
+    169321621,
+    169652752,
+    173151309,
+    174240818,
+    174247297,
+    174669292,
+    175391532,
+    176638123,
+    177380397,
+    177879204,
+    177886734,
+    180753473,
+    181020073,
+    181503558,
+    181686320,
+    181999237,
+    181999311,
+    182048201,
+    182074866,
+    182078003,
+    182083764,
+    182920847,
+    184716457,
+    184976961,
+    185145071,
+    187281445,
+    187872052,
+    188100653,
+    188875944,
+    188919873,
+    188920457,
+    189203987,
+    189371817,
+    189414886,
+    189567458,
+    190266670,
+    191318187,
+    191337609,
+    202479203,
+    202493027,
+    202835587,
+    202843747,
+    203013219,
+    203036048,
+    203045987,
+    203177552,
+    203898516,
+    204648562,
+    205067918,
+    205078130,
+    205096654,
+    205689142,
+    205690439,
+    205766017,
+    205988909,
+    207213161,
+    207794484,
+    207800999,
+    208023602,
+    208213644,
+    208213647,
+    210310273,
+    210940978,
+    213325049,
+    213946445,
+    214055079,
+    215125040,
+    215134273,
+    215135028,
+    215237420,
+    215418148,
+    215553166,
+    215553394,
+    215563858,
+    215627949,
+    215754324,
+    217529652,
+    217713834,
+    217732628,
+    218731945,
+    221417045,
+    221424946,
+    221493746,
+    221515401,
+    221658189,
+    221844577,
+    221908140,
+    221910626,
+    221921586,
+    222659762,
+    225001091,
+    236105833,
+    236113965,
+    236194995,
+    236195427,
+    236206132,
+    236206387,
+    236211683,
+    236212707,
+    236381647,
+    236571826,
+    237124271,
+    238172205,
+    238210544,
+    238270764,
+    238435405,
+    238501172,
+    239224867,
+    239257644,
+    239710497,
+    240307721,
+    241208789,
+    241241557,
+    241318060,
+    241319404,
+    241343533,
+    241344069,
+    241405397,
+    241765845,
+    243864964,
+    244502085,
+    244946220,
+    245109902,
+    247647266,
+    247707956,
+    248648814,
+    248648836,
+    248682161,
+    248986932,
+    249058914,
+    249697357,
+    252132601,
+    252135604,
+    252317348,
+    255007012,
+    255278388,
+    256365156,
+    257566121,
+    269763372,
+    271202790,
+    271863856,
+    272049197,
+    272127474,
+    272770631,
+    274339449,
+    274939471,
+    275388004,
+    275388005,
+    275388006,
+    275977800,
+    278267602,
+    278513831,
+    278712622,
+    281613765,
+    281683369,
+    282120228,
+    282250732,
+    282508942,
+    283743649,
+    283787570,
+    284710386,
+    285391148,
+    285478533,
+    285854898,
+    285873762,
+    286931113,
+    288964227,
+    289445441,
+    289689648,
+    291671489,
+    303512884,
+    305319975,
+    305610036,
+    305764101,
+    308448294,
+    308675890,
+    312085683,
+    312264750,
+    315032867,
+    316391000,
+    317331042,
+    317902135,
+    318950711,
+    319447220,
+    321499182,
+    322538804,
+    323145200,
+    337067316,
+    337826293,
+    339905989,
+    340833697,
+    341457068,
+    345302593,
+    349554733,
+    349771471,
+    349786245,
+    350819405,
+    356072847,
+    370349192,
+    373962798,
+    374509141,
+    375558638,
+    375574835,
+    376053993,
+    383276530,
+    383373833,
+    383407586,
+    384439906,
+    386079012,
+    404133513,
+    404307343,
+    407031852,
+    408072233,
+    409112005,
+    409608425,
+    409771500,
+    419040932,
+    437730612,
+    439529766,
+    442616365,
+    442813037,
+    443157674,
+    443295316,
+    450118444,
+    450482697,
+    456789668,
+    459935396,
+    471217869,
+    474073645,
+    476230702,
+    476665218,
+    476717289,
+    483014825,
+    485083298,
+    489306281,
+    538364390,
+    540675748,
+    543819186,
+    543958612,
+    576960820,
+    577242548,
+    610515252,
+    642202932,
+    644420819,
+    };
+
+
+}
diff --git a/parser/html/java/htmlparser/src/ErrorReportingTokenizer.java b/parser/html/java/htmlparser/src/ErrorReportingTokenizer.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/ErrorReportingTokenizer.java
@@ -0,0 +1,655 @@
+/*
+ * Copyright (c) 2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.Inline;
+import nu.validator.htmlparser.annotation.NoLength;
+import nu.validator.htmlparser.common.TokenHandler;
+import nu.validator.htmlparser.common.XmlViolationPolicy;
+
+import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
+
+public class ErrorReportingTokenizer extends Tokenizer {
+
+    /**
+     * Magic value for UTF-16 operations.
+     */
+    private static final int SURROGATE_OFFSET = (0x10000 - (0xD800 << 10) - 0xDC00);
+
+    /**
+     * The policy for non-space non-XML characters.
+     */
+    private XmlViolationPolicy contentNonXmlCharPolicy = XmlViolationPolicy.ALTER_INFOSET;
+    
+    /**
+     * Used together with <code>nonAsciiProhibited</code>.
+     */
+    private boolean alreadyComplainedAboutNonAscii;
+
+    /**
+     * Keeps track of PUA warnings.
+     */
+    private boolean alreadyWarnedAboutPrivateUseCharacters;
+    
+    /**
+     * The current line number in the current resource being parsed. (First line
+     * is 1.) Passed on as locator data.
+     */
+    private int line;
+
+    private int linePrev;
+
+    /**
+     * The current column number in the current resource being tokenized. (First
+     * column is 1, counted by UTF-16 code units.) Passed on as locator data.
+     */
+    private int col;
+
+    private int colPrev;
+
+    private boolean nextCharOnNewLine;
+
+    private char prev;
+    
+    /**
+     * @param tokenHandler
+     * @param newAttributesEachTime
+     */
+    public ErrorReportingTokenizer(TokenHandler tokenHandler,
+            boolean newAttributesEachTime) {
+        super(tokenHandler, newAttributesEachTime);
+    }
+
+    /**
+     * @param tokenHandler
+     */
+    public ErrorReportingTokenizer(TokenHandler tokenHandler) {
+        super(tokenHandler);
+    }
+
+    /**
+     * @see org.xml.sax.Locator#getLineNumber()
+     */
+    public int getLineNumber() {
+        if (line > 0) {
+            return line;
+        } else {
+            return -1;
+        }
+    }
+
+    /**
+     * @see org.xml.sax.Locator#getColumnNumber()
+     */
+    public int getColumnNumber() {
+        if (col > 0) {
+            return col;
+        } else {
+            return -1;
+        }
+    }
+    
+    /**
+     * Sets the contentNonXmlCharPolicy.
+     * 
+     * @param contentNonXmlCharPolicy
+     *            the contentNonXmlCharPolicy to set
+     */
+    public void setContentNonXmlCharPolicy(
+            XmlViolationPolicy contentNonXmlCharPolicy) {
+        this.contentNonXmlCharPolicy = contentNonXmlCharPolicy;
+    }
+    
+    protected void startErrorReporting() throws SAXException {
+        alreadyComplainedAboutNonAscii = false;   
+        line = linePrev = 0;
+        col = colPrev = 1;
+        nextCharOnNewLine = true;
+        prev = '\u0000';
+        alreadyWarnedAboutPrivateUseCharacters = false;
+    }
+    
+    @Inline protected void silentCarriageReturn() {
+        nextCharOnNewLine = true;
+        lastCR = true;
+    }
+
+    @Inline protected void silentLineFeed() {
+        nextCharOnNewLine = true;
+    }
+    
+    /**
+     * Returns the line.
+     * 
+     * @return the line
+     */
+    public int getLine() {
+        return line;
+    }
+
+    /**
+     * Returns the col.
+     * 
+     * @return the col
+     */
+    public int getCol() {
+        return col;
+    }
+    
+    /**
+     * Returns the nextCharOnNewLine.
+     * 
+     * @return the nextCharOnNewLine
+     */
+    public boolean isNextCharOnNewLine() {
+        return nextCharOnNewLine;
+    }
+    
+    private void complainAboutNonAscii() throws SAXException {
+        String encoding = null;
+        if (encodingDeclarationHandler != null) {
+            encoding = encodingDeclarationHandler.getCharacterEncoding();
+        }
+        if (encoding == null) {
+            err("The character encoding of the document was not explicit but the document contains non-ASCII.");
+        } else {
+            err("No explicit character encoding declaration has been seen yet (assumed \u201C"
+                    + encoding + "\u201D) but the document contains non-ASCII.");
+        }
+    }
+
+    /**
+     * Returns the alreadyComplainedAboutNonAscii.
+     * 
+     * @return the alreadyComplainedAboutNonAscii
+     */
+    public boolean isAlreadyComplainedAboutNonAscii() {
+        return alreadyComplainedAboutNonAscii;
+    }
+    
+    /**
+     * Flushes coalesced character tokens.
+     * @param buf TODO
+     * @param pos TODO
+     * 
+     * @throws SAXException
+     */
+    @Override protected void flushChars(char[] buf, int pos) throws SAXException {
+        if (pos > cstart) {
+            int currLine = line;
+            int currCol = col;
+            line = linePrev;
+            col = colPrev;
+            tokenHandler.characters(buf, cstart, pos - cstart);
+            line = currLine;
+            col = currCol;
+        }
+        cstart = 0x7fffffff;
+    }
+    
+    @Override protected char checkChar(@NoLength char[] buf, int pos) throws SAXException {
+        linePrev = line;
+        colPrev = col;
+        if (nextCharOnNewLine) {
+            line++;
+            col = 1;
+            nextCharOnNewLine = false;
+        } else {
+            col++;
+        }
+
+        char c = buf[pos];
+        if (!confident && !alreadyComplainedAboutNonAscii && c > '\u007F') {
+            complainAboutNonAscii();
+            alreadyComplainedAboutNonAscii = true;
+        }
+        switch (c) {
+            case '\u0000':
+                err("Saw U+0000 in stream.");
+            case '\t':
+            case '\r':
+            case '\n':
+                break;
+            case '\u000C':
+                if (contentNonXmlCharPolicy == XmlViolationPolicy.FATAL) {
+                    fatal("This document is not mappable to XML 1.0 without data loss due to "
+                            + toUPlusString(c)
+                            + " which is not a legal XML 1.0 character.");
+                } else {
+                    if (contentNonXmlCharPolicy == XmlViolationPolicy.ALTER_INFOSET) {
+                        c = buf[pos] = ' ';
+                    }
+                    warn("This document is not mappable to XML 1.0 without data loss due to "
+                            + toUPlusString(c)
+                            + " which is not a legal XML 1.0 character.");
+                }
+                break;
+            default:
+                if ((c & 0xFC00) == 0xDC00) {
+                    // Got a low surrogate. See if prev was high
+                    // surrogate
+                    if ((prev & 0xFC00) == 0xD800) {
+                        int intVal = (prev << 10) + c
+                                + SURROGATE_OFFSET;
+                        if ((intVal & 0xFFFE) == 0xFFFE) {
+                            err("Astral non-character.");
+                        }
+                        if (isAstralPrivateUse(intVal)) {
+                            warnAboutPrivateUseChar();
+                        }
+                    }
+                } else if ((c < ' ' || ((c & 0xFFFE) == 0xFFFE))) {
+                    switch (contentNonXmlCharPolicy) {
+                        case FATAL:
+                            fatal("Forbidden code point " + toUPlusString(c)
+                                    + ".");
+                            break;
+                        case ALTER_INFOSET:
+                            c = buf[pos] = '\uFFFD';
+                            // fall through
+                        case ALLOW:
+                            err("Forbidden code point " + toUPlusString(c)
+                                    + ".");
+                    }
+                } else if ((c >= '\u007F') && (c <= '\u009F')
+                        || (c >= '\uFDD0') && (c <= '\uFDDF')) {
+                    err("Forbidden code point " + toUPlusString(c) + ".");
+                } else if (isPrivateUse(c)) {
+                    warnAboutPrivateUseChar();
+                }
+        }
+        prev = c;
+        return c;
+    }
+
+    private String toUPlusString(char c) {
+        String hexString = Integer.toHexString(c);
+        switch (hexString.length()) {
+            case 1:
+                return "U+000" + hexString;
+            case 2:
+                return "U+00" + hexString;
+            case 3:
+                return "U+0" + hexString;
+            case 4:
+                return "U+" + hexString;
+            default:
+                throw new RuntimeException("Unreachable.");
+        }
+    }
+
+    /**
+     * Emits a warning about private use characters if the warning has not been
+     * emitted yet.
+     * 
+     * @throws SAXException
+     */
+    private void warnAboutPrivateUseChar() throws SAXException {
+        if (!alreadyWarnedAboutPrivateUseCharacters) {
+            warn("Document uses the Unicode Private Use Area(s), which should not be used in publicly exchanged documents. (Charmod C073)");
+            alreadyWarnedAboutPrivateUseCharacters = true;
+        }
+    }
+    
+    /**
+     * Tells if the argument is a BMP PUA character.
+     * 
+     * @param c
+     *            the UTF-16 code unit to check
+     * @return <code>true</code> if PUA character
+     */
+    private boolean isPrivateUse(char c) {
+        return c >= '\uE000' && c <= '\uF8FF';
+    }
+
+    /**
+     * Tells if the argument is an astral PUA character.
+     * 
+     * @param c
+     *            the code point to check
+     * @return <code>true</code> if astral private use
+     */
+    private boolean isAstralPrivateUse(int c) {
+        return (c >= 0xF0000 && c <= 0xFFFFD)
+                || (c >= 0x100000 && c <= 0x10FFFD);
+    }
+
+    
+    @Override protected void errGarbageAfterLtSlash() throws SAXException {
+        err("Garbage after \u201C</\u201D.");
+    }
+
+    @Override protected void errLtSlashGt() throws SAXException {
+        err("Saw \u201C</>\u201D. Probable causes: Unescaped \u201C<\u201D (escape as \u201C&lt;\u201D) or mistyped end tag.");
+    }
+
+    @Override protected void errWarnLtSlashInRcdata() throws SAXException {
+        if (html4) {
+            err((stateSave == Tokenizer.DATA ? "CDATA" : "RCDATA")
+                    + " element \u201C"
+                    + contentModelElement
+                    + "\u201D contained the string \u201C</\u201D, but it was not the start of the end tag. (HTML4-only error)");
+        } else {
+            warn((stateSave == Tokenizer.DATA ? "CDATA" : "RCDATA")
+                    + " element \u201C"
+                    + contentModelElement
+                    + "\u201D contained the string \u201C</\u201D, but this did not close the element.");
+        }
+    }
+
+    @Override protected void errHtml4LtSlashInRcdata(char folded)
+            throws SAXException {
+                if (html4 && (index > 0 || (folded >= 'a' && folded <= 'z'))
+                        && ElementName.IFRAME != contentModelElement) {
+                    err((stateSave == Tokenizer.DATA ? "CDATA" : "RCDATA")
+                            + " element \u201C"
+                            + contentModelElement.name
+                            + "\u201D contained the string \u201C</\u201D, but it was not the start of the end tag. (HTML4-only error)");
+                }
+            }
+
+    @Override protected void errCharRefLacksSemicolon() throws SAXException {
+        err("Character reference was not terminated by a semicolon.");
+    }
+
+    @Override protected void errNoDigitsInNCR() throws SAXException {
+        err("No digits after \u201C" + strBufToString() + "\u201D.");
+    }
+
+    @Override protected void errGtInSystemId() throws SAXException {
+        err("\u201C>\u201D in system identifier.");
+    }
+
+    @Override protected void errGtInPublicId() throws SAXException {
+        err("\u201C>\u201D in public identifier.");
+    }
+
+    @Override protected void errNamelessDoctype() throws SAXException {
+        err("Nameless doctype.");
+    }
+
+    @Override protected void errConsecutiveHyphens() throws SAXException {
+        err("Consecutive hyphens did not terminate a comment. \u201C--\u201D is not permitted inside a comment, but e.g. \u201C- -\u201D is.");
+    }
+
+    @Override protected void errPrematureEndOfComment() throws SAXException {
+        err("Premature end of comment. Use \u201C-->\u201D to end a comment properly.");
+    }
+
+    @Override protected void errBogusComment() throws SAXException {
+        err("Bogus comment.");
+    }
+
+    @Override protected void errUnquotedAttributeValOrNull(char c)
+            throws SAXException {
+                if (c == '<') {
+                    err("\u201C<\u201D in an unquoted attribute value. Probable cause: Missing \u201C>\u201D immediately before.");
+                } else if (c != '\uFFFD') {
+                    err("\u201C"
+                            + c
+                            + "\u201D in an unquoted attribute value. Probable causes: Attributes running together or a URL query string in an unquoted attribute value.");
+                }
+            }
+
+    @Override protected void errSlashNotFollowedByGt() throws SAXException {
+        err("A slash was not immediate followed by \u201C>\u201D.");
+    }
+
+    @Override protected void errHtml4XmlVoidSyntax() throws SAXException {
+        if (html4) {
+            err("The \u201C/>\u201D syntax on void elements is not allowed.  (This is an HTML4-only error.)");
+        }
+    }
+
+    @Override protected void errNoSpaceBetweenAttributes()
+            throws SAXException {
+                err("No space between attributes.");
+            }
+
+    @Override protected void errHtml4NonNameInUnquotedAttribute(char c)
+            throws SAXException {
+                if (html4
+                        && !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
+                                || (c >= '0' && c <= '9') || c == '.' || c == '-'
+                                || c == '_' || c == ':')) {
+                    err("Non-name character in an unquoted attribute value. (This is an HTML4-only error.)");
+                }
+            }
+
+    @Override protected void errLtOrEqualsInUnquotedAttributeOrNull(char c)
+            throws SAXException {
+        switch (c) {
+            case '=':
+                err("\u201C=\u201D in an unquoted attribute value. Probable cause: Stray duplicate equals sign.");
+                return;
+            case '<':
+                err("\u201C<\u201D in an unquoted attribute value. Probable cause: Missing \u201C>\u201D immediately before.");
+                return;
+        }
+    }
+
+    @Override protected void errAttributeValueMissing() throws SAXException {
+        err("Attribute value missing.");
+    }
+
+    @Override protected void errBadCharBeforeAttributeNameOrNull(char c)
+            throws SAXException {
+                if (c == '<') {
+                    err("Saw \u201C<\u201D when expecting an attribute name. Probable cause: Missing \u201C>\u201D immediately before.");                    
+                } else if (c == '=') {
+                    errEqualsSignBeforeAttributeName();
+                } else if (c != '\uFFFD') {
+                    errQuoteBeforeAttributeName(c);
+                }
+            }
+
+    @Override protected void errEqualsSignBeforeAttributeName()
+            throws SAXException {
+                err("Saw \u201C=\u201D when expecting an attribute name. Probable cause: Attribute name missing.");
+            }
+
+    @Override protected void errBadCharAfterLt(char c)
+            throws SAXException {
+                err("Bad character \u201C"
+                        + c
+                        + "\u201D after \u201C<\u201D. Probable cause: Unescaped \u201C<\u201D. Try escaping it as \u201C&lt;\u201D.");
+            }
+
+    @Override protected void errLtGt() throws SAXException {
+        err("Saw \u201C<>\u201D. Probable causes: Unescaped \u201C<\u201D (escape as \u201C&lt;\u201D) or mistyped start tag.");
+    }
+
+    @Override protected void errProcessingInstruction() throws SAXException {
+        err("Saw \u201C<?\u201D. Probable cause: Attempt to use an XML processing instruction in HTML. (XML processing instructions are not supported in HTML.)");
+    }
+
+    @Override protected void errUnescapedAmpersandInterpretedAsCharacterReference()
+            throws SAXException {
+                if (errorHandler == null) {
+                    return;
+                }
+                SAXParseException spe = new SAXParseException(
+                        "The string following \u201C&\u201D was interpreted as a character reference. (\u201C&\u201D probably should have been escaped as \u201C&amp;\u201D.)",
+                        ampersandLocation);
+                errorHandler.error(spe);
+            }
+
+    @Override protected void errNotSemicolonTerminated() throws SAXException {
+        err("Named character reference was not terminated by a semicolon. (Or \u201C&\u201D should have been escaped as \u201C&amp;\u201D.)");
+    }
+
+    @Override protected void errNoNamedCharacterMatch() throws SAXException {
+        if (errorHandler == null) {
+            return;
+        }
+        SAXParseException spe = new SAXParseException(
+                "\u201C&\u201D did not start a character reference. (\u201C&\u201D probably should have been escaped as \u201C&amp;\u201D.)",
+                ampersandLocation);
+        errorHandler.error(spe);
+    }
+
+    @Override protected void errQuoteBeforeAttributeName(char c)
+            throws SAXException {
+                err("Saw \u201C"
+                        + c
+                        + "\u201D when expecting an attribute name. Probable cause: \u201C=\u201D missing immediately before.");
+    }
+
+    @Override protected void errQuoteOrLtInAttributeNameOrNull(char c)
+            throws SAXException {
+        if (c == '<') {
+            err("\u201C<\u201D in attribute name. Probable cause: \u201C>\u201D missing immediately before.");            
+        } else if (c != '\uFFFD') {
+            err("Quote \u201C"
+                    + c
+                    + "\u201D in attribute name. Probable cause: Matching quote missing somewhere earlier.");
+        }
+    }
+
+    @Override protected void errExpectedPublicId() throws SAXException {
+        err("Expected a public identifier but the doctype ended.");
+    }
+
+    @Override protected void errBogusDoctype() throws SAXException {
+        err("Bogus doctype.");
+    }
+
+    @Override protected void maybeWarnPrivateUseAstral() throws SAXException {
+        if (errorHandler != null && isAstralPrivateUse(value)) {
+            warnAboutPrivateUseChar();
+        }
+    }
+
+    @Override protected void maybeWarnPrivateUse(char ch)
+            throws SAXException {
+                if (errorHandler != null && isPrivateUse(ch)) {
+                    warnAboutPrivateUseChar();
+                }
+            }
+
+    @Override protected void maybeErrAttributesOnEndTag(HtmlAttributes attrs)
+            throws SAXException {
+                if (attrs.getLength() != 0) {
+                    /*
+                     * When an end tag token is emitted with attributes, that is a parse
+                     * error.
+                     */
+                    err("End tag had attributes.");
+                }
+            }
+
+    @Override protected void maybeErrSlashInEndTag(boolean selfClosing)
+            throws SAXException {
+                if (selfClosing && endTag) {
+                    err("Stray \u201C/\u201D at the end of an end tag.");
+                }
+            }
+
+    @Override protected void errNcrNonCharacter() throws SAXException {
+        err("Character reference expands to a non-character.");
+    }
+
+    @Override protected void errNcrSurrogate() throws SAXException {
+        err("Character reference expands to a surrogate.");
+    }
+
+    @Override protected void errNcrControlChar() throws SAXException {
+        err("Character reference expands to a control character ("
+                + toUPlusString((char) value) + ").");
+    }
+
+    @Override protected void errRcnCr() throws SAXException {
+        err("A numeric character reference expanded to carriage return.");
+    }
+
+    @Override protected void errNcrInC1Range() throws SAXException {
+        err("A numeric character reference expanded to the C1 controls range.");
+    }
+
+    @Override protected void errEofInPublicId() throws SAXException {
+        err("End of file inside public identifier.");
+    }
+
+    @Override protected void errEofInComment() throws SAXException {
+        err("End of file inside comment.");
+    }
+
+    @Override protected void errEofInDoctype() throws SAXException {
+        err("End of file inside doctype.");
+    }
+
+    @Override protected void errEofInAttributeValue() throws SAXException {
+        err("End of file reached when inside an attribute value. Ignoring tag.");
+    }
+
+    @Override protected void errEofInAttributeName() throws SAXException {
+        err("End of file occurred in an attribute name. Ignoring tag.");
+    }
+
+    @Override protected void errEofWithoutGt() throws SAXException {
+        err("Saw end of file without the previous tag ending with \u201C>\u201D. Ignoring tag.");
+    }
+
+    @Override protected void errEofInTagName() throws SAXException {
+        err("End of file seen when looking for tag name. Ignoring tag.");
+    }
+
+    @Override protected void errEofInEndTag() throws SAXException {
+        err("End of file inside end tag. Ignoring tag.");
+    }
+
+    @Override protected void errEofAfterLt() throws SAXException {
+        err("End of file after \u201C<\u201D.");
+    }
+
+    @Override protected void errNcrOutOfRange() throws SAXException {
+        err("Character reference outside the permissible Unicode range.");
+    }
+
+    @Override protected void errNcrUnassigned() throws SAXException {
+        err("Character reference expands to a permanently unassigned code point.");
+    }
+
+    @Override protected void errDuplicateAttribute() throws SAXException {
+        err("Duplicate attribute \u201C"
+                + attributeName.getLocal(AttributeName.HTML) + "\u201D.");
+    }
+
+    @Override protected void errEofInSystemId() throws SAXException {
+        err("End of file inside system identifier.");
+    }
+
+    @Override protected void errExpectedSystemId() throws SAXException {
+        err("Expected a system identifier but the doctype ended.");
+    }
+
+    @Override protected void errMissingSpaceBeforeDoctypeName()
+            throws SAXException {
+        err("Missing space before doctype name.");
+    }
+
+    @Override protected void errHyphenHyphenBang() throws SAXException {
+        err("\u201C--!\u201D found in comment.");
+    }
+}
diff --git a/parser/html/java/htmlparser/src/HtmlAttributes.java b/parser/html/java/htmlparser/src/HtmlAttributes.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/HtmlAttributes.java
@@ -0,0 +1,486 @@
+/*
+ * Copyright (c) 2007 Henri Sivonen
+ * Copyright (c) 2008-2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.IdType;
+import nu.validator.htmlparser.annotation.Local;
+import nu.validator.htmlparser.annotation.NsUri;
+import nu.validator.htmlparser.annotation.Prefix;
+import nu.validator.htmlparser.annotation.QName;
+import nu.validator.htmlparser.common.XmlViolationPolicy;
+
+import org.xml.sax.Attributes;
+import org.xml.sax.SAXException;
+
+/**
+ * Be careful with this class. QName is the name in from HTML tokenization.
+ * Otherwise, please refer to the interface doc.
+ * 
+ * @version $Id: AttributesImpl.java 206 2008-03-20 14:09:29Z hsivonen $
+ * @author hsivonen
+ */
+public final class HtmlAttributes implements Attributes {
+
+    // [NOCPP[
+
+    private static final AttributeName[] EMPTY_ATTRIBUTENAMES = new AttributeName[0];
+
+    private static final String[] EMPTY_STRINGS = new String[0];
+
+    // ]NOCPP]
+
+    public static final HtmlAttributes EMPTY_ATTRIBUTES = new HtmlAttributes(
+            AttributeName.HTML);
+
+    private int mode;
+
+    private int length;
+
+    private AttributeName[] names;
+
+    private String[] values; // XXX perhaps make this @NoLength?
+
+    // [NOCPP[
+
+    private String idValue;
+
+    private int xmlnsLength;
+
+    private AttributeName[] xmlnsNames;
+
+    private String[] xmlnsValues;
+
+    // ]NOCPP]
+
+    public HtmlAttributes(int mode) {
+        this.mode = mode;
+        this.length = 0;
+        /*
+         * The length of 5 covers covers 98.3% of elements
+         * according to Hixie
+         */
+        this.names = new AttributeName[5];
+        this.values = new String[5];
+
+        // [NOCPP[
+
+        this.idValue = null;
+
+        this.xmlnsLength = 0;
+
+        this.xmlnsNames = HtmlAttributes.EMPTY_ATTRIBUTENAMES;
+
+        this.xmlnsValues = HtmlAttributes.EMPTY_STRINGS;
+
+        // ]NOCPP]
+    }
+    /*
+    public HtmlAttributes(HtmlAttributes other) {
+        this.mode = other.mode;
+        this.length = other.length;
+        this.names = new AttributeName[other.length];
+        this.values = new String[other.length];
+        // [NOCPP[
+        this.idValue = other.idValue;
+        this.xmlnsLength = other.xmlnsLength;
+        this.xmlnsNames = new AttributeName[other.xmlnsLength];
+        this.xmlnsValues = new String[other.xmlnsLength];
+        // ]NOCPP]
+    }
+    */
+
+    void destructor() {
+        clear(0);
+        Portability.releaseArray(names);
+        Portability.releaseArray(values);
+    }
+    
+    /**
+     * Only use with a static argument
+     * 
+     * @param name
+     * @return
+     */
+    public int getIndex(AttributeName name) {
+        for (int i = 0; i < length; i++) {
+            if (names[i] == name) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    // [NOCPP[
+    
+    public int getIndex(String qName) {
+        for (int i = 0; i < length; i++) {
+            if (names[i].getQName(mode).equals(qName)) {
+                return i;
+            }
+        }
+        return -1;
+    }
+    
+    public int getIndex(String uri, String localName) {
+        for (int i = 0; i < length; i++) {
+            if (names[i].getLocal(mode).equals(localName)
+                    && names[i].getUri(mode).equals(uri)) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    public @IdType String getType(String qName) {
+        int index = getIndex(qName);
+        if (index == -1) {
+            return null;
+        } else {
+            return getType(index);
+        }
+    }
+
+    public @IdType String getType(String uri, String localName) {
+        int index = getIndex(uri, localName);
+        if (index == -1) {
+            return null;
+        } else {
+            return getType(index);
+        }
+    }
+    
+    public String getValue(String qName) {
+        int index = getIndex(qName);
+        if (index == -1) {
+            return null;
+        } else {
+            return getValue(index);
+        }
+    }
+
+    public String getValue(String uri, String localName) {
+        int index = getIndex(uri, localName);
+        if (index == -1) {
+            return null;
+        } else {
+            return getValue(index);
+        }
+    }
+    
+    // ]NOCPP]
+    
+    public int getLength() {
+        return length;
+    }
+
+    public @Local String getLocalName(int index) {
+        if (index < length && index >= 0) {
+            return names[index].getLocal(mode);
+        } else {
+            return null;
+        }
+    }
+
+    // [NOCPP[
+    
+    public @QName String getQName(int index) {
+        if (index < length && index >= 0) {
+            return names[index].getQName(mode);
+        } else {
+            return null;
+        }
+    }
+
+    public @IdType String getType(int index) {
+        if (index < length && index >= 0) {
+            return names[index].getType(mode);
+        } else {
+            return null;
+        }
+    }
+
+    // ]NOCPP]
+    
+    public AttributeName getAttributeName(int index) {
+        if (index < length && index >= 0) {
+            return names[index];
+        } else {
+            return null;
+        }
+    }
+
+    public @NsUri String getURI(int index) {
+        if (index < length && index >= 0) {
+            return names[index].getUri(mode);
+        } else {
+            return null;
+        }
+    }
+
+    public @Prefix String getPrefix(int index) {
+        if (index < length && index >= 0) {
+            return names[index].getPrefix(mode);
+        } else {
+            return null;
+        }
+    }
+
+    public String getValue(int index) {
+        if (index < length && index >= 0) {
+            return values[index];
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Only use with static argument.
+     * 
+     * @see org.xml.sax.Attributes#getValue(java.lang.String)
+     */
+    public String getValue(AttributeName name) {
+        int index = getIndex(name);
+        if (index == -1) {
+            return null;
+        } else {
+            return getValue(index);
+        }
+    }
+    
+    // [NOCPP[
+
+    public String getId() {
+        return idValue;
+    }
+
+    public int getXmlnsLength() {
+        return xmlnsLength;
+    }
+
+    public @Local String getXmlnsLocalName(int index) {
+        if (index < xmlnsLength && index >= 0) {
+            return xmlnsNames[index].getLocal(mode);
+        } else {
+            return null;
+        }
+    }
+
+    public @NsUri String getXmlnsURI(int index) {
+        if (index < xmlnsLength && index >= 0) {
+            return xmlnsNames[index].getUri(mode);
+        } else {
+            return null;
+        }
+    }
+
+    public String getXmlnsValue(int index) {
+        if (index < xmlnsLength && index >= 0) {
+            return xmlnsValues[index];
+        } else {
+            return null;
+        }
+    }
+    
+    public int getXmlnsIndex(AttributeName name) {
+        for (int i = 0; i < xmlnsLength; i++) {
+            if (xmlnsNames[i] == name) {
+                return i;
+            }
+        }
+        return -1;
+    }
+    
+    public String getXmlnsValue(AttributeName name) {
+        int index = getXmlnsIndex(name);
+        if (index == -1) {
+            return null;
+        } else {
+            return getXmlnsValue(index);
+        }
+    }
+    
+    public AttributeName getXmlnsAttributeName(int index) {
+        if (index < xmlnsLength && index >= 0) {
+            return xmlnsNames[index];
+        } else {
+            return null;
+        }
+    }
+
+    // ]NOCPP]
+
+    void addAttribute(AttributeName name, String value
+            // [NOCPP[
+            , XmlViolationPolicy xmlnsPolicy
+    // ]NOCPP]        
+    ) throws SAXException {
+        // [NOCPP[
+        if (name == AttributeName.ID) {
+            idValue = value;
+        }
+
+        if (name.isXmlns()) {
+            if (xmlnsNames.length == xmlnsLength) {
+                int newLen = xmlnsLength == 0 ? 2 : xmlnsLength << 1;
+                AttributeName[] newNames = new AttributeName[newLen];
+                System.arraycopy(xmlnsNames, 0, newNames, 0, xmlnsNames.length);
+                xmlnsNames = newNames;
+                String[] newValues = new String[newLen];
+                System.arraycopy(xmlnsValues, 0, newValues, 0, xmlnsValues.length);
+                xmlnsValues = newValues;
+            }
+            xmlnsNames[xmlnsLength] = name;
+            xmlnsValues[xmlnsLength] = value;
+            xmlnsLength++;
+            switch (xmlnsPolicy) {
+                case FATAL:
+                    // this is ugly
+                    throw new SAXException("Saw an xmlns attribute.");
+                case ALTER_INFOSET:
+                    return;
+                case ALLOW:
+                    // fall through
+            }
+        }
+
+        // ]NOCPP]
+
+        if (names.length == length) {
+            int newLen = length << 1; // The first growth covers virtually
+            // 100% of elements according to
+            // Hixie
+            AttributeName[] newNames = new AttributeName[newLen];
+            System.arraycopy(names, 0, newNames, 0, names.length);
+            Portability.releaseArray(names);
+            names = newNames;
+            String[] newValues = new String[newLen];
+            System.arraycopy(values, 0, newValues, 0, values.length);
+            Portability.releaseArray(values);
+            values = newValues;
+        }
+        names[length] = name;
+        values[length] = value;
+        length++;
+    }
+
+    void clear(int m) {
+        for (int i = 0; i < length; i++) {
+            names[i].release();
+            names[i] = null;
+            Portability.releaseString(values[i]);
+            values[i] = null;
+        }
+        length = 0;
+        mode = m;
+        // [NOCPP[
+        idValue = null;
+        for (int i = 0; i < xmlnsLength; i++) {
+            xmlnsNames[i] = null;
+            xmlnsValues[i] = null;
+        }
+        xmlnsLength = 0;
+        // ]NOCPP]
+    }
+    
+    /**
+     * This is used in C++ to release special <code>isindex</code>
+     * attribute values whose ownership is not transferred.
+     */
+    void releaseValue(int i) {
+        Portability.releaseString(values[i]);        
+    }
+    
+    /**
+     * This is only used for <code>AttributeName</code> ownership transfer
+     * in the isindex case to avoid freeing custom names twice in C++.
+     */
+    void clearWithoutReleasingContents() {
+        for (int i = 0; i < length; i++) {
+            names[i] = null;
+            values[i] = null;
+        }
+        length = 0;
+    }
+
+    boolean contains(AttributeName name) {
+        for (int i = 0; i < length; i++) {
+            if (name.equalsAnother(names[i])) {
+                return true;
+            }
+        }
+        // [NOCPP[
+        for (int i = 0; i < xmlnsLength; i++) {
+            if (name.equalsAnother(xmlnsNames[i])) {
+                return true;
+            }
+        }
+        // ]NOCPP]
+        return false;
+    }
+
+    public void adjustForMath() {
+        mode = AttributeName.MATHML;
+    }
+
+    public void adjustForSvg() {
+        mode = AttributeName.SVG;
+    }
+
+    // [NOCPP[
+    
+    void processNonNcNames(TreeBuilder<?> treeBuilder, XmlViolationPolicy namePolicy) throws SAXException {
+        for (int i = 0; i < length; i++) {
+            AttributeName attName = names[i];
+            if (!attName.isNcName(mode)) {
+                String name = attName.getLocal(mode);
+                switch (namePolicy) {
+                    case ALTER_INFOSET:
+                        names[i] = AttributeName.create(NCName.escapeName(name));
+                        // fall through
+                    case ALLOW:
+                        if (attName != AttributeName.XML_LANG) {
+                            treeBuilder.warn("Attribute \u201C" + name + "\u201D is not serializable as XML 1.0.");
+                        }
+                        break;
+                    case FATAL:
+                        treeBuilder.fatal("Attribute \u201C" + name + "\u201D is not serializable as XML 1.0.");
+                        break;
+                }
+            }
+        }
+    }
+    
+    public void merge(HtmlAttributes attributes) throws SAXException {
+        int len = attributes.getLength();
+        for (int i = 0; i < len; i++) {
+            AttributeName name = attributes.getAttributeName(i);
+            if (!contains(name)) {
+                addAttribute(name, attributes.getValue(i), XmlViolationPolicy.ALLOW);
+            }
+        }
+    }
+
+    // ]NOCPP]
+    
+}
diff --git a/parser/html/java/htmlparser/src/LocatorImpl.java b/parser/html/java/htmlparser/src/LocatorImpl.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/LocatorImpl.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2007 Henri Sivonen
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import org.xml.sax.Locator;
+
+public final class LocatorImpl implements Locator {
+
+    private final String systemId;
+
+    private final String publicId;
+
+    private final int column;
+
+    private final int line;
+
+    public LocatorImpl(Locator locator) {
+        this.systemId = locator.getSystemId();
+        this.publicId = locator.getPublicId();
+        this.column = locator.getColumnNumber();
+        this.line = locator.getLineNumber();
+    }
+
+    public int getColumnNumber() {
+        return column;
+    }
+
+    public int getLineNumber() {
+        return line;
+    }
+
+    public String getPublicId() {
+        return publicId;
+    }
+
+    public String getSystemId() {
+        return systemId;
+    }
+}
diff --git a/parser/html/java/htmlparser/src/MetaScanner.java b/parser/html/java/htmlparser/src/MetaScanner.java
new file mode 100755
--- /dev/null
+++ b/parser/html/java/htmlparser/src/MetaScanner.java
@@ -0,0 +1,696 @@
+/*
+ * Copyright (c) 2007 Henri Sivonen
+ * Copyright (c) 2008-2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import java.io.IOException;
+
+import nu.validator.htmlparser.annotation.NoLength;
+import nu.validator.htmlparser.common.ByteReadable;
+
+import org.xml.sax.SAXException;
+
+public abstract class MetaScanner {
+
+    private static final @NoLength char[] CHARSET = "charset".toCharArray();
+    
+    private static final @NoLength char[] CONTENT = "content".toCharArray();
+
+    private static final int NO = 0;
+
+    private static final int M = 1;
+    
+    private static final int E = 2;
+    
+    private static final int T = 3;
+
+    private static final int A = 4;
+    
+    private static final int DATA = 0;
+
+    private static final int TAG_OPEN = 1;
+
+    private static final int SCAN_UNTIL_GT = 2;
+
+    private static final int TAG_NAME = 3;
+
+    private static final int BEFORE_ATTRIBUTE_NAME = 4;
+
+    private static final int ATTRIBUTE_NAME = 5;
+
+    private static final int AFTER_ATTRIBUTE_NAME = 6;
+
+    private static final int BEFORE_ATTRIBUTE_VALUE = 7;
+
+    private static final int ATTRIBUTE_VALUE_DOUBLE_QUOTED = 8;
+
+    private static final int ATTRIBUTE_VALUE_SINGLE_QUOTED = 9;
+
+    private static final int ATTRIBUTE_VALUE_UNQUOTED = 10;
+
+    private static final int AFTER_ATTRIBUTE_VALUE_QUOTED = 11;
+
+    private static final int MARKUP_DECLARATION_OPEN = 13;
+    
+    private static final int MARKUP_DECLARATION_HYPHEN = 14;
+
+    private static final int COMMENT_START = 15;
+
+    private static final int COMMENT_START_DASH = 16;
+
+    private static final int COMMENT = 17;
+
+    private static final int COMMENT_END_DASH = 18;
+
+    private static final int COMMENT_END = 19;
+    
+    private static final int SELF_CLOSING_START_TAG = 20;
+    
+    protected ByteReadable readable;
+    
+    private int metaState = NO;
+
+    private int contentIndex = -1;
+    
+    private int charsetIndex = -1;
+
+    protected int stateSave = DATA;
+
+    private int strBufLen;
+
+    private char[] strBuf;
+    
+    // [NOCPP[
+    
+    /**
+     * @param source
+     * @param errorHandler
+     * @param publicId
+     * @param systemId
+     */
+    public MetaScanner() {
+        this.readable = null;
+        this.metaState = NO;
+        this.contentIndex = -1;
+        this.charsetIndex = -1;
+        this.stateSave = DATA;
+        strBufLen = 0;
+        strBuf = new char[36];
+    }
+    
+    /**
+     * -1 means end.
+     * @return
+     * @throws IOException
+     */
+    protected int read() throws IOException {
+        return readable.readByte();
+    }
+
+    // ]NOCPP]
+
+    // WARNING When editing this, makes sure the bytecode length shown by javap
+    // stays under 8000 bytes!
+    protected final void stateLoop(int state)
+            throws SAXException, IOException {
+        int c = -1;
+        boolean reconsume = false;
+        stateloop: for (;;) {
+            switch (state) {
+                case DATA:
+                    dataloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            c = read();
+                        }
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '<':
+                                state = MetaScanner.TAG_OPEN;
+                                break dataloop; // FALL THROUGH continue
+                            // stateloop;
+                            default:
+                                continue;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case TAG_OPEN:
+                    tagopenloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case 'm':
+                            case 'M':
+                                metaState = M;
+                                state = MetaScanner.TAG_NAME;
+                                break tagopenloop;
+                                // continue stateloop;                                
+                            case '!':
+                                state = MetaScanner.MARKUP_DECLARATION_OPEN;
+                                continue stateloop;
+                            case '?':
+                            case '/':
+                                state = MetaScanner.SCAN_UNTIL_GT;
+                                continue stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            default:
+                                if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
+                                    metaState = NO;
+                                    state = MetaScanner.TAG_NAME;
+                                    break tagopenloop;
+                                    // continue stateloop;
+                                }
+                                state = MetaScanner.DATA;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALL THROUGH DON'T REORDER
+                case TAG_NAME:
+                    tagnameloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\n':
+                            case '\u000C':
+                                state = MetaScanner.BEFORE_ATTRIBUTE_NAME;
+                                break tagnameloop;
+                            // continue stateloop;
+                            case '/':
+                                state = MetaScanner.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            case 'e':
+                            case 'E':
+                                if (metaState == M) {
+                                    metaState = E;
+                                } else {
+                                    metaState = NO;
+                                }
+                                continue;
+                            case 't':
+                            case 'T':
+                                if (metaState == E) {
+                                    metaState = T;
+                                } else {
+                                    metaState = NO;
+                                }
+                                continue;
+                            case 'a':
+                            case 'A':
+                                if (metaState == T) {
+                                    metaState = A;
+                                } else {
+                                    metaState = NO;
+                                }
+                                continue;
+                            default:
+                                metaState = NO;
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BEFORE_ATTRIBUTE_NAME:
+                    beforeattributenameloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            c = read();
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\n':
+                            case '\u000C':
+                                continue;
+                            case '/':
+                                state = MetaScanner.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '>':
+                                state = DATA;
+                                continue stateloop;
+                            case 'c':
+                            case 'C':
+                                contentIndex = 0;
+                                charsetIndex = 0;
+                                state = MetaScanner.ATTRIBUTE_NAME;
+                                break beforeattributenameloop;                                
+                            default:
+                                contentIndex = -1;
+                                charsetIndex = -1;
+                                state = MetaScanner.ATTRIBUTE_NAME;
+                                break beforeattributenameloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case ATTRIBUTE_NAME:
+                    attributenameloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\n':
+                            case '\u000C':
+                                state = MetaScanner.AFTER_ATTRIBUTE_NAME;
+                                continue stateloop;
+                            case '/':
+                                state = MetaScanner.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '=':
+                                strBufLen = 0;
+                                state = MetaScanner.BEFORE_ATTRIBUTE_VALUE;
+                                break attributenameloop;
+                            // continue stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            default:
+                                if (metaState == A) {
+                                    if (c >= 'A' && c <= 'Z') {
+                                        c += 0x20;
+                                    }
+                                    if (contentIndex == 6) {
+                                        contentIndex = -1;
+                                    } else if (contentIndex > -1
+                                            && contentIndex < 6
+                                            && (c == CONTENT[contentIndex + 1])) {
+                                        contentIndex++;
+                                    }
+                                    if (charsetIndex == 6) {
+                                        charsetIndex = -1;
+                                    } else if (charsetIndex > -1
+                                            && charsetIndex < 6
+                                            && (c == CHARSET[charsetIndex + 1])) {
+                                        charsetIndex++;
+                                    }
+                                }
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BEFORE_ATTRIBUTE_VALUE:
+                    beforeattributevalueloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\n':
+                            case '\u000C':
+                                continue;
+                            case '"':
+                                state = MetaScanner.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
+                                break beforeattributevalueloop;
+                            // continue stateloop;
+                            case '\'':
+                                state = MetaScanner.ATTRIBUTE_VALUE_SINGLE_QUOTED;
+                                continue stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            default:
+                                if (charsetIndex == 6 || contentIndex == 6) {
+                                    addToBuffer(c);
+                                }
+                                state = MetaScanner.ATTRIBUTE_VALUE_UNQUOTED;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case ATTRIBUTE_VALUE_DOUBLE_QUOTED:
+                    attributevaluedoublequotedloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            c = read();
+                        }
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '"':
+                                if (tryCharset()) {
+                                    break stateloop;
+                                }
+                                state = MetaScanner.AFTER_ATTRIBUTE_VALUE_QUOTED;
+                                break attributevaluedoublequotedloop;
+                            // continue stateloop;
+                            default:
+                                if (metaState == A && (contentIndex == 6 || charsetIndex == 6)) {
+                                    addToBuffer(c);
+                                }
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case AFTER_ATTRIBUTE_VALUE_QUOTED:
+                    afterattributevaluequotedloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\n':
+                            case '\u000C':
+                                state = MetaScanner.BEFORE_ATTRIBUTE_NAME;
+                                continue stateloop;
+                            case '/':
+                                state = MetaScanner.SELF_CLOSING_START_TAG;
+                                break afterattributevaluequotedloop;
+                            // continue stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            default:
+                                state = MetaScanner.BEFORE_ATTRIBUTE_NAME;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case SELF_CLOSING_START_TAG:
+                    c = read();
+                    switch (c) {
+                        case -1:
+                            break stateloop;
+                        case '>':
+                            state = MetaScanner.DATA;
+                            continue stateloop;
+                        default:
+                            state = MetaScanner.BEFORE_ATTRIBUTE_NAME;
+                            reconsume = true;
+                            continue stateloop;
+                    }
+                    // XXX reorder point
+                case ATTRIBUTE_VALUE_UNQUOTED:
+                    for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            c = read();
+                        }
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\n':
+
+                            case '\u000C':
+                                if (tryCharset()) {
+                                    break stateloop;
+                                }
+                                state = MetaScanner.BEFORE_ATTRIBUTE_NAME;
+                                continue stateloop;
+                            case '>':
+                                if (tryCharset()) {
+                                    break stateloop;
+                                }
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            default:
+                                if (metaState == A && (contentIndex == 6 || charsetIndex == 6)) {
+                                    addToBuffer(c);
+                                }
+                                continue;
+                        }
+                    }
+                    // XXX reorder point
+                case AFTER_ATTRIBUTE_NAME:
+                    for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\n':
+                            case '\u000C':
+                                continue;
+                            case '/':
+                                if (tryCharset()) {
+                                    break stateloop;
+                                }
+                                state = MetaScanner.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '=':
+                                state = MetaScanner.BEFORE_ATTRIBUTE_VALUE;
+                                continue stateloop;
+                            case '>':
+                                if (tryCharset()) {
+                                    break stateloop;
+                                }
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            case 'c':
+                            case 'C':
+                                contentIndex = 0;
+                                charsetIndex = 0;
+                                state = MetaScanner.ATTRIBUTE_NAME;
+                                continue stateloop;
+                            default:
+                                contentIndex = -1;
+                                charsetIndex = -1;
+                                state = MetaScanner.ATTRIBUTE_NAME;
+                                continue stateloop;
+                        }
+                    }
+                    // XXX reorder point
+                case MARKUP_DECLARATION_OPEN:
+                    markupdeclarationopenloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '-':
+                                state = MetaScanner.MARKUP_DECLARATION_HYPHEN;
+                                break markupdeclarationopenloop;
+                            // continue stateloop;
+                            default:
+                                state = MetaScanner.SCAN_UNTIL_GT;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case MARKUP_DECLARATION_HYPHEN:
+                    markupdeclarationhyphenloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '-':
+                                state = MetaScanner.COMMENT_START;
+                                break markupdeclarationhyphenloop;
+                            // continue stateloop;
+                            default:
+                                state = MetaScanner.SCAN_UNTIL_GT;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT_START:
+                    commentstartloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '-':
+                                state = MetaScanner.COMMENT_START_DASH;
+                                continue stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            default:
+                                state = MetaScanner.COMMENT;
+                                break commentstartloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT:
+                    commentloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '-':
+                                state = MetaScanner.COMMENT_END_DASH;
+                                break commentloop;
+                            // continue stateloop;
+                            default:
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT_END_DASH:
+                    commentenddashloop: for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '-':
+                                state = MetaScanner.COMMENT_END;
+                                break commentenddashloop;
+                            // continue stateloop;
+                            default:
+                                state = MetaScanner.COMMENT;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT_END:
+                    for (;;) {
+                        c = read();
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            case '-':
+                                continue;
+                            default:
+                                state = MetaScanner.COMMENT;
+                                continue stateloop;
+                        }
+                    }
+                    // XXX reorder point
+                case COMMENT_START_DASH:
+                    c = read();
+                    switch (c) {
+                        case -1:
+                            break stateloop;
+                        case '-':
+                            state = MetaScanner.COMMENT_END;
+                            continue stateloop;
+                        case '>':
+                            state = MetaScanner.DATA;
+                            continue stateloop;
+                        default:
+                            state = MetaScanner.COMMENT;
+                            continue stateloop;
+                    }
+                    // XXX reorder point
+                case ATTRIBUTE_VALUE_SINGLE_QUOTED:
+                    for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            c = read();
+                        }
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '\'':
+                                if (tryCharset()) {
+                                    break stateloop;
+                                }
+                                state = MetaScanner.AFTER_ATTRIBUTE_VALUE_QUOTED;
+                                continue stateloop;
+                            default:
+                                if (metaState == A && (contentIndex == 6 || charsetIndex == 6)) {
+                                    addToBuffer(c);
+                                }
+                                continue;
+                        }
+                    }
+                    // XXX reorder point
+                case SCAN_UNTIL_GT:
+                    for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            c = read();
+                        }
+                        switch (c) {
+                            case -1:
+                                break stateloop;
+                            case '>':
+                                state = MetaScanner.DATA;
+                                continue stateloop;
+                            default:
+                                continue;
+                        }
+                    }
+            }
+        }
+        stateSave  = state;
+    }
+
+    private void addToBuffer(int c) {
+        if (strBufLen == strBuf.length) {
+            char[] newBuf = new char[strBuf.length + (strBuf.length << 1)];
+            System.arraycopy(strBuf, 0, newBuf, 0, strBuf.length);
+            Portability.releaseArray(strBuf);
+            strBuf = newBuf;
+        }
+        strBuf[strBufLen++] = (char)c;
+    }
+
+    private boolean tryCharset() throws SAXException {
+        if (metaState != A || !(contentIndex == 6 || charsetIndex == 6)) {
+            return false;
+        }
+        String attVal = Portability.newStringFromBuffer(strBuf, 0, strBufLen);
+        String candidateEncoding;
+        if (contentIndex == 6) {
+            candidateEncoding = TreeBuilder.extractCharsetFromContent(attVal);
+            Portability.releaseString(attVal);
+        } else {
+            candidateEncoding = attVal;
+        }
+        if (candidateEncoding == null) {
+            return false;
+        }
+        boolean success = tryCharset(candidateEncoding);
+        Portability.releaseString(candidateEncoding);
+        contentIndex = -1;
+        charsetIndex = -1;
+        return success;
+    }
+    
+    protected abstract boolean tryCharset(String encoding) throws SAXException;
+
+    
+}
diff --git a/parser/html/java/htmlparser/src/NCName.java b/parser/html/java/htmlparser/src/NCName.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/NCName.java
@@ -0,0 +1,495 @@
+/*
+ * Copyright (c) 2008 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+public final class NCName {
+    // [NOCPP[
+
+    private static final int SURROGATE_OFFSET = 0x10000 - (0xD800 << 10) - 0xDC00;
+    
+    private static final char[] HEX_TABLE = "0123456789ABCDEF".toCharArray();
+    
+    public static boolean isNCNameStart(char c) {
+        return ((c >= '\u0041' && c <= '\u005A')
+                || (c >= '\u0061' && c <= '\u007A')
+                || (c >= '\u00C0' && c <= '\u00D6')
+                || (c >= '\u00D8' && c <= '\u00F6')
+                || (c >= '\u00F8' && c <= '\u00FF')
+                || (c >= '\u0100' && c <= '\u0131')
+                || (c >= '\u0134' && c <= '\u013E')
+                || (c >= '\u0141' && c <= '\u0148')
+                || (c >= '\u014A' && c <= '\u017E')
+                || (c >= '\u0180' && c <= '\u01C3')
+                || (c >= '\u01CD' && c <= '\u01F0')
+                || (c >= '\u01F4' && c <= '\u01F5')
+                || (c >= '\u01FA' && c <= '\u0217')
+                || (c >= '\u0250' && c <= '\u02A8')
+                || (c >= '\u02BB' && c <= '\u02C1') || (c == '\u0386')
+                || (c >= '\u0388' && c <= '\u038A') || (c == '\u038C')
+                || (c >= '\u038E' && c <= '\u03A1')
+                || (c >= '\u03A3' && c <= '\u03CE')
+                || (c >= '\u03D0' && c <= '\u03D6') || (c == '\u03DA')
+                || (c == '\u03DC') || (c == '\u03DE') || (c == '\u03E0')
+                || (c >= '\u03E2' && c <= '\u03F3')
+                || (c >= '\u0401' && c <= '\u040C')
+                || (c >= '\u040E' && c <= '\u044F')
+                || (c >= '\u0451' && c <= '\u045C')
+                || (c >= '\u045E' && c <= '\u0481')
+                || (c >= '\u0490' && c <= '\u04C4')
+                || (c >= '\u04C7' && c <= '\u04C8')
+                || (c >= '\u04CB' && c <= '\u04CC')
+                || (c >= '\u04D0' && c <= '\u04EB')
+                || (c >= '\u04EE' && c <= '\u04F5')
+                || (c >= '\u04F8' && c <= '\u04F9')
+                || (c >= '\u0531' && c <= '\u0556') || (c == '\u0559')
+                || (c >= '\u0561' && c <= '\u0586')
+                || (c >= '\u05D0' && c <= '\u05EA')
+                || (c >= '\u05F0' && c <= '\u05F2')
+                || (c >= '\u0621' && c <= '\u063A')
+                || (c >= '\u0641' && c <= '\u064A')
+                || (c >= '\u0671' && c <= '\u06B7')
+                || (c >= '\u06BA' && c <= '\u06BE')
+                || (c >= '\u06C0' && c <= '\u06CE')
+                || (c >= '\u06D0' && c <= '\u06D3') || (c == '\u06D5')
+                || (c >= '\u06E5' && c <= '\u06E6')
+                || (c >= '\u0905' && c <= '\u0939') || (c == '\u093D')
+                || (c >= '\u0958' && c <= '\u0961')
+                || (c >= '\u0985' && c <= '\u098C')
+                || (c >= '\u098F' && c <= '\u0990')
+                || (c >= '\u0993' && c <= '\u09A8')
+                || (c >= '\u09AA' && c <= '\u09B0') || (c == '\u09B2')
+                || (c >= '\u09B6' && c <= '\u09B9')
+                || (c >= '\u09DC' && c <= '\u09DD')
+                || (c >= '\u09DF' && c <= '\u09E1')
+                || (c >= '\u09F0' && c <= '\u09F1')
+                || (c >= '\u0A05' && c <= '\u0A0A')
+                || (c >= '\u0A0F' && c <= '\u0A10')
+                || (c >= '\u0A13' && c <= '\u0A28')
+                || (c >= '\u0A2A' && c <= '\u0A30')
+                || (c >= '\u0A32' && c <= '\u0A33')
+                || (c >= '\u0A35' && c <= '\u0A36')
+                || (c >= '\u0A38' && c <= '\u0A39')
+                || (c >= '\u0A59' && c <= '\u0A5C') || (c == '\u0A5E')
+                || (c >= '\u0A72' && c <= '\u0A74')
+                || (c >= '\u0A85' && c <= '\u0A8B') || (c == '\u0A8D')
+                || (c >= '\u0A8F' && c <= '\u0A91')
+                || (c >= '\u0A93' && c <= '\u0AA8')
+                || (c >= '\u0AAA' && c <= '\u0AB0')
+                || (c >= '\u0AB2' && c <= '\u0AB3')
+                || (c >= '\u0AB5' && c <= '\u0AB9') || (c == '\u0ABD')
+                || (c == '\u0AE0') || (c >= '\u0B05' && c <= '\u0B0C')
+                || (c >= '\u0B0F' && c <= '\u0B10')
+                || (c >= '\u0B13' && c <= '\u0B28')
+                || (c >= '\u0B2A' && c <= '\u0B30')
+                || (c >= '\u0B32' && c <= '\u0B33')
+                || (c >= '\u0B36' && c <= '\u0B39') || (c == '\u0B3D')
+                || (c >= '\u0B5C' && c <= '\u0B5D')
+                || (c >= '\u0B5F' && c <= '\u0B61')
+                || (c >= '\u0B85' && c <= '\u0B8A')
+                || (c >= '\u0B8E' && c <= '\u0B90')
+                || (c >= '\u0B92' && c <= '\u0B95')
+                || (c >= '\u0B99' && c <= '\u0B9A') || (c == '\u0B9C')
+                || (c >= '\u0B9E' && c <= '\u0B9F')
+                || (c >= '\u0BA3' && c <= '\u0BA4')
+                || (c >= '\u0BA8' && c <= '\u0BAA')
+                || (c >= '\u0BAE' && c <= '\u0BB5')
+                || (c >= '\u0BB7' && c <= '\u0BB9')
+                || (c >= '\u0C05' && c <= '\u0C0C')
+                || (c >= '\u0C0E' && c <= '\u0C10')
+                || (c >= '\u0C12' && c <= '\u0C28')
+                || (c >= '\u0C2A' && c <= '\u0C33')
+                || (c >= '\u0C35' && c <= '\u0C39')
+                || (c >= '\u0C60' && c <= '\u0C61')
+                || (c >= '\u0C85' && c <= '\u0C8C')
+                || (c >= '\u0C8E' && c <= '\u0C90')
+                || (c >= '\u0C92' && c <= '\u0CA8')
+                || (c >= '\u0CAA' && c <= '\u0CB3')
+                || (c >= '\u0CB5' && c <= '\u0CB9') || (c == '\u0CDE')
+                || (c >= '\u0CE0' && c <= '\u0CE1')
+                || (c >= '\u0D05' && c <= '\u0D0C')
+                || (c >= '\u0D0E' && c <= '\u0D10')
+                || (c >= '\u0D12' && c <= '\u0D28')
+                || (c >= '\u0D2A' && c <= '\u0D39')
+                || (c >= '\u0D60' && c <= '\u0D61')
+                || (c >= '\u0E01' && c <= '\u0E2E') || (c == '\u0E30')
+                || (c >= '\u0E32' && c <= '\u0E33')
+                || (c >= '\u0E40' && c <= '\u0E45')
+                || (c >= '\u0E81' && c <= '\u0E82') || (c == '\u0E84')
+                || (c >= '\u0E87' && c <= '\u0E88') || (c == '\u0E8A')
+                || (c == '\u0E8D') || (c >= '\u0E94' && c <= '\u0E97')
+                || (c >= '\u0E99' && c <= '\u0E9F')
+                || (c >= '\u0EA1' && c <= '\u0EA3') || (c == '\u0EA5')
+                || (c == '\u0EA7') || (c >= '\u0EAA' && c <= '\u0EAB')
+                || (c >= '\u0EAD' && c <= '\u0EAE') || (c == '\u0EB0')
+                || (c >= '\u0EB2' && c <= '\u0EB3') || (c == '\u0EBD')
+                || (c >= '\u0EC0' && c <= '\u0EC4')
+                || (c >= '\u0F40' && c <= '\u0F47')
+                || (c >= '\u0F49' && c <= '\u0F69')
+                || (c >= '\u10A0' && c <= '\u10C5')
+                || (c >= '\u10D0' && c <= '\u10F6') || (c == '\u1100')
+                || (c >= '\u1102' && c <= '\u1103')
+                || (c >= '\u1105' && c <= '\u1107') || (c == '\u1109')
+                || (c >= '\u110B' && c <= '\u110C')
+                || (c >= '\u110E' && c <= '\u1112') || (c == '\u113C')
+                || (c == '\u113E') || (c == '\u1140') || (c == '\u114C')
+                || (c == '\u114E') || (c == '\u1150')
+                || (c >= '\u1154' && c <= '\u1155') || (c == '\u1159')
+                || (c >= '\u115F' && c <= '\u1161') || (c == '\u1163')
+                || (c == '\u1165') || (c == '\u1167') || (c == '\u1169')
+                || (c >= '\u116D' && c <= '\u116E')
+                || (c >= '\u1172' && c <= '\u1173') || (c == '\u1175')
+                || (c == '\u119E') || (c == '\u11A8') || (c == '\u11AB')
+                || (c >= '\u11AE' && c <= '\u11AF')
+                || (c >= '\u11B7' && c <= '\u11B8') || (c == '\u11BA')
+                || (c >= '\u11BC' && c <= '\u11C2') || (c == '\u11EB')
+                || (c == '\u11F0') || (c == '\u11F9')
+                || (c >= '\u1E00' && c <= '\u1E9B')
+                || (c >= '\u1EA0' && c <= '\u1EF9')
+                || (c >= '\u1F00' && c <= '\u1F15')
+                || (c >= '\u1F18' && c <= '\u1F1D')
+                || (c >= '\u1F20' && c <= '\u1F45')
+                || (c >= '\u1F48' && c <= '\u1F4D')
+                || (c >= '\u1F50' && c <= '\u1F57') || (c == '\u1F59')
+                || (c == '\u1F5B') || (c == '\u1F5D')
+                || (c >= '\u1F5F' && c <= '\u1F7D')
+                || (c >= '\u1F80' && c <= '\u1FB4')
+                || (c >= '\u1FB6' && c <= '\u1FBC') || (c == '\u1FBE')
+                || (c >= '\u1FC2' && c <= '\u1FC4')
+                || (c >= '\u1FC6' && c <= '\u1FCC')
+                || (c >= '\u1FD0' && c <= '\u1FD3')
+                || (c >= '\u1FD6' && c <= '\u1FDB')
+                || (c >= '\u1FE0' && c <= '\u1FEC')
+                || (c >= '\u1FF2' && c <= '\u1FF4')
+                || (c >= '\u1FF6' && c <= '\u1FFC') || (c == '\u2126')
+                || (c >= '\u212A' && c <= '\u212B') || (c == '\u212E')
+                || (c >= '\u2180' && c <= '\u2182')
+                || (c >= '\u3041' && c <= '\u3094')
+                || (c >= '\u30A1' && c <= '\u30FA')
+                || (c >= '\u3105' && c <= '\u312C')
+                || (c >= '\uAC00' && c <= '\uD7A3')
+                || (c >= '\u4E00' && c <= '\u9FA5') || (c == '\u3007')
+                || (c >= '\u3021' && c <= '\u3029') || (c == '_'));
+    }
+
+    public static boolean isNCNameTrail(char c) {
+        return ((c >= '\u0030' && c <= '\u0039')
+                || (c >= '\u0660' && c <= '\u0669')
+                || (c >= '\u06F0' && c <= '\u06F9')
+                || (c >= '\u0966' && c <= '\u096F')
+                || (c >= '\u09E6' && c <= '\u09EF')
+                || (c >= '\u0A66' && c <= '\u0A6F')
+                || (c >= '\u0AE6' && c <= '\u0AEF')
+                || (c >= '\u0B66' && c <= '\u0B6F')
+                || (c >= '\u0BE7' && c <= '\u0BEF')
+                || (c >= '\u0C66' && c <= '\u0C6F')
+                || (c >= '\u0CE6' && c <= '\u0CEF')
+                || (c >= '\u0D66' && c <= '\u0D6F')
+                || (c >= '\u0E50' && c <= '\u0E59')
+                || (c >= '\u0ED0' && c <= '\u0ED9')
+                || (c >= '\u0F20' && c <= '\u0F29')
+                || (c >= '\u0041' && c <= '\u005A')
+                || (c >= '\u0061' && c <= '\u007A')
+                || (c >= '\u00C0' && c <= '\u00D6')
+                || (c >= '\u00D8' && c <= '\u00F6')
+                || (c >= '\u00F8' && c <= '\u00FF')
+                || (c >= '\u0100' && c <= '\u0131')
+                || (c >= '\u0134' && c <= '\u013E')
+                || (c >= '\u0141' && c <= '\u0148')
+                || (c >= '\u014A' && c <= '\u017E')
+                || (c >= '\u0180' && c <= '\u01C3')
+                || (c >= '\u01CD' && c <= '\u01F0')
+                || (c >= '\u01F4' && c <= '\u01F5')
+                || (c >= '\u01FA' && c <= '\u0217')
+                || (c >= '\u0250' && c <= '\u02A8')
+                || (c >= '\u02BB' && c <= '\u02C1') || (c == '\u0386')
+                || (c >= '\u0388' && c <= '\u038A') || (c == '\u038C')
+                || (c >= '\u038E' && c <= '\u03A1')
+                || (c >= '\u03A3' && c <= '\u03CE')
+                || (c >= '\u03D0' && c <= '\u03D6') || (c == '\u03DA')
+                || (c == '\u03DC') || (c == '\u03DE') || (c == '\u03E0')
+                || (c >= '\u03E2' && c <= '\u03F3')
+                || (c >= '\u0401' && c <= '\u040C')
+                || (c >= '\u040E' && c <= '\u044F')
+                || (c >= '\u0451' && c <= '\u045C')
+                || (c >= '\u045E' && c <= '\u0481')
+                || (c >= '\u0490' && c <= '\u04C4')
+                || (c >= '\u04C7' && c <= '\u04C8')
+                || (c >= '\u04CB' && c <= '\u04CC')
+                || (c >= '\u04D0' && c <= '\u04EB')
+                || (c >= '\u04EE' && c <= '\u04F5')
+                || (c >= '\u04F8' && c <= '\u04F9')
+                || (c >= '\u0531' && c <= '\u0556') || (c == '\u0559')
+                || (c >= '\u0561' && c <= '\u0586')
+                || (c >= '\u05D0' && c <= '\u05EA')
+                || (c >= '\u05F0' && c <= '\u05F2')
+                || (c >= '\u0621' && c <= '\u063A')
+                || (c >= '\u0641' && c <= '\u064A')
+                || (c >= '\u0671' && c <= '\u06B7')
+                || (c >= '\u06BA' && c <= '\u06BE')
+                || (c >= '\u06C0' && c <= '\u06CE')
+                || (c >= '\u06D0' && c <= '\u06D3') || (c == '\u06D5')
+                || (c >= '\u06E5' && c <= '\u06E6')
+                || (c >= '\u0905' && c <= '\u0939') || (c == '\u093D')
+                || (c >= '\u0958' && c <= '\u0961')
+                || (c >= '\u0985' && c <= '\u098C')
+                || (c >= '\u098F' && c <= '\u0990')
+                || (c >= '\u0993' && c <= '\u09A8')
+                || (c >= '\u09AA' && c <= '\u09B0') || (c == '\u09B2')
+                || (c >= '\u09B6' && c <= '\u09B9')
+                || (c >= '\u09DC' && c <= '\u09DD')
+                || (c >= '\u09DF' && c <= '\u09E1')
+                || (c >= '\u09F0' && c <= '\u09F1')
+                || (c >= '\u0A05' && c <= '\u0A0A')
+                || (c >= '\u0A0F' && c <= '\u0A10')
+                || (c >= '\u0A13' && c <= '\u0A28')
+                || (c >= '\u0A2A' && c <= '\u0A30')
+                || (c >= '\u0A32' && c <= '\u0A33')
+                || (c >= '\u0A35' && c <= '\u0A36')
+                || (c >= '\u0A38' && c <= '\u0A39')
+                || (c >= '\u0A59' && c <= '\u0A5C') || (c == '\u0A5E')
+                || (c >= '\u0A72' && c <= '\u0A74')
+                || (c >= '\u0A85' && c <= '\u0A8B') || (c == '\u0A8D')
+                || (c >= '\u0A8F' && c <= '\u0A91')
+                || (c >= '\u0A93' && c <= '\u0AA8')
+                || (c >= '\u0AAA' && c <= '\u0AB0')
+                || (c >= '\u0AB2' && c <= '\u0AB3')
+                || (c >= '\u0AB5' && c <= '\u0AB9') || (c == '\u0ABD')
+                || (c == '\u0AE0') || (c >= '\u0B05' && c <= '\u0B0C')
+                || (c >= '\u0B0F' && c <= '\u0B10')
+                || (c >= '\u0B13' && c <= '\u0B28')
+                || (c >= '\u0B2A' && c <= '\u0B30')
+                || (c >= '\u0B32' && c <= '\u0B33')
+                || (c >= '\u0B36' && c <= '\u0B39') || (c == '\u0B3D')
+                || (c >= '\u0B5C' && c <= '\u0B5D')
+                || (c >= '\u0B5F' && c <= '\u0B61')
+                || (c >= '\u0B85' && c <= '\u0B8A')
+                || (c >= '\u0B8E' && c <= '\u0B90')
+                || (c >= '\u0B92' && c <= '\u0B95')
+                || (c >= '\u0B99' && c <= '\u0B9A') || (c == '\u0B9C')
+                || (c >= '\u0B9E' && c <= '\u0B9F')
+                || (c >= '\u0BA3' && c <= '\u0BA4')
+                || (c >= '\u0BA8' && c <= '\u0BAA')
+                || (c >= '\u0BAE' && c <= '\u0BB5')
+                || (c >= '\u0BB7' && c <= '\u0BB9')
+                || (c >= '\u0C05' && c <= '\u0C0C')
+                || (c >= '\u0C0E' && c <= '\u0C10')
+                || (c >= '\u0C12' && c <= '\u0C28')
+                || (c >= '\u0C2A' && c <= '\u0C33')
+                || (c >= '\u0C35' && c <= '\u0C39')
+                || (c >= '\u0C60' && c <= '\u0C61')
+                || (c >= '\u0C85' && c <= '\u0C8C')
+                || (c >= '\u0C8E' && c <= '\u0C90')
+                || (c >= '\u0C92' && c <= '\u0CA8')
+                || (c >= '\u0CAA' && c <= '\u0CB3')
+                || (c >= '\u0CB5' && c <= '\u0CB9') || (c == '\u0CDE')
+                || (c >= '\u0CE0' && c <= '\u0CE1')
+                || (c >= '\u0D05' && c <= '\u0D0C')
+                || (c >= '\u0D0E' && c <= '\u0D10')
+                || (c >= '\u0D12' && c <= '\u0D28')
+                || (c >= '\u0D2A' && c <= '\u0D39')
+                || (c >= '\u0D60' && c <= '\u0D61')
+                || (c >= '\u0E01' && c <= '\u0E2E') || (c == '\u0E30')
+                || (c >= '\u0E32' && c <= '\u0E33')
+                || (c >= '\u0E40' && c <= '\u0E45')
+                || (c >= '\u0E81' && c <= '\u0E82') || (c == '\u0E84')
+                || (c >= '\u0E87' && c <= '\u0E88') || (c == '\u0E8A')
+                || (c == '\u0E8D') || (c >= '\u0E94' && c <= '\u0E97')
+                || (c >= '\u0E99' && c <= '\u0E9F')
+                || (c >= '\u0EA1' && c <= '\u0EA3') || (c == '\u0EA5')
+                || (c == '\u0EA7') || (c >= '\u0EAA' && c <= '\u0EAB')
+                || (c >= '\u0EAD' && c <= '\u0EAE') || (c == '\u0EB0')
+                || (c >= '\u0EB2' && c <= '\u0EB3') || (c == '\u0EBD')
+                || (c >= '\u0EC0' && c <= '\u0EC4')
+                || (c >= '\u0F40' && c <= '\u0F47')
+                || (c >= '\u0F49' && c <= '\u0F69')
+                || (c >= '\u10A0' && c <= '\u10C5')
+                || (c >= '\u10D0' && c <= '\u10F6') || (c == '\u1100')
+                || (c >= '\u1102' && c <= '\u1103')
+                || (c >= '\u1105' && c <= '\u1107') || (c == '\u1109')
+                || (c >= '\u110B' && c <= '\u110C')
+                || (c >= '\u110E' && c <= '\u1112') || (c == '\u113C')
+                || (c == '\u113E') || (c == '\u1140') || (c == '\u114C')
+                || (c == '\u114E') || (c == '\u1150')
+                || (c >= '\u1154' && c <= '\u1155') || (c == '\u1159')
+                || (c >= '\u115F' && c <= '\u1161') || (c == '\u1163')
+                || (c == '\u1165') || (c == '\u1167') || (c == '\u1169')
+                || (c >= '\u116D' && c <= '\u116E')
+                || (c >= '\u1172' && c <= '\u1173') || (c == '\u1175')
+                || (c == '\u119E') || (c == '\u11A8') || (c == '\u11AB')
+                || (c >= '\u11AE' && c <= '\u11AF')
+                || (c >= '\u11B7' && c <= '\u11B8') || (c == '\u11BA')
+                || (c >= '\u11BC' && c <= '\u11C2') || (c == '\u11EB')
+                || (c == '\u11F0') || (c == '\u11F9')
+                || (c >= '\u1E00' && c <= '\u1E9B')
+                || (c >= '\u1EA0' && c <= '\u1EF9')
+                || (c >= '\u1F00' && c <= '\u1F15')
+                || (c >= '\u1F18' && c <= '\u1F1D')
+                || (c >= '\u1F20' && c <= '\u1F45')
+                || (c >= '\u1F48' && c <= '\u1F4D')
+                || (c >= '\u1F50' && c <= '\u1F57') || (c == '\u1F59')
+                || (c == '\u1F5B') || (c == '\u1F5D')
+                || (c >= '\u1F5F' && c <= '\u1F7D')
+                || (c >= '\u1F80' && c <= '\u1FB4')
+                || (c >= '\u1FB6' && c <= '\u1FBC') || (c == '\u1FBE')
+                || (c >= '\u1FC2' && c <= '\u1FC4')
+                || (c >= '\u1FC6' && c <= '\u1FCC')
+                || (c >= '\u1FD0' && c <= '\u1FD3')
+                || (c >= '\u1FD6' && c <= '\u1FDB')
+                || (c >= '\u1FE0' && c <= '\u1FEC')
+                || (c >= '\u1FF2' && c <= '\u1FF4')
+                || (c >= '\u1FF6' && c <= '\u1FFC') || (c == '\u2126')
+                || (c >= '\u212A' && c <= '\u212B') || (c == '\u212E')
+                || (c >= '\u2180' && c <= '\u2182')
+                || (c >= '\u3041' && c <= '\u3094')
+                || (c >= '\u30A1' && c <= '\u30FA')
+                || (c >= '\u3105' && c <= '\u312C')
+                || (c >= '\uAC00' && c <= '\uD7A3')
+                || (c >= '\u4E00' && c <= '\u9FA5') || (c == '\u3007')
+                || (c >= '\u3021' && c <= '\u3029') || (c == '_') || (c == '.')
+                || (c == '-') || (c >= '\u0300' && c <= '\u0345')
+                || (c >= '\u0360' && c <= '\u0361')
+                || (c >= '\u0483' && c <= '\u0486')
+                || (c >= '\u0591' && c <= '\u05A1')
+                || (c >= '\u05A3' && c <= '\u05B9')
+                || (c >= '\u05BB' && c <= '\u05BD') || (c == '\u05BF')
+                || (c >= '\u05C1' && c <= '\u05C2') || (c == '\u05C4')
+                || (c >= '\u064B' && c <= '\u0652') || (c == '\u0670')
+                || (c >= '\u06D6' && c <= '\u06DC')
+                || (c >= '\u06DD' && c <= '\u06DF')
+                || (c >= '\u06E0' && c <= '\u06E4')
+                || (c >= '\u06E7' && c <= '\u06E8')
+                || (c >= '\u06EA' && c <= '\u06ED')
+                || (c >= '\u0901' && c <= '\u0903') || (c == '\u093C')
+                || (c >= '\u093E' && c <= '\u094C') || (c == '\u094D')
+                || (c >= '\u0951' && c <= '\u0954')
+                || (c >= '\u0962' && c <= '\u0963')
+                || (c >= '\u0981' && c <= '\u0983') || (c == '\u09BC')
+                || (c == '\u09BE') || (c == '\u09BF')
+                || (c >= '\u09C0' && c <= '\u09C4')
+                || (c >= '\u09C7' && c <= '\u09C8')
+                || (c >= '\u09CB' && c <= '\u09CD') || (c == '\u09D7')
+                || (c >= '\u09E2' && c <= '\u09E3') || (c == '\u0A02')
+                || (c == '\u0A3C') || (c == '\u0A3E') || (c == '\u0A3F')
+                || (c >= '\u0A40' && c <= '\u0A42')
+                || (c >= '\u0A47' && c <= '\u0A48')
+                || (c >= '\u0A4B' && c <= '\u0A4D')
+                || (c >= '\u0A70' && c <= '\u0A71')
+                || (c >= '\u0A81' && c <= '\u0A83') || (c == '\u0ABC')
+                || (c >= '\u0ABE' && c <= '\u0AC5')
+                || (c >= '\u0AC7' && c <= '\u0AC9')
+                || (c >= '\u0ACB' && c <= '\u0ACD')
+                || (c >= '\u0B01' && c <= '\u0B03') || (c == '\u0B3C')
+                || (c >= '\u0B3E' && c <= '\u0B43')
+                || (c >= '\u0B47' && c <= '\u0B48')
+                || (c >= '\u0B4B' && c <= '\u0B4D')
+                || (c >= '\u0B56' && c <= '\u0B57')
+                || (c >= '\u0B82' && c <= '\u0B83')
+                || (c >= '\u0BBE' && c <= '\u0BC2')
+                || (c >= '\u0BC6' && c <= '\u0BC8')
+                || (c >= '\u0BCA' && c <= '\u0BCD') || (c == '\u0BD7')
+                || (c >= '\u0C01' && c <= '\u0C03')
+                || (c >= '\u0C3E' && c <= '\u0C44')
+                || (c >= '\u0C46' && c <= '\u0C48')
+                || (c >= '\u0C4A' && c <= '\u0C4D')
+                || (c >= '\u0C55' && c <= '\u0C56')
+                || (c >= '\u0C82' && c <= '\u0C83')
+                || (c >= '\u0CBE' && c <= '\u0CC4')
+                || (c >= '\u0CC6' && c <= '\u0CC8')
+                || (c >= '\u0CCA' && c <= '\u0CCD')
+                || (c >= '\u0CD5' && c <= '\u0CD6')
+                || (c >= '\u0D02' && c <= '\u0D03')
+                || (c >= '\u0D3E' && c <= '\u0D43')
+                || (c >= '\u0D46' && c <= '\u0D48')
+                || (c >= '\u0D4A' && c <= '\u0D4D') || (c == '\u0D57')
+                || (c == '\u0E31') || (c >= '\u0E34' && c <= '\u0E3A')
+                || (c >= '\u0E47' && c <= '\u0E4E') || (c == '\u0EB1')
+                || (c >= '\u0EB4' && c <= '\u0EB9')
+                || (c >= '\u0EBB' && c <= '\u0EBC')
+                || (c >= '\u0EC8' && c <= '\u0ECD')
+                || (c >= '\u0F18' && c <= '\u0F19') || (c == '\u0F35')
+                || (c == '\u0F37') || (c == '\u0F39') || (c == '\u0F3E')
+                || (c == '\u0F3F') || (c >= '\u0F71' && c <= '\u0F84')
+                || (c >= '\u0F86' && c <= '\u0F8B')
+                || (c >= '\u0F90' && c <= '\u0F95') || (c == '\u0F97')
+                || (c >= '\u0F99' && c <= '\u0FAD')
+                || (c >= '\u0FB1' && c <= '\u0FB7') || (c == '\u0FB9')
+                || (c >= '\u20D0' && c <= '\u20DC') || (c == '\u20E1')
+                || (c >= '\u302A' && c <= '\u302F') || (c == '\u3099')
+                || (c == '\u309A') || (c == '\u00B7') || (c == '\u02D0')
+                || (c == '\u02D1') || (c == '\u0387') || (c == '\u0640')
+                || (c == '\u0E46') || (c == '\u0EC6') || (c == '\u3005')
+                || (c >= '\u3031' && c <= '\u3035')
+                || (c >= '\u309D' && c <= '\u309E') || (c >= '\u30FC' && c <= '\u30FE'));
+    }
+
+    public static boolean isNCName(String str) {
+        if (str == null) {
+            return false;
+        } else {
+            int len = str.length();
+            switch (len) {
+                case 0:
+                    return false;
+                case 1:
+                    return NCName.isNCNameStart(str.charAt(0));
+                default:
+                    if (!NCName.isNCNameStart(str.charAt(0))) {
+                        return false;
+                    }
+                    for (int i = 1; i < len; i++) {
+                        if (!NCName.isNCNameTrail(str.charAt(i))) {
+                            return false;
+                        }
+                    }
+            }
+            return true;
+        }
+    }
+    
+    private static void appendUHexTo(StringBuilder sb, int c) {
+        sb.append('U');
+        for (int i = 0; i < 6; i++) {
+            sb.append(HEX_TABLE[(c & 0xF0000) >> 16]);
+            c <<= 4;
+        }
+    }
+    
+    public static String escapeName(String str) {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < str.length(); i++) {
+            char c = str.charAt(i);
+            if ((c & 0xFC00) == 0xD800) {
+                char next = str.charAt(++i);
+                appendUHexTo(sb, (c << 10) + next + SURROGATE_OFFSET);          
+            } else if (i == 0 && !isNCNameStart(c)) {
+                appendUHexTo(sb, c);
+            } else if (i != 0 && !isNCNameTrail(c)) {
+                appendUHexTo(sb, c);                
+            } else {
+                sb.append(c);
+            }
+        }
+        return sb.toString().intern();
+    }
+    // ]NOCPP]
+}
diff --git a/parser/html/java/htmlparser/src/NamedCharacters.java b/parser/html/java/htmlparser/src/NamedCharacters.java
new file mode 100755
--- /dev/null
+++ b/parser/html/java/htmlparser/src/NamedCharacters.java
@@ -0,0 +1,1644 @@
+/*
+ * Copyright (c) 2005 Henri Sivonen
+ * Copyright (c) 2008 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.NoLength;
+
+/**
+ * @version $Id: NamedCharacters.java 455 2008-09-29 07:00:58Z hsivonen $
+ * @author hsivonen
+ */
+public final class NamedCharacters {
+    static final char[][] NAMES = { "AElig".toCharArray(),
+            "AElig;".toCharArray(), "AMP".toCharArray(), "AMP;".toCharArray(),
+            "Aacute".toCharArray(), "Aacute;".toCharArray(),
+            "Abreve;".toCharArray(), "Acirc".toCharArray(),
+            "Acirc;".toCharArray(), "Acy;".toCharArray(), "Afr;".toCharArray(),
+            "Agrave".toCharArray(), "Agrave;".toCharArray(),
+            "Alpha;".toCharArray(), "Amacr;".toCharArray(),
+            "And;".toCharArray(), "Aogon;".toCharArray(),
+            "Aopf;".toCharArray(), "ApplyFunction;".toCharArray(),
+            "Aring".toCharArray(), "Aring;".toCharArray(),
+            "Ascr;".toCharArray(), "Assign;".toCharArray(),
+            "Atilde".toCharArray(), "Atilde;".toCharArray(),
+            "Auml".toCharArray(), "Auml;".toCharArray(),
+            "Backslash;".toCharArray(), "Barv;".toCharArray(),
+            "Barwed;".toCharArray(), "Bcy;".toCharArray(),
+            "Because;".toCharArray(), "Bernoullis;".toCharArray(),
+            "Beta;".toCharArray(), "Bfr;".toCharArray(), "Bopf;".toCharArray(),
+            "Breve;".toCharArray(), "Bscr;".toCharArray(),
+            "Bumpeq;".toCharArray(), "CHcy;".toCharArray(),
+            "COPY".toCharArray(), "COPY;".toCharArray(),
+            "Cacute;".toCharArray(), "Cap;".toCharArray(),
+            "CapitalDifferentialD;".toCharArray(), "Cayleys;".toCharArray(),
+            "Ccaron;".toCharArray(), "Ccedil".toCharArray(),
+            "Ccedil;".toCharArray(), "Ccirc;".toCharArray(),
+            "Cconint;".toCharArray(), "Cdot;".toCharArray(),
+            "Cedilla;".toCharArray(), "CenterDot;".toCharArray(),
+            "Cfr;".toCharArray(), "Chi;".toCharArray(),
+            "CircleDot;".toCharArray(), "CircleMinus;".toCharArray(),
+            "CirclePlus;".toCharArray(), "CircleTimes;".toCharArray(),
+            "ClockwiseContourIntegral;".toCharArray(),
+            "CloseCurlyDoubleQuote;".toCharArray(),
+            "CloseCurlyQuote;".toCharArray(), "Colon;".toCharArray(),
+            "Colone;".toCharArray(), "Congruent;".toCharArray(),
+            "Conint;".toCharArray(), "ContourIntegral;".toCharArray(),
+            "Copf;".toCharArray(), "Coproduct;".toCharArray(),
+            "CounterClockwiseContourIntegral;".toCharArray(),
+            "Cross;".toCharArray(), "Cscr;".toCharArray(),
+            "Cup;".toCharArray(), "CupCap;".toCharArray(), "DD;".toCharArray(),
+            "DDotrahd;".toCharArray(), "DJcy;".toCharArray(),
+            "DScy;".toCharArray(), "DZcy;".toCharArray(),
+            "Dagger;".toCharArray(), "Darr;".toCharArray(),
+            "Dashv;".toCharArray(), "Dcaron;".toCharArray(),
+            "Dcy;".toCharArray(), "Del;".toCharArray(), "Delta;".toCharArray(),
+            "Dfr;".toCharArray(), "DiacriticalAcute;".toCharArray(),
+            "DiacriticalDot;".toCharArray(),
+            "DiacriticalDoubleAcute;".toCharArray(),
+            "DiacriticalGrave;".toCharArray(),
+            "DiacriticalTilde;".toCharArray(), "Diamond;".toCharArray(),
+            "DifferentialD;".toCharArray(), "Dopf;".toCharArray(),
+            "Dot;".toCharArray(), "DotDot;".toCharArray(),
+            "DotEqual;".toCharArray(), "DoubleContourIntegral;".toCharArray(),
+            "DoubleDot;".toCharArray(), "DoubleDownArrow;".toCharArray(),
+            "DoubleLeftArrow;".toCharArray(),
+            "DoubleLeftRightArrow;".toCharArray(),
+            "DoubleLeftTee;".toCharArray(),
+            "DoubleLongLeftArrow;".toCharArray(),
+            "DoubleLongLeftRightArrow;".toCharArray(),
+            "DoubleLongRightArrow;".toCharArray(),
+            "DoubleRightArrow;".toCharArray(), "DoubleRightTee;".toCharArray(),
+            "DoubleUpArrow;".toCharArray(), "DoubleUpDownArrow;".toCharArray(),
+            "DoubleVerticalBar;".toCharArray(), "DownArrow;".toCharArray(),
+            "DownArrowBar;".toCharArray(), "DownArrowUpArrow;".toCharArray(),
+            "DownBreve;".toCharArray(), "DownLeftRightVector;".toCharArray(),
+            "DownLeftTeeVector;".toCharArray(),
+            "DownLeftVector;".toCharArray(),
+            "DownLeftVectorBar;".toCharArray(),
+            "DownRightTeeVector;".toCharArray(),
+            "DownRightVector;".toCharArray(),
+            "DownRightVectorBar;".toCharArray(), "DownTee;".toCharArray(),
+            "DownTeeArrow;".toCharArray(), "Downarrow;".toCharArray(),
+            "Dscr;".toCharArray(), "Dstrok;".toCharArray(),
+            "ENG;".toCharArray(), "ETH".toCharArray(), "ETH;".toCharArray(),
+            "Eacute".toCharArray(), "Eacute;".toCharArray(),
+            "Ecaron;".toCharArray(), "Ecirc".toCharArray(),
+            "Ecirc;".toCharArray(), "Ecy;".toCharArray(),
+            "Edot;".toCharArray(), "Efr;".toCharArray(),
+            "Egrave".toCharArray(), "Egrave;".toCharArray(),
+            "Element;".toCharArray(), "Emacr;".toCharArray(),
+            "EmptySmallSquare;".toCharArray(),
+            "EmptyVerySmallSquare;".toCharArray(), "Eogon;".toCharArray(),
+            "Eopf;".toCharArray(), "Epsilon;".toCharArray(),
+            "Equal;".toCharArray(), "EqualTilde;".toCharArray(),
+            "Equilibrium;".toCharArray(), "Escr;".toCharArray(),
+            "Esim;".toCharArray(), "Eta;".toCharArray(), "Euml".toCharArray(),
+            "Euml;".toCharArray(), "Exists;".toCharArray(),
+            "ExponentialE;".toCharArray(), "Fcy;".toCharArray(),
+            "Ffr;".toCharArray(), "FilledSmallSquare;".toCharArray(),
+            "FilledVerySmallSquare;".toCharArray(), "Fopf;".toCharArray(),
+            "ForAll;".toCharArray(), "Fouriertrf;".toCharArray(),
+            "Fscr;".toCharArray(), "GJcy;".toCharArray(), "GT".toCharArray(),
+            "GT;".toCharArray(), "Gamma;".toCharArray(),
+            "Gammad;".toCharArray(), "Gbreve;".toCharArray(),
+            "Gcedil;".toCharArray(), "Gcirc;".toCharArray(),
+            "Gcy;".toCharArray(), "Gdot;".toCharArray(), "Gfr;".toCharArray(),
+            "Gg;".toCharArray(), "Gopf;".toCharArray(),
+            "GreaterEqual;".toCharArray(), "GreaterEqualLess;".toCharArray(),
+            "GreaterFullEqual;".toCharArray(), "GreaterGreater;".toCharArray(),
+            "GreaterLess;".toCharArray(), "GreaterSlantEqual;".toCharArray(),
+            "GreaterTilde;".toCharArray(), "Gscr;".toCharArray(),
+            "Gt;".toCharArray(), "HARDcy;".toCharArray(),
+            "Hacek;".toCharArray(), "Hat;".toCharArray(),
+            "Hcirc;".toCharArray(), "Hfr;".toCharArray(),
+            "HilbertSpace;".toCharArray(), "Hopf;".toCharArray(),
+            "HorizontalLine;".toCharArray(), "Hscr;".toCharArray(),
+            "Hstrok;".toCharArray(), "HumpDownHump;".toCharArray(),
+            "HumpEqual;".toCharArray(), "IEcy;".toCharArray(),
+            "IJlig;".toCharArray(), "IOcy;".toCharArray(),
+            "Iacute".toCharArray(), "Iacute;".toCharArray(),
+            "Icirc".toCharArray(), "Icirc;".toCharArray(),
+            "Icy;".toCharArray(), "Idot;".toCharArray(), "Ifr;".toCharArray(),
+            "Igrave".toCharArray(), "Igrave;".toCharArray(),
+            "Im;".toCharArray(), "Imacr;".toCharArray(),
+            "ImaginaryI;".toCharArray(), "Implies;".toCharArray(),
+            "Int;".toCharArray(), "Integral;".toCharArray(),
+            "Intersection;".toCharArray(), "InvisibleComma;".toCharArray(),
+            "InvisibleTimes;".toCharArray(), "Iogon;".toCharArray(),
+            "Iopf;".toCharArray(), "Iota;".toCharArray(),
+            "Iscr;".toCharArray(), "Itilde;".toCharArray(),
+            "Iukcy;".toCharArray(), "Iuml".toCharArray(),
+            "Iuml;".toCharArray(), "Jcirc;".toCharArray(),
+            "Jcy;".toCharArray(), "Jfr;".toCharArray(), "Jopf;".toCharArray(),
+            "Jscr;".toCharArray(), "Jsercy;".toCharArray(),
+            "Jukcy;".toCharArray(), "KHcy;".toCharArray(),
+            "KJcy;".toCharArray(), "Kappa;".toCharArray(),
+            "Kcedil;".toCharArray(), "Kcy;".toCharArray(),
+            "Kfr;".toCharArray(), "Kopf;".toCharArray(), "Kscr;".toCharArray(),
+            "LJcy;".toCharArray(), "LT".toCharArray(), "LT;".toCharArray(),
+            "Lacute;".toCharArray(), "Lambda;".toCharArray(),
+            "Lang;".toCharArray(), "Laplacetrf;".toCharArray(),
+            "Larr;".toCharArray(), "Lcaron;".toCharArray(),
+            "Lcedil;".toCharArray(), "Lcy;".toCharArray(),
+            "LeftAngleBracket;".toCharArray(), "LeftArrow;".toCharArray(),
+            "LeftArrowBar;".toCharArray(),
+            "LeftArrowRightArrow;".toCharArray(), "LeftCeiling;".toCharArray(),
+            "LeftDoubleBracket;".toCharArray(),
+            "LeftDownTeeVector;".toCharArray(),
+            "LeftDownVector;".toCharArray(),
+            "LeftDownVectorBar;".toCharArray(), "LeftFloor;".toCharArray(),
+            "LeftRightArrow;".toCharArray(), "LeftRightVector;".toCharArray(),
+            "LeftTee;".toCharArray(), "LeftTeeArrow;".toCharArray(),
+            "LeftTeeVector;".toCharArray(), "LeftTriangle;".toCharArray(),
+            "LeftTriangleBar;".toCharArray(),
+            "LeftTriangleEqual;".toCharArray(),
+            "LeftUpDownVector;".toCharArray(),
+            "LeftUpTeeVector;".toCharArray(), "LeftUpVector;".toCharArray(),
+            "LeftUpVectorBar;".toCharArray(), "LeftVector;".toCharArray(),
+            "LeftVectorBar;".toCharArray(), "Leftarrow;".toCharArray(),
+            "Leftrightarrow;".toCharArray(), "LessEqualGreater;".toCharArray(),
+            "LessFullEqual;".toCharArray(), "LessGreater;".toCharArray(),
+            "LessLess;".toCharArray(), "LessSlantEqual;".toCharArray(),
+            "LessTilde;".toCharArray(), "Lfr;".toCharArray(),
+            "Ll;".toCharArray(), "Lleftarrow;".toCharArray(),
+            "Lmidot;".toCharArray(), "LongLeftArrow;".toCharArray(),
+            "LongLeftRightArrow;".toCharArray(),
+            "LongRightArrow;".toCharArray(), "Longleftarrow;".toCharArray(),
+            "Longleftrightarrow;".toCharArray(),
+            "Longrightarrow;".toCharArray(), "Lopf;".toCharArray(),
+            "LowerLeftArrow;".toCharArray(), "LowerRightArrow;".toCharArray(),
+            "Lscr;".toCharArray(), "Lsh;".toCharArray(),
+            "Lstrok;".toCharArray(), "Lt;".toCharArray(), "Map;".toCharArray(),
+            "Mcy;".toCharArray(), "MediumSpace;".toCharArray(),
+            "Mellintrf;".toCharArray(), "Mfr;".toCharArray(),
+            "MinusPlus;".toCharArray(), "Mopf;".toCharArray(),
+            "Mscr;".toCharArray(), "Mu;".toCharArray(), "NJcy;".toCharArray(),
+            "Nacute;".toCharArray(), "Ncaron;".toCharArray(),
+            "Ncedil;".toCharArray(), "Ncy;".toCharArray(),
+            "NegativeMediumSpace;".toCharArray(),
+            "NegativeThickSpace;".toCharArray(),
+            "NegativeThinSpace;".toCharArray(),
+            "NegativeVeryThinSpace;".toCharArray(),
+            "NestedGreaterGreater;".toCharArray(),
+            "NestedLessLess;".toCharArray(), "NewLine;".toCharArray(),
+            "Nfr;".toCharArray(), "NoBreak;".toCharArray(),
+            "NonBreakingSpace;".toCharArray(), "Nopf;".toCharArray(),
+            "Not;".toCharArray(), "NotCongruent;".toCharArray(),
+            "NotCupCap;".toCharArray(), "NotDoubleVerticalBar;".toCharArray(),
+            "NotElement;".toCharArray(), "NotEqual;".toCharArray(),
+            "NotExists;".toCharArray(), "NotGreater;".toCharArray(),
+            "NotGreaterEqual;".toCharArray(), "NotGreaterLess;".toCharArray(),
+            "NotGreaterTilde;".toCharArray(), "NotLeftTriangle;".toCharArray(),
+            "NotLeftTriangleEqual;".toCharArray(), "NotLess;".toCharArray(),
+            "NotLessEqual;".toCharArray(), "NotLessGreater;".toCharArray(),
+            "NotLessTilde;".toCharArray(), "NotPrecedes;".toCharArray(),
+            "NotPrecedesSlantEqual;".toCharArray(),
+            "NotReverseElement;".toCharArray(),
+            "NotRightTriangle;".toCharArray(),
+            "NotRightTriangleEqual;".toCharArray(),
+            "NotSquareSubsetEqual;".toCharArray(),
+            "NotSquareSupersetEqual;".toCharArray(),
+            "NotSubsetEqual;".toCharArray(), "NotSucceeds;".toCharArray(),
+            "NotSucceedsSlantEqual;".toCharArray(),
+            "NotSupersetEqual;".toCharArray(), "NotTilde;".toCharArray(),
+            "NotTildeEqual;".toCharArray(), "NotTildeFullEqual;".toCharArray(),
+            "NotTildeTilde;".toCharArray(), "NotVerticalBar;".toCharArray(),
+            "Nscr;".toCharArray(), "Ntilde".toCharArray(),
+            "Ntilde;".toCharArray(), "Nu;".toCharArray(),
+            "OElig;".toCharArray(), "Oacute".toCharArray(),
+            "Oacute;".toCharArray(), "Ocirc".toCharArray(),
+            "Ocirc;".toCharArray(), "Ocy;".toCharArray(),
+            "Odblac;".toCharArray(), "Ofr;".toCharArray(),
+            "Ograve".toCharArray(), "Ograve;".toCharArray(),
+            "Omacr;".toCharArray(), "Omega;".toCharArray(),
+            "Omicron;".toCharArray(), "Oopf;".toCharArray(),
+            "OpenCurlyDoubleQuote;".toCharArray(),
+            "OpenCurlyQuote;".toCharArray(), "Or;".toCharArray(),
+            "Oscr;".toCharArray(), "Oslash".toCharArray(),
+            "Oslash;".toCharArray(), "Otilde".toCharArray(),
+            "Otilde;".toCharArray(), "Otimes;".toCharArray(),
+            "Ouml".toCharArray(), "Ouml;".toCharArray(),
+            "OverBar;".toCharArray(), "OverBrace;".toCharArray(),
+            "OverBracket;".toCharArray(), "OverParenthesis;".toCharArray(),
+            "PartialD;".toCharArray(), "Pcy;".toCharArray(),
+            "Pfr;".toCharArray(), "Phi;".toCharArray(), "Pi;".toCharArray(),
+            "PlusMinus;".toCharArray(), "Poincareplane;".toCharArray(),
+            "Popf;".toCharArray(), "Pr;".toCharArray(),
+            "Precedes;".toCharArray(), "PrecedesEqual;".toCharArray(),
+            "PrecedesSlantEqual;".toCharArray(),
+            "PrecedesTilde;".toCharArray(), "Prime;".toCharArray(),
+            "Product;".toCharArray(), "Proportion;".toCharArray(),
+            "Proportional;".toCharArray(), "Pscr;".toCharArray(),
+            "Psi;".toCharArray(), "QUOT".toCharArray(), "QUOT;".toCharArray(),
+            "Qfr;".toCharArray(), "Qopf;".toCharArray(), "Qscr;".toCharArray(),
+            "RBarr;".toCharArray(), "REG".toCharArray(), "REG;".toCharArray(),
+            "Racute;".toCharArray(), "Rang;".toCharArray(),
+            "Rarr;".toCharArray(), "Rarrtl;".toCharArray(),
+            "Rcaron;".toCharArray(), "Rcedil;".toCharArray(),
+            "Rcy;".toCharArray(), "Re;".toCharArray(),
+            "ReverseElement;".toCharArray(),
+            "ReverseEquilibrium;".toCharArray(),
+            "ReverseUpEquilibrium;".toCharArray(), "Rfr;".toCharArray(),
+            "Rho;".toCharArray(), "RightAngleBracket;".toCharArray(),
+            "RightArrow;".toCharArray(), "RightArrowBar;".toCharArray(),
+            "RightArrowLeftArrow;".toCharArray(),
+            "RightCeiling;".toCharArray(), "RightDoubleBracket;".toCharArray(),
+            "RightDownTeeVector;".toCharArray(),
+            "RightDownVector;".toCharArray(),
+            "RightDownVectorBar;".toCharArray(), "RightFloor;".toCharArray(),
+            "RightTee;".toCharArray(), "RightTeeArrow;".toCharArray(),
+            "RightTeeVector;".toCharArray(), "RightTriangle;".toCharArray(),
+            "RightTriangleBar;".toCharArray(),
+            "RightTriangleEqual;".toCharArray(),
+            "RightUpDownVector;".toCharArray(),
+            "RightUpTeeVector;".toCharArray(), "RightUpVector;".toCharArray(),
+            "RightUpVectorBar;".toCharArray(), "RightVector;".toCharArray(),
+            "RightVectorBar;".toCharArray(), "Rightarrow;".toCharArray(),
+            "Ropf;".toCharArray(), "RoundImplies;".toCharArray(),
+            "Rrightarrow;".toCharArray(), "Rscr;".toCharArray(),
+            "Rsh;".toCharArray(), "RuleDelayed;".toCharArray(),
+            "SHCHcy;".toCharArray(), "SHcy;".toCharArray(),
+            "SOFTcy;".toCharArray(), "Sacute;".toCharArray(),
+            "Sc;".toCharArray(), "Scaron;".toCharArray(),
+            "Scedil;".toCharArray(), "Scirc;".toCharArray(),
+            "Scy;".toCharArray(), "Sfr;".toCharArray(),
+            "ShortDownArrow;".toCharArray(), "ShortLeftArrow;".toCharArray(),
+            "ShortRightArrow;".toCharArray(), "ShortUpArrow;".toCharArray(),
+            "Sigma;".toCharArray(), "SmallCircle;".toCharArray(),
+            "Sopf;".toCharArray(), "Sqrt;".toCharArray(),
+            "Square;".toCharArray(), "SquareIntersection;".toCharArray(),
+            "SquareSubset;".toCharArray(), "SquareSubsetEqual;".toCharArray(),
+            "SquareSuperset;".toCharArray(),
+            "SquareSupersetEqual;".toCharArray(), "SquareUnion;".toCharArray(),
+            "Sscr;".toCharArray(), "Star;".toCharArray(), "Sub;".toCharArray(),
+            "Subset;".toCharArray(), "SubsetEqual;".toCharArray(),
+            "Succeeds;".toCharArray(), "SucceedsEqual;".toCharArray(),
+            "SucceedsSlantEqual;".toCharArray(),
+            "SucceedsTilde;".toCharArray(), "SuchThat;".toCharArray(),
+            "Sum;".toCharArray(), "Sup;".toCharArray(),
+            "Superset;".toCharArray(), "SupersetEqual;".toCharArray(),
+            "Supset;".toCharArray(), "THORN".toCharArray(),
+            "THORN;".toCharArray(), "TRADE;".toCharArray(),
+            "TSHcy;".toCharArray(), "TScy;".toCharArray(),
+            "Tab;".toCharArray(), "Tau;".toCharArray(),
+            "Tcaron;".toCharArray(), "Tcedil;".toCharArray(),
+            "Tcy;".toCharArray(), "Tfr;".toCharArray(),
+            "Therefore;".toCharArray(), "Theta;".toCharArray(),
+            "ThinSpace;".toCharArray(), "Tilde;".toCharArray(),
+            "TildeEqual;".toCharArray(), "TildeFullEqual;".toCharArray(),
+            "TildeTilde;".toCharArray(), "Topf;".toCharArray(),
+            "TripleDot;".toCharArray(), "Tscr;".toCharArray(),
+            "Tstrok;".toCharArray(), "Uacute".toCharArray(),
+            "Uacute;".toCharArray(), "Uarr;".toCharArray(),
+            "Uarrocir;".toCharArray(), "Ubrcy;".toCharArray(),
+            "Ubreve;".toCharArray(), "Ucirc".toCharArray(),
+            "Ucirc;".toCharArray(), "Ucy;".toCharArray(),
+            "Udblac;".toCharArray(), "Ufr;".toCharArray(),
+            "Ugrave".toCharArray(), "Ugrave;".toCharArray(),
+            "Umacr;".toCharArray(), "UnderBar;".toCharArray(),
+            "UnderBrace;".toCharArray(), "UnderBracket;".toCharArray(),
+            "UnderParenthesis;".toCharArray(), "Union;".toCharArray(),
+            "UnionPlus;".toCharArray(), "Uogon;".toCharArray(),
+            "Uopf;".toCharArray(), "UpArrow;".toCharArray(),
+            "UpArrowBar;".toCharArray(), "UpArrowDownArrow;".toCharArray(),
+            "UpDownArrow;".toCharArray(), "UpEquilibrium;".toCharArray(),
+            "UpTee;".toCharArray(), "UpTeeArrow;".toCharArray(),
+            "Uparrow;".toCharArray(), "Updownarrow;".toCharArray(),
+            "UpperLeftArrow;".toCharArray(), "UpperRightArrow;".toCharArray(),
+            "Upsi;".toCharArray(), "Upsilon;".toCharArray(),
+            "Uring;".toCharArray(), "Uscr;".toCharArray(),
+            "Utilde;".toCharArray(), "Uuml".toCharArray(),
+            "Uuml;".toCharArray(), "VDash;".toCharArray(),
+            "Vbar;".toCharArray(), "Vcy;".toCharArray(),
+            "Vdash;".toCharArray(), "Vdashl;".toCharArray(),
+            "Vee;".toCharArray(), "Verbar;".toCharArray(),
+            "Vert;".toCharArray(), "VerticalBar;".toCharArray(),
+            "VerticalLine;".toCharArray(), "VerticalSeparator;".toCharArray(),
+            "VerticalTilde;".toCharArray(), "VeryThinSpace;".toCharArray(),
+            "Vfr;".toCharArray(), "Vopf;".toCharArray(), "Vscr;".toCharArray(),
+            "Vvdash;".toCharArray(), "Wcirc;".toCharArray(),
+            "Wedge;".toCharArray(), "Wfr;".toCharArray(),
+            "Wopf;".toCharArray(), "Wscr;".toCharArray(), "Xfr;".toCharArray(),
+            "Xi;".toCharArray(), "Xopf;".toCharArray(), "Xscr;".toCharArray(),
+            "YAcy;".toCharArray(), "YIcy;".toCharArray(),
+            "YUcy;".toCharArray(), "Yacute".toCharArray(),
+            "Yacute;".toCharArray(), "Ycirc;".toCharArray(),
+            "Ycy;".toCharArray(), "Yfr;".toCharArray(), "Yopf;".toCharArray(),
+            "Yscr;".toCharArray(), "Yuml;".toCharArray(),
+            "ZHcy;".toCharArray(), "Zacute;".toCharArray(),
+            "Zcaron;".toCharArray(), "Zcy;".toCharArray(),
+            "Zdot;".toCharArray(), "ZeroWidthSpace;".toCharArray(),
+            "Zeta;".toCharArray(), "Zfr;".toCharArray(), "Zopf;".toCharArray(),
+            "Zscr;".toCharArray(), "aacute".toCharArray(),
+            "aacute;".toCharArray(), "abreve;".toCharArray(),
+            "ac;".toCharArray(), "acd;".toCharArray(), "acirc".toCharArray(),
+            "acirc;".toCharArray(), "acute".toCharArray(),
+            "acute;".toCharArray(), "acy;".toCharArray(),
+            "aelig".toCharArray(), "aelig;".toCharArray(), "af;".toCharArray(),
+            "afr;".toCharArray(), "agrave".toCharArray(),
+            "agrave;".toCharArray(), "alefsym;".toCharArray(),
+            "aleph;".toCharArray(), "alpha;".toCharArray(),
+            "amacr;".toCharArray(), "amalg;".toCharArray(),
+            "amp".toCharArray(), "amp;".toCharArray(), "and;".toCharArray(),
+            "andand;".toCharArray(), "andd;".toCharArray(),
+            "andslope;".toCharArray(), "andv;".toCharArray(),
+            "ang;".toCharArray(), "ange;".toCharArray(),
+            "angle;".toCharArray(), "angmsd;".toCharArray(),
+            "angmsdaa;".toCharArray(), "angmsdab;".toCharArray(),
+            "angmsdac;".toCharArray(), "angmsdad;".toCharArray(),
+            "angmsdae;".toCharArray(), "angmsdaf;".toCharArray(),
+            "angmsdag;".toCharArray(), "angmsdah;".toCharArray(),
+            "angrt;".toCharArray(), "angrtvb;".toCharArray(),
+            "angrtvbd;".toCharArray(), "angsph;".toCharArray(),
+            "angst;".toCharArray(), "angzarr;".toCharArray(),
+            "aogon;".toCharArray(), "aopf;".toCharArray(), "ap;".toCharArray(),
+            "apE;".toCharArray(), "apacir;".toCharArray(),
+            "ape;".toCharArray(), "apid;".toCharArray(), "apos;".toCharArray(),
+            "approx;".toCharArray(), "approxeq;".toCharArray(),
+            "aring".toCharArray(), "aring;".toCharArray(),
+            "ascr;".toCharArray(), "ast;".toCharArray(),
+            "asymp;".toCharArray(), "asympeq;".toCharArray(),
+            "atilde".toCharArray(), "atilde;".toCharArray(),
+            "auml".toCharArray(), "auml;".toCharArray(),
+            "awconint;".toCharArray(), "awint;".toCharArray(),
+            "bNot;".toCharArray(), "backcong;".toCharArray(),
+            "backepsilon;".toCharArray(), "backprime;".toCharArray(),
+            "backsim;".toCharArray(), "backsimeq;".toCharArray(),
+            "barvee;".toCharArray(), "barwed;".toCharArray(),
+            "barwedge;".toCharArray(), "bbrk;".toCharArray(),
+            "bbrktbrk;".toCharArray(), "bcong;".toCharArray(),
+            "bcy;".toCharArray(), "bdquo;".toCharArray(),
+            "becaus;".toCharArray(), "because;".toCharArray(),
+            "bemptyv;".toCharArray(), "bepsi;".toCharArray(),
+            "bernou;".toCharArray(), "beta;".toCharArray(),
+            "beth;".toCharArray(), "between;".toCharArray(),
+            "bfr;".toCharArray(), "bigcap;".toCharArray(),
+            "bigcirc;".toCharArray(), "bigcup;".toCharArray(),
+            "bigodot;".toCharArray(), "bigoplus;".toCharArray(),
+            "bigotimes;".toCharArray(), "bigsqcup;".toCharArray(),
+            "bigstar;".toCharArray(), "bigtriangledown;".toCharArray(),
+            "bigtriangleup;".toCharArray(), "biguplus;".toCharArray(),
+            "bigvee;".toCharArray(), "bigwedge;".toCharArray(),
+            "bkarow;".toCharArray(), "blacklozenge;".toCharArray(),
+            "blacksquare;".toCharArray(), "blacktriangle;".toCharArray(),
+            "blacktriangledown;".toCharArray(),
+            "blacktriangleleft;".toCharArray(),
+            "blacktriangleright;".toCharArray(), "blank;".toCharArray(),
+            "blk12;".toCharArray(), "blk14;".toCharArray(),
+            "blk34;".toCharArray(), "block;".toCharArray(),
+            "bnot;".toCharArray(), "bopf;".toCharArray(), "bot;".toCharArray(),
+            "bottom;".toCharArray(), "bowtie;".toCharArray(),
+            "boxDL;".toCharArray(), "boxDR;".toCharArray(),
+            "boxDl;".toCharArray(), "boxDr;".toCharArray(),
+            "boxH;".toCharArray(), "boxHD;".toCharArray(),
+            "boxHU;".toCharArray(), "boxHd;".toCharArray(),
+            "boxHu;".toCharArray(), "boxUL;".toCharArray(),
+            "boxUR;".toCharArray(), "boxUl;".toCharArray(),
+            "boxUr;".toCharArray(), "boxV;".toCharArray(),
+            "boxVH;".toCharArray(), "boxVL;".toCharArray(),
+            "boxVR;".toCharArray(), "boxVh;".toCharArray(),
+            "boxVl;".toCharArray(), "boxVr;".toCharArray(),
+            "boxbox;".toCharArray(), "boxdL;".toCharArray(),
+            "boxdR;".toCharArray(), "boxdl;".toCharArray(),
+            "boxdr;".toCharArray(), "boxh;".toCharArray(),
+            "boxhD;".toCharArray(), "boxhU;".toCharArray(),
+            "boxhd;".toCharArray(), "boxhu;".toCharArray(),
+            "boxminus;".toCharArray(), "boxplus;".toCharArray(),
+            "boxtimes;".toCharArray(), "boxuL;".toCharArray(),
+            "boxuR;".toCharArray(), "boxul;".toCharArray(),
+            "boxur;".toCharArray(), "boxv;".toCharArray(),
+            "boxvH;".toCharArray(), "boxvL;".toCharArray(),
+            "boxvR;".toCharArray(), "boxvh;".toCharArray(),
+            "boxvl;".toCharArray(), "boxvr;".toCharArray(),
+            "bprime;".toCharArray(), "breve;".toCharArray(),
+            "brvbar".toCharArray(), "brvbar;".toCharArray(),
+            "bscr;".toCharArray(), "bsemi;".toCharArray(),
+            "bsim;".toCharArray(), "bsime;".toCharArray(),
+            "bsol;".toCharArray(), "bsolb;".toCharArray(),
+            "bull;".toCharArray(), "bullet;".toCharArray(),
+            "bump;".toCharArray(), "bumpE;".toCharArray(),
+            "bumpe;".toCharArray(), "bumpeq;".toCharArray(),
+            "cacute;".toCharArray(), "cap;".toCharArray(),
+            "capand;".toCharArray(), "capbrcup;".toCharArray(),
+            "capcap;".toCharArray(), "capcup;".toCharArray(),
+            "capdot;".toCharArray(), "caret;".toCharArray(),
+            "caron;".toCharArray(), "ccaps;".toCharArray(),
+            "ccaron;".toCharArray(), "ccedil".toCharArray(),
+            "ccedil;".toCharArray(), "ccirc;".toCharArray(),
+            "ccups;".toCharArray(), "ccupssm;".toCharArray(),
+            "cdot;".toCharArray(), "cedil".toCharArray(),
+            "cedil;".toCharArray(), "cemptyv;".toCharArray(),
+            "cent".toCharArray(), "cent;".toCharArray(),
+            "centerdot;".toCharArray(), "cfr;".toCharArray(),
+            "chcy;".toCharArray(), "check;".toCharArray(),
+            "checkmark;".toCharArray(), "chi;".toCharArray(),
+            "cir;".toCharArray(), "cirE;".toCharArray(), "circ;".toCharArray(),
+            "circeq;".toCharArray(), "circlearrowleft;".toCharArray(),
+            "circlearrowright;".toCharArray(), "circledR;".toCharArray(),
+            "circledS;".toCharArray(), "circledast;".toCharArray(),
+            "circledcirc;".toCharArray(), "circleddash;".toCharArray(),
+            "cire;".toCharArray(), "cirfnint;".toCharArray(),
+            "cirmid;".toCharArray(), "cirscir;".toCharArray(),
+            "clubs;".toCharArray(), "clubsuit;".toCharArray(),
+            "colon;".toCharArray(), "colone;".toCharArray(),
+            "coloneq;".toCharArray(), "comma;".toCharArray(),
+            "commat;".toCharArray(), "comp;".toCharArray(),
+            "compfn;".toCharArray(), "complement;".toCharArray(),
+            "complexes;".toCharArray(), "cong;".toCharArray(),
+            "congdot;".toCharArray(), "conint;".toCharArray(),
+            "copf;".toCharArray(), "coprod;".toCharArray(),
+            "copy".toCharArray(), "copy;".toCharArray(),
+            "copysr;".toCharArray(), "crarr;".toCharArray(),
+            "cross;".toCharArray(), "cscr;".toCharArray(),
+            "csub;".toCharArray(), "csube;".toCharArray(),
+            "csup;".toCharArray(), "csupe;".toCharArray(),
+            "ctdot;".toCharArray(), "cudarrl;".toCharArray(),
+            "cudarrr;".toCharArray(), "cuepr;".toCharArray(),
+            "cuesc;".toCharArray(), "cularr;".toCharArray(),
+            "cularrp;".toCharArray(), "cup;".toCharArray(),
+            "cupbrcap;".toCharArray(), "cupcap;".toCharArray(),
+            "cupcup;".toCharArray(), "cupdot;".toCharArray(),
+            "cupor;".toCharArray(), "curarr;".toCharArray(),
+            "curarrm;".toCharArray(), "curlyeqprec;".toCharArray(),
+            "curlyeqsucc;".toCharArray(), "curlyvee;".toCharArray(),
+            "curlywedge;".toCharArray(), "curren".toCharArray(),
+            "curren;".toCharArray(), "curvearrowleft;".toCharArray(),
+            "curvearrowright;".toCharArray(), "cuvee;".toCharArray(),
+            "cuwed;".toCharArray(), "cwconint;".toCharArray(),
+            "cwint;".toCharArray(), "cylcty;".toCharArray(),
+            "dArr;".toCharArray(), "dHar;".toCharArray(),
+            "dagger;".toCharArray(), "daleth;".toCharArray(),
+            "darr;".toCharArray(), "dash;".toCharArray(),
+            "dashv;".toCharArray(), "dbkarow;".toCharArray(),
+            "dblac;".toCharArray(), "dcaron;".toCharArray(),
+            "dcy;".toCharArray(), "dd;".toCharArray(),
+            "ddagger;".toCharArray(), "ddarr;".toCharArray(),
+            "ddotseq;".toCharArray(), "deg".toCharArray(),
+            "deg;".toCharArray(), "delta;".toCharArray(),
+            "demptyv;".toCharArray(), "dfisht;".toCharArray(),
+            "dfr;".toCharArray(), "dharl;".toCharArray(),
+            "dharr;".toCharArray(), "diam;".toCharArray(),
+            "diamond;".toCharArray(), "diamondsuit;".toCharArray(),
+            "diams;".toCharArray(), "die;".toCharArray(),
+            "digamma;".toCharArray(), "disin;".toCharArray(),
+            "div;".toCharArray(), "divide".toCharArray(),
+            "divide;".toCharArray(), "divideontimes;".toCharArray(),
+            "divonx;".toCharArray(), "djcy;".toCharArray(),
+            "dlcorn;".toCharArray(), "dlcrop;".toCharArray(),
+            "dollar;".toCharArray(), "dopf;".toCharArray(),
+            "dot;".toCharArray(), "doteq;".toCharArray(),
+            "doteqdot;".toCharArray(), "dotminus;".toCharArray(),
+            "dotplus;".toCharArray(), "dotsquare;".toCharArray(),
+            "doublebarwedge;".toCharArray(), "downarrow;".toCharArray(),
+            "downdownarrows;".toCharArray(), "downharpoonleft;".toCharArray(),
+            "downharpoonright;".toCharArray(), "drbkarow;".toCharArray(),
+            "drcorn;".toCharArray(), "drcrop;".toCharArray(),
+            "dscr;".toCharArray(), "dscy;".toCharArray(),
+            "dsol;".toCharArray(), "dstrok;".toCharArray(),
+            "dtdot;".toCharArray(), "dtri;".toCharArray(),
+            "dtrif;".toCharArray(), "duarr;".toCharArray(),
+            "duhar;".toCharArray(), "dwangle;".toCharArray(),
+            "dzcy;".toCharArray(), "dzigrarr;".toCharArray(),
+            "eDDot;".toCharArray(), "eDot;".toCharArray(),
+            "eacute".toCharArray(), "eacute;".toCharArray(),
+            "easter;".toCharArray(), "ecaron;".toCharArray(),
+            "ecir;".toCharArray(), "ecirc".toCharArray(),
+            "ecirc;".toCharArray(), "ecolon;".toCharArray(),
+            "ecy;".toCharArray(), "edot;".toCharArray(), "ee;".toCharArray(),
+            "efDot;".toCharArray(), "efr;".toCharArray(), "eg;".toCharArray(),
+            "egrave".toCharArray(), "egrave;".toCharArray(),
+            "egs;".toCharArray(), "egsdot;".toCharArray(), "el;".toCharArray(),
+            "elinters;".toCharArray(), "ell;".toCharArray(),
+            "els;".toCharArray(), "elsdot;".toCharArray(),
+            "emacr;".toCharArray(), "empty;".toCharArray(),
+            "emptyset;".toCharArray(), "emptyv;".toCharArray(),
+            "emsp13;".toCharArray(), "emsp14;".toCharArray(),
+            "emsp;".toCharArray(), "eng;".toCharArray(), "ensp;".toCharArray(),
+            "eogon;".toCharArray(), "eopf;".toCharArray(),
+            "epar;".toCharArray(), "eparsl;".toCharArray(),
+            "eplus;".toCharArray(), "epsi;".toCharArray(),
+            "epsilon;".toCharArray(), "epsiv;".toCharArray(),
+            "eqcirc;".toCharArray(), "eqcolon;".toCharArray(),
+            "eqsim;".toCharArray(), "eqslantgtr;".toCharArray(),
+            "eqslantless;".toCharArray(), "equals;".toCharArray(),
+            "equest;".toCharArray(), "equiv;".toCharArray(),
+            "equivDD;".toCharArray(), "eqvparsl;".toCharArray(),
+            "erDot;".toCharArray(), "erarr;".toCharArray(),
+            "escr;".toCharArray(), "esdot;".toCharArray(),
+            "esim;".toCharArray(), "eta;".toCharArray(), "eth".toCharArray(),
+            "eth;".toCharArray(), "euml".toCharArray(), "euml;".toCharArray(),
+            "euro;".toCharArray(), "excl;".toCharArray(),
+            "exist;".toCharArray(), "expectation;".toCharArray(),
+            "exponentiale;".toCharArray(), "fallingdotseq;".toCharArray(),
+            "fcy;".toCharArray(), "female;".toCharArray(),
+            "ffilig;".toCharArray(), "fflig;".toCharArray(),
+            "ffllig;".toCharArray(), "ffr;".toCharArray(),
+            "filig;".toCharArray(), "flat;".toCharArray(),
+            "fllig;".toCharArray(), "fltns;".toCharArray(),
+            "fnof;".toCharArray(), "fopf;".toCharArray(),
+            "forall;".toCharArray(), "fork;".toCharArray(),
+            "forkv;".toCharArray(), "fpartint;".toCharArray(),
+            "frac12".toCharArray(), "frac12;".toCharArray(),
+            "frac13;".toCharArray(), "frac14".toCharArray(),
+            "frac14;".toCharArray(), "frac15;".toCharArray(),
+            "frac16;".toCharArray(), "frac18;".toCharArray(),
+            "frac23;".toCharArray(), "frac25;".toCharArray(),
+            "frac34".toCharArray(), "frac34;".toCharArray(),
+            "frac35;".toCharArray(), "frac38;".toCharArray(),
+            "frac45;".toCharArray(), "frac56;".toCharArray(),
+            "frac58;".toCharArray(), "frac78;".toCharArray(),
+            "frasl;".toCharArray(), "frown;".toCharArray(),
+            "fscr;".toCharArray(), "gE;".toCharArray(), "gEl;".toCharArray(),
+            "gacute;".toCharArray(), "gamma;".toCharArray(),
+            "gammad;".toCharArray(), "gap;".toCharArray(),
+            "gbreve;".toCharArray(), "gcirc;".toCharArray(),
+            "gcy;".toCharArray(), "gdot;".toCharArray(), "ge;".toCharArray(),
+            "gel;".toCharArray(), "geq;".toCharArray(), "geqq;".toCharArray(),
+            "geqslant;".toCharArray(), "ges;".toCharArray(),
+            "gescc;".toCharArray(), "gesdot;".toCharArray(),
+            "gesdoto;".toCharArray(), "gesdotol;".toCharArray(),
+            "gesles;".toCharArray(), "gfr;".toCharArray(), "gg;".toCharArray(),
+            "ggg;".toCharArray(), "gimel;".toCharArray(),
+            "gjcy;".toCharArray(), "gl;".toCharArray(), "glE;".toCharArray(),
+            "gla;".toCharArray(), "glj;".toCharArray(), "gnE;".toCharArray(),
+            "gnap;".toCharArray(), "gnapprox;".toCharArray(),
+            "gne;".toCharArray(), "gneq;".toCharArray(),
+            "gneqq;".toCharArray(), "gnsim;".toCharArray(),
+            "gopf;".toCharArray(), "grave;".toCharArray(),
+            "gscr;".toCharArray(), "gsim;".toCharArray(),
+            "gsime;".toCharArray(), "gsiml;".toCharArray(), "gt".toCharArray(),
+            "gt;".toCharArray(), "gtcc;".toCharArray(), "gtcir;".toCharArray(),
+            "gtdot;".toCharArray(), "gtlPar;".toCharArray(),
+            "gtquest;".toCharArray(), "gtrapprox;".toCharArray(),
+            "gtrarr;".toCharArray(), "gtrdot;".toCharArray(),
+            "gtreqless;".toCharArray(), "gtreqqless;".toCharArray(),
+            "gtrless;".toCharArray(), "gtrsim;".toCharArray(),
+            "hArr;".toCharArray(), "hairsp;".toCharArray(),
+            "half;".toCharArray(), "hamilt;".toCharArray(),
+            "hardcy;".toCharArray(), "harr;".toCharArray(),
+            "harrcir;".toCharArray(), "harrw;".toCharArray(),
+            "hbar;".toCharArray(), "hcirc;".toCharArray(),
+            "hearts;".toCharArray(), "heartsuit;".toCharArray(),
+            "hellip;".toCharArray(), "hercon;".toCharArray(),
+            "hfr;".toCharArray(), "hksearow;".toCharArray(),
+            "hkswarow;".toCharArray(), "hoarr;".toCharArray(),
+            "homtht;".toCharArray(), "hookleftarrow;".toCharArray(),
+            "hookrightarrow;".toCharArray(), "hopf;".toCharArray(),
+            "horbar;".toCharArray(), "hscr;".toCharArray(),
+            "hslash;".toCharArray(), "hstrok;".toCharArray(),
+            "hybull;".toCharArray(), "hyphen;".toCharArray(),
+            "iacute".toCharArray(), "iacute;".toCharArray(),
+            "ic;".toCharArray(), "icirc".toCharArray(), "icirc;".toCharArray(),
+            "icy;".toCharArray(), "iecy;".toCharArray(), "iexcl".toCharArray(),
+            "iexcl;".toCharArray(), "iff;".toCharArray(), "ifr;".toCharArray(),
+            "igrave".toCharArray(), "igrave;".toCharArray(),
+            "ii;".toCharArray(), "iiiint;".toCharArray(),
+            "iiint;".toCharArray(), "iinfin;".toCharArray(),
+            "iiota;".toCharArray(), "ijlig;".toCharArray(),
+            "imacr;".toCharArray(), "image;".toCharArray(),
+            "imagline;".toCharArray(), "imagpart;".toCharArray(),
+            "imath;".toCharArray(), "imof;".toCharArray(),
+            "imped;".toCharArray(), "in;".toCharArray(),
+            "incare;".toCharArray(), "infin;".toCharArray(),
+            "infintie;".toCharArray(), "inodot;".toCharArray(),
+            "int;".toCharArray(), "intcal;".toCharArray(),
+            "integers;".toCharArray(), "intercal;".toCharArray(),
+            "intlarhk;".toCharArray(), "intprod;".toCharArray(),
+            "iocy;".toCharArray(), "iogon;".toCharArray(),
+            "iopf;".toCharArray(), "iota;".toCharArray(),
+            "iprod;".toCharArray(), "iquest".toCharArray(),
+            "iquest;".toCharArray(), "iscr;".toCharArray(),
+            "isin;".toCharArray(), "isinE;".toCharArray(),
+            "isindot;".toCharArray(), "isins;".toCharArray(),
+            "isinsv;".toCharArray(), "isinv;".toCharArray(),
+            "it;".toCharArray(), "itilde;".toCharArray(),
+            "iukcy;".toCharArray(), "iuml".toCharArray(),
+            "iuml;".toCharArray(), "jcirc;".toCharArray(),
+            "jcy;".toCharArray(), "jfr;".toCharArray(), "jmath;".toCharArray(),
+            "jopf;".toCharArray(), "jscr;".toCharArray(),
+            "jsercy;".toCharArray(), "jukcy;".toCharArray(),
+            "kappa;".toCharArray(), "kappav;".toCharArray(),
+            "kcedil;".toCharArray(), "kcy;".toCharArray(),
+            "kfr;".toCharArray(), "kgreen;".toCharArray(),
+            "khcy;".toCharArray(), "kjcy;".toCharArray(),
+            "kopf;".toCharArray(), "kscr;".toCharArray(),
+            "lAarr;".toCharArray(), "lArr;".toCharArray(),
+            "lAtail;".toCharArray(), "lBarr;".toCharArray(),
+            "lE;".toCharArray(), "lEg;".toCharArray(), "lHar;".toCharArray(),
+            "lacute;".toCharArray(), "laemptyv;".toCharArray(),
+            "lagran;".toCharArray(), "lambda;".toCharArray(),
+            "lang;".toCharArray(), "langd;".toCharArray(),
+            "langle;".toCharArray(), "lap;".toCharArray(),
+            "laquo".toCharArray(), "laquo;".toCharArray(),
+            "larr;".toCharArray(), "larrb;".toCharArray(),
+            "larrbfs;".toCharArray(), "larrfs;".toCharArray(),
+            "larrhk;".toCharArray(), "larrlp;".toCharArray(),
+            "larrpl;".toCharArray(), "larrsim;".toCharArray(),
+            "larrtl;".toCharArray(), "lat;".toCharArray(),
+            "latail;".toCharArray(), "late;".toCharArray(),
+            "lbarr;".toCharArray(), "lbbrk;".toCharArray(),
+            "lbrace;".toCharArray(), "lbrack;".toCharArray(),
+            "lbrke;".toCharArray(), "lbrksld;".toCharArray(),
+            "lbrkslu;".toCharArray(), "lcaron;".toCharArray(),
+            "lcedil;".toCharArray(), "lceil;".toCharArray(),
+            "lcub;".toCharArray(), "lcy;".toCharArray(), "ldca;".toCharArray(),
+            "ldquo;".toCharArray(), "ldquor;".toCharArray(),
+            "ldrdhar;".toCharArray(), "ldrushar;".toCharArray(),
+            "ldsh;".toCharArray(), "le;".toCharArray(),
+            "leftarrow;".toCharArray(), "leftarrowtail;".toCharArray(),
+            "leftharpoondown;".toCharArray(), "leftharpoonup;".toCharArray(),
+            "leftleftarrows;".toCharArray(), "leftrightarrow;".toCharArray(),
+            "leftrightarrows;".toCharArray(),
+            "leftrightharpoons;".toCharArray(),
+            "leftrightsquigarrow;".toCharArray(),
+            "leftthreetimes;".toCharArray(), "leg;".toCharArray(),
+            "leq;".toCharArray(), "leqq;".toCharArray(),
+            "leqslant;".toCharArray(), "les;".toCharArray(),
+            "lescc;".toCharArray(), "lesdot;".toCharArray(),
+            "lesdoto;".toCharArray(), "lesdotor;".toCharArray(),
+            "lesges;".toCharArray(), "lessapprox;".toCharArray(),
+            "lessdot;".toCharArray(), "lesseqgtr;".toCharArray(),
+            "lesseqqgtr;".toCharArray(), "lessgtr;".toCharArray(),
+            "lesssim;".toCharArray(), "lfisht;".toCharArray(),
+            "lfloor;".toCharArray(), "lfr;".toCharArray(), "lg;".toCharArray(),
+            "lgE;".toCharArray(), "lhard;".toCharArray(),
+            "lharu;".toCharArray(), "lharul;".toCharArray(),
+            "lhblk;".toCharArray(), "ljcy;".toCharArray(), "ll;".toCharArray(),
+            "llarr;".toCharArray(), "llcorner;".toCharArray(),
+            "llhard;".toCharArray(), "lltri;".toCharArray(),
+            "lmidot;".toCharArray(), "lmoust;".toCharArray(),
+            "lmoustache;".toCharArray(), "lnE;".toCharArray(),
+            "lnap;".toCharArray(), "lnapprox;".toCharArray(),
+            "lne;".toCharArray(), "lneq;".toCharArray(),
+            "lneqq;".toCharArray(), "lnsim;".toCharArray(),
+            "loang;".toCharArray(), "loarr;".toCharArray(),
+            "lobrk;".toCharArray(), "longleftarrow;".toCharArray(),
+            "longleftrightarrow;".toCharArray(), "longmapsto;".toCharArray(),
+            "longrightarrow;".toCharArray(), "looparrowleft;".toCharArray(),
+            "looparrowright;".toCharArray(), "lopar;".toCharArray(),
+            "lopf;".toCharArray(), "loplus;".toCharArray(),
+            "lotimes;".toCharArray(), "lowast;".toCharArray(),
+            "lowbar;".toCharArray(), "loz;".toCharArray(),
+            "lozenge;".toCharArray(), "lozf;".toCharArray(),
+            "lpar;".toCharArray(), "lparlt;".toCharArray(),
+            "lrarr;".toCharArray(), "lrcorner;".toCharArray(),
+            "lrhar;".toCharArray(), "lrhard;".toCharArray(),
+            "lrm;".toCharArray(), "lrtri;".toCharArray(),
+            "lsaquo;".toCharArray(), "lscr;".toCharArray(),
+            "lsh;".toCharArray(), "lsim;".toCharArray(),
+            "lsime;".toCharArray(), "lsimg;".toCharArray(),
+            "lsqb;".toCharArray(), "lsquo;".toCharArray(),
+            "lsquor;".toCharArray(), "lstrok;".toCharArray(),
+            "lt".toCharArray(), "lt;".toCharArray(), "ltcc;".toCharArray(),
+            "ltcir;".toCharArray(), "ltdot;".toCharArray(),
+            "lthree;".toCharArray(), "ltimes;".toCharArray(),
+            "ltlarr;".toCharArray(), "ltquest;".toCharArray(),
+            "ltrPar;".toCharArray(), "ltri;".toCharArray(),
+            "ltrie;".toCharArray(), "ltrif;".toCharArray(),
+            "lurdshar;".toCharArray(), "luruhar;".toCharArray(),
+            "mDDot;".toCharArray(), "macr".toCharArray(),
+            "macr;".toCharArray(), "male;".toCharArray(),
+            "malt;".toCharArray(), "maltese;".toCharArray(),
+            "map;".toCharArray(), "mapsto;".toCharArray(),
+            "mapstodown;".toCharArray(), "mapstoleft;".toCharArray(),
+            "mapstoup;".toCharArray(), "marker;".toCharArray(),
+            "mcomma;".toCharArray(), "mcy;".toCharArray(),
+            "mdash;".toCharArray(), "measuredangle;".toCharArray(),
+            "mfr;".toCharArray(), "mho;".toCharArray(), "micro".toCharArray(),
+            "micro;".toCharArray(), "mid;".toCharArray(),
+            "midast;".toCharArray(), "midcir;".toCharArray(),
+            "middot".toCharArray(), "middot;".toCharArray(),
+            "minus;".toCharArray(), "minusb;".toCharArray(),
+            "minusd;".toCharArray(), "minusdu;".toCharArray(),
+            "mlcp;".toCharArray(), "mldr;".toCharArray(),
+            "mnplus;".toCharArray(), "models;".toCharArray(),
+            "mopf;".toCharArray(), "mp;".toCharArray(), "mscr;".toCharArray(),
+            "mstpos;".toCharArray(), "mu;".toCharArray(),
+            "multimap;".toCharArray(), "mumap;".toCharArray(),
+            "nLeftarrow;".toCharArray(), "nLeftrightarrow;".toCharArray(),
+            "nRightarrow;".toCharArray(), "nVDash;".toCharArray(),
+            "nVdash;".toCharArray(), "nabla;".toCharArray(),
+            "nacute;".toCharArray(), "nap;".toCharArray(),
+            "napos;".toCharArray(), "napprox;".toCharArray(),
+            "natur;".toCharArray(), "natural;".toCharArray(),
+            "naturals;".toCharArray(), "nbsp".toCharArray(),
+            "nbsp;".toCharArray(), "ncap;".toCharArray(),
+            "ncaron;".toCharArray(), "ncedil;".toCharArray(),
+            "ncong;".toCharArray(), "ncup;".toCharArray(),
+            "ncy;".toCharArray(), "ndash;".toCharArray(), "ne;".toCharArray(),
+            "neArr;".toCharArray(), "nearhk;".toCharArray(),
+            "nearr;".toCharArray(), "nearrow;".toCharArray(),
+            "nequiv;".toCharArray(), "nesear;".toCharArray(),
+            "nexist;".toCharArray(), "nexists;".toCharArray(),
+            "nfr;".toCharArray(), "nge;".toCharArray(), "ngeq;".toCharArray(),
+            "ngsim;".toCharArray(), "ngt;".toCharArray(),
+            "ngtr;".toCharArray(), "nhArr;".toCharArray(),
+            "nharr;".toCharArray(), "nhpar;".toCharArray(),
+            "ni;".toCharArray(), "nis;".toCharArray(), "nisd;".toCharArray(),
+            "niv;".toCharArray(), "njcy;".toCharArray(),
+            "nlArr;".toCharArray(), "nlarr;".toCharArray(),
+            "nldr;".toCharArray(), "nle;".toCharArray(),
+            "nleftarrow;".toCharArray(), "nleftrightarrow;".toCharArray(),
+            "nleq;".toCharArray(), "nless;".toCharArray(),
+            "nlsim;".toCharArray(), "nlt;".toCharArray(),
+            "nltri;".toCharArray(), "nltrie;".toCharArray(),
+            "nmid;".toCharArray(), "nopf;".toCharArray(), "not".toCharArray(),
+            "not;".toCharArray(), "notin;".toCharArray(),
+            "notinva;".toCharArray(), "notinvb;".toCharArray(),
+            "notinvc;".toCharArray(), "notni;".toCharArray(),
+            "notniva;".toCharArray(), "notnivb;".toCharArray(),
+            "notnivc;".toCharArray(), "npar;".toCharArray(),
+            "nparallel;".toCharArray(), "npolint;".toCharArray(),
+            "npr;".toCharArray(), "nprcue;".toCharArray(),
+            "nprec;".toCharArray(), "nrArr;".toCharArray(),
+            "nrarr;".toCharArray(), "nrightarrow;".toCharArray(),
+            "nrtri;".toCharArray(), "nrtrie;".toCharArray(),
+            "nsc;".toCharArray(), "nsccue;".toCharArray(),
+            "nscr;".toCharArray(), "nshortmid;".toCharArray(),
+            "nshortparallel;".toCharArray(), "nsim;".toCharArray(),
+            "nsime;".toCharArray(), "nsimeq;".toCharArray(),
+            "nsmid;".toCharArray(), "nspar;".toCharArray(),
+            "nsqsube;".toCharArray(), "nsqsupe;".toCharArray(),
+            "nsub;".toCharArray(), "nsube;".toCharArray(),
+            "nsubseteq;".toCharArray(), "nsucc;".toCharArray(),
+            "nsup;".toCharArray(), "nsupe;".toCharArray(),
+            "nsupseteq;".toCharArray(), "ntgl;".toCharArray(),
+            "ntilde".toCharArray(), "ntilde;".toCharArray(),
+            "ntlg;".toCharArray(), "ntriangleleft;".toCharArray(),
+            "ntrianglelefteq;".toCharArray(), "ntriangleright;".toCharArray(),
+            "ntrianglerighteq;".toCharArray(), "nu;".toCharArray(),
+            "num;".toCharArray(), "numero;".toCharArray(),
+            "numsp;".toCharArray(), "nvDash;".toCharArray(),
+            "nvHarr;".toCharArray(), "nvdash;".toCharArray(),
+            "nvinfin;".toCharArray(), "nvlArr;".toCharArray(),
+            "nvrArr;".toCharArray(), "nwArr;".toCharArray(),
+            "nwarhk;".toCharArray(), "nwarr;".toCharArray(),
+            "nwarrow;".toCharArray(), "nwnear;".toCharArray(),
+            "oS;".toCharArray(), "oacute".toCharArray(),
+            "oacute;".toCharArray(), "oast;".toCharArray(),
+            "ocir;".toCharArray(), "ocirc".toCharArray(),
+            "ocirc;".toCharArray(), "ocy;".toCharArray(),
+            "odash;".toCharArray(), "odblac;".toCharArray(),
+            "odiv;".toCharArray(), "odot;".toCharArray(),
+            "odsold;".toCharArray(), "oelig;".toCharArray(),
+            "ofcir;".toCharArray(), "ofr;".toCharArray(),
+            "ogon;".toCharArray(), "ograve".toCharArray(),
+            "ograve;".toCharArray(), "ogt;".toCharArray(),
+            "ohbar;".toCharArray(), "ohm;".toCharArray(),
+            "oint;".toCharArray(), "olarr;".toCharArray(),
+            "olcir;".toCharArray(), "olcross;".toCharArray(),
+            "oline;".toCharArray(), "olt;".toCharArray(),
+            "omacr;".toCharArray(), "omega;".toCharArray(),
+            "omicron;".toCharArray(), "omid;".toCharArray(),
+            "ominus;".toCharArray(), "oopf;".toCharArray(),
+            "opar;".toCharArray(), "operp;".toCharArray(),
+            "oplus;".toCharArray(), "or;".toCharArray(),
+            "orarr;".toCharArray(), "ord;".toCharArray(),
+            "order;".toCharArray(), "orderof;".toCharArray(),
+            "ordf".toCharArray(), "ordf;".toCharArray(), "ordm".toCharArray(),
+            "ordm;".toCharArray(), "origof;".toCharArray(),
+            "oror;".toCharArray(), "orslope;".toCharArray(),
+            "orv;".toCharArray(), "oscr;".toCharArray(),
+            "oslash".toCharArray(), "oslash;".toCharArray(),
+            "osol;".toCharArray(), "otilde".toCharArray(),
+            "otilde;".toCharArray(), "otimes;".toCharArray(),
+            "otimesas;".toCharArray(), "ouml".toCharArray(),
+            "ouml;".toCharArray(), "ovbar;".toCharArray(),
+            "par;".toCharArray(), "para".toCharArray(), "para;".toCharArray(),
+            "parallel;".toCharArray(), "parsim;".toCharArray(),
+            "parsl;".toCharArray(), "part;".toCharArray(),
+            "pcy;".toCharArray(), "percnt;".toCharArray(),
+            "period;".toCharArray(), "permil;".toCharArray(),
+            "perp;".toCharArray(), "pertenk;".toCharArray(),
+            "pfr;".toCharArray(), "phi;".toCharArray(), "phiv;".toCharArray(),
+            "phmmat;".toCharArray(), "phone;".toCharArray(),
+            "pi;".toCharArray(), "pitchfork;".toCharArray(),
+            "piv;".toCharArray(), "planck;".toCharArray(),
+            "planckh;".toCharArray(), "plankv;".toCharArray(),
+            "plus;".toCharArray(), "plusacir;".toCharArray(),
+            "plusb;".toCharArray(), "pluscir;".toCharArray(),
+            "plusdo;".toCharArray(), "plusdu;".toCharArray(),
+            "pluse;".toCharArray(), "plusmn".toCharArray(),
+            "plusmn;".toCharArray(), "plussim;".toCharArray(),
+            "plustwo;".toCharArray(), "pm;".toCharArray(),
+            "pointint;".toCharArray(), "popf;".toCharArray(),
+            "pound".toCharArray(), "pound;".toCharArray(), "pr;".toCharArray(),
+            "prE;".toCharArray(), "prap;".toCharArray(),
+            "prcue;".toCharArray(), "pre;".toCharArray(),
+            "prec;".toCharArray(), "precapprox;".toCharArray(),
+            "preccurlyeq;".toCharArray(), "preceq;".toCharArray(),
+            "precnapprox;".toCharArray(), "precneqq;".toCharArray(),
+            "precnsim;".toCharArray(), "precsim;".toCharArray(),
+            "prime;".toCharArray(), "primes;".toCharArray(),
+            "prnE;".toCharArray(), "prnap;".toCharArray(),
+            "prnsim;".toCharArray(), "prod;".toCharArray(),
+            "profalar;".toCharArray(), "profline;".toCharArray(),
+            "profsurf;".toCharArray(), "prop;".toCharArray(),
+            "propto;".toCharArray(), "prsim;".toCharArray(),
+            "prurel;".toCharArray(), "pscr;".toCharArray(),
+            "psi;".toCharArray(), "puncsp;".toCharArray(),
+            "qfr;".toCharArray(), "qint;".toCharArray(), "qopf;".toCharArray(),
+            "qprime;".toCharArray(), "qscr;".toCharArray(),
+            "quaternions;".toCharArray(), "quatint;".toCharArray(),
+            "quest;".toCharArray(), "questeq;".toCharArray(),
+            "quot".toCharArray(), "quot;".toCharArray(),
+            "rAarr;".toCharArray(), "rArr;".toCharArray(),
+            "rAtail;".toCharArray(), "rBarr;".toCharArray(),
+            "rHar;".toCharArray(), "race;".toCharArray(),
+            "racute;".toCharArray(), "radic;".toCharArray(),
+            "raemptyv;".toCharArray(), "rang;".toCharArray(),
+            "rangd;".toCharArray(), "range;".toCharArray(),
+            "rangle;".toCharArray(), "raquo".toCharArray(),
+            "raquo;".toCharArray(), "rarr;".toCharArray(),
+            "rarrap;".toCharArray(), "rarrb;".toCharArray(),
+            "rarrbfs;".toCharArray(), "rarrc;".toCharArray(),
+            "rarrfs;".toCharArray(), "rarrhk;".toCharArray(),
+            "rarrlp;".toCharArray(), "rarrpl;".toCharArray(),
+            "rarrsim;".toCharArray(), "rarrtl;".toCharArray(),
+            "rarrw;".toCharArray(), "ratail;".toCharArray(),
+            "ratio;".toCharArray(), "rationals;".toCharArray(),
+            "rbarr;".toCharArray(), "rbbrk;".toCharArray(),
+            "rbrace;".toCharArray(), "rbrack;".toCharArray(),
+            "rbrke;".toCharArray(), "rbrksld;".toCharArray(),
+            "rbrkslu;".toCharArray(), "rcaron;".toCharArray(),
+            "rcedil;".toCharArray(), "rceil;".toCharArray(),
+            "rcub;".toCharArray(), "rcy;".toCharArray(), "rdca;".toCharArray(),
+            "rdldhar;".toCharArray(), "rdquo;".toCharArray(),
+            "rdquor;".toCharArray(), "rdsh;".toCharArray(),
+            "real;".toCharArray(), "realine;".toCharArray(),
+            "realpart;".toCharArray(), "reals;".toCharArray(),
+            "rect;".toCharArray(), "reg".toCharArray(), "reg;".toCharArray(),
+            "rfisht;".toCharArray(), "rfloor;".toCharArray(),
+            "rfr;".toCharArray(), "rhard;".toCharArray(),
+            "rharu;".toCharArray(), "rharul;".toCharArray(),
+            "rho;".toCharArray(), "rhov;".toCharArray(),
+            "rightarrow;".toCharArray(), "rightarrowtail;".toCharArray(),
+            "rightharpoondown;".toCharArray(), "rightharpoonup;".toCharArray(),
+            "rightleftarrows;".toCharArray(),
+            "rightleftharpoons;".toCharArray(),
+            "rightrightarrows;".toCharArray(),
+            "rightsquigarrow;".toCharArray(), "rightthreetimes;".toCharArray(),
+            "ring;".toCharArray(), "risingdotseq;".toCharArray(),
+            "rlarr;".toCharArray(), "rlhar;".toCharArray(),
+            "rlm;".toCharArray(), "rmoust;".toCharArray(),
+            "rmoustache;".toCharArray(), "rnmid;".toCharArray(),
+            "roang;".toCharArray(), "roarr;".toCharArray(),
+            "robrk;".toCharArray(), "ropar;".toCharArray(),
+            "ropf;".toCharArray(), "roplus;".toCharArray(),
+            "rotimes;".toCharArray(), "rpar;".toCharArray(),
+            "rpargt;".toCharArray(), "rppolint;".toCharArray(),
+            "rrarr;".toCharArray(), "rsaquo;".toCharArray(),
+            "rscr;".toCharArray(), "rsh;".toCharArray(), "rsqb;".toCharArray(),
+            "rsquo;".toCharArray(), "rsquor;".toCharArray(),
+            "rthree;".toCharArray(), "rtimes;".toCharArray(),
+            "rtri;".toCharArray(), "rtrie;".toCharArray(),
+            "rtrif;".toCharArray(), "rtriltri;".toCharArray(),
+            "ruluhar;".toCharArray(), "rx;".toCharArray(),
+            "sacute;".toCharArray(), "sbquo;".toCharArray(),
+            "sc;".toCharArray(), "scE;".toCharArray(), "scap;".toCharArray(),
+            "scaron;".toCharArray(), "sccue;".toCharArray(),
+            "sce;".toCharArray(), "scedil;".toCharArray(),
+            "scirc;".toCharArray(), "scnE;".toCharArray(),
+            "scnap;".toCharArray(), "scnsim;".toCharArray(),
+            "scpolint;".toCharArray(), "scsim;".toCharArray(),
+            "scy;".toCharArray(), "sdot;".toCharArray(),
+            "sdotb;".toCharArray(), "sdote;".toCharArray(),
+            "seArr;".toCharArray(), "searhk;".toCharArray(),
+            "searr;".toCharArray(), "searrow;".toCharArray(),
+            "sect".toCharArray(), "sect;".toCharArray(), "semi;".toCharArray(),
+            "seswar;".toCharArray(), "setminus;".toCharArray(),
+            "setmn;".toCharArray(), "sext;".toCharArray(),
+            "sfr;".toCharArray(), "sfrown;".toCharArray(),
+            "sharp;".toCharArray(), "shchcy;".toCharArray(),
+            "shcy;".toCharArray(), "shortmid;".toCharArray(),
+            "shortparallel;".toCharArray(), "shy".toCharArray(),
+            "shy;".toCharArray(), "sigma;".toCharArray(),
+            "sigmaf;".toCharArray(), "sigmav;".toCharArray(),
+            "sim;".toCharArray(), "simdot;".toCharArray(),
+            "sime;".toCharArray(), "simeq;".toCharArray(),
+            "simg;".toCharArray(), "simgE;".toCharArray(),
+            "siml;".toCharArray(), "simlE;".toCharArray(),
+            "simne;".toCharArray(), "simplus;".toCharArray(),
+            "simrarr;".toCharArray(), "slarr;".toCharArray(),
+            "smallsetminus;".toCharArray(), "smashp;".toCharArray(),
+            "smeparsl;".toCharArray(), "smid;".toCharArray(),
+            "smile;".toCharArray(), "smt;".toCharArray(),
+            "smte;".toCharArray(), "softcy;".toCharArray(),
+            "sol;".toCharArray(), "solb;".toCharArray(),
+            "solbar;".toCharArray(), "sopf;".toCharArray(),
+            "spades;".toCharArray(), "spadesuit;".toCharArray(),
+            "spar;".toCharArray(), "sqcap;".toCharArray(),
+            "sqcup;".toCharArray(), "sqsub;".toCharArray(),
+            "sqsube;".toCharArray(), "sqsubset;".toCharArray(),
+            "sqsubseteq;".toCharArray(), "sqsup;".toCharArray(),
+            "sqsupe;".toCharArray(), "sqsupset;".toCharArray(),
+            "sqsupseteq;".toCharArray(), "squ;".toCharArray(),
+            "square;".toCharArray(), "squarf;".toCharArray(),
+            "squf;".toCharArray(), "srarr;".toCharArray(),
+            "sscr;".toCharArray(), "ssetmn;".toCharArray(),
+            "ssmile;".toCharArray(), "sstarf;".toCharArray(),
+            "star;".toCharArray(), "starf;".toCharArray(),
+            "straightepsilon;".toCharArray(), "straightphi;".toCharArray(),
+            "strns;".toCharArray(), "sub;".toCharArray(),
+            "subE;".toCharArray(), "subdot;".toCharArray(),
+            "sube;".toCharArray(), "subedot;".toCharArray(),
+            "submult;".toCharArray(), "subnE;".toCharArray(),
+            "subne;".toCharArray(), "subplus;".toCharArray(),
+            "subrarr;".toCharArray(), "subset;".toCharArray(),
+            "subseteq;".toCharArray(), "subseteqq;".toCharArray(),
+            "subsetneq;".toCharArray(), "subsetneqq;".toCharArray(),
+            "subsim;".toCharArray(), "subsub;".toCharArray(),
+            "subsup;".toCharArray(), "succ;".toCharArray(),
+            "succapprox;".toCharArray(), "succcurlyeq;".toCharArray(),
+            "succeq;".toCharArray(), "succnapprox;".toCharArray(),
+            "succneqq;".toCharArray(), "succnsim;".toCharArray(),
+            "succsim;".toCharArray(), "sum;".toCharArray(),
+            "sung;".toCharArray(), "sup1".toCharArray(), "sup1;".toCharArray(),
+            "sup2".toCharArray(), "sup2;".toCharArray(), "sup3".toCharArray(),
+            "sup3;".toCharArray(), "sup;".toCharArray(), "supE;".toCharArray(),
+            "supdot;".toCharArray(), "supdsub;".toCharArray(),
+            "supe;".toCharArray(), "supedot;".toCharArray(),
+            "suphsub;".toCharArray(), "suplarr;".toCharArray(),
+            "supmult;".toCharArray(), "supnE;".toCharArray(),
+            "supne;".toCharArray(), "supplus;".toCharArray(),
+            "supset;".toCharArray(), "supseteq;".toCharArray(),
+            "supseteqq;".toCharArray(), "supsetneq;".toCharArray(),
+            "supsetneqq;".toCharArray(), "supsim;".toCharArray(),
+            "supsub;".toCharArray(), "supsup;".toCharArray(),
+            "swArr;".toCharArray(), "swarhk;".toCharArray(),
+            "swarr;".toCharArray(), "swarrow;".toCharArray(),
+            "swnwar;".toCharArray(), "szlig".toCharArray(),
+            "szlig;".toCharArray(), "target;".toCharArray(),
+            "tau;".toCharArray(), "tbrk;".toCharArray(),
+            "tcaron;".toCharArray(), "tcedil;".toCharArray(),
+            "tcy;".toCharArray(), "tdot;".toCharArray(),
+            "telrec;".toCharArray(), "tfr;".toCharArray(),
+            "there4;".toCharArray(), "therefore;".toCharArray(),
+            "theta;".toCharArray(), "thetasym;".toCharArray(),
+            "thetav;".toCharArray(), "thickapprox;".toCharArray(),
+            "thicksim;".toCharArray(), "thinsp;".toCharArray(),
+            "thkap;".toCharArray(), "thksim;".toCharArray(),
+            "thorn".toCharArray(), "thorn;".toCharArray(),
+            "tilde;".toCharArray(), "times".toCharArray(),
+            "times;".toCharArray(), "timesb;".toCharArray(),
+            "timesbar;".toCharArray(), "timesd;".toCharArray(),
+            "tint;".toCharArray(), "toea;".toCharArray(), "top;".toCharArray(),
+            "topbot;".toCharArray(), "topcir;".toCharArray(),
+            "topf;".toCharArray(), "topfork;".toCharArray(),
+            "tosa;".toCharArray(), "tprime;".toCharArray(),
+            "trade;".toCharArray(), "triangle;".toCharArray(),
+            "triangledown;".toCharArray(), "triangleleft;".toCharArray(),
+            "trianglelefteq;".toCharArray(), "triangleq;".toCharArray(),
+            "triangleright;".toCharArray(), "trianglerighteq;".toCharArray(),
+            "tridot;".toCharArray(), "trie;".toCharArray(),
+            "triminus;".toCharArray(), "triplus;".toCharArray(),
+            "trisb;".toCharArray(), "tritime;".toCharArray(),
+            "trpezium;".toCharArray(), "tscr;".toCharArray(),
+            "tscy;".toCharArray(), "tshcy;".toCharArray(),
+            "tstrok;".toCharArray(), "twixt;".toCharArray(),
+            "twoheadleftarrow;".toCharArray(),
+            "twoheadrightarrow;".toCharArray(), "uArr;".toCharArray(),
+            "uHar;".toCharArray(), "uacute".toCharArray(),
+            "uacute;".toCharArray(), "uarr;".toCharArray(),
+            "ubrcy;".toCharArray(), "ubreve;".toCharArray(),
+            "ucirc".toCharArray(), "ucirc;".toCharArray(),
+            "ucy;".toCharArray(), "udarr;".toCharArray(),
+            "udblac;".toCharArray(), "udhar;".toCharArray(),
+            "ufisht;".toCharArray(), "ufr;".toCharArray(),
+            "ugrave".toCharArray(), "ugrave;".toCharArray(),
+            "uharl;".toCharArray(), "uharr;".toCharArray(),
+            "uhblk;".toCharArray(), "ulcorn;".toCharArray(),
+            "ulcorner;".toCharArray(), "ulcrop;".toCharArray(),
+            "ultri;".toCharArray(), "umacr;".toCharArray(),
+            "uml".toCharArray(), "uml;".toCharArray(), "uogon;".toCharArray(),
+            "uopf;".toCharArray(), "uparrow;".toCharArray(),
+            "updownarrow;".toCharArray(), "upharpoonleft;".toCharArray(),
+            "upharpoonright;".toCharArray(), "uplus;".toCharArray(),
+            "upsi;".toCharArray(), "upsih;".toCharArray(),
+            "upsilon;".toCharArray(), "upuparrows;".toCharArray(),
+            "urcorn;".toCharArray(), "urcorner;".toCharArray(),
+            "urcrop;".toCharArray(), "uring;".toCharArray(),
+            "urtri;".toCharArray(), "uscr;".toCharArray(),
+            "utdot;".toCharArray(), "utilde;".toCharArray(),
+            "utri;".toCharArray(), "utrif;".toCharArray(),
+            "uuarr;".toCharArray(), "uuml".toCharArray(),
+            "uuml;".toCharArray(), "uwangle;".toCharArray(),
+            "vArr;".toCharArray(), "vBar;".toCharArray(),
+            "vBarv;".toCharArray(), "vDash;".toCharArray(),
+            "vangrt;".toCharArray(), "varepsilon;".toCharArray(),
+            "varkappa;".toCharArray(), "varnothing;".toCharArray(),
+            "varphi;".toCharArray(), "varpi;".toCharArray(),
+            "varpropto;".toCharArray(), "varr;".toCharArray(),
+            "varrho;".toCharArray(), "varsigma;".toCharArray(),
+            "vartheta;".toCharArray(), "vartriangleleft;".toCharArray(),
+            "vartriangleright;".toCharArray(), "vcy;".toCharArray(),
+            "vdash;".toCharArray(), "vee;".toCharArray(),
+            "veebar;".toCharArray(), "veeeq;".toCharArray(),
+            "vellip;".toCharArray(), "verbar;".toCharArray(),
+            "vert;".toCharArray(), "vfr;".toCharArray(),
+            "vltri;".toCharArray(), "vopf;".toCharArray(),
+            "vprop;".toCharArray(), "vrtri;".toCharArray(),
+            "vscr;".toCharArray(), "vzigzag;".toCharArray(),
+            "wcirc;".toCharArray(), "wedbar;".toCharArray(),
+            "wedge;".toCharArray(), "wedgeq;".toCharArray(),
+            "weierp;".toCharArray(), "wfr;".toCharArray(),
+            "wopf;".toCharArray(), "wp;".toCharArray(), "wr;".toCharArray(),
+            "wreath;".toCharArray(), "wscr;".toCharArray(),
+            "xcap;".toCharArray(), "xcirc;".toCharArray(),
+            "xcup;".toCharArray(), "xdtri;".toCharArray(),
+            "xfr;".toCharArray(), "xhArr;".toCharArray(),
+            "xharr;".toCharArray(), "xi;".toCharArray(),
+            "xlArr;".toCharArray(), "xlarr;".toCharArray(),
+            "xmap;".toCharArray(), "xnis;".toCharArray(),
+            "xodot;".toCharArray(), "xopf;".toCharArray(),
+            "xoplus;".toCharArray(), "xotime;".toCharArray(),
+            "xrArr;".toCharArray(), "xrarr;".toCharArray(),
+            "xscr;".toCharArray(), "xsqcup;".toCharArray(),
+            "xuplus;".toCharArray(), "xutri;".toCharArray(),
+            "xvee;".toCharArray(), "xwedge;".toCharArray(),
+            "yacute".toCharArray(), "yacute;".toCharArray(),
+            "yacy;".toCharArray(), "ycirc;".toCharArray(),
+            "ycy;".toCharArray(), "yen".toCharArray(), "yen;".toCharArray(),
+            "yfr;".toCharArray(), "yicy;".toCharArray(), "yopf;".toCharArray(),
+            "yscr;".toCharArray(), "yucy;".toCharArray(), "yuml".toCharArray(),
+            "yuml;".toCharArray(), "zacute;".toCharArray(),
+            "zcaron;".toCharArray(), "zcy;".toCharArray(),
+            "zdot;".toCharArray(), "zeetrf;".toCharArray(),
+            "zeta;".toCharArray(), "zfr;".toCharArray(), "zhcy;".toCharArray(),
+            "zigrarr;".toCharArray(), "zopf;".toCharArray(),
+            "zscr;".toCharArray(), "zwj;".toCharArray(), "zwnj;".toCharArray(), };
+
+    static final @NoLength char[][] VALUES = { { '\u00c6' }, { '\u00c6' },
+            { '\u0026' }, { '\u0026' }, { '\u00c1' }, { '\u00c1' },
+            { '\u0102' }, { '\u00c2' }, { '\u00c2' }, { '\u0410' },
+            { '\ud835', '\udd04' }, { '\u00c0' }, { '\u00c0' }, { '\u0391' },
+            { '\u0100' }, { '\u2a53' }, { '\u0104' }, { '\ud835', '\udd38' },
+            { '\u2061' }, { '\u00c5' }, { '\u00c5' }, { '\ud835', '\udc9c' },
+            { '\u2254' }, { '\u00c3' }, { '\u00c3' }, { '\u00c4' },
+            { '\u00c4' }, { '\u2216' }, { '\u2ae7' }, { '\u2306' },
+            { '\u0411' }, { '\u2235' }, { '\u212c' }, { '\u0392' },
+            { '\ud835', '\udd05' }, { '\ud835', '\udd39' }, { '\u02d8' },
+            { '\u212c' }, { '\u224e' }, { '\u0427' }, { '\u00a9' },
+            { '\u00a9' }, { '\u0106' }, { '\u22d2' }, { '\u2145' },
+            { '\u212d' }, { '\u010c' }, { '\u00c7' }, { '\u00c7' },
+            { '\u0108' }, { '\u2230' }, { '\u010a' }, { '\u00b8' },
+            { '\u00b7' }, { '\u212d' }, { '\u03a7' }, { '\u2299' },
+            { '\u2296' }, { '\u2295' }, { '\u2297' }, { '\u2232' },
+            { '\u201d' }, { '\u2019' }, { '\u2237' }, { '\u2a74' },
+            { '\u2261' }, { '\u222f' }, { '\u222e' }, { '\u2102' },
+            { '\u2210' }, { '\u2233' }, { '\u2a2f' }, { '\ud835', '\udc9e' },
+            { '\u22d3' }, { '\u224d' }, { '\u2145' }, { '\u2911' },
+            { '\u0402' }, { '\u0405' }, { '\u040f' }, { '\u2021' },
+            { '\u21a1' }, { '\u2ae4' }, { '\u010e' }, { '\u0414' },
+            { '\u2207' }, { '\u0394' }, { '\ud835', '\udd07' }, { '\u00b4' },
+            { '\u02d9' }, { '\u02dd' }, { '\u0060' }, { '\u02dc' },
+            { '\u22c4' }, { '\u2146' }, { '\ud835', '\udd3b' }, { '\u00a8' },
+            { '\u20dc' }, { '\u2250' }, { '\u222f' }, { '\u00a8' },
+            { '\u21d3' }, { '\u21d0' }, { '\u21d4' }, { '\u2ae4' },
+            { '\u27f8' }, { '\u27fa' }, { '\u27f9' }, { '\u21d2' },
+            { '\u22a8' }, { '\u21d1' }, { '\u21d5' }, { '\u2225' },
+            { '\u2193' }, { '\u2913' }, { '\u21f5' }, { '\u0311' },
+            { '\u2950' }, { '\u295e' }, { '\u21bd' }, { '\u2956' },
+            { '\u295f' }, { '\u21c1' }, { '\u2957' }, { '\u22a4' },
+            { '\u21a7' }, { '\u21d3' }, { '\ud835', '\udc9f' }, { '\u0110' },
+            { '\u014a' }, { '\u00d0' }, { '\u00d0' }, { '\u00c9' },
+            { '\u00c9' }, { '\u011a' }, { '\u00ca' }, { '\u00ca' },
+            { '\u042d' }, { '\u0116' }, { '\ud835', '\udd08' }, { '\u00c8' },
+            { '\u00c8' }, { '\u2208' }, { '\u0112' }, { '\u25fb' },
+            { '\u25ab' }, { '\u0118' }, { '\ud835', '\udd3c' }, { '\u0395' },
+            { '\u2a75' }, { '\u2242' }, { '\u21cc' }, { '\u2130' },
+            { '\u2a73' }, { '\u0397' }, { '\u00cb' }, { '\u00cb' },
+            { '\u2203' }, { '\u2147' }, { '\u0424' }, { '\ud835', '\udd09' },
+            { '\u25fc' }, { '\u25aa' }, { '\ud835', '\udd3d' }, { '\u2200' },
+            { '\u2131' }, { '\u2131' }, { '\u0403' }, { '\u003e' },
+            { '\u003e' }, { '\u0393' }, { '\u03dc' }, { '\u011e' },
+            { '\u0122' }, { '\u011c' }, { '\u0413' }, { '\u0120' },
+            { '\ud835', '\udd0a' }, { '\u22d9' }, { '\ud835', '\udd3e' },
+            { '\u2265' }, { '\u22db' }, { '\u2267' }, { '\u2aa2' },
+            { '\u2277' }, { '\u2a7e' }, { '\u2273' }, { '\ud835', '\udca2' },
+            { '\u226b' }, { '\u042a' }, { '\u02c7' }, { '\u005e' },
+            { '\u0124' }, { '\u210c' }, { '\u210b' }, { '\u210d' },
+            { '\u2500' }, { '\u210b' }, { '\u0126' }, { '\u224e' },
+            { '\u224f' }, { '\u0415' }, { '\u0132' }, { '\u0401' },
+            { '\u00cd' }, { '\u00cd' }, { '\u00ce' }, { '\u00ce' },
+            { '\u0418' }, { '\u0130' }, { '\u2111' }, { '\u00cc' },
+            { '\u00cc' }, { '\u2111' }, { '\u012a' }, { '\u2148' },
+            { '\u21d2' }, { '\u222c' }, { '\u222b' }, { '\u22c2' },
+            { '\u2063' }, { '\u2062' }, { '\u012e' }, { '\ud835', '\udd40' },
+            { '\u0399' }, { '\u2110' }, { '\u0128' }, { '\u0406' },
+            { '\u00cf' }, { '\u00cf' }, { '\u0134' }, { '\u0419' },
+            { '\ud835', '\udd0d' }, { '\ud835', '\udd41' },
+            { '\ud835', '\udca5' }, { '\u0408' }, { '\u0404' }, { '\u0425' },
+            { '\u040c' }, { '\u039a' }, { '\u0136' }, { '\u041a' },
+            { '\ud835', '\udd0e' }, { '\ud835', '\udd42' },
+            { '\ud835', '\udca6' }, { '\u0409' }, { '\u003c' }, { '\u003c' },
+            { '\u0139' }, { '\u039b' }, { '\u27ea' }, { '\u2112' },
+            { '\u219e' }, { '\u013d' }, { '\u013b' }, { '\u041b' },
+            { '\u27e8' }, { '\u2190' }, { '\u21e4' }, { '\u21c6' },
+            { '\u2308' }, { '\u27e6' }, { '\u2961' }, { '\u21c3' },
+            { '\u2959' }, { '\u230a' }, { '\u2194' }, { '\u294e' },
+            { '\u22a3' }, { '\u21a4' }, { '\u295a' }, { '\u22b2' },
+            { '\u29cf' }, { '\u22b4' }, { '\u2951' }, { '\u2960' },
+            { '\u21bf' }, { '\u2958' }, { '\u21bc' }, { '\u2952' },
+            { '\u21d0' }, { '\u21d4' }, { '\u22da' }, { '\u2266' },
+            { '\u2276' }, { '\u2aa1' }, { '\u2a7d' }, { '\u2272' },
+            { '\ud835', '\udd0f' }, { '\u22d8' }, { '\u21da' }, { '\u013f' },
+            { '\u27f5' }, { '\u27f7' }, { '\u27f6' }, { '\u27f8' },
+            { '\u27fa' }, { '\u27f9' }, { '\ud835', '\udd43' }, { '\u2199' },
+            { '\u2198' }, { '\u2112' }, { '\u21b0' }, { '\u0141' },
+            { '\u226a' }, { '\u2905' }, { '\u041c' }, { '\u205f' },
+            { '\u2133' }, { '\ud835', '\udd10' }, { '\u2213' },
+            { '\ud835', '\udd44' }, { '\u2133' }, { '\u039c' }, { '\u040a' },
+            { '\u0143' }, { '\u0147' }, { '\u0145' }, { '\u041d' },
+            { '\u200b' }, { '\u200b' }, { '\u200b' }, { '\u200b' },
+            { '\u226b' }, { '\u226a' }, { '\n' }, { '\ud835', '\udd11' },
+            { '\u2060' }, { '\u00a0' }, { '\u2115' }, { '\u2aec' },
+            { '\u2262' }, { '\u226d' }, { '\u2226' }, { '\u2209' },
+            { '\u2260' }, { '\u2204' }, { '\u226f' }, { '\u2271' },
+            { '\u2279' }, { '\u2275' }, { '\u22ea' }, { '\u22ec' },
+            { '\u226e' }, { '\u2270' }, { '\u2278' }, { '\u2274' },
+            { '\u2280' }, { '\u22e0' }, { '\u220c' }, { '\u22eb' },
+            { '\u22ed' }, { '\u22e2' }, { '\u22e3' }, { '\u2288' },
+            { '\u2281' }, { '\u22e1' }, { '\u2289' }, { '\u2241' },
+            { '\u2244' }, { '\u2247' }, { '\u2249' }, { '\u2224' },
+            { '\ud835', '\udca9' }, { '\u00d1' }, { '\u00d1' }, { '\u039d' },
+            { '\u0152' }, { '\u00d3' }, { '\u00d3' }, { '\u00d4' },
+            { '\u00d4' }, { '\u041e' }, { '\u0150' }, { '\ud835', '\udd12' },
+            { '\u00d2' }, { '\u00d2' }, { '\u014c' }, { '\u03a9' },
+            { '\u039f' }, { '\ud835', '\udd46' }, { '\u201c' }, { '\u2018' },
+            { '\u2a54' }, { '\ud835', '\udcaa' }, { '\u00d8' }, { '\u00d8' },
+            { '\u00d5' }, { '\u00d5' }, { '\u2a37' }, { '\u00d6' },
+            { '\u00d6' }, { '\u00af' }, { '\u23de' }, { '\u23b4' },
+            { '\u23dc' }, { '\u2202' }, { '\u041f' }, { '\ud835', '\udd13' },
+            { '\u03a6' }, { '\u03a0' }, { '\u00b1' }, { '\u210c' },
+            { '\u2119' }, { '\u2abb' }, { '\u227a' }, { '\u2aaf' },
+            { '\u227c' }, { '\u227e' }, { '\u2033' }, { '\u220f' },
+            { '\u2237' }, { '\u221d' }, { '\ud835', '\udcab' }, { '\u03a8' },
+            { '\u0022' }, { '\u0022' }, { '\ud835', '\udd14' }, { '\u211a' },
+            { '\ud835', '\udcac' }, { '\u2910' }, { '\u00ae' }, { '\u00ae' },
+            { '\u0154' }, { '\u27eb' }, { '\u21a0' }, { '\u2916' },
+            { '\u0158' }, { '\u0156' }, { '\u0420' }, { '\u211c' },
+            { '\u220b' }, { '\u21cb' }, { '\u296f' }, { '\u211c' },
+            { '\u03a1' }, { '\u27e9' }, { '\u2192' }, { '\u21e5' },
+            { '\u21c4' }, { '\u2309' }, { '\u27e7' }, { '\u295d' },
+            { '\u21c2' }, { '\u2955' }, { '\u230b' }, { '\u22a2' },
+            { '\u21a6' }, { '\u295b' }, { '\u22b3' }, { '\u29d0' },
+            { '\u22b5' }, { '\u294f' }, { '\u295c' }, { '\u21be' },
+            { '\u2954' }, { '\u21c0' }, { '\u2953' }, { '\u21d2' },
+            { '\u211d' }, { '\u2970' }, { '\u21db' }, { '\u211b' },
+            { '\u21b1' }, { '\u29f4' }, { '\u0429' }, { '\u0428' },
+            { '\u042c' }, { '\u015a' }, { '\u2abc' }, { '\u0160' },
+            { '\u015e' }, { '\u015c' }, { '\u0421' }, { '\ud835', '\udd16' },
+            { '\u2193' }, { '\u2190' }, { '\u2192' }, { '\u2191' },
+            { '\u03a3' }, { '\u2218' }, { '\ud835', '\udd4a' }, { '\u221a' },
+            { '\u25a1' }, { '\u2293' }, { '\u228f' }, { '\u2291' },
+            { '\u2290' }, { '\u2292' }, { '\u2294' }, { '\ud835', '\udcae' },
+            { '\u22c6' }, { '\u22d0' }, { '\u22d0' }, { '\u2286' },
+            { '\u227b' }, { '\u2ab0' }, { '\u227d' }, { '\u227f' },
+            { '\u220b' }, { '\u2211' }, { '\u22d1' }, { '\u2283' },
+            { '\u2287' }, { '\u22d1' }, { '\u00de' }, { '\u00de' },
+            { '\u2122' }, { '\u040b' }, { '\u0426' }, { '\u0009' },
+            { '\u03a4' }, { '\u0164' }, { '\u0162' }, { '\u0422' },
+            { '\ud835', '\udd17' }, { '\u2234' }, { '\u0398' }, { '\u2009' },
+            { '\u223c' }, { '\u2243' }, { '\u2245' }, { '\u2248' },
+            { '\ud835', '\udd4b' }, { '\u20db' }, { '\ud835', '\udcaf' },
+            { '\u0166' }, { '\u00da' }, { '\u00da' }, { '\u219f' },
+            { '\u2949' }, { '\u040e' }, { '\u016c' }, { '\u00db' },
+            { '\u00db' }, { '\u0423' }, { '\u0170' }, { '\ud835', '\udd18' },
+            { '\u00d9' }, { '\u00d9' }, { '\u016a' }, { '\u0332' },
+            { '\u23df' }, { '\u23b5' }, { '\u23dd' }, { '\u22c3' },
+            { '\u228e' }, { '\u0172' }, { '\ud835', '\udd4c' }, { '\u2191' },
+            { '\u2912' }, { '\u21c5' }, { '\u2195' }, { '\u296e' },
+            { '\u22a5' }, { '\u21a5' }, { '\u21d1' }, { '\u21d5' },
+            { '\u2196' }, { '\u2197' }, { '\u03d2' }, { '\u03a5' },
+            { '\u016e' }, { '\ud835', '\udcb0' }, { '\u0168' }, { '\u00dc' },
+            { '\u00dc' }, { '\u22ab' }, { '\u2aeb' }, { '\u0412' },
+            { '\u22a9' }, { '\u2ae6' }, { '\u22c1' }, { '\u2016' },
+            { '\u2016' }, { '\u2223' }, { '\u007c' }, { '\u2758' },
+            { '\u2240' }, { '\u200a' }, { '\ud835', '\udd19' },
+            { '\ud835', '\udd4d' }, { '\ud835', '\udcb1' }, { '\u22aa' },
+            { '\u0174' }, { '\u22c0' }, { '\ud835', '\udd1a' },
+            { '\ud835', '\udd4e' }, { '\ud835', '\udcb2' },
+            { '\ud835', '\udd1b' }, { '\u039e' }, { '\ud835', '\udd4f' },
+            { '\ud835', '\udcb3' }, { '\u042f' }, { '\u0407' }, { '\u042e' },
+            { '\u00dd' }, { '\u00dd' }, { '\u0176' }, { '\u042b' },
+            { '\ud835', '\udd1c' }, { '\ud835', '\udd50' },
+            { '\ud835', '\udcb4' }, { '\u0178' }, { '\u0416' }, { '\u0179' },
+            { '\u017d' }, { '\u0417' }, { '\u017b' }, { '\u200b' },
+            { '\u0396' }, { '\u2128' }, { '\u2124' }, { '\ud835', '\udcb5' },
+            { '\u00e1' }, { '\u00e1' }, { '\u0103' }, { '\u223e' },
+            { '\u223f' }, { '\u00e2' }, { '\u00e2' }, { '\u00b4' },
+            { '\u00b4' }, { '\u0430' }, { '\u00e6' }, { '\u00e6' },
+            { '\u2061' }, { '\ud835', '\udd1e' }, { '\u00e0' }, { '\u00e0' },
+            { '\u2135' }, { '\u2135' }, { '\u03b1' }, { '\u0101' },
+            { '\u2a3f' }, { '\u0026' }, { '\u0026' }, { '\u2227' },
+            { '\u2a55' }, { '\u2a5c' }, { '\u2a58' }, { '\u2a5a' },
+            { '\u2220' }, { '\u29a4' }, { '\u2220' }, { '\u2221' },
+            { '\u29a8' }, { '\u29a9' }, { '\u29aa' }, { '\u29ab' },
+            { '\u29ac' }, { '\u29ad' }, { '\u29ae' }, { '\u29af' },
+            { '\u221f' }, { '\u22be' }, { '\u299d' }, { '\u2222' },
+            { '\u212b' }, { '\u237c' }, { '\u0105' }, { '\ud835', '\udd52' },
+            { '\u2248' }, { '\u2a70' }, { '\u2a6f' }, { '\u224a' },
+            { '\u224b' }, { '\'' }, { '\u2248' }, { '\u224a' }, { '\u00e5' },
+            { '\u00e5' }, { '\ud835', '\udcb6' }, { '\u002a' }, { '\u2248' },
+            { '\u224d' }, { '\u00e3' }, { '\u00e3' }, { '\u00e4' },
+            { '\u00e4' }, { '\u2233' }, { '\u2a11' }, { '\u2aed' },
+            { '\u224c' }, { '\u03f6' }, { '\u2035' }, { '\u223d' },
+            { '\u22cd' }, { '\u22bd' }, { '\u2305' }, { '\u2305' },
+            { '\u23b5' }, { '\u23b6' }, { '\u224c' }, { '\u0431' },
+            { '\u201e' }, { '\u2235' }, { '\u2235' }, { '\u29b0' },
+            { '\u03f6' }, { '\u212c' }, { '\u03b2' }, { '\u2136' },
+            { '\u226c' }, { '\ud835', '\udd1f' }, { '\u22c2' }, { '\u25ef' },
+            { '\u22c3' }, { '\u2a00' }, { '\u2a01' }, { '\u2a02' },
+            { '\u2a06' }, { '\u2605' }, { '\u25bd' }, { '\u25b3' },
+            { '\u2a04' }, { '\u22c1' }, { '\u22c0' }, { '\u290d' },
+            { '\u29eb' }, { '\u25aa' }, { '\u25b4' }, { '\u25be' },
+            { '\u25c2' }, { '\u25b8' }, { '\u2423' }, { '\u2592' },
+            { '\u2591' }, { '\u2593' }, { '\u2588' }, { '\u2310' },
+            { '\ud835', '\udd53' }, { '\u22a5' }, { '\u22a5' }, { '\u22c8' },
+            { '\u2557' }, { '\u2554' }, { '\u2556' }, { '\u2553' },
+            { '\u2550' }, { '\u2566' }, { '\u2569' }, { '\u2564' },
+            { '\u2567' }, { '\u255d' }, { '\u255a' }, { '\u255c' },
+            { '\u2559' }, { '\u2551' }, { '\u256c' }, { '\u2563' },
+            { '\u2560' }, { '\u256b' }, { '\u2562' }, { '\u255f' },
+            { '\u29c9' }, { '\u2555' }, { '\u2552' }, { '\u2510' },
+            { '\u250c' }, { '\u2500' }, { '\u2565' }, { '\u2568' },
+            { '\u252c' }, { '\u2534' }, { '\u229f' }, { '\u229e' },
+            { '\u22a0' }, { '\u255b' }, { '\u2558' }, { '\u2518' },
+            { '\u2514' }, { '\u2502' }, { '\u256a' }, { '\u2561' },
+            { '\u255e' }, { '\u253c' }, { '\u2524' }, { '\u251c' },
+            { '\u2035' }, { '\u02d8' }, { '\u00a6' }, { '\u00a6' },
+            { '\ud835', '\udcb7' }, { '\u204f' }, { '\u223d' }, { '\u22cd' },
+            { '\\' }, { '\u29c5' }, { '\u2022' }, { '\u2022' }, { '\u224e' },
+            { '\u2aae' }, { '\u224f' }, { '\u224f' }, { '\u0107' },
+            { '\u2229' }, { '\u2a44' }, { '\u2a49' }, { '\u2a4b' },
+            { '\u2a47' }, { '\u2a40' }, { '\u2041' }, { '\u02c7' },
+            { '\u2a4d' }, { '\u010d' }, { '\u00e7' }, { '\u00e7' },
+            { '\u0109' }, { '\u2a4c' }, { '\u2a50' }, { '\u010b' },
+            { '\u00b8' }, { '\u00b8' }, { '\u29b2' }, { '\u00a2' },
+            { '\u00a2' }, { '\u00b7' }, { '\ud835', '\udd20' }, { '\u0447' },
+            { '\u2713' }, { '\u2713' }, { '\u03c7' }, { '\u25cb' },
+            { '\u29c3' }, { '\u02c6' }, { '\u2257' }, { '\u21ba' },
+            { '\u21bb' }, { '\u00ae' }, { '\u24c8' }, { '\u229b' },
+            { '\u229a' }, { '\u229d' }, { '\u2257' }, { '\u2a10' },
+            { '\u2aef' }, { '\u29c2' }, { '\u2663' }, { '\u2663' },
+            { '\u003a' }, { '\u2254' }, { '\u2254' }, { '\u002c' },
+            { '\u0040' }, { '\u2201' }, { '\u2218' }, { '\u2201' },
+            { '\u2102' }, { '\u2245' }, { '\u2a6d' }, { '\u222e' },
+            { '\ud835', '\udd54' }, { '\u2210' }, { '\u00a9' }, { '\u00a9' },
+            { '\u2117' }, { '\u21b5' }, { '\u2717' }, { '\ud835', '\udcb8' },
+            { '\u2acf' }, { '\u2ad1' }, { '\u2ad0' }, { '\u2ad2' },
+            { '\u22ef' }, { '\u2938' }, { '\u2935' }, { '\u22de' },
+            { '\u22df' }, { '\u21b6' }, { '\u293d' }, { '\u222a' },
+            { '\u2a48' }, { '\u2a46' }, { '\u2a4a' }, { '\u228d' },
+            { '\u2a45' }, { '\u21b7' }, { '\u293c' }, { '\u22de' },
+            { '\u22df' }, { '\u22ce' }, { '\u22cf' }, { '\u00a4' },
+            { '\u00a4' }, { '\u21b6' }, { '\u21b7' }, { '\u22ce' },
+            { '\u22cf' }, { '\u2232' }, { '\u2231' }, { '\u232d' },
+            { '\u21d3' }, { '\u2965' }, { '\u2020' }, { '\u2138' },
+            { '\u2193' }, { '\u2010' }, { '\u22a3' }, { '\u290f' },
+            { '\u02dd' }, { '\u010f' }, { '\u0434' }, { '\u2146' },
+            { '\u2021' }, { '\u21ca' }, { '\u2a77' }, { '\u00b0' },
+            { '\u00b0' }, { '\u03b4' }, { '\u29b1' }, { '\u297f' },
+            { '\ud835', '\udd21' }, { '\u21c3' }, { '\u21c2' }, { '\u22c4' },
+            { '\u22c4' }, { '\u2666' }, { '\u2666' }, { '\u00a8' },
+            { '\u03dd' }, { '\u22f2' }, { '\u00f7' }, { '\u00f7' },
+            { '\u00f7' }, { '\u22c7' }, { '\u22c7' }, { '\u0452' },
+            { '\u231e' }, { '\u230d' }, { '\u0024' }, { '\ud835', '\udd55' },
+            { '\u02d9' }, { '\u2250' }, { '\u2251' }, { '\u2238' },
+            { '\u2214' }, { '\u22a1' }, { '\u2306' }, { '\u2193' },
+            { '\u21ca' }, { '\u21c3' }, { '\u21c2' }, { '\u2910' },
+            { '\u231f' }, { '\u230c' }, { '\ud835', '\udcb9' }, { '\u0455' },
+            { '\u29f6' }, { '\u0111' }, { '\u22f1' }, { '\u25bf' },
+            { '\u25be' }, { '\u21f5' }, { '\u296f' }, { '\u29a6' },
+            { '\u045f' }, { '\u27ff' }, { '\u2a77' }, { '\u2251' },
+            { '\u00e9' }, { '\u00e9' }, { '\u2a6e' }, { '\u011b' },
+            { '\u2256' }, { '\u00ea' }, { '\u00ea' }, { '\u2255' },
+            { '\u044d' }, { '\u0117' }, { '\u2147' }, { '\u2252' },
+            { '\ud835', '\udd22' }, { '\u2a9a' }, { '\u00e8' }, { '\u00e8' },
+            { '\u2a96' }, { '\u2a98' }, { '\u2a99' }, { '\u23e7' },
+            { '\u2113' }, { '\u2a95' }, { '\u2a97' }, { '\u0113' },
+            { '\u2205' }, { '\u2205' }, { '\u2205' }, { '\u2004' },
+            { '\u2005' }, { '\u2003' }, { '\u014b' }, { '\u2002' },
+            { '\u0119' }, { '\ud835', '\udd56' }, { '\u22d5' }, { '\u29e3' },
+            { '\u2a71' }, { '\u03f5' }, { '\u03b5' }, { '\u03b5' },
+            { '\u2256' }, { '\u2255' }, { '\u2242' }, { '\u2a96' },
+            { '\u2a95' }, { '\u003d' }, { '\u225f' }, { '\u2261' },
+            { '\u2a78' }, { '\u29e5' }, { '\u2253' }, { '\u2971' },
+            { '\u212f' }, { '\u2250' }, { '\u2242' }, { '\u03b7' },
+            { '\u00f0' }, { '\u00f0' }, { '\u00eb' }, { '\u00eb' },
+            { '\u20ac' }, { '\u0021' }, { '\u2203' }, { '\u2130' },
+            { '\u2147' }, { '\u2252' }, { '\u0444' }, { '\u2640' },
+            { '\ufb03' }, { '\ufb00' }, { '\ufb04' }, { '\ud835', '\udd23' },
+            { '\ufb01' }, { '\u266d' }, { '\ufb02' }, { '\u25b1' },
+            { '\u0192' }, { '\ud835', '\udd57' }, { '\u2200' }, { '\u22d4' },
+            { '\u2ad9' }, { '\u2a0d' }, { '\u00bd' }, { '\u00bd' },
+            { '\u2153' }, { '\u00bc' }, { '\u00bc' }, { '\u2155' },
+            { '\u2159' }, { '\u215b' }, { '\u2154' }, { '\u2156' },
+            { '\u00be' }, { '\u00be' }, { '\u2157' }, { '\u215c' },
+            { '\u2158' }, { '\u215a' }, { '\u215d' }, { '\u215e' },
+            { '\u2044' }, { '\u2322' }, { '\ud835', '\udcbb' }, { '\u2267' },
+            { '\u2a8c' }, { '\u01f5' }, { '\u03b3' }, { '\u03dd' },
+            { '\u2a86' }, { '\u011f' }, { '\u011d' }, { '\u0433' },
+            { '\u0121' }, { '\u2265' }, { '\u22db' }, { '\u2265' },
+            { '\u2267' }, { '\u2a7e' }, { '\u2a7e' }, { '\u2aa9' },
+            { '\u2a80' }, { '\u2a82' }, { '\u2a84' }, { '\u2a94' },
+            { '\ud835', '\udd24' }, { '\u226b' }, { '\u22d9' }, { '\u2137' },
+            { '\u0453' }, { '\u2277' }, { '\u2a92' }, { '\u2aa5' },
+            { '\u2aa4' }, { '\u2269' }, { '\u2a8a' }, { '\u2a8a' },
+            { '\u2a88' }, { '\u2a88' }, { '\u2269' }, { '\u22e7' },
+            { '\ud835', '\udd58' }, { '\u0060' }, { '\u210a' }, { '\u2273' },
+            { '\u2a8e' }, { '\u2a90' }, { '\u003e' }, { '\u003e' },
+            { '\u2aa7' }, { '\u2a7a' }, { '\u22d7' }, { '\u2995' },
+            { '\u2a7c' }, { '\u2a86' }, { '\u2978' }, { '\u22d7' },
+            { '\u22db' }, { '\u2a8c' }, { '\u2277' }, { '\u2273' },
+            { '\u21d4' }, { '\u200a' }, { '\u00bd' }, { '\u210b' },
+            { '\u044a' }, { '\u2194' }, { '\u2948' }, { '\u21ad' },
+            { '\u210f' }, { '\u0125' }, { '\u2665' }, { '\u2665' },
+            { '\u2026' }, { '\u22b9' }, { '\ud835', '\udd25' }, { '\u2925' },
+            { '\u2926' }, { '\u21ff' }, { '\u223b' }, { '\u21a9' },
+            { '\u21aa' }, { '\ud835', '\udd59' }, { '\u2015' },
+            { '\ud835', '\udcbd' }, { '\u210f' }, { '\u0127' }, { '\u2043' },
+            { '\u2010' }, { '\u00ed' }, { '\u00ed' }, { '\u2063' },
+            { '\u00ee' }, { '\u00ee' }, { '\u0438' }, { '\u0435' },
+            { '\u00a1' }, { '\u00a1' }, { '\u21d4' }, { '\ud835', '\udd26' },
+            { '\u00ec' }, { '\u00ec' }, { '\u2148' }, { '\u2a0c' },
+            { '\u222d' }, { '\u29dc' }, { '\u2129' }, { '\u0133' },
+            { '\u012b' }, { '\u2111' }, { '\u2110' }, { '\u2111' },
+            { '\u0131' }, { '\u22b7' }, { '\u01b5' }, { '\u2208' },
+            { '\u2105' }, { '\u221e' }, { '\u29dd' }, { '\u0131' },
+            { '\u222b' }, { '\u22ba' }, { '\u2124' }, { '\u22ba' },
+            { '\u2a17' }, { '\u2a3c' }, { '\u0451' }, { '\u012f' },
+            { '\ud835', '\udd5a' }, { '\u03b9' }, { '\u2a3c' }, { '\u00bf' },
+            { '\u00bf' }, { '\ud835', '\udcbe' }, { '\u2208' }, { '\u22f9' },
+            { '\u22f5' }, { '\u22f4' }, { '\u22f3' }, { '\u2208' },
+            { '\u2062' }, { '\u0129' }, { '\u0456' }, { '\u00ef' },
+            { '\u00ef' }, { '\u0135' }, { '\u0439' }, { '\ud835', '\udd27' },
+            { '\u0237' }, { '\ud835', '\udd5b' }, { '\ud835', '\udcbf' },
+            { '\u0458' }, { '\u0454' }, { '\u03ba' }, { '\u03f0' },
+            { '\u0137' }, { '\u043a' }, { '\ud835', '\udd28' }, { '\u0138' },
+            { '\u0445' }, { '\u045c' }, { '\ud835', '\udd5c' },
+            { '\ud835', '\udcc0' }, { '\u21da' }, { '\u21d0' }, { '\u291b' },
+            { '\u290e' }, { '\u2266' }, { '\u2a8b' }, { '\u2962' },
+            { '\u013a' }, { '\u29b4' }, { '\u2112' }, { '\u03bb' },
+            { '\u27e8' }, { '\u2991' }, { '\u27e8' }, { '\u2a85' },
+            { '\u00ab' }, { '\u00ab' }, { '\u2190' }, { '\u21e4' },
+            { '\u291f' }, { '\u291d' }, { '\u21a9' }, { '\u21ab' },
+            { '\u2939' }, { '\u2973' }, { '\u21a2' }, { '\u2aab' },
+            { '\u2919' }, { '\u2aad' }, { '\u290c' }, { '\u2772' },
+            { '\u007b' }, { '\u005b' }, { '\u298b' }, { '\u298f' },
+            { '\u298d' }, { '\u013e' }, { '\u013c' }, { '\u2308' },
+            { '\u007b' }, { '\u043b' }, { '\u2936' }, { '\u201c' },
+            { '\u201e' }, { '\u2967' }, { '\u294b' }, { '\u21b2' },
+            { '\u2264' }, { '\u2190' }, { '\u21a2' }, { '\u21bd' },
+            { '\u21bc' }, { '\u21c7' }, { '\u2194' }, { '\u21c6' },
+            { '\u21cb' }, { '\u21ad' }, { '\u22cb' }, { '\u22da' },
+            { '\u2264' }, { '\u2266' }, { '\u2a7d' }, { '\u2a7d' },
+            { '\u2aa8' }, { '\u2a7f' }, { '\u2a81' }, { '\u2a83' },
+            { '\u2a93' }, { '\u2a85' }, { '\u22d6' }, { '\u22da' },
+            { '\u2a8b' }, { '\u2276' }, { '\u2272' }, { '\u297c' },
+            { '\u230a' }, { '\ud835', '\udd29' }, { '\u2276' }, { '\u2a91' },
+            { '\u21bd' }, { '\u21bc' }, { '\u296a' }, { '\u2584' },
+            { '\u0459' }, { '\u226a' }, { '\u21c7' }, { '\u231e' },
+            { '\u296b' }, { '\u25fa' }, { '\u0140' }, { '\u23b0' },
+            { '\u23b0' }, { '\u2268' }, { '\u2a89' }, { '\u2a89' },
+            { '\u2a87' }, { '\u2a87' }, { '\u2268' }, { '\u22e6' },
+            { '\u27ec' }, { '\u21fd' }, { '\u27e6' }, { '\u27f5' },
+            { '\u27f7' }, { '\u27fc' }, { '\u27f6' }, { '\u21ab' },
+            { '\u21ac' }, { '\u2985' }, { '\ud835', '\udd5d' }, { '\u2a2d' },
+            { '\u2a34' }, { '\u2217' }, { '\u005f' }, { '\u25ca' },
+            { '\u25ca' }, { '\u29eb' }, { '\u0028' }, { '\u2993' },
+            { '\u21c6' }, { '\u231f' }, { '\u21cb' }, { '\u296d' },
+            { '\u200e' }, { '\u22bf' }, { '\u2039' }, { '\ud835', '\udcc1' },
+            { '\u21b0' }, { '\u2272' }, { '\u2a8d' }, { '\u2a8f' },
+            { '\u005b' }, { '\u2018' }, { '\u201a' }, { '\u0142' },
+            { '\u003c' }, { '\u003c' }, { '\u2aa6' }, { '\u2a79' },
+            { '\u22d6' }, { '\u22cb' }, { '\u22c9' }, { '\u2976' },
+            { '\u2a7b' }, { '\u2996' }, { '\u25c3' }, { '\u22b4' },
+            { '\u25c2' }, { '\u294a' }, { '\u2966' }, { '\u223a' },
+            { '\u00af' }, { '\u00af' }, { '\u2642' }, { '\u2720' },
+            { '\u2720' }, { '\u21a6' }, { '\u21a6' }, { '\u21a7' },
+            { '\u21a4' }, { '\u21a5' }, { '\u25ae' }, { '\u2a29' },
+            { '\u043c' }, { '\u2014' }, { '\u2221' }, { '\ud835', '\udd2a' },
+            { '\u2127' }, { '\u00b5' }, { '\u00b5' }, { '\u2223' },
+            { '\u002a' }, { '\u2af0' }, { '\u00b7' }, { '\u00b7' },
+            { '\u2212' }, { '\u229f' }, { '\u2238' }, { '\u2a2a' },
+            { '\u2adb' }, { '\u2026' }, { '\u2213' }, { '\u22a7' },
+            { '\ud835', '\udd5e' }, { '\u2213' }, { '\ud835', '\udcc2' },
+            { '\u223e' }, { '\u03bc' }, { '\u22b8' }, { '\u22b8' },
+            { '\u21cd' }, { '\u21ce' }, { '\u21cf' }, { '\u22af' },
+            { '\u22ae' }, { '\u2207' }, { '\u0144' }, { '\u2249' },
+            { '\u0149' }, { '\u2249' }, { '\u266e' }, { '\u266e' },
+            { '\u2115' }, { '\u00a0' }, { '\u00a0' }, { '\u2a43' },
+            { '\u0148' }, { '\u0146' }, { '\u2247' }, { '\u2a42' },
+            { '\u043d' }, { '\u2013' }, { '\u2260' }, { '\u21d7' },
+            { '\u2924' }, { '\u2197' }, { '\u2197' }, { '\u2262' },
+            { '\u2928' }, { '\u2204' }, { '\u2204' }, { '\ud835', '\udd2b' },
+            { '\u2271' }, { '\u2271' }, { '\u2275' }, { '\u226f' },
+            { '\u226f' }, { '\u21ce' }, { '\u21ae' }, { '\u2af2' },
+            { '\u220b' }, { '\u22fc' }, { '\u22fa' }, { '\u220b' },
+            { '\u045a' }, { '\u21cd' }, { '\u219a' }, { '\u2025' },
+            { '\u2270' }, { '\u219a' }, { '\u21ae' }, { '\u2270' },
+            { '\u226e' }, { '\u2274' }, { '\u226e' }, { '\u22ea' },
+            { '\u22ec' }, { '\u2224' }, { '\ud835', '\udd5f' }, { '\u00ac' },
+            { '\u00ac' }, { '\u2209' }, { '\u2209' }, { '\u22f7' },
+            { '\u22f6' }, { '\u220c' }, { '\u220c' }, { '\u22fe' },
+            { '\u22fd' }, { '\u2226' }, { '\u2226' }, { '\u2a14' },
+            { '\u2280' }, { '\u22e0' }, { '\u2280' }, { '\u21cf' },
+            { '\u219b' }, { '\u219b' }, { '\u22eb' }, { '\u22ed' },
+            { '\u2281' }, { '\u22e1' }, { '\ud835', '\udcc3' }, { '\u2224' },
+            { '\u2226' }, { '\u2241' }, { '\u2244' }, { '\u2244' },
+            { '\u2224' }, { '\u2226' }, { '\u22e2' }, { '\u22e3' },
+            { '\u2284' }, { '\u2288' }, { '\u2288' }, { '\u2281' },
+            { '\u2285' }, { '\u2289' }, { '\u2289' }, { '\u2279' },
+            { '\u00f1' }, { '\u00f1' }, { '\u2278' }, { '\u22ea' },
+            { '\u22ec' }, { '\u22eb' }, { '\u22ed' }, { '\u03bd' },
+            { '\u0023' }, { '\u2116' }, { '\u2007' }, { '\u22ad' },
+            { '\u2904' }, { '\u22ac' }, { '\u29de' }, { '\u2902' },
+            { '\u2903' }, { '\u21d6' }, { '\u2923' }, { '\u2196' },
+            { '\u2196' }, { '\u2927' }, { '\u24c8' }, { '\u00f3' },
+            { '\u00f3' }, { '\u229b' }, { '\u229a' }, { '\u00f4' },
+            { '\u00f4' }, { '\u043e' }, { '\u229d' }, { '\u0151' },
+            { '\u2a38' }, { '\u2299' }, { '\u29bc' }, { '\u0153' },
+            { '\u29bf' }, { '\ud835', '\udd2c' }, { '\u02db' }, { '\u00f2' },
+            { '\u00f2' }, { '\u29c1' }, { '\u29b5' }, { '\u2126' },
+            { '\u222e' }, { '\u21ba' }, { '\u29be' }, { '\u29bb' },
+            { '\u203e' }, { '\u29c0' }, { '\u014d' }, { '\u03c9' },
+            { '\u03bf' }, { '\u29b6' }, { '\u2296' }, { '\ud835', '\udd60' },
+            { '\u29b7' }, { '\u29b9' }, { '\u2295' }, { '\u2228' },
+            { '\u21bb' }, { '\u2a5d' }, { '\u2134' }, { '\u2134' },
+            { '\u00aa' }, { '\u00aa' }, { '\u00ba' }, { '\u00ba' },
+            { '\u22b6' }, { '\u2a56' }, { '\u2a57' }, { '\u2a5b' },
+            { '\u2134' }, { '\u00f8' }, { '\u00f8' }, { '\u2298' },
+            { '\u00f5' }, { '\u00f5' }, { '\u2297' }, { '\u2a36' },
+            { '\u00f6' }, { '\u00f6' }, { '\u233d' }, { '\u2225' },
+            { '\u00b6' }, { '\u00b6' }, { '\u2225' }, { '\u2af3' },
+            { '\u2afd' }, { '\u2202' }, { '\u043f' }, { '\u0025' },
+            { '\u002e' }, { '\u2030' }, { '\u22a5' }, { '\u2031' },
+            { '\ud835', '\udd2d' }, { '\u03c6' }, { '\u03c6' }, { '\u2133' },
+            { '\u260e' }, { '\u03c0' }, { '\u22d4' }, { '\u03d6' },
+            { '\u210f' }, { '\u210e' }, { '\u210f' }, { '\u002b' },
+            { '\u2a23' }, { '\u229e' }, { '\u2a22' }, { '\u2214' },
+            { '\u2a25' }, { '\u2a72' }, { '\u00b1' }, { '\u00b1' },
+            { '\u2a26' }, { '\u2a27' }, { '\u00b1' }, { '\u2a15' },
+            { '\ud835', '\udd61' }, { '\u00a3' }, { '\u00a3' }, { '\u227a' },
+            { '\u2ab3' }, { '\u2ab7' }, { '\u227c' }, { '\u2aaf' },
+            { '\u227a' }, { '\u2ab7' }, { '\u227c' }, { '\u2aaf' },
+            { '\u2ab9' }, { '\u2ab5' }, { '\u22e8' }, { '\u227e' },
+            { '\u2032' }, { '\u2119' }, { '\u2ab5' }, { '\u2ab9' },
+            { '\u22e8' }, { '\u220f' }, { '\u232e' }, { '\u2312' },
+            { '\u2313' }, { '\u221d' }, { '\u221d' }, { '\u227e' },
+            { '\u22b0' }, { '\ud835', '\udcc5' }, { '\u03c8' }, { '\u2008' },
+            { '\ud835', '\udd2e' }, { '\u2a0c' }, { '\ud835', '\udd62' },
+            { '\u2057' }, { '\ud835', '\udcc6' }, { '\u210d' }, { '\u2a16' },
+            { '\u003f' }, { '\u225f' }, { '\u0022' }, { '\u0022' },
+            { '\u21db' }, { '\u21d2' }, { '\u291c' }, { '\u290f' },
+            { '\u2964' }, { '\u29da' }, { '\u0155' }, { '\u221a' },
+            { '\u29b3' }, { '\u27e9' }, { '\u2992' }, { '\u29a5' },
+            { '\u27e9' }, { '\u00bb' }, { '\u00bb' }, { '\u2192' },
+            { '\u2975' }, { '\u21e5' }, { '\u2920' }, { '\u2933' },
+            { '\u291e' }, { '\u21aa' }, { '\u21ac' }, { '\u2945' },
+            { '\u2974' }, { '\u21a3' }, { '\u219d' }, { '\u291a' },
+            { '\u2236' }, { '\u211a' }, { '\u290d' }, { '\u2773' },
+            { '\u007d' }, { '\u005d' }, { '\u298c' }, { '\u298e' },
+            { '\u2990' }, { '\u0159' }, { '\u0157' }, { '\u2309' },
+            { '\u007d' }, { '\u0440' }, { '\u2937' }, { '\u2969' },
+            { '\u201d' }, { '\u201d' }, { '\u21b3' }, { '\u211c' },
+            { '\u211b' }, { '\u211c' }, { '\u211d' }, { '\u25ad' },
+            { '\u00ae' }, { '\u00ae' }, { '\u297d' }, { '\u230b' },
+            { '\ud835', '\udd2f' }, { '\u21c1' }, { '\u21c0' }, { '\u296c' },
+            { '\u03c1' }, { '\u03f1' }, { '\u2192' }, { '\u21a3' },
+            { '\u21c1' }, { '\u21c0' }, { '\u21c4' }, { '\u21cc' },
+            { '\u21c9' }, { '\u219d' }, { '\u22cc' }, { '\u02da' },
+            { '\u2253' }, { '\u21c4' }, { '\u21cc' }, { '\u200f' },
+            { '\u23b1' }, { '\u23b1' }, { '\u2aee' }, { '\u27ed' },
+            { '\u21fe' }, { '\u27e7' }, { '\u2986' }, { '\ud835', '\udd63' },
+            { '\u2a2e' }, { '\u2a35' }, { '\u0029' }, { '\u2994' },
+            { '\u2a12' }, { '\u21c9' }, { '\u203a' }, { '\ud835', '\udcc7' },
+            { '\u21b1' }, { '\u005d' }, { '\u2019' }, { '\u2019' },
+            { '\u22cc' }, { '\u22ca' }, { '\u25b9' }, { '\u22b5' },
+            { '\u25b8' }, { '\u29ce' }, { '\u2968' }, { '\u211e' },
+            { '\u015b' }, { '\u201a' }, { '\u227b' }, { '\u2ab4' },
+            { '\u2ab8' }, { '\u0161' }, { '\u227d' }, { '\u2ab0' },
+            { '\u015f' }, { '\u015d' }, { '\u2ab6' }, { '\u2aba' },
+            { '\u22e9' }, { '\u2a13' }, { '\u227f' }, { '\u0441' },
+            { '\u22c5' }, { '\u22a1' }, { '\u2a66' }, { '\u21d8' },
+            { '\u2925' }, { '\u2198' }, { '\u2198' }, { '\u00a7' },
+            { '\u00a7' }, { '\u003b' }, { '\u2929' }, { '\u2216' },
+            { '\u2216' }, { '\u2736' }, { '\ud835', '\udd30' }, { '\u2322' },
+            { '\u266f' }, { '\u0449' }, { '\u0448' }, { '\u2223' },
+            { '\u2225' }, { '\u00ad' }, { '\u00ad' }, { '\u03c3' },
+            { '\u03c2' }, { '\u03c2' }, { '\u223c' }, { '\u2a6a' },
+            { '\u2243' }, { '\u2243' }, { '\u2a9e' }, { '\u2aa0' },
+            { '\u2a9d' }, { '\u2a9f' }, { '\u2246' }, { '\u2a24' },
+            { '\u2972' }, { '\u2190' }, { '\u2216' }, { '\u2a33' },
+            { '\u29e4' }, { '\u2223' }, { '\u2323' }, { '\u2aaa' },
+            { '\u2aac' }, { '\u044c' }, { '\u002f' }, { '\u29c4' },
+            { '\u233f' }, { '\ud835', '\udd64' }, { '\u2660' }, { '\u2660' },
+            { '\u2225' }, { '\u2293' }, { '\u2294' }, { '\u228f' },
+            { '\u2291' }, { '\u228f' }, { '\u2291' }, { '\u2290' },
+            { '\u2292' }, { '\u2290' }, { '\u2292' }, { '\u25a1' },
+            { '\u25a1' }, { '\u25aa' }, { '\u25aa' }, { '\u2192' },
+            { '\ud835', '\udcc8' }, { '\u2216' }, { '\u2323' }, { '\u22c6' },
+            { '\u2606' }, { '\u2605' }, { '\u03f5' }, { '\u03d5' },
+            { '\u00af' }, { '\u2282' }, { '\u2ac5' }, { '\u2abd' },
+            { '\u2286' }, { '\u2ac3' }, { '\u2ac1' }, { '\u2acb' },
+            { '\u228a' }, { '\u2abf' }, { '\u2979' }, { '\u2282' },
+            { '\u2286' }, { '\u2ac5' }, { '\u228a' }, { '\u2acb' },
+            { '\u2ac7' }, { '\u2ad5' }, { '\u2ad3' }, { '\u227b' },
+            { '\u2ab8' }, { '\u227d' }, { '\u2ab0' }, { '\u2aba' },
+            { '\u2ab6' }, { '\u22e9' }, { '\u227f' }, { '\u2211' },
+            { '\u266a' }, { '\u00b9' }, { '\u00b9' }, { '\u00b2' },
+            { '\u00b2' }, { '\u00b3' }, { '\u00b3' }, { '\u2283' },
+            { '\u2ac6' }, { '\u2abe' }, { '\u2ad8' }, { '\u2287' },
+            { '\u2ac4' }, { '\u2ad7' }, { '\u297b' }, { '\u2ac2' },
+            { '\u2acc' }, { '\u228b' }, { '\u2ac0' }, { '\u2283' },
+            { '\u2287' }, { '\u2ac6' }, { '\u228b' }, { '\u2acc' },
+            { '\u2ac8' }, { '\u2ad4' }, { '\u2ad6' }, { '\u21d9' },
+            { '\u2926' }, { '\u2199' }, { '\u2199' }, { '\u292a' },
+            { '\u00df' }, { '\u00df' }, { '\u2316' }, { '\u03c4' },
+            { '\u23b4' }, { '\u0165' }, { '\u0163' }, { '\u0442' },
+            { '\u20db' }, { '\u2315' }, { '\ud835', '\udd31' }, { '\u2234' },
+            { '\u2234' }, { '\u03b8' }, { '\u03d1' }, { '\u03d1' },
+            { '\u2248' }, { '\u223c' }, { '\u2009' }, { '\u2248' },
+            { '\u223c' }, { '\u00fe' }, { '\u00fe' }, { '\u02dc' },
+            { '\u00d7' }, { '\u00d7' }, { '\u22a0' }, { '\u2a31' },
+            { '\u2a30' }, { '\u222d' }, { '\u2928' }, { '\u22a4' },
+            { '\u2336' }, { '\u2af1' }, { '\ud835', '\udd65' }, { '\u2ada' },
+            { '\u2929' }, { '\u2034' }, { '\u2122' }, { '\u25b5' },
+            { '\u25bf' }, { '\u25c3' }, { '\u22b4' }, { '\u225c' },
+            { '\u25b9' }, { '\u22b5' }, { '\u25ec' }, { '\u225c' },
+            { '\u2a3a' }, { '\u2a39' }, { '\u29cd' }, { '\u2a3b' },
+            { '\u23e2' }, { '\ud835', '\udcc9' }, { '\u0446' }, { '\u045b' },
+            { '\u0167' }, { '\u226c' }, { '\u219e' }, { '\u21a0' },
+            { '\u21d1' }, { '\u2963' }, { '\u00fa' }, { '\u00fa' },
+            { '\u2191' }, { '\u045e' }, { '\u016d' }, { '\u00fb' },
+            { '\u00fb' }, { '\u0443' }, { '\u21c5' }, { '\u0171' },
+            { '\u296e' }, { '\u297e' }, { '\ud835', '\udd32' }, { '\u00f9' },
+            { '\u00f9' }, { '\u21bf' }, { '\u21be' }, { '\u2580' },
+            { '\u231c' }, { '\u231c' }, { '\u230f' }, { '\u25f8' },
+            { '\u016b' }, { '\u00a8' }, { '\u00a8' }, { '\u0173' },
+            { '\ud835', '\udd66' }, { '\u2191' }, { '\u2195' }, { '\u21bf' },
+            { '\u21be' }, { '\u228e' }, { '\u03c5' }, { '\u03d2' },
+            { '\u03c5' }, { '\u21c8' }, { '\u231d' }, { '\u231d' },
+            { '\u230e' }, { '\u016f' }, { '\u25f9' }, { '\ud835', '\udcca' },
+            { '\u22f0' }, { '\u0169' }, { '\u25b5' }, { '\u25b4' },
+            { '\u21c8' }, { '\u00fc' }, { '\u00fc' }, { '\u29a7' },
+            { '\u21d5' }, { '\u2ae8' }, { '\u2ae9' }, { '\u22a8' },
+            { '\u299c' }, { '\u03b5' }, { '\u03f0' }, { '\u2205' },
+            { '\u03c6' }, { '\u03d6' }, { '\u221d' }, { '\u2195' },
+            { '\u03f1' }, { '\u03c2' }, { '\u03d1' }, { '\u22b2' },
+            { '\u22b3' }, { '\u0432' }, { '\u22a2' }, { '\u2228' },
+            { '\u22bb' }, { '\u225a' }, { '\u22ee' }, { '\u007c' },
+            { '\u007c' }, { '\ud835', '\udd33' }, { '\u22b2' },
+            { '\ud835', '\udd67' }, { '\u221d' }, { '\u22b3' },
+            { '\ud835', '\udccb' }, { '\u299a' }, { '\u0175' }, { '\u2a5f' },
+            { '\u2227' }, { '\u2259' }, { '\u2118' }, { '\ud835', '\udd34' },
+            { '\ud835', '\udd68' }, { '\u2118' }, { '\u2240' }, { '\u2240' },
+            { '\ud835', '\udccc' }, { '\u22c2' }, { '\u25ef' }, { '\u22c3' },
+            { '\u25bd' }, { '\ud835', '\udd35' }, { '\u27fa' }, { '\u27f7' },
+            { '\u03be' }, { '\u27f8' }, { '\u27f5' }, { '\u27fc' },
+            { '\u22fb' }, { '\u2a00' }, { '\ud835', '\udd69' }, { '\u2a01' },
+            { '\u2a02' }, { '\u27f9' }, { '\u27f6' }, { '\ud835', '\udccd' },
+            { '\u2a06' }, { '\u2a04' }, { '\u25b3' }, { '\u22c1' },
+            { '\u22c0' }, { '\u00fd' }, { '\u00fd' }, { '\u044f' },
+            { '\u0177' }, { '\u044b' }, { '\u00a5' }, { '\u00a5' },
+            { '\ud835', '\udd36' }, { '\u0457' }, { '\ud835', '\udd6a' },
+            { '\ud835', '\udcce' }, { '\u044e' }, { '\u00ff' }, { '\u00ff' },
+            { '\u017a' }, { '\u017e' }, { '\u0437' }, { '\u017c' },
+            { '\u2128' }, { '\u03b6' }, { '\ud835', '\udd37' }, { '\u0436' },
+            { '\u21dd' }, { '\ud835', '\udd6b' }, { '\ud835', '\udccf' },
+            { '\u200d' }, { '\u200c' }, };
+
+    final static char[][] WINDOWS_1252 = { { '\u20AC' }, { '\uFFFD' },
+            { '\u201A' }, { '\u0192' }, { '\u201E' }, { '\u2026' },
+            { '\u2020' }, { '\u2021' }, { '\u02C6' }, { '\u2030' },
+            { '\u0160' }, { '\u2039' }, { '\u0152' }, { '\uFFFD' },
+            { '\u017D' }, { '\uFFFD' }, { '\uFFFD' }, { '\u2018' },
+            { '\u2019' }, { '\u201C' }, { '\u201D' }, { '\u2022' },
+            { '\u2013' }, { '\u2014' }, { '\u02DC' }, { '\u2122' },
+            { '\u0161' }, { '\u203A' }, { '\u0153' }, { '\uFFFD' },
+            { '\u017E' }, { '\u0178' } };
+
+}
diff --git a/parser/html/java/htmlparser/src/Portability.java b/parser/html/java/htmlparser/src/Portability.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/Portability.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (c) 2008-2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.Literal;
+import nu.validator.htmlparser.annotation.Local;
+import nu.validator.htmlparser.annotation.NoLength;
+
+public final class Portability {
+
+    // Allocating methods
+
+    /**
+     * Allocates a new local name object. In C++, the refcount must be set up in such a way that 
+     * calling <code>releaseLocal</code> on the return value balances the refcount set by this method.
+     */
+    public static @Local String newLocalNameFromBuffer(@NoLength char[] buf, int offset, int length) {
+        return new String(buf, offset, length).intern();
+    }
+
+    public static String newStringFromBuffer(@NoLength char[] buf, int offset, int length) {
+        return new String(buf, offset, length);
+    }
+
+    public static String newEmptyString() {
+        return "";
+    }
+
+    public static String newStringFromLiteral(@Literal String literal) {
+        return literal;
+    }
+    
+    // XXX get rid of this
+    public static char[] newCharArrayFromLocal(@Local String local) {
+        return local.toCharArray();
+    }
+
+    public static char[] newCharArrayFromString(String string) {
+        return string.toCharArray();
+    }
+    
+    // Deallocation methods
+    
+    public static void releaseString(String str) {
+        // No-op in Java
+    }
+    
+    public static void retainLocal(@Local String local) {
+        // No-op in Java
+    }
+
+    /**
+     * This MUST be a no-op on locals that are known at compile time.
+     * @param local
+     */
+    public static void releaseLocal(@Local String local) {
+        // No-op in Java
+    }
+    
+    /**
+     * Releases a Java array. This method is magically replaced by a macro in C++.
+     * @param arr
+     */
+    public static void releaseArray(Object arr) {
+        // No-op in Java
+    }    
+    
+    public static void retainElement(Object elt) {
+        // No-op in Java
+    }
+
+    public static void releaseElement(Object elt) {
+        // No-op in Java
+    }
+    
+    // Comparison methods
+    
+    public static boolean localEqualsBuffer(@Local String local, @NoLength char[] buf, int offset, int length) {
+        if (local.length() != length) {
+            return false;
+        }
+        for (int i = 0; i < length; i++) {
+            if (local.charAt(i) != buf[offset + i]) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public static boolean lowerCaseLiteralIsPrefixOfIgnoreAsciiCaseString(@Literal String lowerCaseLiteral,
+            String string) {
+        if (string == null) {
+            return false;
+        }
+        if (lowerCaseLiteral.length() > string.length()) {
+            return false;
+        }
+        for (int i = 0; i < lowerCaseLiteral.length(); i++) {
+            char c0 = lowerCaseLiteral.charAt(i);
+            char c1 = string.charAt(i);
+            if (c1 >= 'A' && c1 <= 'Z') {
+                c1 += 0x20;
+            }
+            if (c0 != c1) {
+                return false;
+            }
+        }
+        return true;
+    }
+    
+    public static boolean lowerCaseLiteralEqualsIgnoreAsciiCaseString(@Literal String lowerCaseLiteral,
+            String string) {
+        if (string == null) {
+            return false;
+        }
+        if (lowerCaseLiteral.length() != string.length()) {
+            return false;
+        }
+        for (int i = 0; i < lowerCaseLiteral.length(); i++) {
+            char c0 = lowerCaseLiteral.charAt(i);
+            char c1 = string.charAt(i);
+            if (c1 >= 'A' && c1 <= 'Z') {
+                c1 += 0x20;
+            }
+            if (c0 != c1) {
+                return false;
+            }
+        }
+        return true;
+    }
+    
+    public static boolean literalEqualsString(@Literal String literal, String string) {
+        return literal.equals(string);
+    }
+
+    public static char[] isIndexPrompt() {
+        return "This is a searchable index. Insert your search keywords here: ".toCharArray();
+    }
+
+    public static void delete(Object o) {
+        
+    }
+
+    public static void deleteArray(Object o) {
+        
+    }
+}
diff --git a/parser/html/java/htmlparser/src/PushedLocation.java b/parser/html/java/htmlparser/src/PushedLocation.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/PushedLocation.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 2008 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+public class PushedLocation {
+    private final int line;
+
+    private final int linePrev;
+
+    private final int col;
+
+    private final int colPrev;
+
+    private final boolean nextCharOnNewLine;
+
+    private final String publicId;
+
+    private final String systemId;
+
+    private final PushedLocation next;
+
+    /**
+     * @param line
+     * @param linePrev
+     * @param col
+     * @param colPrev
+     * @param nextCharOnNewLine
+     * @param publicId
+     * @param systemId
+     * @param next
+     */
+    public PushedLocation(int line, int linePrev, int col, int colPrev,
+            boolean nextCharOnNewLine, String publicId, String systemId,
+            PushedLocation next) {
+        this.line = line;
+        this.linePrev = linePrev;
+        this.col = col;
+        this.colPrev = colPrev;
+        this.nextCharOnNewLine = nextCharOnNewLine;
+        this.publicId = publicId;
+        this.systemId = systemId;
+        this.next = next;
+    }
+
+    /**
+     * Returns the line.
+     * 
+     * @return the line
+     */
+    public int getLine() {
+        return line;
+    }
+
+    /**
+     * Returns the linePrev.
+     * 
+     * @return the linePrev
+     */
+    public int getLinePrev() {
+        return linePrev;
+    }
+
+    /**
+     * Returns the col.
+     * 
+     * @return the col
+     */
+    public int getCol() {
+        return col;
+    }
+
+    /**
+     * Returns the colPrev.
+     * 
+     * @return the colPrev
+     */
+    public int getColPrev() {
+        return colPrev;
+    }
+
+    /**
+     * Returns the nextCharOnNewLine.
+     * 
+     * @return the nextCharOnNewLine
+     */
+    public boolean isNextCharOnNewLine() {
+        return nextCharOnNewLine;
+    }
+
+    /**
+     * Returns the publicId.
+     * 
+     * @return the publicId
+     */
+    public String getPublicId() {
+        return publicId;
+    }
+
+    /**
+     * Returns the systemId.
+     * 
+     * @return the systemId
+     */
+    public String getSystemId() {
+        return systemId;
+    }
+
+    /**
+     * Returns the next.
+     * 
+     * @return the next
+     */
+    public PushedLocation getNext() {
+        return next;
+    }
+}
diff --git a/parser/html/java/htmlparser/src/StackNode.java b/parser/html/java/htmlparser/src/StackNode.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/StackNode.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2007 Henri Sivonen
+ * Copyright (c) 2007-2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.Local;
+import nu.validator.htmlparser.annotation.NsUri;
+
+final class StackNode<T> {
+    final int group;
+
+    final @Local String name;
+
+    final @Local String popName;
+
+    final @NsUri String ns;
+
+    final T node;
+
+    final boolean scoping;
+
+    final boolean special;
+
+    final boolean fosterParenting;
+    
+    private int refcount = 1;
+
+    /**
+     * @param group
+     *            TODO
+     * @param name
+     * @param node
+     * @param scoping
+     * @param special
+     * @param popName
+     *            TODO
+     */
+    StackNode(int group, final @NsUri String ns, final @Local String name, final T node,
+            final boolean scoping, final boolean special,
+            final boolean fosterParenting, final @Local String popName) {
+        this.group = group;
+        this.name = name;
+        this.popName = popName;
+        this.ns = ns;
+        this.node = node;
+        this.scoping = scoping;
+        this.special = special;
+        this.fosterParenting = fosterParenting;
+        this.refcount = 1;
+        Portability.retainLocal(name);
+        Portability.retainLocal(popName);
+        Portability.retainElement(node);
+        // not retaining namespace for now        
+    }
+
+    /**
+     * @param elementName
+     *            TODO
+     * @param node
+     */
+    StackNode(final @NsUri String ns, ElementName elementName, final T node) {
+        this.group = elementName.group;
+        this.name = elementName.name;
+        this.popName = elementName.name;
+        this.ns = ns;
+        this.node = node;
+        this.scoping = elementName.scoping;
+        this.special = elementName.special;
+        this.fosterParenting = elementName.fosterParenting;
+        this.refcount = 1;
+        Portability.retainLocal(name);
+        Portability.retainLocal(popName);
+        Portability.retainElement(node);
+        // not retaining namespace for now        
+    }
+
+    StackNode(final @NsUri String ns, ElementName elementName, final T node, @Local String popName) {
+        this.group = elementName.group;
+        this.name = elementName.name;
+        this.popName = popName;
+        this.ns = ns;
+        this.node = node;
+        this.scoping = elementName.scoping;
+        this.special = elementName.special;
+        this.fosterParenting = elementName.fosterParenting;
+        this.refcount = 1;
+        Portability.retainLocal(name);
+        Portability.retainLocal(popName);
+        Portability.retainElement(node);
+        // not retaining namespace for now        
+    }
+
+    StackNode(final @NsUri String ns, ElementName elementName, final T node, @Local String popName, boolean scoping) {
+        this.group = elementName.group;
+        this.name = elementName.name;
+        this.popName = popName;
+        this.ns = ns;
+        this.node = node;
+        this.scoping = scoping;
+        this.special = false;
+        this.fosterParenting = false;
+        this.refcount = 1;
+        Portability.retainLocal(name);
+        Portability.retainLocal(popName);
+        Portability.retainElement(node);
+        // not retaining namespace for now        
+    }
+    
+    @SuppressWarnings("unused") private void destructor() {
+        Portability.releaseLocal(name);
+        Portability.releaseLocal(popName);
+        Portability.releaseElement(node);
+        // not releasing namespace for now        
+    }
+    
+    // [NOCPP[
+    /**
+     * @see java.lang.Object#toString()
+     */
+    @Override public @Local String toString() {
+        return name;
+    }
+    // ]NOCPP]
+    
+    public void retain() {   
+        refcount++;
+    }
+    
+    public void release() {
+        refcount--;
+        if (refcount == 0) {
+            Portability.delete(this);
+        }
+    }
+}
diff --git a/parser/html/java/htmlparser/src/StateSnapshot.java b/parser/html/java/htmlparser/src/StateSnapshot.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/StateSnapshot.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2009 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+
+public class StateSnapshot<T> {
+
+    /**
+     * @param stack
+     * @param listOfActiveFormattingElements
+     * @param formPointer
+     */
+    StateSnapshot(StackNode<T>[] stack,
+            StackNode<T>[] listOfActiveFormattingElements, T formPointer) {
+        this.stack = stack;
+        this.listOfActiveFormattingElements = listOfActiveFormattingElements;
+        this.formPointer = formPointer;
+    }
+
+    final StackNode<T>[] stack;
+
+    final StackNode<T>[] listOfActiveFormattingElements;
+
+    final T formPointer;
+    
+    @SuppressWarnings("unused") private void destructor() {
+        for (int i = 0; i < stack.length; i++) {
+            stack[i].release();
+        }
+        Portability.releaseArray(stack);
+        for (int i = 0; i < listOfActiveFormattingElements.length; i++) {
+            if (listOfActiveFormattingElements[i] != null) {
+                listOfActiveFormattingElements[i].release();                
+            }
+        }
+        Portability.releaseArray(listOfActiveFormattingElements);
+        Portability.retainElement(formPointer);
+    }
+}
diff --git a/parser/html/java/htmlparser/src/Tokenizer.java b/parser/html/java/htmlparser/src/Tokenizer.java
new file mode 100755
--- /dev/null
+++ b/parser/html/java/htmlparser/src/Tokenizer.java
@@ -0,0 +1,5888 @@
+/*
+ * Copyright (c) 2005-2007 Henri Sivonen
+ * Copyright (c) 2007-2009 Mozilla Foundation
+ * Portions of comments Copyright 2004-2008 Apple Computer, Inc., Mozilla 
+ * Foundation, and Opera Software ASA.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * The comments following this one that use the same comment syntax as this 
+ * comment are quotes from the WHATWG HTML 5 spec as of 2 June 2007 
+ * amended as of June 18 2008.
+ * That document came with this statement:
+ * " Copyright 2004-2008 Apple Computer, Inc., Mozilla Foundation, and 
+ * Opera Software ASA. You are granted a license to use, reproduce and 
+ * create derivative works of this document."
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.Inline;
+import nu.validator.htmlparser.annotation.Local;
+import nu.validator.htmlparser.annotation.NoLength;
+import nu.validator.htmlparser.common.EncodingDeclarationHandler;
+import nu.validator.htmlparser.common.TokenHandler;
+import nu.validator.htmlparser.common.XmlViolationPolicy;
+
+import org.xml.sax.ErrorHandler;
+import org.xml.sax.Locator;
+import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
+
+/**
+ * An implementation of
+ * http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html
+ * 
+ * This class implements the <code>Locator</code> interface. This is not an
+ * incidental implementation detail: Users of this class are encouraged to make
+ * use of the <code>Locator</code> nature.
+ * 
+ * By default, the tokenizer may report data that XML 1.0 bans. The tokenizer
+ * can be configured to treat these conditions as fatal or to coerce the infoset
+ * to something that XML 1.0 allows.
+ * 
+ * @version $Id: Tokenizer.java 565 2009-07-03 14:40:35Z hsivonen $
+ * @author hsivonen
+ */
+public class Tokenizer implements Locator {
+
+    public static final int DATA = 0;
+
+    public static final int RCDATA = 1;
+
+    public static final int CDATA = 2;
+
+    public static final int PLAINTEXT = 3;
+
+    private static final int TAG_OPEN = 4;
+
+    private static final int CLOSE_TAG_OPEN_PCDATA = 5;
+
+    private static final int TAG_NAME = 6;
+
+    private static final int BEFORE_ATTRIBUTE_NAME = 7;
+
+    private static final int ATTRIBUTE_NAME = 8;
+
+    private static final int AFTER_ATTRIBUTE_NAME = 9;
+
+    private static final int BEFORE_ATTRIBUTE_VALUE = 10;
+
+    private static final int ATTRIBUTE_VALUE_DOUBLE_QUOTED = 11;
+
+    private static final int ATTRIBUTE_VALUE_SINGLE_QUOTED = 12;
+
+    private static final int ATTRIBUTE_VALUE_UNQUOTED = 13;
+
+    private static final int AFTER_ATTRIBUTE_VALUE_QUOTED = 14;
+
+    private static final int BOGUS_COMMENT = 15;
+
+    private static final int MARKUP_DECLARATION_OPEN = 16;
+
+    private static final int DOCTYPE = 17;
+
+    private static final int BEFORE_DOCTYPE_NAME = 18;
+
+    private static final int DOCTYPE_NAME = 19;
+
+    private static final int AFTER_DOCTYPE_NAME = 20;
+
+    private static final int BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 21;
+
+    private static final int DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 22;
+
+    private static final int DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 23;
+
+    private static final int AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 24;
+
+    private static final int BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 25;
+
+    private static final int DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 26;
+
+    private static final int DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 27;
+
+    private static final int AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 28;
+
+    private static final int BOGUS_DOCTYPE = 29;
+
+    private static final int COMMENT_START = 30;
+
+    private static final int COMMENT_START_DASH = 31;
+
+    private static final int COMMENT = 32;
+
+    private static final int COMMENT_END_DASH = 33;
+
+    private static final int COMMENT_END = 34;
+
+    private static final int COMMENT_END_SPACE = 35;
+
+    private static final int COMMENT_END_BANG = 36;
+
+    private static final int CLOSE_TAG_OPEN_NOT_PCDATA = 37;
+
+    private static final int MARKUP_DECLARATION_HYPHEN = 38;
+
+    private static final int MARKUP_DECLARATION_OCTYPE = 39;
+
+    private static final int DOCTYPE_UBLIC = 40;
+
+    private static final int DOCTYPE_YSTEM = 41;
+
+    private static final int CONSUME_CHARACTER_REFERENCE = 42;
+
+    private static final int CONSUME_NCR = 43;
+
+    private static final int CHARACTER_REFERENCE_LOOP = 44;
+
+    private static final int HEX_NCR_LOOP = 45;
+
+    private static final int DECIMAL_NRC_LOOP = 46;
+
+    private static final int HANDLE_NCR_VALUE = 47;
+
+    private static final int SELF_CLOSING_START_TAG = 48;
+
+    private static final int CDATA_START = 49;
+
+    private static final int CDATA_SECTION = 50;
+
+    private static final int CDATA_RSQB = 51;
+
+    private static final int CDATA_RSQB_RSQB = 52;
+
+    private static final int TAG_OPEN_NON_PCDATA = 53;
+
+    private static final int ESCAPE_EXCLAMATION = 54;
+
+    private static final int ESCAPE_EXCLAMATION_HYPHEN = 55;
+
+    private static final int ESCAPE = 56;
+
+    private static final int ESCAPE_HYPHEN = 57;
+
+    private static final int ESCAPE_HYPHEN_HYPHEN = 58;
+
+    private static final int BOGUS_COMMENT_HYPHEN = 59;
+
+    /**
+     * Magic value for UTF-16 operations.
+     */
+    private static final int LEAD_OFFSET = (0xD800 - (0x10000 >> 10));
+
+    /**
+     * UTF-16 code unit array containing less than and greater than for emitting
+     * those characters on certain parse errors.
+     */
+    private static final @NoLength char[] LT_GT = { '<', '>' };
+
+    /**
+     * UTF-16 code unit array containing less than and solidus for emitting
+     * those characters on certain parse errors.
+     */
+    private static final @NoLength char[] LT_SOLIDUS = { '<', '/' };
+
+    /**
+     * UTF-16 code unit array containing ]] for emitting those characters on
+     * state transitions.
+     */
+    private static final @NoLength char[] RSQB_RSQB = { ']', ']' };
+
+    /**
+     * Array version of U+FFFD.
+     */
+    private static final @NoLength char[] REPLACEMENT_CHARACTER = { '\uFFFD' };
+
+    // [NOCPP[
+
+    /**
+     * Array version of space.
+     */
+    private static final @NoLength char[] SPACE = { ' ' };
+
+    // ]NOCPP]
+
+    /**
+     * Array version of line feed.
+     */
+    private static final @NoLength char[] LF = { '\n' };
+
+    /**
+     * Buffer growth parameter.
+     */
+    private static final int BUFFER_GROW_BY = 1024;
+
+    /**
+     * "CDATA[" as <code>char[]</code>
+     */
+    private static final @NoLength char[] CDATA_LSQB = "CDATA[".toCharArray();
+
+    /**
+     * "octype" as <code>char[]</code>
+     */
+    private static final @NoLength char[] OCTYPE = "octype".toCharArray();
+
+    /**
+     * "ublic" as <code>char[]</code>
+     */
+    private static final @NoLength char[] UBLIC = "ublic".toCharArray();
+
+    /**
+     * "ystem" as <code>char[]</code>
+     */
+    private static final @NoLength char[] YSTEM = "ystem".toCharArray();
+
+    private static final char[] TITLE_ARR = { 't', 'i', 't', 'l', 'e' };
+
+    private static final char[] SCRIPT_ARR = { 's', 'c', 'r', 'i', 'p', 't' };
+
+    private static final char[] STYLE_ARR = { 's', 't', 'y', 'l', 'e' };
+
+    private static final char[] PLAINTEXT_ARR = { 'p', 'l', 'a', 'i', 'n', 't',
+            'e', 'x', 't' };
+
+    private static final char[] XMP_ARR = { 'x', 'm', 'p' };
+
+    private static final char[] TEXTAREA_ARR = { 't', 'e', 'x', 't', 'a', 'r',
+            'e', 'a' };
+
+    private static final char[] IFRAME_ARR = { 'i', 'f', 'r', 'a', 'm', 'e' };
+
+    private static final char[] NOEMBED_ARR = { 'n', 'o', 'e', 'm', 'b', 'e',
+            'd' };
+
+    private static final char[] NOSCRIPT_ARR = { 'n', 'o', 's', 'c', 'r', 'i',
+            'p', 't' };
+
+    private static final char[] NOFRAMES_ARR = { 'n', 'o', 'f', 'r', 'a', 'm',
+            'e', 's' };
+
+    /**
+     * The token handler.
+     */
+    protected final TokenHandler tokenHandler;
+
+    protected EncodingDeclarationHandler encodingDeclarationHandler;
+
+    // [NOCPP[
+
+    /**
+     * The error handler.
+     */
+    protected ErrorHandler errorHandler;
+
+    // ]NOCPP]
+
+    /**
+     * Whether the previous char read was CR.
+     */
+    protected boolean lastCR;
+
+    protected int stateSave;
+
+    private int returnStateSave;
+
+    protected int index;
+
+    private boolean forceQuirks;
+
+    private char additional;
+
+    private int entCol;
+
+    private int lo;
+
+    private int hi;
+
+    private int candidate;
+
+    private int strBufMark;
+
+    private int prevValue;
+
+    protected int value;
+
+    private boolean seenDigits;
+
+    protected int cstart;
+
+    /**
+     * The SAX public id for the resource being tokenized. (Only passed to back
+     * as part of locator data.)
+     */
+    private String publicId;
+
+    /**
+     * The SAX system id for the resource being tokenized. (Only passed to back
+     * as part of locator data.)
+     */
+    private String systemId;
+
+    /**
+     * Buffer for short identifiers.
+     */
+    private char[] strBuf;
+
+    /**
+     * Number of significant <code>char</code>s in <code>strBuf</code>.
+     */
+    private int strBufLen;
+
+    /**
+     * <code>-1</code> to indicate that <code>strBuf</code> is used or otherwise
+     * an offset to the main buffer.
+     */
+    // private int strBufOffset = -1;
+    /**
+     * Buffer for long strings.
+     */
+    private char[] longStrBuf;
+
+    /**
+     * Number of significant <code>char</code>s in <code>longStrBuf</code>.
+     */
+    private int longStrBufLen;
+
+    /**
+     * <code>-1</code> to indicate that <code>longStrBuf</code> is used or
+     * otherwise an offset to the main buffer.
+     */
+    // private int longStrBufOffset = -1;
+    /**
+     * The attribute holder.
+     */
+    private HtmlAttributes attributes;
+
+    /**
+     * Buffer for expanding NCRs falling into the Basic Multilingual Plane.
+     */
+    private final char[] bmpChar;
+
+    /**
+     * Buffer for expanding astral NCRs.
+     */
+    private final char[] astralChar;
+
+    /**
+     * The element whose end tag closes the current CDATA or RCDATA element.
+     */
+    protected ElementName contentModelElement = null;
+
+    private char[] contentModelElementNameAsArray;
+
+    /**
+     * <code>true</code> if tokenizing an end tag
+     */
+    protected boolean endTag;
+
+    /**
+     * The current tag token name.
+     */
+    private ElementName tagName = null;
+
+    /**
+     * The current attribute name.
+     */
+    protected AttributeName attributeName = null;
+
+    // [NOCPP[
+
+    /**
+     * Whether comment tokens are emitted.
+     */
+    private boolean wantsComments = false;
+
+    /**
+     * <code>true</code> when HTML4-specific additional errors are requested.
+     */
+    protected boolean html4;
+
+    /**
+     * Whether the stream is past the first 512 bytes.
+     */
+    private boolean metaBoundaryPassed;
+
+    // ]NOCPP]
+
+    /**
+     * The name of the current doctype token.
+     */
+    private @Local String doctypeName;
+
+    /**
+     * The public id of the current doctype token.
+     */
+    private String publicIdentifier;
+
+    /**
+     * The system id of the current doctype token.
+     */
+    private String systemIdentifier;
+
+    // [NOCPP[
+
+    /**
+     * The policy for vertical tab and form feed.
+     */
+    private XmlViolationPolicy contentSpacePolicy = XmlViolationPolicy.ALTER_INFOSET;
+
+    /**
+     * The policy for comments.
+     */
+    private XmlViolationPolicy commentPolicy = XmlViolationPolicy.ALTER_INFOSET;
+
+    private XmlViolationPolicy xmlnsPolicy = XmlViolationPolicy.ALTER_INFOSET;
+
+    private XmlViolationPolicy namePolicy = XmlViolationPolicy.ALTER_INFOSET;
+
+    private boolean html4ModeCompatibleWithXhtml1Schemata;
+
+    private final boolean newAttributesEachTime;
+
+    // ]NOCPP]
+
+    private int mappingLangToXmlLang;
+
+    private boolean shouldSuspend;
+
+    protected boolean confident;
+
+    private int line;
+
+    // [NOCPP[
+
+    protected LocatorImpl ampersandLocation;
+
+    public Tokenizer(TokenHandler tokenHandler, boolean newAttributesEachTime) {
+        this.tokenHandler = tokenHandler;
+        this.encodingDeclarationHandler = null;
+        this.newAttributesEachTime = newAttributesEachTime;
+        this.bmpChar = new char[1];
+        this.astralChar = new char[2];
+    }
+
+    // ]NOCPP]
+
+    /**
+     * The constructor.
+     * 
+     * @param tokenHandler
+     *            the handler for receiving tokens
+     */
+    public Tokenizer(TokenHandler tokenHandler) {
+        this.tokenHandler = tokenHandler;
+        this.encodingDeclarationHandler = null;
+        // [NOCPP[
+        this.newAttributesEachTime = false;
+        // ]NOCPP]
+        this.bmpChar = new char[1];
+        this.astralChar = new char[2];
+    }
+
+    public void initLocation(String newPublicId, String newSystemId) {
+        this.systemId = newSystemId;
+        this.publicId = newPublicId;
+
+    }
+
+    void destructor() {
+        Portability.releaseArray(bmpChar);
+        Portability.releaseArray(astralChar);
+    }
+
+    // [NOCPP[
+
+    /**
+     * Returns the mappingLangToXmlLang.
+     * 
+     * @return the mappingLangToXmlLang
+     */
+    public boolean isMappingLangToXmlLang() {
+        return mappingLangToXmlLang == AttributeName.HTML_LANG;
+    }
+
+    /**
+     * Sets the mappingLangToXmlLang.
+     * 
+     * @param mappingLangToXmlLang
+     *            the mappingLangToXmlLang to set
+     */
+    public void setMappingLangToXmlLang(boolean mappingLangToXmlLang) {
+        this.mappingLangToXmlLang = mappingLangToXmlLang ? AttributeName.HTML_LANG
+                : AttributeName.HTML;
+    }
+
+    /**
+     * Sets the error handler.
+     * 
+     * @see org.xml.sax.XMLReader#setErrorHandler(org.xml.sax.ErrorHandler)
+     */
+    public void setErrorHandler(ErrorHandler eh) {
+        this.errorHandler = eh;
+    }
+
+    public ErrorHandler getErrorHandler() {
+        return this.errorHandler;
+    }
+
+    /**
+     * Sets the commentPolicy.
+     * 
+     * @param commentPolicy
+     *            the commentPolicy to set
+     */
+    public void setCommentPolicy(XmlViolationPolicy commentPolicy) {
+        this.commentPolicy = commentPolicy;
+    }
+
+    /**
+     * Sets the contentNonXmlCharPolicy.
+     * 
+     * @param contentNonXmlCharPolicy
+     *            the contentNonXmlCharPolicy to set
+     */
+    public void setContentNonXmlCharPolicy(
+            XmlViolationPolicy contentNonXmlCharPolicy) {
+        if (contentNonXmlCharPolicy != XmlViolationPolicy.ALLOW) {
+            throw new IllegalArgumentException(
+                    "Must use ErrorReportingTokenizer to set contentNonXmlCharPolicy to non-ALLOW.");
+        }
+    }
+
+    /**
+     * Sets the contentSpacePolicy.
+     * 
+     * @param contentSpacePolicy
+     *            the contentSpacePolicy to set
+     */
+    public void setContentSpacePolicy(XmlViolationPolicy contentSpacePolicy) {
+        this.contentSpacePolicy = contentSpacePolicy;
+    }
+
+    /**
+     * Sets the xmlnsPolicy.
+     * 
+     * @param xmlnsPolicy
+     *            the xmlnsPolicy to set
+     */
+    public void setXmlnsPolicy(XmlViolationPolicy xmlnsPolicy) {
+        if (xmlnsPolicy == XmlViolationPolicy.FATAL) {
+            throw new IllegalArgumentException("Can't use FATAL here.");
+        }
+        this.xmlnsPolicy = xmlnsPolicy;
+    }
+
+    public void setNamePolicy(XmlViolationPolicy namePolicy) {
+        this.namePolicy = namePolicy;
+    }
+
+    /**
+     * Sets the html4ModeCompatibleWithXhtml1Schemata.
+     * 
+     * @param html4ModeCompatibleWithXhtml1Schemata
+     *            the html4ModeCompatibleWithXhtml1Schemata to set
+     */
+    public void setHtml4ModeCompatibleWithXhtml1Schemata(
+            boolean html4ModeCompatibleWithXhtml1Schemata) {
+        this.html4ModeCompatibleWithXhtml1Schemata = html4ModeCompatibleWithXhtml1Schemata;
+    }
+
+    // ]NOCPP]
+
+    // For the token handler to call
+    /**
+     * Sets the content model flag and the associated element name.
+     * 
+     * @param contentModelFlag
+     *            the flag
+     * @param contentModelElement
+     *            the element causing the flag to be set
+     */
+    public void setContentModelFlag(int contentModelFlag,
+            @Local String contentModelElement) {
+        this.stateSave = contentModelFlag;
+        if (contentModelFlag == Tokenizer.DATA) {
+            return;
+        }
+        // XXX does this make any sense?
+        char[] asArray = Portability.newCharArrayFromLocal(contentModelElement);
+        this.contentModelElement = ElementName.elementNameByBuffer(asArray, 0,
+                asArray.length);
+        Portability.releaseArray(asArray);
+        contentModelElementToArray();
+    }
+
+    /**
+     * Sets the content model flag and the associated element name.
+     * 
+     * @param contentModelFlag
+     *            the flag
+     * @param contentModelElement
+     *            the element causing the flag to be set
+     */
+    public void setContentModelFlag(int contentModelFlag,
+            ElementName contentModelElement) {
+        this.stateSave = contentModelFlag;
+        this.contentModelElement = contentModelElement;
+        contentModelElementToArray();
+    }
+
+    private void contentModelElementToArray() {
+        switch (contentModelElement.group) {
+            case TreeBuilder.TITLE:
+                contentModelElementNameAsArray = TITLE_ARR;
+                return;
+            case TreeBuilder.SCRIPT:
+                contentModelElementNameAsArray = SCRIPT_ARR;
+                return;
+            case TreeBuilder.STYLE:
+                contentModelElementNameAsArray = STYLE_ARR;
+                return;
+            case TreeBuilder.PLAINTEXT:
+                contentModelElementNameAsArray = PLAINTEXT_ARR;
+                return;
+            case TreeBuilder.XMP:
+                contentModelElementNameAsArray = XMP_ARR;
+                return;
+            case TreeBuilder.TEXTAREA:
+                contentModelElementNameAsArray = TEXTAREA_ARR;
+                return;
+            case TreeBuilder.IFRAME:
+                contentModelElementNameAsArray = IFRAME_ARR;
+                return;
+            case TreeBuilder.NOEMBED:
+                contentModelElementNameAsArray = NOEMBED_ARR;
+                return;
+            case TreeBuilder.NOSCRIPT:
+                contentModelElementNameAsArray = NOSCRIPT_ARR;
+                return;
+            case TreeBuilder.NOFRAMES:
+                contentModelElementNameAsArray = NOFRAMES_ARR;
+                return;
+            default:
+                assert false;
+                return;
+        }
+    }
+
+    /**
+     * For C++ use only.
+     */
+    public void setLineNumber(int line) {
+        this.line = line;
+    }
+
+    // start Locator impl
+
+    /**
+     * @see org.xml.sax.Locator#getLineNumber()
+     */
+    @Inline public int getLineNumber() {
+        return line;
+    }
+
+    // [NOCPP[
+
+    /**
+     * @see org.xml.sax.Locator#getColumnNumber()
+     */
+    @Inline public int getColumnNumber() {
+        return -1;
+    }
+
+    /**
+     * @see org.xml.sax.Locator#getPublicId()
+     */
+    public String getPublicId() {
+        return publicId;
+    }
+
+    /**
+     * @see org.xml.sax.Locator#getSystemId()
+     */
+    public String getSystemId() {
+        return systemId;
+    }
+
+    // end Locator impl
+
+    // end public API
+
+    public void notifyAboutMetaBoundary() {
+        metaBoundaryPassed = true;
+    }
+
+    void turnOnAdditionalHtml4Errors() {
+        html4 = true;
+    }
+
+    // ]NOCPP]
+
+    HtmlAttributes emptyAttributes() {
+        // [NOCPP[
+        if (newAttributesEachTime) {
+            return new HtmlAttributes(mappingLangToXmlLang);
+        } else {
+            // ]NOCPP]
+            return HtmlAttributes.EMPTY_ATTRIBUTES;
+            // [NOCPP[
+        }
+        // ]NOCPP]
+    }
+
+    private void clearStrBufAndAppendCurrentC(char c) {
+        strBuf[0] = c;
+
+        strBufLen = 1;
+        // strBufOffset = pos;
+    }
+
+    private void clearStrBufAndAppendForceWrite(char c) {
+        strBuf[0] = c; // test
+
+        strBufLen = 1;
+        // strBufOffset = pos;
+        // buf[pos] = c;
+    }
+
+    private void clearStrBufForNextState() {
+        strBufLen = 0;
+        // strBufOffset = pos + 1;
+    }
+
+    /**
+     * Appends to the smaller buffer.
+     * 
+     * @param c
+     *            the UTF-16 code unit to append
+     */
+    private void appendStrBuf(char c) {
+        // if (strBufOffset != -1) {
+        // strBufLen++;
+        // } else {
+        if (strBufLen == strBuf.length) {
+            char[] newBuf = new char[strBuf.length + Tokenizer.BUFFER_GROW_BY];
+            System.arraycopy(strBuf, 0, newBuf, 0, strBuf.length);
+            Portability.releaseArray(strBuf);
+            strBuf = newBuf;
+        }
+        strBuf[strBufLen++] = c;
+        // }
+    }
+
+    /**
+     * Appends to the smaller buffer.
+     * 
+     * @param c
+     *            the UTF-16 code unit to append
+     */
+    private void appendStrBufForceWrite(char c) {
+        // if (strBufOffset != -1) {
+        // strBufLen++;
+        // buf[pos] = c;
+        // } else {
+        if (strBufLen == strBuf.length) {
+            char[] newBuf = new char[strBuf.length + Tokenizer.BUFFER_GROW_BY];
+            System.arraycopy(strBuf, 0, newBuf, 0, strBuf.length);
+            Portability.releaseArray(strBuf);
+            strBuf = newBuf;
+        }
+        strBuf[strBufLen++] = c;
+        // }
+    }
+
+    /**
+     * The smaller buffer as a String. Currently only used for error reporting.
+     * 
+     * <p>
+     * C++ memory note: The return value must be released.
+     * 
+     * @return the smaller buffer as a string
+     */
+    protected String strBufToString() {
+        // if (strBufOffset != -1) {
+        // return Portability.newStringFromBuffer(buf, strBufOffset, strBufLen);
+        // } else {
+        return Portability.newStringFromBuffer(strBuf, 0, strBufLen);
+        // }
+    }
+
+    /**
+     * Returns the short buffer as a local name. The return value is released in
+     * emitDoctypeToken().
+     * 
+     * @return the smaller buffer as local name
+     */
+    private void strBufToDoctypeName() {
+        doctypeName = Portability.newLocalNameFromBuffer(strBuf, 0, strBufLen);
+    }
+
+    /**
+     * Emits the smaller buffer as character tokens.
+     * 
+     * @throws SAXException
+     *             if the token handler threw
+     */
+    private void emitStrBuf() throws SAXException {
+        if (strBufLen > 0) {
+            // if (strBufOffset != -1) {
+            // tokenHandler.characters(buf, strBufOffset, strBufLen);
+            // } else {
+            tokenHandler.characters(strBuf, 0, strBufLen);
+            // }
+        }
+    }
+
+    private void clearLongStrBufForNextState() {
+        // longStrBufOffset = pos + 1;
+        longStrBufLen = 0;
+    }
+
+    private void clearLongStrBuf() {
+        // longStrBufOffset = pos;
+        longStrBufLen = 0;
+    }
+
+    private void clearLongStrBufAndAppendCurrentC(char c) {
+        longStrBuf[0] = c;
+        longStrBufLen = 1;
+        // longStrBufOffset = pos;
+    }
+
+    private void clearLongStrBufAndAppendToComment(char c) {
+        longStrBuf[0] = c;
+        // longStrBufOffset = pos;
+        longStrBufLen = 1;
+    }
+
+    /**
+     * Appends to the larger buffer.
+     * 
+     * @param c
+     *            the UTF-16 code unit to append
+     */
+    private void appendLongStrBuf(char c) {
+        // if (longStrBufOffset != -1) {
+        // longStrBufLen++;
+        // } else {
+        if (longStrBufLen == longStrBuf.length) {
+            char[] newBuf = new char[longStrBufLen + (longStrBufLen >> 1)];
+            System.arraycopy(longStrBuf, 0, newBuf, 0, longStrBuf.length);
+            Portability.releaseArray(longStrBuf);
+            longStrBuf = newBuf;
+        }
+        longStrBuf[longStrBufLen++] = c;
+        // }
+    }
+
+    private void appendSecondHyphenToBogusComment() throws SAXException {
+        // [NOCPP[
+        switch (commentPolicy) {
+            case ALTER_INFOSET:
+                // detachLongStrBuf();
+                appendLongStrBuf(' ');
+                // FALLTHROUGH
+            case ALLOW:
+                warn("The document is not mappable to XML 1.0 due to two consecutive hyphens in a comment.");
+                // ]NOCPP]
+                appendLongStrBuf('-');
+                // [NOCPP[
+                break;
+            case FATAL:
+                fatal("The document is not mappable to XML 1.0 due to two consecutive hyphens in a comment.");
+                break;
+        }
+        // ]NOCPP]
+    }
+
+    // [NOCPP[
+    private void maybeAppendSpaceToBogusComment() throws SAXException {
+        switch (commentPolicy) {
+            case ALTER_INFOSET:
+                // detachLongStrBuf();
+                appendLongStrBuf(' ');
+                // FALLTHROUGH
+            case ALLOW:
+                warn("The document is not mappable to XML 1.0 due to a trailing hyphen in a comment.");
+                break;
+            case FATAL:
+                fatal("The document is not mappable to XML 1.0 due to a trailing hyphen in a comment.");
+                break;
+        }
+    }
+
+    // ]NOCPP]
+
+    private void adjustDoubleHyphenAndAppendToLongStrBufAndErr(char c)
+            throws SAXException {
+        errConsecutiveHyphens();
+        // [NOCPP[
+        switch (commentPolicy) {
+            case ALTER_INFOSET:
+                // detachLongStrBuf();
+                longStrBufLen--;
+                appendLongStrBuf(' ');
+                appendLongStrBuf('-');
+                // FALLTHROUGH
+            case ALLOW:
+                warn("The document is not mappable to XML 1.0 due to two consecutive hyphens in a comment.");
+                // ]NOCPP]
+                appendLongStrBuf(c);
+                // [NOCPP[
+                break;
+            case FATAL:
+                fatal("The document is not mappable to XML 1.0 due to two consecutive hyphens in a comment.");
+                break;
+        }
+        // ]NOCPP]
+    }
+
+    private void appendLongStrBuf(char[] buffer, int offset, int length) {
+        int reqLen = longStrBufLen + length;
+        if (longStrBuf.length < reqLen) {
+            char[] newBuf = new char[reqLen + (reqLen >> 1)];
+            System.arraycopy(longStrBuf, 0, newBuf, 0, longStrBuf.length);
+            Portability.releaseArray(longStrBuf);
+            longStrBuf = newBuf;
+        }
+        System.arraycopy(buffer, offset, longStrBuf, longStrBufLen, length);
+        longStrBufLen = reqLen;
+    }
+
+    /**
+     * Appends to the larger buffer.
+     * 
+     * @param arr
+     *            the UTF-16 code units to append
+     */
+    private void appendLongStrBuf(char[] arr) {
+        // assert longStrBufOffset == -1;
+        appendLongStrBuf(arr, 0, arr.length);
+    }
+
+    /**
+     * Append the contents of the smaller buffer to the larger one.
+     */
+    private void appendStrBufToLongStrBuf() {
+        // assert longStrBufOffset == -1;
+        // if (strBufOffset != -1) {
+        // appendLongStrBuf(buf, strBufOffset, strBufLen);
+        // } else {
+        appendLongStrBuf(strBuf, 0, strBufLen);
+        // }
+    }
+
+    /**
+     * The larger buffer as a string.
+     * 
+     * <p>
+     * C++ memory note: The return value must be released.
+     * 
+     * @return the larger buffer as a string
+     */
+    private String longStrBufToString() {
+        // if (longStrBufOffset != -1) {
+        // return Portability.newStringFromBuffer(buf, longStrBufOffset,
+        // longStrBufLen);
+        // } else {
+        return Portability.newStringFromBuffer(longStrBuf, 0, longStrBufLen);
+        // }
+    }
+
+    /**
+     * Emits the current comment token.
+     * 
+     * @param pos
+     *            TODO
+     * 
+     * @throws SAXException
+     */
+    private void emitComment(int provisionalHyphens, int pos)
+            throws SAXException {
+        // [NOCPP[
+        if (wantsComments) {
+            // ]NOCPP]
+            // if (longStrBufOffset != -1) {
+            // tokenHandler.comment(buf, longStrBufOffset, longStrBufLen
+            // - provisionalHyphens);
+            // } else {
+            tokenHandler.comment(longStrBuf, 0, longStrBufLen
+                    - provisionalHyphens);
+            // }
+            // [NOCPP[
+        }
+        // ]NOCPP]
+        cstart = pos + 1;
+    }
+
+    /**
+     * Flushes coalesced character tokens.
+     * 
+     * @param buf
+     *            TODO
+     * @param pos
+     *            TODO
+     * 
+     * @throws SAXException
+     */
+    protected void flushChars(@NoLength char[] buf, int pos)
+            throws SAXException {
+        if (pos > cstart) {
+            tokenHandler.characters(buf, cstart, pos - cstart);
+        }
+        cstart = 0x7fffffff;
+    }
+
+    /**
+     * Reports an condition that would make the infoset incompatible with XML
+     * 1.0 as fatal.
+     * 
+     * @param message
+     *            the message
+     * @throws SAXException
+     * @throws SAXParseException
+     */
+    public void fatal(String message) throws SAXException {
+        SAXParseException spe = new SAXParseException(message, this);
+        if (errorHandler != null) {
+            errorHandler.fatalError(spe);
+        }
+        throw spe;
+    }
+
+    /**
+     * Reports a Parse Error.
+     * 
+     * @param message
+     *            the message
+     * @throws SAXException
+     */
+    public void err(String message) throws SAXException {
+        if (errorHandler == null) {
+            return;
+        }
+        SAXParseException spe = new SAXParseException(message, this);
+        errorHandler.error(spe);
+    }
+
+    public void errTreeBuilder(String message) throws SAXException {
+        ErrorHandler eh = null;
+        if (tokenHandler instanceof TreeBuilder<?>) {
+            TreeBuilder<?> treeBuilder = (TreeBuilder<?>) tokenHandler;
+            eh = treeBuilder.getErrorHandler();
+        }
+        if (eh == null) {
+            eh = errorHandler;
+        }
+        if (eh == null) {
+            return;
+        }
+        SAXParseException spe = new SAXParseException(message, this);
+        eh.error(spe);
+    }
+
+    /**
+     * Reports a warning
+     * 
+     * @param message
+     *            the message
+     * @throws SAXException
+     */
+    public void warn(String message) throws SAXException {
+        if (errorHandler == null) {
+            return;
+        }
+        SAXParseException spe = new SAXParseException(message, this);
+        errorHandler.warning(spe);
+    }
+
+    /**
+     * 
+     */
+    private void resetAttributes() {
+        // [NOCPP[
+        if (newAttributesEachTime) {
+            attributes = null;
+        } else {
+            // ]NOCPP]
+            attributes.clear(mappingLangToXmlLang);
+            // [NOCPP[
+        }
+        // ]NOCPP]
+    }
+
+    private void strBufToElementNameString() {
+        // if (strBufOffset != -1) {
+        // return ElementName.elementNameByBuffer(buf, strBufOffset, strBufLen);
+        // } else {
+        tagName = ElementName.elementNameByBuffer(strBuf, 0, strBufLen);
+        // }
+    }
+
+    private int emitCurrentTagToken(boolean selfClosing, int pos)
+            throws SAXException {
+        cstart = pos + 1;
+        maybeErrSlashInEndTag(selfClosing);
+        stateSave = Tokenizer.DATA;
+        HtmlAttributes attrs = (attributes == null ? HtmlAttributes.EMPTY_ATTRIBUTES
+                : attributes);
+        if (endTag) {
+            /*
+             * When an end tag token is emitted, the content model flag must be
+             * switched to the PCDATA state.
+             */
+            maybeErrAttributesOnEndTag(attrs);
+            tokenHandler.endTag(tagName);
+        } else {
+            tokenHandler.startTag(tagName, attrs, selfClosing);
+        }
+        resetAttributes();
+        return stateSave;
+    }
+
+    private void attributeNameComplete() throws SAXException {
+        // if (strBufOffset != -1) {
+        // attributeName = AttributeName.nameByBuffer(buf, strBufOffset,
+        // strBufLen, namePolicy != XmlViolationPolicy.ALLOW);
+        // } else {
+        attributeName = AttributeName.nameByBuffer(strBuf, 0, strBufLen
+        // [NOCPP[
+                , namePolicy != XmlViolationPolicy.ALLOW
+        // ]NOCPP]
+        );
+        // }
+
+        // [NOCPP[
+        if (attributes == null) {
+            attributes = new HtmlAttributes(mappingLangToXmlLang);
+        }
+        // ]NOCPP]
+
+        /*
+         * When the user agent leaves the attribute name state (and before
+         * emitting the tag token, if appropriate), the complete attribute's
+         * name must be compared to the other attributes on the same token; if
+         * there is already an attribute on the token with the exact same name,
+         * then this is a parse error and the new attribute must be dropped,
+         * along with the value that gets associated with it (if any).
+         */
+        if (attributes.contains(attributeName)) {
+            errDuplicateAttribute();
+            attributeName.release();
+            attributeName = null;
+        }
+    }
+
+    private void addAttributeWithoutValue() throws SAXException {
+        // [NOCPP[
+        if (metaBoundaryPassed && AttributeName.CHARSET == attributeName
+                && ElementName.META == tagName) {
+            err("A \u201Ccharset\u201D attribute on a \u201Cmeta\u201D element found after the first 512 bytes.");
+        }
+        // ]NOCPP]
+        if (attributeName != null) {
+            // [NOCPP[
+            if (html4) {
+                if (attributeName.isBoolean()) {
+                    if (html4ModeCompatibleWithXhtml1Schemata) {
+                        attributes.addAttribute(attributeName,
+                                attributeName.getLocal(AttributeName.HTML),
+                                xmlnsPolicy);
+                    } else {
+                        attributes.addAttribute(attributeName, "", xmlnsPolicy);
+                    }
+                } else {
+                    err("Attribute value omitted for a non-boolean attribute. (HTML4-only error.)");
+                    attributes.addAttribute(attributeName, "", xmlnsPolicy);
+                }
+            } else {
+                if (AttributeName.SRC == attributeName
+                        || AttributeName.HREF == attributeName) {
+                    warn("Attribute \u201C"
+                            + attributeName.getLocal(AttributeName.HTML)
+                            + "\u201D without an explicit value seen. The attribute may be dropped by IE7.");
+                }
+                // ]NOCPP]
+                attributes.addAttribute(attributeName,
+                        Portability.newEmptyString()
+                        // [NOCPP[
+                        , xmlnsPolicy
+                // ]NOCPP]
+                );
+                // [NOCPP[
+            }
+            // ]NOCPP]
+        }
+    }
+
+    private void addAttributeWithValue() throws SAXException {
+        // [NOCPP[
+        if (metaBoundaryPassed && ElementName.META == tagName
+                && AttributeName.CHARSET == attributeName) {
+            err("A \u201Ccharset\u201D attribute on a \u201Cmeta\u201D element found after the first 512 bytes.");
+        }
+        // ]NOCPP]
+        if (attributeName != null) {
+            String value = longStrBufToString(); // Ownership transferred to
+            // HtmlAttributes
+            // [NOCPP[
+            if (!endTag && html4 && html4ModeCompatibleWithXhtml1Schemata
+                    && attributeName.isCaseFolded()) {
+                value = newAsciiLowerCaseStringFromString(value);
+            }
+            // ]NOCPP]
+            attributes.addAttribute(attributeName, value
+            // [NOCPP[
+                    , xmlnsPolicy
+            // ]NOCPP]
+            );
+        }
+    }
+
+    // [NOCPP[
+
+    private static String newAsciiLowerCaseStringFromString(String str) {
+        if (str == null) {
+            return null;
+        }
+        char[] buf = new char[str.length()];
+        for (int i = 0; i < str.length(); i++) {
+            char c = str.charAt(i);
+            if (c >= 'A' && c <= 'Z') {
+                c += 0x20;
+            }
+            buf[i] = c;
+        }
+        return new String(buf);
+    }
+
+    // ]NOCPP]
+
+    protected void startErrorReporting() throws SAXException {
+
+    }
+
+    public void start() throws SAXException {
+        confident = false;
+        strBuf = new char[64];
+        strBufLen = 0;
+        longStrBuf = new char[1024];
+        longStrBufLen = 0;
+        stateSave = Tokenizer.DATA;
+        line = 1;
+        lastCR = false;
+        // [NOCPP[
+        html4 = false;
+        metaBoundaryPassed = false;
+        // ]NOCPP]
+        tokenHandler.startTokenization(this);
+        // [NOCPP[
+        wantsComments = tokenHandler.wantsComments();
+        // ]NOCPP]
+        index = 0;
+        forceQuirks = false;
+        additional = '\u0000';
+        entCol = -1;
+        lo = 0;
+        hi = (NamedCharacters.NAMES.length - 1);
+        candidate = -1;
+        strBufMark = 0;
+        prevValue = -1;
+        value = 0;
+        seenDigits = false;
+        shouldSuspend = false;
+        // [NOCPP[
+        if (!newAttributesEachTime) {
+            // ]NOCPP]
+            attributes = new HtmlAttributes(mappingLangToXmlLang);
+            // [NOCPP[
+        }
+        startErrorReporting();
+        // ]NOCPP]
+    }
+
+    public boolean tokenizeBuffer(UTF16Buffer buffer) throws SAXException {
+        int state = stateSave;
+        int returnState = returnStateSave;
+        char c = '\u0000';
+        shouldSuspend = false;
+        lastCR = false;
+
+        int start = buffer.getStart();
+        /**
+         * The index of the last <code>char</code> read from <code>buf</code>.
+         */
+        int pos = start - 1;
+
+        /**
+         * The index of the first <code>char</code> in <code>buf</code> that is
+         * part of a coalesced run of character tokens or
+         * <code>Integer.MAX_VALUE</code> if there is not a current run being
+         * coalesced.
+         */
+        switch (state) {
+            case DATA:
+            case RCDATA:
+            case CDATA:
+            case PLAINTEXT:
+            case CDATA_SECTION:
+            case ESCAPE:
+            case ESCAPE_EXCLAMATION:
+            case ESCAPE_EXCLAMATION_HYPHEN:
+            case ESCAPE_HYPHEN:
+            case ESCAPE_HYPHEN_HYPHEN:
+                cstart = start;
+                break;
+            default:
+                cstart = Integer.MAX_VALUE;
+                break;
+        }
+
+        /**
+         * The number of <code>char</code>s in <code>buf</code> that have
+         * meaning. (The rest of the array is garbage and should not be
+         * examined.)
+         */
+        pos = stateLoop(state, c, pos, buffer.getBuffer(), false, returnState,
+                buffer.getEnd());
+        if (pos == buffer.getEnd()) {
+            // exiting due to end of buffer
+            buffer.setStart(pos);
+        } else {
+            buffer.setStart(pos + 1);
+        }
+        return lastCR;
+    }
+
+    // WARNING When editing this, makes sure the bytecode length shown by javap
+    // stays under 8000 bytes!
+    private int stateLoop(int state, char c, int pos, @NoLength char[] buf,
+            boolean reconsume, int returnState, int endPos) throws SAXException {
+        stateloop: for (;;) {
+            switch (state) {
+                case DATA:
+                    dataloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        switch (c) {
+                            case '&':
+                                /*
+                                 * U+0026 AMPERSAND (&) When the content model
+                                 * flag is set to one of the PCDATA or RCDATA
+                                 * states and the escape flag is false: switch
+                                 * to the character reference data state.
+                                 * Otherwise: treat it as per the "anything
+                                 * else" entry below.
+                                 */
+                                flushChars(buf, pos);
+                                clearStrBufAndAppendCurrentC(c);
+                                rememberAmpersandLocation('\u0000');
+                                returnState = state;
+                                state = Tokenizer.CONSUME_CHARACTER_REFERENCE;
+                                continue stateloop;
+                            case '<':
+                                /*
+                                 * U+003C LESS-THAN SIGN (<) When the content
+                                 * model flag is set to the PCDATA state: switch
+                                 * to the tag open state. When the content model
+                                 * flag is set to either the RCDATA state or the
+                                 * CDATA state, and the escape flag is false:
+                                 * switch to the tag open state. Otherwise:
+                                 * treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                                flushChars(buf, pos);
+
+                                state = Tokenizer.TAG_OPEN;
+                                break dataloop; // FALL THROUGH continue
+                            // stateloop;
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                continue;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            default:
+                                /*
+                                 * Anything else Emit the input character as a
+                                 * character token.
+                                 */
+                                /*
+                                 * Stay in the data state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case TAG_OPEN:
+                    tagopenloop: for (;;) {
+                        /*
+                         * The behavior of this state depends on the content
+                         * model flag.
+                         */
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * If the content model flag is set to the PCDATA state
+                         * Consume the next input character:
+                         */
+                        if (c >= 'A' && c <= 'Z') {
+                            /*
+                             * U+0041 LATIN CAPITAL LETTER A through to U+005A
+                             * LATIN CAPITAL LETTER Z Create a new start tag
+                             * token,
+                             */
+                            endTag = false;
+                            /*
+                             * set its tag name to the lowercase version of the
+                             * input character (add 0x0020 to the character's
+                             * code point),
+                             */
+                            clearStrBufAndAppendForceWrite((char) (c + 0x20));
+                            /* then switch to the tag name state. */
+                            state = Tokenizer.TAG_NAME;
+                            /*
+                             * (Don't emit the token yet; further details will
+                             * be filled in before it is emitted.)
+                             */
+                            break tagopenloop;
+                            // continue stateloop;
+                        } else if (c >= 'a' && c <= 'z') {
+                            /*
+                             * U+0061 LATIN SMALL LETTER A through to U+007A
+                             * LATIN SMALL LETTER Z Create a new start tag
+                             * token,
+                             */
+                            endTag = false;
+                            /*
+                             * set its tag name to the input character,
+                             */
+                            clearStrBufAndAppendCurrentC(c);
+                            /* then switch to the tag name state. */
+                            state = Tokenizer.TAG_NAME;
+                            /*
+                             * (Don't emit the token yet; further details will
+                             * be filled in before it is emitted.)
+                             */
+                            break tagopenloop;
+                            // continue stateloop;
+                        }
+                        switch (c) {
+                            case '!':
+                                /*
+                                 * U+0021 EXCLAMATION MARK (!) Switch to the
+                                 * markup declaration open state.
+                                 */
+                                state = Tokenizer.MARKUP_DECLARATION_OPEN;
+                                continue stateloop;
+                            case '/':
+                                /*
+                                 * U+002F SOLIDUS (/) Switch to the close tag
+                                 * open state.
+                                 */
+                                state = Tokenizer.CLOSE_TAG_OPEN_PCDATA;
+                                continue stateloop;
+                            case '?':
+                                /*
+                                 * U+003F QUESTION MARK (?) Parse error.
+                                 */
+                                errProcessingInstruction();
+                                /*
+                                 * Switch to the bogus comment state.
+                                 */
+                                clearLongStrBufAndAppendToComment(c);
+                                state = Tokenizer.BOGUS_COMMENT;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Parse error.
+                                 */
+                                errLtGt();
+                                /*
+                                 * Emit a U+003C LESS-THAN SIGN character token
+                                 * and a U+003E GREATER-THAN SIGN character
+                                 * token.
+                                 */
+                                tokenHandler.characters(Tokenizer.LT_GT, 0, 2);
+                                /* Switch to the data state. */
+                                cstart = pos + 1;
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            default:
+                                /*
+                                 * Anything else Parse error.
+                                 */
+                                errBadCharAfterLt(c);
+                                /*
+                                 * Emit a U+003C LESS-THAN SIGN character token
+                                 */
+                                tokenHandler.characters(Tokenizer.LT_GT, 0, 1);
+                                /*
+                                 * and reconsume the current input character in
+                                 * the data state.
+                                 */
+                                cstart = pos;
+                                state = Tokenizer.DATA;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALL THROUGH DON'T REORDER
+                case TAG_NAME:
+                    tagnameloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                strBufToElementNameString();
+                                state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE
+                                 * Switch to the before attribute name state.
+                                 */
+                                strBufToElementNameString();
+                                state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                break tagnameloop;
+                            // continue stateloop;
+                            case '/':
+                                /*
+                                 * U+002F SOLIDUS (/) Switch to the self-closing
+                                 * start tag state.
+                                 */
+                                strBufToElementNameString();
+                                state = Tokenizer.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * tag token.
+                                 */
+                                strBufToElementNameString();
+                                state = emitCurrentTagToken(false, pos);
+                                if (shouldSuspend) {
+                                    break stateloop;
+                                }
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                if (c >= 'A' && c <= 'Z') {
+                                    /*
+                                     * U+0041 LATIN CAPITAL LETTER A through to
+                                     * U+005A LATIN CAPITAL LETTER Z Append the
+                                     * lowercase version of the current input
+                                     * character (add 0x0020 to the character's
+                                     * code point) to the current tag token's
+                                     * tag name.
+                                     */
+                                    c += 0x20;
+                                }
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current tag token's tag
+                                 * name.
+                                 */
+                                appendStrBuf(c);
+                                /*
+                                 * Stay in the tag name state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BEFORE_ATTRIBUTE_NAME:
+                    beforeattributenameloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the before attribute name state.
+                                 */
+                                continue;
+                            case '/':
+                                /*
+                                 * U+002F SOLIDUS (/) Switch to the self-closing
+                                 * start tag state.
+                                 */
+                                state = Tokenizer.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * tag token.
+                                 */
+                                state = emitCurrentTagToken(false, pos);
+                                if (shouldSuspend) {
+                                    break stateloop;
+                                }
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            case '\"':
+                            case '\'':
+                            case '<':
+                            case '=':
+                                /*
+                                 * U+0022 QUOTATION MARK (") U+0027 APOSTROPHE
+                                 * (') U+003C LESS-THAN SIGN (<) U+003D EQUALS
+                                 * SIGN (=) Parse error.
+                                 */
+                                errBadCharBeforeAttributeNameOrNull(c);
+                                /*
+                                 * Treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                            default:
+                                /*
+                                 * Anything else Start a new attribute in the
+                                 * current tag token.
+                                 */
+                                if (c >= 'A' && c <= 'Z') {
+                                    /*
+                                     * U+0041 LATIN CAPITAL LETTER A through to
+                                     * U+005A LATIN CAPITAL LETTER Z Set that
+                                     * attribute's name to the lowercase version
+                                     * of the current input character (add
+                                     * 0x0020 to the character's code point)
+                                     */
+                                    c += 0x20;
+                                }
+                                /*
+                                 * Set that attribute's name to the current
+                                 * input character,
+                                 */
+                                clearStrBufAndAppendCurrentC(c);
+                                /*
+                                 * and its value to the empty string.
+                                 */
+                                // Will do later.
+                                /*
+                                 * Switch to the attribute name state.
+                                 */
+                                state = Tokenizer.ATTRIBUTE_NAME;
+                                break beforeattributenameloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case ATTRIBUTE_NAME:
+                    attributenameloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                attributeNameComplete();
+                                state = Tokenizer.AFTER_ATTRIBUTE_NAME;
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE
+                                 * Switch to the after attribute name state.
+                                 */
+                                attributeNameComplete();
+                                state = Tokenizer.AFTER_ATTRIBUTE_NAME;
+                                continue stateloop;
+                            case '/':
+                                /*
+                                 * U+002F SOLIDUS (/) Switch to the self-closing
+                                 * start tag state.
+                                 */
+                                attributeNameComplete();
+                                addAttributeWithoutValue();
+                                state = Tokenizer.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '=':
+                                /*
+                                 * U+003D EQUALS SIGN (=) Switch to the before
+                                 * attribute value state.
+                                 */
+                                attributeNameComplete();
+                                state = Tokenizer.BEFORE_ATTRIBUTE_VALUE;
+                                break attributenameloop;
+                            // continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * tag token.
+                                 */
+                                attributeNameComplete();
+                                addAttributeWithoutValue();
+                                state = emitCurrentTagToken(false, pos);
+                                if (shouldSuspend) {
+                                    break stateloop;
+                                }
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            case '\"':
+                            case '\'':
+                            case '<':
+                                /*
+                                 * U+0022 QUOTATION MARK (") U+0027 APOSTROPHE
+                                 * (') U+003C LESS-THAN SIGN (<) Parse error.
+                                 */
+                                errQuoteOrLtInAttributeNameOrNull(c);
+                                /*
+                                 * Treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                            default:
+                                if (c >= 'A' && c <= 'Z') {
+                                    /*
+                                     * U+0041 LATIN CAPITAL LETTER A through to
+                                     * U+005A LATIN CAPITAL LETTER Z Append the
+                                     * lowercase version of the current input
+                                     * character (add 0x0020 to the character's
+                                     * code point) to the current attribute's
+                                     * name.
+                                     */
+                                    c += 0x20;
+                                }
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current attribute's name.
+                                 */
+                                appendStrBuf(c);
+                                /*
+                                 * Stay in the attribute name state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BEFORE_ATTRIBUTE_VALUE:
+                    beforeattributevalueloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the before attribute value state.
+                                 */
+                                continue;
+                            case '"':
+                                /*
+                                 * U+0022 QUOTATION MARK (") Switch to the
+                                 * attribute value (double-quoted) state.
+                                 */
+                                clearLongStrBufForNextState();
+                                state = Tokenizer.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
+                                break beforeattributevalueloop;
+                            // continue stateloop;
+                            case '&':
+                                /*
+                                 * U+0026 AMPERSAND (&) Switch to the attribute
+                                 * value (unquoted) state and reconsume this
+                                 * input character.
+                                 */
+                                clearLongStrBuf();
+                                state = Tokenizer.ATTRIBUTE_VALUE_UNQUOTED;
+                                reconsume = true;
+                                continue stateloop;
+                            case '\'':
+                                /*
+                                 * U+0027 APOSTROPHE (') Switch to the attribute
+                                 * value (single-quoted) state.
+                                 */
+                                clearLongStrBufForNextState();
+                                state = Tokenizer.ATTRIBUTE_VALUE_SINGLE_QUOTED;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Parse error.
+                                 */
+                                errAttributeValueMissing();
+                                /*
+                                 * Emit the current tag token.
+                                 */
+                                addAttributeWithoutValue();
+                                state = emitCurrentTagToken(false, pos);
+                                if (shouldSuspend) {
+                                    break stateloop;
+                                }
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            case '<':
+                            case '=':
+                                /*
+                                 * U+003D EQUALS SIGN (=) Parse error.
+                                 */
+                                errLtOrEqualsInUnquotedAttributeOrNull(c);
+                                /*
+                                 * Treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                            default:
+                                // [NOCPP[
+                                errHtml4NonNameInUnquotedAttribute(c);
+                                // ]NOCPP]
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current attribute's value.
+                                 */
+                                clearLongStrBufAndAppendCurrentC(c);
+                                /*
+                                 * Switch to the attribute value (unquoted)
+                                 * state.
+                                 */
+
+                                state = Tokenizer.ATTRIBUTE_VALUE_UNQUOTED;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case ATTRIBUTE_VALUE_DOUBLE_QUOTED:
+                    attributevaluedoublequotedloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '"':
+                                /*
+                                 * U+0022 QUOTATION MARK (") Switch to the after
+                                 * attribute value (quoted) state.
+                                 */
+                                addAttributeWithValue();
+
+                                state = Tokenizer.AFTER_ATTRIBUTE_VALUE_QUOTED;
+                                break attributevaluedoublequotedloop;
+                            // continue stateloop;
+                            case '&':
+                                /*
+                                 * U+0026 AMPERSAND (&) Switch to the character
+                                 * reference in attribute value state, with the
+                                 * additional allowed character being U+0022
+                                 * QUOTATION MARK (").
+                                 */
+                                clearStrBufAndAppendCurrentC(c);
+                                rememberAmpersandLocation('\"');
+                                returnState = state;
+                                state = Tokenizer.CONSUME_CHARACTER_REFERENCE;
+                                continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current attribute's value.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the attribute value (double-quoted)
+                                 * state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case AFTER_ATTRIBUTE_VALUE_QUOTED:
+                    afterattributevaluequotedloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE
+                                 * Switch to the before attribute name state.
+                                 */
+                                state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                continue stateloop;
+                            case '/':
+                                /*
+                                 * U+002F SOLIDUS (/) Switch to the self-closing
+                                 * start tag state.
+                                 */
+                                state = Tokenizer.SELF_CLOSING_START_TAG;
+                                break afterattributevaluequotedloop;
+                            // continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * tag token.
+                                 */
+                                state = emitCurrentTagToken(false, pos);
+                                if (shouldSuspend) {
+                                    break stateloop;
+                                }
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                continue stateloop;
+                            default:
+                                /*
+                                 * Anything else Parse error.
+                                 */
+                                errNoSpaceBetweenAttributes();
+                                /*
+                                 * Reconsume the character in the before
+                                 * attribute name state.
+                                 */
+                                state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case SELF_CLOSING_START_TAG:
+                    if (++pos == endPos) {
+                        break stateloop;
+                    }
+                    c = checkChar(buf, pos);
+                    /*
+                     * Consume the next input character:
+                     */
+                    switch (c) {
+                        case '>':
+                            /*
+                             * U+003E GREATER-THAN SIGN (>) Set the self-closing
+                             * flag of the current tag token. Emit the current
+                             * tag token.
+                             */
+                            // [NOCPP[
+                            errHtml4XmlVoidSyntax();
+                            // ]NOCPP]
+                            state = emitCurrentTagToken(true, pos);
+                            if (shouldSuspend) {
+                                break stateloop;
+                            }
+                            /*
+                             * Switch to the data state.
+                             */
+                            continue stateloop;
+                        default:
+                            /* Anything else Parse error. */
+                            errSlashNotFollowedByGt();
+                            /*
+                             * Reconsume the character in the before attribute
+                             * name state.
+                             */
+                            state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                            reconsume = true;
+                            continue stateloop;
+                    }
+                    // XXX reorder point
+                case ATTRIBUTE_VALUE_UNQUOTED:
+                    for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                addAttributeWithValue();
+                                state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE
+                                 * Switch to the before attribute name state.
+                                 */
+                                addAttributeWithValue();
+                                state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                continue stateloop;
+                            case '&':
+                                /*
+                                 * U+0026 AMPERSAND (&) Switch to the character
+                                 * reference in attribute value state, with no +
+                                 * additional allowed character.
+                                 */
+                                clearStrBufAndAppendCurrentC(c);
+                                rememberAmpersandLocation('\u0000');
+                                returnState = state;
+                                state = Tokenizer.CONSUME_CHARACTER_REFERENCE;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * tag token.
+                                 */
+                                addAttributeWithValue();
+                                state = emitCurrentTagToken(false, pos);
+                                if (shouldSuspend) {
+                                    break stateloop;
+                                }
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            case '<':
+                            case '\"':
+                            case '\'':
+                            case '=':
+                                /*
+                                 * U+0022 QUOTATION MARK (") U+0027 APOSTROPHE
+                                 * (') U+003D EQUALS SIGN (=) Parse error.
+                                 */
+                                errUnquotedAttributeValOrNull(c);
+                                /*
+                                 * Treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                                // fall through
+                            default:
+                                // [NOCPP]
+                                errHtml4NonNameInUnquotedAttribute(c);
+                                // ]NOCPP]
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current attribute's value.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the attribute value (unquoted) state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // XXX reorder point
+                case AFTER_ATTRIBUTE_NAME:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the after attribute name state.
+                                 */
+                                continue;
+                            case '/':
+                                /*
+                                 * U+002F SOLIDUS (/) Switch to the self-closing
+                                 * start tag state.
+                                 */
+                                addAttributeWithoutValue();
+                                state = Tokenizer.SELF_CLOSING_START_TAG;
+                                continue stateloop;
+                            case '=':
+                                /*
+                                 * U+003D EQUALS SIGN (=) Switch to the before
+                                 * attribute value state.
+                                 */
+                                state = Tokenizer.BEFORE_ATTRIBUTE_VALUE;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * tag token.
+                                 */
+                                addAttributeWithoutValue();
+                                state = emitCurrentTagToken(false, pos);
+                                if (shouldSuspend) {
+                                    break stateloop;
+                                }
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            case '\"':
+                            case '\'':
+                            case '<':
+                                errQuoteOrLtInAttributeNameOrNull(c);
+                                /*
+                                 * Treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                            default:
+                                addAttributeWithoutValue();
+                                /*
+                                 * Anything else Start a new attribute in the
+                                 * current tag token.
+                                 */
+                                if (c >= 'A' && c <= 'Z') {
+                                    /*
+                                     * U+0041 LATIN CAPITAL LETTER A through to
+                                     * U+005A LATIN CAPITAL LETTER Z Set that
+                                     * attribute's name to the lowercase version
+                                     * of the current input character (add
+                                     * 0x0020 to the character's code point)
+                                     */
+                                    c += 0x20;
+                                }
+                                /*
+                                 * Set that attribute's name to the current
+                                 * input character,
+                                 */
+                                clearStrBufAndAppendCurrentC(c);
+                                /*
+                                 * and its value to the empty string.
+                                 */
+                                // Will do later.
+                                /*
+                                 * Switch to the attribute name state.
+                                 */
+                                state = Tokenizer.ATTRIBUTE_NAME;
+                                continue stateloop;
+                        }
+                    }
+                    // XXX reorder point
+                case BOGUS_COMMENT:
+                    boguscommentloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * (This can only happen if the content model flag is
+                         * set to the PCDATA state.)
+                         * 
+                         * Consume every character up to and including the first
+                         * U+003E GREATER-THAN SIGN character (>) or the end of
+                         * the file (EOF), whichever comes first. Emit a comment
+                         * token whose data is the concatenation of all the
+                         * characters starting from and including the character
+                         * that caused the state machine to switch into the
+                         * bogus comment state, up to and including the
+                         * character immediately before the last consumed
+                         * character (i.e. up to the character just before the
+                         * U+003E or EOF character). (If the comment was started
+                         * by the end of the file (EOF), the token is empty.)
+                         * 
+                         * Switch to the data state.
+                         * 
+                         * If the end of the file was reached, reconsume the EOF
+                         * character.
+                         */
+                        switch (c) {
+                            case '>':
+                                emitComment(0, pos);
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '-':
+                                appendLongStrBuf(c);
+                                state = Tokenizer.BOGUS_COMMENT_HYPHEN;
+                                break boguscommentloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                appendLongStrBuf(c);
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BOGUS_COMMENT_HYPHEN:
+                    boguscommenthyphenloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '>':
+                                // [NOCPP[
+                                maybeAppendSpaceToBogusComment();
+                                // ]NOCPP]
+                                emitComment(0, pos);
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '-':
+                                appendSecondHyphenToBogusComment();
+                                continue boguscommenthyphenloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                state = Tokenizer.BOGUS_COMMENT;
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                state = Tokenizer.BOGUS_COMMENT;
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                appendLongStrBuf(c);
+                                state = Tokenizer.BOGUS_COMMENT;
+                                continue stateloop;
+                        }
+                    }
+                    // XXX reorder point
+                case MARKUP_DECLARATION_OPEN:
+                    markupdeclarationopenloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * (This can only happen if the content model flag is
+                         * set to the PCDATA state.)
+                         * 
+                         * If the next two characters are both U+002D
+                         * HYPHEN-MINUS (-) characters, consume those two
+                         * characters, create a comment token whose data is the
+                         * empty string, and switch to the comment start state.
+                         * 
+                         * Otherwise, if the next seven characters are an ASCII
+                         * case-insensitive match for the word "DOCTYPE", then
+                         * consume those characters and switch to the DOCTYPE
+                         * state.
+                         * 
+                         * Otherwise, if the insertion mode is "in foreign
+                         * content" and the current node is not an element in
+                         * the HTML namespace and the next seven characters are
+                         * an ASCII case-sensitive match for the string
+                         * "[CDATA[" (the five uppercase letters "CDATA" with a
+                         * U+005B LEFT SQUARE BRACKET character before and
+                         * after), then consume those characters and switch to
+                         * the CDATA section state (which is unrelated to the
+                         * content model flag's CDATA state).
+                         * 
+                         * Otherwise, is is a parse error. Switch to the bogus
+                         * comment state. The next character that is consumed,
+                         * if any, is the first character that will be in the
+                         * comment.
+                         */
+                        switch (c) {
+                            case '-':
+                                clearLongStrBufAndAppendToComment(c);
+                                state = Tokenizer.MARKUP_DECLARATION_HYPHEN;
+                                break markupdeclarationopenloop;
+                            // continue stateloop;
+                            case 'd':
+                            case 'D':
+                                clearLongStrBufAndAppendToComment(c);
+                                index = 0;
+                                state = Tokenizer.MARKUP_DECLARATION_OCTYPE;
+                                continue stateloop;
+                            case '[':
+                                if (tokenHandler.inForeign()) {
+                                    clearLongStrBufAndAppendToComment(c);
+                                    index = 0;
+                                    state = Tokenizer.CDATA_START;
+                                    continue stateloop;
+                                } else {
+                                    // fall through
+                                }
+                            default:
+                                errBogusComment();
+                                clearLongStrBuf();
+                                state = Tokenizer.BOGUS_COMMENT;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case MARKUP_DECLARATION_HYPHEN:
+                    markupdeclarationhyphenloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '\u0000':
+                                break stateloop;
+                            case '-':
+                                clearLongStrBufForNextState();
+                                state = Tokenizer.COMMENT_START;
+                                break markupdeclarationhyphenloop;
+                            // continue stateloop;
+                            default:
+                                errBogusComment();
+                                state = Tokenizer.BOGUS_COMMENT;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT_START:
+                    commentstartloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Comment start state
+                         * 
+                         * 
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '-':
+                                /*
+                                 * U+002D HYPHEN-MINUS (-) Switch to the comment
+                                 * start dash state.
+                                 */
+                                appendLongStrBuf(c);
+                                state = Tokenizer.COMMENT_START_DASH;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Parse error.
+                                 */
+                                errPrematureEndOfComment();
+                                /* Emit the comment token. */
+                                emitComment(0, pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                state = Tokenizer.COMMENT;
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                state = Tokenizer.COMMENT;
+                                break commentstartloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the input character to
+                                 * the comment token's data.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Switch to the comment state.
+                                 */
+                                state = Tokenizer.COMMENT;
+                                break commentstartloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT:
+                    commentloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Comment state Consume the next input character:
+                         */
+                        switch (c) {
+                            case '-':
+                                /*
+                                 * U+002D HYPHEN-MINUS (-) Switch to the comment
+                                 * end dash state
+                                 */
+                                appendLongStrBuf(c);
+                                state = Tokenizer.COMMENT_END_DASH;
+                                break commentloop;
+                            // continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the input character to
+                                 * the comment token's data.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the comment state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT_END_DASH:
+                    commentenddashloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Comment end dash state Consume the next input
+                         * character:
+                         */
+                        switch (c) {
+                            case '-':
+                                /*
+                                 * U+002D HYPHEN-MINUS (-) Switch to the comment
+                                 * end state
+                                 */
+                                appendLongStrBuf(c);
+                                state = Tokenizer.COMMENT_END;
+                                break commentenddashloop;
+                            // continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                state = Tokenizer.COMMENT;
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                state = Tokenizer.COMMENT;
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append a U+002D HYPHEN-MINUS
+                                 * (-) character and the input character to the
+                                 * comment token's data.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Switch to the comment state.
+                                 */
+                                state = Tokenizer.COMMENT;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case COMMENT_END:
+                    commentendloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Comment end dash state Consume the next input
+                         * character:
+                         */
+                        switch (c) {
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the comment
+                                 * token.
+                                 */
+                                emitComment(2, pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '-':
+                                /* U+002D HYPHEN-MINUS (-) Parse error. */
+                                /*
+                                 * Append a U+002D HYPHEN-MINUS (-) character to
+                                 * the comment token's data.
+                                 */
+                                adjustDoubleHyphenAndAppendToLongStrBufAndErr(c);
+                                /*
+                                 * Stay in the comment end state.
+                                 */
+                                continue;
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * Parse error. Append two U+002D HYPHEN-MINUS
+                                 * (-) characters and the input character to the
+                                 * comment token's data. Switch to the comment
+                                 * end space state.
+                                 */
+                                adjustDoubleHyphenAndAppendToLongStrBufAndErr(c);
+                                state = Tokenizer.COMMENT_END_SPACE;
+                                break commentendloop;
+                            // continue stateloop;
+                            case '\r':
+                                adjustDoubleHyphenAndAppendToLongStrBufCarriageReturn();
+                                state = Tokenizer.COMMENT_END_SPACE;
+                                break stateloop;
+                            case '\n':
+                                adjustDoubleHyphenAndAppendToLongStrBufLineFeed();
+                                state = Tokenizer.COMMENT_END_SPACE;
+                                break commentendloop;
+                            // continue stateloop;
+                            case '!':
+                                errHyphenHyphenBang();
+                                appendLongStrBuf(c);
+                                state = Tokenizer.COMMENT_END_BANG;
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Append two U+002D HYPHEN-MINUS (-) characters
+                                 * and the input character to the comment
+                                 * token's data.
+                                 */
+                                adjustDoubleHyphenAndAppendToLongStrBufAndErr(c);
+                                /*
+                                 * Switch to the comment state.
+                                 */
+                                state = Tokenizer.COMMENT;
+                                continue stateloop;
+                        }
+                    }
+                case COMMENT_END_SPACE:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Comment end space state
+                         * 
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the comment
+                                 * token.
+                                 */
+                                emitComment(0, pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '-':
+                                /*
+                                 * U+002D HYPHEN-MINUS (-) Switch to the comment
+                                 * end dash state.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Switch to the comment end dash state.
+                                 */
+                                state = Tokenizer.COMMENT_END_DASH;
+                                continue stateloop;
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE
+                                 * Append the input character to the comment
+                                 * token's data. Stay in the comment end space
+                                 * state.
+                                 */
+                                appendLongStrBuf(c);
+                                continue;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the input character to
+                                 * the comment token's data. Switch to the
+                                 * comment state.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Switch to the comment state.
+                                 */
+                                state = Tokenizer.COMMENT;
+                                continue stateloop;
+                        }
+                    }
+                    // XXX reorder point
+                case COMMENT_END_BANG:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Comment end bang state
+                         * 
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the comment
+                                 * token.
+                                 */
+                                emitComment(3, pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '-':
+                                /*
+                                 * Append two U+002D HYPHEN-MINUS (-) characters
+                                 * and a U+0021 EXCLAMATION MARK (!) character
+                                 * to the comment token's data.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Switch to the comment end dash state.
+                                 */
+                                state = Tokenizer.COMMENT_END_DASH;
+                                continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append two U+002D HYPHEN-MINUS
+                                 * (-) characters, a U+0021 EXCLAMATION MARK (!)
+                                 * character, and the input character to the
+                                 * comment token's data. Switch to the comment
+                                 * state.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Switch to the comment state.
+                                 */
+                                state = Tokenizer.COMMENT;
+                                continue stateloop;
+                        }
+                    }
+                    // XXX reorder point
+                case COMMENT_START_DASH:
+                    if (++pos == endPos) {
+                        break stateloop;
+                    }
+                    c = checkChar(buf, pos);
+                    /*
+                     * Comment start dash state
+                     * 
+                     * Consume the next input character:
+                     */
+                    switch (c) {
+                        case '-':
+                            /*
+                             * U+002D HYPHEN-MINUS (-) Switch to the comment end
+                             * state
+                             */
+                            appendLongStrBuf(c);
+                            state = Tokenizer.COMMENT_END;
+                            continue stateloop;
+                        case '>':
+                            errPrematureEndOfComment();
+                            /* Emit the comment token. */
+                            emitComment(1, pos);
+                            /*
+                             * Switch to the data state.
+                             */
+                            state = Tokenizer.DATA;
+                            continue stateloop;
+                        case '\r':
+                            appendLongStrBufCarriageReturn();
+                            state = Tokenizer.COMMENT;
+                            break stateloop;
+                        case '\n':
+                            appendLongStrBufLineFeed();
+                            state = Tokenizer.COMMENT;
+                            continue stateloop;
+                        case '\u0000':
+                            c = '\uFFFD';
+                            // fall thru
+                        default:
+                            /*
+                             * Anything else Append a U+002D HYPHEN-MINUS (-)
+                             * character and the input character to the comment
+                             * token's data.
+                             */
+                            appendLongStrBuf(c);
+                            /*
+                             * Switch to the comment state.
+                             */
+                            state = Tokenizer.COMMENT;
+                            continue stateloop;
+                    }
+                    // XXX reorder point
+                case MARKUP_DECLARATION_OCTYPE:
+                    markupdeclarationdoctypeloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        if (index < 6) { // OCTYPE.length
+                            char folded = c;
+                            if (c >= 'A' && c <= 'Z') {
+                                folded += 0x20;
+                            }
+                            if (folded == Tokenizer.OCTYPE[index]) {
+                                appendLongStrBuf(c);
+                            } else {
+                                errBogusComment();
+                                state = Tokenizer.BOGUS_COMMENT;
+                                reconsume = true;
+                                continue stateloop;
+                            }
+                            index++;
+                            continue;
+                        } else {
+                            state = Tokenizer.DOCTYPE;
+                            reconsume = true;
+                            break markupdeclarationdoctypeloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case DOCTYPE:
+                    doctypeloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        initDoctypeFields();
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                state = Tokenizer.BEFORE_DOCTYPE_NAME;
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE
+                                 * Switch to the before DOCTYPE name state.
+                                 */
+                                state = Tokenizer.BEFORE_DOCTYPE_NAME;
+                                break doctypeloop;
+                            // continue stateloop;
+                            default:
+                                /*
+                                 * Anything else Parse error.
+                                 */
+                                errMissingSpaceBeforeDoctypeName();
+                                /*
+                                 * Reconsume the current character in the before
+                                 * DOCTYPE name state.
+                                 */
+                                state = Tokenizer.BEFORE_DOCTYPE_NAME;
+                                reconsume = true;
+                                break doctypeloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BEFORE_DOCTYPE_NAME:
+                    beforedoctypenameloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the before DOCTYPE name state.
+                                 */
+                                continue;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Parse error.
+                                 */
+                                errNamelessDoctype();
+                                /*
+                                 * Create a new DOCTYPE token. Set its
+                                 * force-quirks flag to on.
+                                 */
+                                forceQuirks = true;
+                                /*
+                                 * Emit the token.
+                                 */
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                if (c >= 'A' && c <= 'Z') {
+                                    /*
+                                     * U+0041 LATIN CAPITAL LETTER A through to
+                                     * U+005A LATIN CAPITAL LETTER Z Create a
+                                     * new DOCTYPE token. Set the token's name
+                                     * to the lowercase version of the input
+                                     * character (add 0x0020 to the character's
+                                     * code point).
+                                     */
+                                    c += 0x20;
+                                }
+                                /* Anything else Create a new DOCTYPE token. */
+                                /*
+                                 * Set the token's name name to the current
+                                 * input character.
+                                 */
+                                clearStrBufAndAppendCurrentC(c);
+                                /*
+                                 * Switch to the DOCTYPE name state.
+                                 */
+                                state = Tokenizer.DOCTYPE_NAME;
+                                break beforedoctypenameloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case DOCTYPE_NAME:
+                    doctypenameloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                strBufToDoctypeName();
+                                state = Tokenizer.AFTER_DOCTYPE_NAME;
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE
+                                 * Switch to the after DOCTYPE name state.
+                                 */
+                                strBufToDoctypeName();
+                                state = Tokenizer.AFTER_DOCTYPE_NAME;
+                                break doctypenameloop;
+                            // continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * DOCTYPE token.
+                                 */
+                                strBufToDoctypeName();
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * U+0041 LATIN CAPITAL LETTER A through to
+                                 * U+005A LATIN CAPITAL LETTER Z Append the
+                                 * lowercase version of the input character (add
+                                 * 0x0020 to the character's code point) to the
+                                 * current DOCTYPE token's name.
+                                 */
+                                if (c >= 'A' && c <= 'Z') {
+                                    c += 0x0020;
+                                }
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current DOCTYPE token's
+                                 * name.
+                                 */
+                                appendStrBuf(c);
+                                /*
+                                 * Stay in the DOCTYPE name state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case AFTER_DOCTYPE_NAME:
+                    afterdoctypenameloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the after DOCTYPE name state.
+                                 */
+                                continue;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * DOCTYPE token.
+                                 */
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case 'p':
+                            case 'P':
+                                index = 0;
+                                state = Tokenizer.DOCTYPE_UBLIC;
+                                break afterdoctypenameloop;
+                            // continue stateloop;
+                            case 's':
+                            case 'S':
+                                index = 0;
+                                state = Tokenizer.DOCTYPE_YSTEM;
+                                continue stateloop;
+                            default:
+                                /*
+                                 * Otherwise, this is the parse error.
+                                 */
+                                bogusDoctype();
+
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                // done by bogusDoctype();
+                                /*
+                                 * Switch to the bogus DOCTYPE state.
+                                 */
+                                state = Tokenizer.BOGUS_DOCTYPE;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case DOCTYPE_UBLIC:
+                    doctypeublicloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * If the six characters starting from the current input
+                         * character are an ASCII case-insensitive match for the
+                         * word "PUBLIC", then consume those characters and
+                         * switch to the before DOCTYPE public identifier state.
+                         */
+                        if (index < 5) { // UBLIC.length
+                            char folded = c;
+                            if (c >= 'A' && c <= 'Z') {
+                                folded += 0x20;
+                            }
+                            if (folded != Tokenizer.UBLIC[index]) {
+                                bogusDoctype();
+                                // forceQuirks = true;
+                                state = Tokenizer.BOGUS_DOCTYPE;
+                                reconsume = true;
+                                continue stateloop;
+                            }
+                            index++;
+                            continue;
+                        } else {
+                            state = Tokenizer.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
+                            reconsume = true;
+                            break doctypeublicloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:
+                    beforedoctypepublicidentifierloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the before DOCTYPE public identifier
+                                 * state.
+                                 */
+                                continue;
+                            case '"':
+                                /*
+                                 * U+0022 QUOTATION MARK (") Set the DOCTYPE
+                                 * token's public identifier to the empty string
+                                 * (not missing),
+                                 */
+                                clearLongStrBufForNextState();
+                                /*
+                                 * then switch to the DOCTYPE public identifier
+                                 * (double-quoted) state.
+                                 */
+                                state = Tokenizer.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
+                                break beforedoctypepublicidentifierloop;
+                            // continue stateloop;
+                            case '\'':
+                                /*
+                                 * U+0027 APOSTROPHE (') Set the DOCTYPE token's
+                                 * public identifier to the empty string (not
+                                 * missing),
+                                 */
+                                clearLongStrBufForNextState();
+                                /*
+                                 * then switch to the DOCTYPE public identifier
+                                 * (single-quoted) state.
+                                 */
+                                state = Tokenizer.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
+                                continue stateloop;
+                            case '>':
+                                /* U+003E GREATER-THAN SIGN (>) Parse error. */
+                                errExpectedPublicId();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                forceQuirks = true;
+                                /*
+                                 * Emit that DOCTYPE token.
+                                 */
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            default:
+                                bogusDoctype();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                // done by bogusDoctype();
+                                /*
+                                 * Switch to the bogus DOCTYPE state.
+                                 */
+                                state = Tokenizer.BOGUS_DOCTYPE;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:
+                    doctypepublicidentifierdoublequotedloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '"':
+                                /*
+                                 * U+0022 QUOTATION MARK (") Switch to the after
+                                 * DOCTYPE public identifier state.
+                                 */
+                                publicIdentifier = longStrBufToString();
+                                state = Tokenizer.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
+                                break doctypepublicidentifierdoublequotedloop;
+                            // continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Parse error.
+                                 */
+                                errGtInPublicId();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                forceQuirks = true;
+                                /*
+                                 * Emit that DOCTYPE token.
+                                 */
+                                publicIdentifier = longStrBufToString();
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current DOCTYPE token's
+                                 * public identifier.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the DOCTYPE public identifier
+                                 * (double-quoted) state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case AFTER_DOCTYPE_PUBLIC_IDENTIFIER:
+                    afterdoctypepublicidentifierloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the after DOCTYPE public identifier state.
+                                 */
+                                continue;
+                            case '"':
+                                /*
+                                 * U+0022 QUOTATION MARK (") Set the DOCTYPE
+                                 * token's system identifier to the empty string
+                                 * (not missing),
+                                 */
+                                clearLongStrBufForNextState();
+                                /*
+                                 * then switch to the DOCTYPE system identifier
+                                 * (double-quoted) state.
+                                 */
+                                state = Tokenizer.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
+                                break afterdoctypepublicidentifierloop;
+                            // continue stateloop;
+                            case '\'':
+                                /*
+                                 * U+0027 APOSTROPHE (') Set the DOCTYPE token's
+                                 * system identifier to the empty string (not
+                                 * missing),
+                                 */
+                                clearLongStrBufForNextState();
+                                /*
+                                 * then switch to the DOCTYPE system identifier
+                                 * (single-quoted) state.
+                                 */
+                                state = Tokenizer.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * DOCTYPE token.
+                                 */
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            default:
+                                bogusDoctype();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                // done by bogusDoctype();
+                                /*
+                                 * Switch to the bogus DOCTYPE state.
+                                 */
+                                state = Tokenizer.BOGUS_DOCTYPE;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:
+                    doctypesystemidentifierdoublequotedloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '"':
+                                /*
+                                 * U+0022 QUOTATION MARK (") Switch to the after
+                                 * DOCTYPE system identifier state.
+                                 */
+                                systemIdentifier = longStrBufToString();
+                                state = Tokenizer.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
+                                continue stateloop;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Parse error.
+                                 */
+                                errGtInSystemId();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                forceQuirks = true;
+                                /*
+                                 * Emit that DOCTYPE token.
+                                 */
+                                systemIdentifier = longStrBufToString();
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current DOCTYPE token's
+                                 * system identifier.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the DOCTYPE system identifier
+                                 * (double-quoted) state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case AFTER_DOCTYPE_SYSTEM_IDENTIFIER:
+                    afterdoctypesystemidentifierloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the after DOCTYPE system identifier state.
+                                 */
+                                continue;
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit the current
+                                 * DOCTYPE token.
+                                 */
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            default:
+                                /*
+                                 * Switch to the bogus DOCTYPE state. (This does
+                                 * not set the DOCTYPE token's force-quirks flag
+                                 * to on.)
+                                 */
+                                bogusDoctypeWithoutQuirks();
+                                state = Tokenizer.BOGUS_DOCTYPE;
+                                break afterdoctypesystemidentifierloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BOGUS_DOCTYPE:
+                    for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '>':
+                                /*
+                                 * U+003E GREATER-THAN SIGN (>) Emit that
+                                 * DOCTYPE token.
+                                 */
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Stay in the bogus DOCTYPE
+                                 * state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // XXX reorder point
+                case DOCTYPE_YSTEM:
+                    doctypeystemloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Otherwise, if the six characters starting from the
+                         * current input character are an ASCII case-insensitive
+                         * match for the word "SYSTEM", then consume those
+                         * characters and switch to the before DOCTYPE system
+                         * identifier state.
+                         */
+                        if (index < 5) { // YSTEM.length
+                            char folded = c;
+                            if (c >= 'A' && c <= 'Z') {
+                                folded += 0x20;
+                            }
+                            if (folded != Tokenizer.YSTEM[index]) {
+                                bogusDoctype();
+                                state = Tokenizer.BOGUS_DOCTYPE;
+                                reconsume = true;
+                                continue stateloop;
+                            }
+                            index++;
+                            continue stateloop;
+                        } else {
+                            state = Tokenizer.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
+                            reconsume = true;
+                            break doctypeystemloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:
+                    beforedoctypesystemidentifierloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\r':
+                                silentCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            case ' ':
+                            case '\t':
+                            case '\u000C':
+                                /*
+                                 * U+0009 CHARACTER TABULATION U+000A LINE FEED
+                                 * (LF) U+000C FORM FEED (FF) U+0020 SPACE Stay
+                                 * in the before DOCTYPE system identifier
+                                 * state.
+                                 */
+                                continue;
+                            case '"':
+                                /*
+                                 * U+0022 QUOTATION MARK (") Set the DOCTYPE
+                                 * token's system identifier to the empty string
+                                 * (not missing),
+                                 */
+                                clearLongStrBufForNextState();
+                                /*
+                                 * then switch to the DOCTYPE system identifier
+                                 * (double-quoted) state.
+                                 */
+                                state = Tokenizer.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
+                                continue stateloop;
+                            case '\'':
+                                /*
+                                 * U+0027 APOSTROPHE (') Set the DOCTYPE token's
+                                 * system identifier to the empty string (not
+                                 * missing),
+                                 */
+                                clearLongStrBufForNextState();
+                                /*
+                                 * then switch to the DOCTYPE system identifier
+                                 * (single-quoted) state.
+                                 */
+                                state = Tokenizer.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
+                                break beforedoctypesystemidentifierloop;
+                            // continue stateloop;
+                            case '>':
+                                /* U+003E GREATER-THAN SIGN (>) Parse error. */
+                                errExpectedSystemId();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                forceQuirks = true;
+                                /*
+                                 * Emit that DOCTYPE token.
+                                 */
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            default:
+                                bogusDoctype();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                // done by bogusDoctype();
+                                /*
+                                 * Switch to the bogus DOCTYPE state.
+                                 */
+                                state = Tokenizer.BOGUS_DOCTYPE;
+                                continue stateloop;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\'':
+                                /*
+                                 * U+0027 APOSTROPHE (') Switch to the after
+                                 * DOCTYPE system identifier state.
+                                 */
+                                systemIdentifier = longStrBufToString();
+                                state = Tokenizer.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
+                                continue stateloop;
+                            case '>':
+                                errGtInSystemId();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                forceQuirks = true;
+                                /*
+                                 * Emit that DOCTYPE token.
+                                 */
+                                systemIdentifier = longStrBufToString();
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current DOCTYPE token's
+                                 * system identifier.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the DOCTYPE system identifier
+                                 * (double-quoted) state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // XXX reorder point
+                case DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\'':
+                                /*
+                                 * U+0027 APOSTROPHE (') Switch to the after
+                                 * DOCTYPE public identifier state.
+                                 */
+                                publicIdentifier = longStrBufToString();
+                                state = Tokenizer.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
+                                continue stateloop;
+                            case '>':
+                                errGtInPublicId();
+                                /*
+                                 * Set the DOCTYPE token's force-quirks flag to
+                                 * on.
+                                 */
+                                forceQuirks = true;
+                                /*
+                                 * Emit that DOCTYPE token.
+                                 */
+                                publicIdentifier = longStrBufToString();
+                                emitDoctypeToken(pos);
+                                /*
+                                 * Switch to the data state.
+                                 */
+                                state = Tokenizer.DATA;
+                                continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current DOCTYPE token's
+                                 * public identifier.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the DOCTYPE public identifier
+                                 * (single-quoted) state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // XXX reorder point
+                case CDATA_START:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        if (index < 6) { // CDATA_LSQB.length
+                            if (c == Tokenizer.CDATA_LSQB[index]) {
+                                appendLongStrBuf(c);
+                            } else {
+                                errBogusComment();
+                                state = Tokenizer.BOGUS_COMMENT;
+                                reconsume = true;
+                                continue stateloop;
+                            }
+                            index++;
+                            continue;
+                        } else {
+                            cstart = pos; // start coalescing
+                            state = Tokenizer.CDATA_SECTION;
+                            reconsume = true;
+                            break; // FALL THROUGH continue stateloop;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case CDATA_SECTION:
+                    cdatasectionloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        switch (c) {
+                            case ']':
+                                flushChars(buf, pos);
+                                state = Tokenizer.CDATA_RSQB;
+                                break cdatasectionloop; // FALL THROUGH
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                continue;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                                // fall thru
+                            default:
+                                continue;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case CDATA_RSQB:
+                    cdatarsqb: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case ']':
+                                state = Tokenizer.CDATA_RSQB_RSQB;
+                                break cdatarsqb;
+                            default:
+                                tokenHandler.characters(Tokenizer.RSQB_RSQB, 0,
+                                        1);
+                                cstart = pos;
+                                state = Tokenizer.CDATA_SECTION;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case CDATA_RSQB_RSQB:
+                    if (++pos == endPos) {
+                        break stateloop;
+                    }
+                    c = checkChar(buf, pos);
+                    switch (c) {
+                        case '>':
+                            cstart = pos + 1;
+                            state = Tokenizer.DATA;
+                            continue stateloop;
+                        default:
+                            tokenHandler.characters(Tokenizer.RSQB_RSQB, 0, 2);
+                            cstart = pos;
+                            state = Tokenizer.CDATA_SECTION;
+                            reconsume = true;
+                            continue stateloop;
+
+                    }
+                    // XXX reorder point
+                case ATTRIBUTE_VALUE_SINGLE_QUOTED:
+                    attributevaluesinglequotedloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        /*
+                         * Consume the next input character:
+                         */
+                        switch (c) {
+                            case '\'':
+                                /*
+                                 * U+0027 APOSTROPHE (') Switch to the after
+                                 * attribute value (quoted) state.
+                                 */
+                                addAttributeWithValue();
+
+                                state = Tokenizer.AFTER_ATTRIBUTE_VALUE_QUOTED;
+                                continue stateloop;
+                            case '&':
+                                /*
+                                 * U+0026 AMPERSAND (&) Switch to the character
+                                 * reference in attribute value state, with the
+                                 * + additional allowed character being U+0027
+                                 * APOSTROPHE (').
+                                 */
+                                clearStrBufAndAppendCurrentC(c);
+                                rememberAmpersandLocation('\'');
+                                returnState = state;
+                                state = Tokenizer.CONSUME_CHARACTER_REFERENCE;
+                                break attributevaluesinglequotedloop;
+                            // continue stateloop;
+                            case '\r':
+                                appendLongStrBufCarriageReturn();
+                                break stateloop;
+                            case '\n':
+                                appendLongStrBufLineFeed();
+                                continue;
+                            case '\u0000':
+                                c = '\uFFFD';
+                                // fall thru
+                            default:
+                                /*
+                                 * Anything else Append the current input
+                                 * character to the current attribute's value.
+                                 */
+                                appendLongStrBuf(c);
+                                /*
+                                 * Stay in the attribute value (double-quoted)
+                                 * state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // FALLTHRU DON'T REORDER
+                case CONSUME_CHARACTER_REFERENCE:
+                    if (++pos == endPos) {
+                        break stateloop;
+                    }
+                    c = checkChar(buf, pos);
+                    if (c == '\u0000') {
+                        break stateloop;
+                    }
+                    /*
+                     * Unlike the definition is the spec, this state does not
+                     * return a value and never requires the caller to
+                     * backtrack. This state takes care of emitting characters
+                     * or appending to the current attribute value. It also
+                     * takes care of that in the case when consuming the
+                     * character reference fails.
+                     */
+                    /*
+                     * This section defines how to consume a character
+                     * reference. This definition is used when parsing character
+                     * references in text and in attributes.
+                     * 
+                     * The behavior depends on the identity of the next
+                     * character (the one immediately after the U+0026 AMPERSAND
+                     * character):
+                     */
+                    switch (c) {
+                        case ' ':
+                        case '\t':
+                        case '\n':
+                        case '\r': // we'll reconsume!
+                        case '\u000C':
+                        case '<':
+                        case '&':
+                            emitOrAppendStrBuf(returnState);
+                            if ((returnState & (~1)) == 0) {
+                                cstart = pos;
+                            }
+                            state = returnState;
+                            reconsume = true;
+                            continue stateloop;
+                        case '#':
+                            /*
+                             * U+0023 NUMBER SIGN (#) Consume the U+0023 NUMBER
+                             * SIGN.
+                             */
+                            appendStrBuf('#');
+                            state = Tokenizer.CONSUME_NCR;
+                            continue stateloop;
+                        default:
+                            if (c == additional) {
+                                emitOrAppendStrBuf(returnState);
+                                state = returnState;
+                                reconsume = true;
+                                continue stateloop;
+                            }
+                            entCol = -1;
+                            lo = 0;
+                            hi = (NamedCharacters.NAMES.length - 1);
+                            candidate = -1;
+                            strBufMark = 0;
+                            state = Tokenizer.CHARACTER_REFERENCE_LOOP;
+                            reconsume = true;
+                            // FALL THROUGH continue stateloop;
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case CHARACTER_REFERENCE_LOOP:
+                    outer: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        if (c == '\u0000') {
+                            break stateloop;
+                        }
+                        entCol++;
+                        /*
+                         * Consume the maximum number of characters possible,
+                         * with the consumed characters matching one of the
+                         * identifiers in the first column of the named
+                         * character references table (in a case-sensitive
+                         * manner).
+                         */
+                        hiloop: for (;;) {
+                            if (hi == -1) {
+                                break hiloop;
+                            }
+                            if (entCol == NamedCharacters.NAMES[hi].length) {
+                                break hiloop;
+                            }
+                            if (entCol > NamedCharacters.NAMES[hi].length) {
+                                break outer;
+                            } else if (c < NamedCharacters.NAMES[hi][entCol]) {
+                                hi--;
+                            } else {
+                                break hiloop;
+                            }
+                        }
+
+                        loloop: for (;;) {
+                            if (hi < lo) {
+                                break outer;
+                            }
+                            if (entCol == NamedCharacters.NAMES[lo].length) {
+                                candidate = lo;
+                                strBufMark = strBufLen;
+                                lo++;
+                            } else if (entCol > NamedCharacters.NAMES[lo].length) {
+                                break outer;
+                            } else if (c > NamedCharacters.NAMES[lo][entCol]) {
+                                lo++;
+                            } else {
+                                break loloop;
+                            }
+                        }
+                        if (hi < lo) {
+                            break outer;
+                        }
+                        appendStrBuf(c);
+                        continue;
+                    }
+
+                    // TODO warn about apos (IE) and TRADE (Opera)
+                    if (candidate == -1) {
+                        // reconsume deals with CR, LF or nul
+                        /*
+                         * If no match can be made, then this is a parse error.
+                         */
+                        errNoNamedCharacterMatch();
+                        emitOrAppendStrBuf(returnState);
+                        if ((returnState & (~1)) == 0) {
+                            cstart = pos;
+                        }
+                        state = returnState;
+                        reconsume = true;
+                        continue stateloop;
+                    } else {
+                        // c can't be CR, LF or nul if we got here
+                        char[] candidateArr = NamedCharacters.NAMES[candidate];
+                        if (candidateArr[candidateArr.length - 1] != ';') {
+                            /*
+                             * If the last character matched is not a U+003B
+                             * SEMICOLON (;), there is a parse error.
+                             */
+                            if ((returnState & (~1)) != 0) {
+                                /*
+                                 * If the entity is being consumed as part of an
+                                 * attribute, and the last character matched is
+                                 * not a U+003B SEMICOLON (;),
+                                 */
+                                char ch;
+                                if (strBufMark == strBufLen) {
+                                    ch = c;
+                                } else {
+                                    // if (strBufOffset != -1) {
+                                    // ch = buf[strBufOffset + strBufMark];
+                                    // } else {
+                                    ch = strBuf[strBufMark];
+                                    // }
+                                }
+                                if ((ch >= '0' && ch <= '9')
+                                        || (ch >= 'A' && ch <= 'Z')
+                                        || (ch >= 'a' && ch <= 'z')) {
+                                    /*
+                                     * and the next character is in the range
+                                     * U+0030 DIGIT ZERO to U+0039 DIGIT NINE,
+                                     * U+0041 LATIN CAPITAL LETTER A to U+005A
+                                     * LATIN CAPITAL LETTER Z, or U+0061 LATIN
+                                     * SMALL LETTER A to U+007A LATIN SMALL
+                                     * LETTER Z, then, for historical reasons,
+                                     * all the characters that were matched
+                                     * after the U+0026 AMPERSAND (&) must be
+                                     * unconsumed, and nothing is returned.
+                                     */
+                                    errNoNamedCharacterMatch();
+                                    appendStrBufToLongStrBuf();
+                                    state = returnState;
+                                    reconsume = true;
+                                    continue stateloop;
+                                }
+                            }
+                            if ((returnState & (~1)) != 0) {
+                                errUnescapedAmpersandInterpretedAsCharacterReference();
+                            } else {
+                                errNotSemicolonTerminated();
+                            }
+                        }
+
+                        /*
+                         * Otherwise, return a character token for the character
+                         * corresponding to the entity name (as given by the
+                         * second column of the named character references
+                         * table).
+                         */
+                        char[] val = NamedCharacters.VALUES[candidate];
+                        emitOrAppend(val, returnState);
+                        // this is so complicated!
+                        if (strBufMark < strBufLen) {
+                            // if (strBufOffset != -1) {
+                            // if ((returnState & (~1)) != 0) {
+                            // for (int i = strBufMark; i < strBufLen; i++) {
+                            // appendLongStrBuf(buf[strBufOffset + i]);
+                            // }
+                            // } else {
+                            // tokenHandler.characters(buf, strBufOffset
+                            // + strBufMark, strBufLen
+                            // - strBufMark);
+                            // }
+                            // } else {
+                            if ((returnState & (~1)) != 0) {
+                                for (int i = strBufMark; i < strBufLen; i++) {
+                                    appendLongStrBuf(strBuf[i]);
+                                }
+                            } else {
+                                tokenHandler.characters(strBuf, strBufMark,
+                                        strBufLen - strBufMark);
+                            }
+                            // }
+                        }
+                        if ((returnState & (~1)) == 0) {
+                            cstart = pos;
+                        }
+                        state = returnState;
+                        reconsume = true;
+                        continue stateloop;
+                        /*
+                         * If the markup contains I'm &notit; I tell you, the
+                         * entity is parsed as "not", as in, I'm it; I tell
+                         * you. But if the markup was I'm &notin; I tell you,
+                         * the entity would be parsed as "notin;", resulting in
+                         * I'm  I tell you.
+                         */
+                    }
+                    // XXX reorder point
+                case CONSUME_NCR:
+                    if (++pos == endPos) {
+                        break stateloop;
+                    }
+                    c = checkChar(buf, pos);
+                    prevValue = -1;
+                    value = 0;
+                    seenDigits = false;
+                    /*
+                     * The behavior further depends on the character after the
+                     * U+0023 NUMBER SIGN:
+                     */
+                    switch (c) {
+                        case 'x':
+                        case 'X':
+
+                            /*
+                             * U+0078 LATIN SMALL LETTER X U+0058 LATIN CAPITAL
+                             * LETTER X Consume the X.
+                             * 
+                             * Follow the steps below, but using the range of
+                             * characters U+0030 DIGIT ZERO through to U+0039
+                             * DIGIT NINE, U+0061 LATIN SMALL LETTER A through
+                             * to U+0066 LATIN SMALL LETTER F, and U+0041 LATIN
+                             * CAPITAL LETTER A, through to U+0046 LATIN CAPITAL
+                             * LETTER F (in other words, 0-9, A-F, a-f).
+                             * 
+                             * When it comes to interpreting the number,
+                             * interpret it as a hexadecimal number.
+                             */
+                            appendStrBuf(c);
+                            state = Tokenizer.HEX_NCR_LOOP;
+                            continue stateloop;
+                        default:
+                            /*
+                             * Anything else Follow the steps below, but using
+                             * the range of characters U+0030 DIGIT ZERO through
+                             * to U+0039 DIGIT NINE (i.e. just 0-9).
+                             * 
+                             * When it comes to interpreting the number,
+                             * interpret it as a decimal number.
+                             */
+                            state = Tokenizer.DECIMAL_NRC_LOOP;
+                            reconsume = true;
+                            // FALL THROUGH continue stateloop;
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case DECIMAL_NRC_LOOP:
+                    decimalloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        // Deal with overflow gracefully
+                        if (value < prevValue) {
+                            value = 0x110000; // Value above Unicode range but
+                            // within int
+                            // range
+                        }
+                        prevValue = value;
+                        /*
+                         * Consume as many characters as match the range of
+                         * characters given above.
+                         */
+                        if (c >= '0' && c <= '9') {
+                            seenDigits = true;
+                            value *= 10;
+                            value += c - '0';
+                            continue;
+                        } else if (c == ';') {
+                            if (seenDigits) {
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos + 1;
+                                }
+                                state = Tokenizer.HANDLE_NCR_VALUE;
+                                // FALL THROUGH continue stateloop;
+                                break decimalloop;
+                            } else {
+                                errNoDigitsInNCR();
+                                appendStrBuf(';');
+                                emitOrAppendStrBuf(returnState);
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos + 1;
+                                }
+                                state = returnState;
+                                continue stateloop;
+                            }
+                        } else {
+                            /*
+                             * If no characters match the range, then don't
+                             * consume any characters (and unconsume the U+0023
+                             * NUMBER SIGN character and, if appropriate, the X
+                             * character). This is a parse error; nothing is
+                             * returned.
+                             * 
+                             * Otherwise, if the next character is a U+003B
+                             * SEMICOLON, consume that too. If it isn't, there
+                             * is a parse error.
+                             */
+                            if (!seenDigits) {
+                                errNoDigitsInNCR();
+                                emitOrAppendStrBuf(returnState);
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos;
+                                }
+                                state = returnState;
+                                reconsume = true;
+                                continue stateloop;
+                            } else {
+                                errCharRefLacksSemicolon();
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos;
+                                }
+                                state = Tokenizer.HANDLE_NCR_VALUE;
+                                reconsume = true;
+                                // FALL THROUGH continue stateloop;
+                                break decimalloop;
+                            }
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case HANDLE_NCR_VALUE:
+                    // WARNING previous state sets reconsume
+                    // XXX inline this case if the method size can take it
+                    handleNcrValue(returnState);
+                    state = returnState;
+                    continue stateloop;
+                    // XXX reorder point
+                case HEX_NCR_LOOP:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        // Deal with overflow gracefully
+                        if (value < prevValue) {
+                            value = 0x110000; // Value above Unicode range but
+                            // within int
+                            // range
+                        }
+                        prevValue = value;
+                        /*
+                         * Consume as many characters as match the range of
+                         * characters given above.
+                         */
+                        if (c >= '0' && c <= '9') {
+                            seenDigits = true;
+                            value *= 16;
+                            value += c - '0';
+                            continue;
+                        } else if (c >= 'A' && c <= 'F') {
+                            seenDigits = true;
+                            value *= 16;
+                            value += c - 'A' + 10;
+                            continue;
+                        } else if (c >= 'a' && c <= 'f') {
+                            seenDigits = true;
+                            value *= 16;
+                            value += c - 'a' + 10;
+                            continue;
+                        } else if (c == ';') {
+                            if (seenDigits) {
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos + 1;
+                                }
+                                state = Tokenizer.HANDLE_NCR_VALUE;
+                                continue stateloop;
+                            } else {
+                                errNoDigitsInNCR();
+                                appendStrBuf(';');
+                                emitOrAppendStrBuf(returnState);
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos + 1;
+                                }
+                                state = returnState;
+                                continue stateloop;
+                            }
+                        } else {
+                            /*
+                             * If no characters match the range, then don't
+                             * consume any characters (and unconsume the U+0023
+                             * NUMBER SIGN character and, if appropriate, the X
+                             * character). This is a parse error; nothing is
+                             * returned.
+                             * 
+                             * Otherwise, if the next character is a U+003B
+                             * SEMICOLON, consume that too. If it isn't, there
+                             * is a parse error.
+                             */
+                            if (!seenDigits) {
+                                errNoDigitsInNCR();
+                                emitOrAppendStrBuf(returnState);
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos;
+                                }
+                                state = returnState;
+                                reconsume = true;
+                                continue stateloop;
+                            } else {
+                                errCharRefLacksSemicolon();
+                                if ((returnState & (~1)) == 0) {
+                                    cstart = pos;
+                                }
+                                state = Tokenizer.HANDLE_NCR_VALUE;
+                                reconsume = true;
+                                continue stateloop;
+                            }
+                        }
+                    }
+                    // XXX reorder point
+                case PLAINTEXT:
+                    plaintextloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        switch (c) {
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                continue;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            default:
+                                /*
+                                 * Anything else Emit the input character as a
+                                 * character token.
+                                 */
+                                /*
+                                 * Stay in the data state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // XXX reorder point
+                case CDATA:
+                    cdataloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        switch (c) {
+                            case '<':
+                                /*
+                                 * U+003C LESS-THAN SIGN (<) When the content
+                                 * model flag is set to the PCDATA state: switch
+                                 * to the tag open state. When the content model
+                                 * flag is set to either the RCDATA state or the
+                                 * CDATA state, and the escape flag is false:
+                                 * switch to the tag open state. Otherwise:
+                                 * treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                                flushChars(buf, pos);
+
+                                returnState = state;
+                                state = Tokenizer.TAG_OPEN_NON_PCDATA;
+                                break cdataloop; // FALL THRU continue
+                            // stateloop;
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                continue;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            default:
+                                /*
+                                 * Anything else Emit the input character as a
+                                 * character token.
+                                 */
+                                /*
+                                 * Stay in the data state.
+                                 */
+                                continue;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case TAG_OPEN_NON_PCDATA:
+                    tagopennonpcdataloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '!':
+                                tokenHandler.characters(Tokenizer.LT_GT, 0, 1);
+                                cstart = pos;
+                                state = Tokenizer.ESCAPE_EXCLAMATION;
+                                break tagopennonpcdataloop; // FALL THRU
+                            // continue
+                            // stateloop;
+                            case '/':
+                                /*
+                                 * If the content model flag is set to the
+                                 * RCDATA or CDATA states Consume the next input
+                                 * character.
+                                 */
+                                if (contentModelElement != null) {
+                                    /*
+                                     * If it is a U+002F SOLIDUS (/) character,
+                                     * switch to the close tag open state.
+                                     */
+                                    index = 0;
+                                    clearStrBufForNextState();
+                                    state = Tokenizer.CLOSE_TAG_OPEN_NOT_PCDATA;
+                                    continue stateloop;
+                                } // else fall through
+                            default:
+                                /*
+                                 * Otherwise, emit a U+003C LESS-THAN SIGN
+                                 * character token
+                                 */
+                                tokenHandler.characters(Tokenizer.LT_GT, 0, 1);
+                                /*
+                                 * and reconsume the current input character in
+                                 * the data state.
+                                 */
+                                cstart = pos;
+                                state = returnState;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case ESCAPE_EXCLAMATION:
+                    escapeexclamationloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '-':
+                                state = Tokenizer.ESCAPE_EXCLAMATION_HYPHEN;
+                                break escapeexclamationloop; // FALL THRU
+                            // continue
+                            // stateloop;
+                            default:
+                                state = returnState;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case ESCAPE_EXCLAMATION_HYPHEN:
+                    escapeexclamationhyphenloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '-':
+                                state = Tokenizer.ESCAPE_HYPHEN_HYPHEN;
+                                break escapeexclamationhyphenloop;
+                            // continue stateloop;
+                            default:
+                                state = returnState;
+                                reconsume = true;
+                                continue stateloop;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case ESCAPE_HYPHEN_HYPHEN:
+                    escapehyphenhyphenloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '-':
+                                continue;
+                            case '>':
+                                state = returnState;
+                                continue stateloop;
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                state = Tokenizer.ESCAPE;
+                                break escapehyphenhyphenloop;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                state = Tokenizer.ESCAPE;
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            default:
+                                state = Tokenizer.ESCAPE;
+                                break escapehyphenhyphenloop;
+                            // continue stateloop;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case ESCAPE:
+                    escapeloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '-':
+                                state = Tokenizer.ESCAPE_HYPHEN;
+                                break escapeloop; // FALL THRU continue
+                            // stateloop;
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                continue;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            default:
+                                continue;
+                        }
+                    }
+                    // WARNING FALLTHRU CASE TRANSITION: DON'T REORDER
+                case ESCAPE_HYPHEN:
+                    escapehyphenloop: for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        switch (c) {
+                            case '-':
+                                state = Tokenizer.ESCAPE_HYPHEN_HYPHEN;
+                                continue stateloop;
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                state = Tokenizer.ESCAPE;
+                                continue stateloop;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                state = Tokenizer.ESCAPE;
+                                continue stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            default:
+                                state = Tokenizer.ESCAPE;
+                                continue stateloop;
+                        }
+                    }
+                    // XXX reorder point
+                case CLOSE_TAG_OPEN_NOT_PCDATA:
+                    for (;;) {
+                        if (++pos == endPos) {
+                            break stateloop;
+                        }
+                        c = checkChar(buf, pos);
+                        // ASSERT! when entering this state, set index to 0 and
+                        // call clearStrBuf()
+                        // assert (contentModelElement != null);
+                        /*
+                         * If the content model flag is set to the RCDATA or
+                         * CDATA states but no start tag token has ever been
+                         * emitted by this instance of the tokeniser (fragment
+                         * case), or, if the content model flag is set to the
+                         * RCDATA or CDATA states and the next few characters do
+                         * not match the tag name of the last start tag token
+                         * emitted (compared in an ASCII case-insensitive
+                         * manner), or if they do but they are not immediately
+                         * followed by one of the following characters: + U+0009
+                         * CHARACTER TABULATION + U+000A LINE FEED (LF) + +
+                         * U+000C FORM FEED (FF) + U+0020 SPACE + U+003E
+                         * GREATER-THAN SIGN (>) + U+002F SOLIDUS (/) + EOF
+                         * 
+                         * ...then emit a U+003C LESS-THAN SIGN character token,
+                         * a U+002F SOLIDUS character token, and switch to the
+                         * data state to process the next input character.
+                         */
+                        // Let's implement the above without lookahead. strBuf
+                        // holds
+                        // characters that need to be emitted if looking for an
+                        // end tag
+                        // fails.
+                        // Duplicating the relevant part of tag name state here
+                        // as well.
+                        if (index < contentModelElementNameAsArray.length) {
+                            char e = contentModelElementNameAsArray[index];
+                            char folded = c;
+                            if (c >= 'A' && c <= 'Z') {
+                                folded += 0x20;
+                            }
+                            if (folded != e) {
+                                // [NOCPP[
+                                errHtml4LtSlashInRcdata(folded);
+                                // ]NOCPP]
+                                tokenHandler.characters(Tokenizer.LT_SOLIDUS,
+                                        0, 2);
+                                emitStrBuf();
+                                cstart = pos;
+                                state = returnState;
+                                reconsume = true;
+                                continue stateloop;
+                            }
+                            appendStrBuf(c);
+                            index++;
+                            continue;
+                        } else {
+                            endTag = true;
+                            // XXX replace contentModelElement with different
+                            // type
+                            tagName = contentModelElement;
+                            switch (c) {
+                                case '\r':
+                                    silentCarriageReturn();
+                                    state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                    break stateloop;
+                                case '\n':
+                                    silentLineFeed();
+                                    // fall thru
+                                case ' ':
+                                case '\t':
+                                case '\u000C':
+                                    /*
+                                     * U+0009 CHARACTER TABULATION U+000A LINE
+                                     * FEED (LF) U+000C FORM FEED (FF) U+0020
+                                     * SPACE Switch to the before attribute name
+                                     * state.
+                                     */
+                                    state = Tokenizer.BEFORE_ATTRIBUTE_NAME;
+                                    continue stateloop;
+                                case '>':
+                                    /*
+                                     * U+003E GREATER-THAN SIGN (>) Emit the
+                                     * current tag token.
+                                     */
+                                    state = emitCurrentTagToken(false, pos);
+                                    if (shouldSuspend) {
+                                        break stateloop;
+                                    }
+                                    /*
+                                     * Switch to the data state.
+                                     */
+                                    continue stateloop;
+                                case '/':
+                                    /*
+                                     * U+002F SOLIDUS (/) Switch to the
+                                     * self-closing start tag state.
+                                     */
+                                    state = Tokenizer.SELF_CLOSING_START_TAG;
+                                    continue stateloop;
+                                default:
+                                    // [NOCPP[
+                                    errWarnLtSlashInRcdata();
+                                    // ]NOCPP]
+                                    tokenHandler.characters(
+                                            Tokenizer.LT_SOLIDUS, 0, 2);
+                                    emitStrBuf();
+                                    if (c == '\u0000') {
+                                        emitReplacementCharacter(buf, pos);
+                                    } else {
+                                        cstart = pos; // don't drop the
+                                                      // character
+                                    }
+                                    state = returnState;
+                                    continue stateloop;
+                            }
+                        }
+                    }
+                    // XXX reorder point
+                case CLOSE_TAG_OPEN_PCDATA:
+                    if (++pos == endPos) {
+                        break stateloop;
+                    }
+                    c = checkChar(buf, pos);
+                    /*
+                     * Otherwise, if the content model flag is set to the PCDATA
+                     * state, or if the next few characters do match that tag
+                     * name, consume the next input character:
+                     */
+                    switch (c) {
+                        case '>':
+                            /* U+003E GREATER-THAN SIGN (>) Parse error. */
+                            errLtSlashGt();
+                            /*
+                             * Switch to the data state.
+                             */
+                            cstart = pos + 1;
+                            state = Tokenizer.DATA;
+                            continue stateloop;
+                        case '\r':
+                            silentCarriageReturn();
+                            /* Anything else Parse error. */
+                            errGarbageAfterLtSlash();
+                            /*
+                             * Switch to the bogus comment state.
+                             */
+                            clearLongStrBufAndAppendToComment('\n');
+                            state = Tokenizer.BOGUS_COMMENT;
+                            break stateloop;
+                        case '\n':
+                            silentLineFeed();
+                            /* Anything else Parse error. */
+                            errGarbageAfterLtSlash();
+                            /*
+                             * Switch to the bogus comment state.
+                             */
+                            clearLongStrBufAndAppendToComment('\n');
+                            state = Tokenizer.BOGUS_COMMENT;
+                            continue stateloop;
+                        case '\u0000':
+                            c = '\uFFFD';
+                            // fall thru
+                        default:
+                            if (c >= 'A' && c <= 'Z') {
+                                c += 0x20;
+                            }
+                            if (c >= 'a' && c <= 'z') {
+                                /*
+                                 * U+0061 LATIN SMALL LETTER A through to U+007A
+                                 * LATIN SMALL LETTER Z Create a new end tag
+                                 * token,
+                                 */
+                                endTag = true;
+                                /*
+                                 * set its tag name to the input character,
+                                 */
+                                clearStrBufAndAppendCurrentC(c);
+                                /*
+                                 * then switch to the tag name state. (Don't
+                                 * emit the token yet; further details will be
+                                 * filled in before it is emitted.)
+                                 */
+                                state = Tokenizer.TAG_NAME;
+                                continue stateloop;
+                            } else {
+                                /* Anything else Parse error. */
+                                errGarbageAfterLtSlash();
+                                /*
+                                 * Switch to the bogus comment state.
+                                 */
+                                clearLongStrBufAndAppendToComment(c);
+                                state = Tokenizer.BOGUS_COMMENT;
+                                continue stateloop;
+                            }
+                    }
+                    // XXX reorder point
+                case RCDATA:
+                    rcdataloop: for (;;) {
+                        if (reconsume) {
+                            reconsume = false;
+                        } else {
+                            if (++pos == endPos) {
+                                break stateloop;
+                            }
+                            c = checkChar(buf, pos);
+                        }
+                        switch (c) {
+                            case '&':
+                                /*
+                                 * U+0026 AMPERSAND (&) When the content model
+                                 * flag is set to one of the PCDATA or RCDATA
+                                 * states and the escape flag is false: switch
+                                 * to the character reference data state.
+                                 * Otherwise: treat it as per the "anything
+                                 * else" entry below.
+                                 */
+                                flushChars(buf, pos);
+                                clearStrBufAndAppendCurrentC(c);
+                                additional = '\u0000';
+                                returnState = state;
+                                state = Tokenizer.CONSUME_CHARACTER_REFERENCE;
+                                continue stateloop;
+                            case '<':
+                                /*
+                                 * U+003C LESS-THAN SIGN (<) When the content
+                                 * model flag is set to the PCDATA state: switch
+                                 * to the tag open state. When the content model
+                                 * flag is set to either the RCDATA state or the
+                                 * CDATA state, and the escape flag is false:
+                                 * switch to the tag open state. Otherwise:
+                                 * treat it as per the "anything else" entry
+                                 * below.
+                                 */
+                                flushChars(buf, pos);
+
+                                returnState = state;
+                                state = Tokenizer.TAG_OPEN_NON_PCDATA;
+                                continue stateloop;
+                            case '\u0000':
+                                emitReplacementCharacter(buf, pos);
+                                continue;
+                            case '\r':
+                                emitCarriageReturn(buf, pos);
+                                break stateloop;
+                            case '\n':
+                                silentLineFeed();
+                            default:
+                                /*
+                                 * Anything else Emit the input character as a
+                                 * character token.
+                                 */
+                                /*
+                                 * Stay in the data state.
+                                 */
+                                continue;
+                        }
+                    }
+
+            }
+        }
+        flushChars(buf, pos);
+        /*
+         * if (prevCR && pos != endPos) { // why is this needed? pos--; col--; }
+         */
+        // Save locals
+        stateSave = state;
+        returnStateSave = returnState;
+        return pos;
+    }
+
+    @Inline private void initDoctypeFields() {
+        doctypeName = "";
+        systemIdentifier = null;
+        publicIdentifier = null;
+        forceQuirks = false;
+    }
+
+    @Inline private void adjustDoubleHyphenAndAppendToLongStrBufCarriageReturn()
+            throws SAXException {
+        silentCarriageReturn();
+        adjustDoubleHyphenAndAppendToLongStrBufAndErr('\n');
+    }
+
+    @Inline private void adjustDoubleHyphenAndAppendToLongStrBufLineFeed()
+            throws SAXException {
+        silentLineFeed();
+        adjustDoubleHyphenAndAppendToLongStrBufAndErr('\n');
+    }
+
+    @Inline private void appendLongStrBufLineFeed() {
+        silentLineFeed();
+        appendLongStrBuf('\n');
+    }
+
+    @Inline private void appendLongStrBufCarriageReturn() {
+        silentCarriageReturn();
+        appendLongStrBuf('\n');
+    }
+
+    @Inline protected void silentCarriageReturn() {
+        ++line;
+        lastCR = true;
+    }
+
+    @Inline protected void silentLineFeed() {
+        ++line;
+    }
+
+    private void emitCarriageReturn(@NoLength char[] buf, int pos)
+            throws SAXException {
+        silentCarriageReturn();
+        flushChars(buf, pos);
+        tokenHandler.characters(Tokenizer.LF, 0, 1);
+        cstart = Integer.MAX_VALUE;
+    }
+
+    private void emitReplacementCharacter(@NoLength char[] buf, int pos)
+            throws SAXException {
+        silentCarriageReturn();
+        flushChars(buf, pos);
+        tokenHandler.characters(Tokenizer.REPLACEMENT_CHARACTER, 0, 1);
+        cstart = Integer.MAX_VALUE;
+    }
+
+    private void rememberAmpersandLocation(char add) {
+        additional = add;
+        // [NOCPP[
+        ampersandLocation = new LocatorImpl(this);
+        // ]NOCPP]
+    }
+
+    private void bogusDoctype() throws SAXException {
+        errBogusDoctype();
+        forceQuirks = true;
+    }
+
+    private void bogusDoctypeWithoutQuirks() throws SAXException {
+        errBogusDoctype();
+        forceQuirks = false;
+    }
+
+    private void emitOrAppendStrBuf(int returnState) throws SAXException {
+        if ((returnState & (~1)) != 0) {
+            appendStrBufToLongStrBuf();
+        } else {
+            emitStrBuf();
+        }
+    }
+
+    private void handleNcrValue(int returnState) throws SAXException {
+        /*
+         * If one or more characters match the range, then take them all and
+         * interpret the string of characters as a number (either hexadecimal or
+         * decimal as appropriate).
+         */
+        if (value >= 0x80 && value <= 0x9f) {
+            /*
+             * If that number is one of the numbers in the first column of the
+             * following table, then this is a parse error.
+             */
+            errNcrInC1Range();
+            /*
+             * Find the row with that number in the first column, and return a
+             * character token for the Unicode character given in the second
+             * column of that row.
+             */
+            @NoLength char[] val = NamedCharacters.WINDOWS_1252[value - 0x80];
+            emitOrAppendOne(val, returnState);
+        } else if (value == 0x0D) {
+            errRcnCr();
+            emitOrAppendOne(Tokenizer.LF, returnState);
+            // [NOCPP[
+        } else if (value == 0xC
+                && contentSpacePolicy != XmlViolationPolicy.ALLOW) {
+            if (contentSpacePolicy == XmlViolationPolicy.ALTER_INFOSET) {
+                emitOrAppendOne(Tokenizer.SPACE, returnState);
+            } else if (contentSpacePolicy == XmlViolationPolicy.FATAL) {
+                fatal("A character reference expanded to a form feed which is not legal XML 1.0 white space.");
+            }
+            // ]NOCPP]
+        } else if ((value >= 0x0000 && value <= 0x0008) || (value == 0x000B)
+                || (value >= 0x000E && value <= 0x001F) || value == 0x007F) {
+            /*
+             * Otherwise, if the number is in the range 0x0000 to 0x0008, 0x000E
+             * to 0x001F, 0x007F to 0x009F, 0xD800 to 0xDFFF, 0xFDD0 to 0xFDEF,
+             * or is one of 0x000B, 0xFFFE, 0xFFFF, 0x1FFFE, 0x1FFFF, 0x2FFFE,
+             * 0x2FFFF, 0x3FFFE, 0x3FFFF, 0x4FFFE, 0x4FFFF, 0x5FFFE, 0x5FFFF,
+             * 0x6FFFE, 0x6FFFF, 0x7FFFE, 0x7FFFF, 0x8FFFE, 0x8FFFF, 0x9FFFE,
+             * 0x9FFFF, 0xAFFFE, 0xAFFFF, 0xBFFFE, 0xBFFFF, 0xCFFFE, 0xCFFFF,
+             * 0xDFFFE, 0xDFFFF, 0xEFFFE, 0xEFFFF, 0xFFFFE, 0xFFFFF, 0x10FFFE,
+             * or 0x10FFFF, or is higher than 0x10FFFF, then this is a parse
+             * error; return a character token for the U+FFFD REPLACEMENT
+             * CHARACTER character instead.
+             */
+            errNcrControlChar();
+            emitOrAppendOne(Tokenizer.REPLACEMENT_CHARACTER, returnState);
+        } else if ((value & 0xF800) == 0xD800) {
+            errNcrSurrogate();
+            emitOrAppendOne(Tokenizer.REPLACEMENT_CHARACTER, returnState);
+        } else if ((value & 0xFFFE) == 0xFFFE) {
+            errNcrNonCharacter();
+            emitOrAppendOne(Tokenizer.REPLACEMENT_CHARACTER, returnState);
+        } else if (value >= 0xFDD0 && value <= 0xFDEF) {
+            errNcrUnassigned();
+            emitOrAppendOne(Tokenizer.REPLACEMENT_CHARACTER, returnState);
+        } else if (value <= 0xFFFF) {
+            /*
+             * Otherwise, return a character token for the Unicode character
+             * whose code point is that number.
+             */
+            char ch = (char) value;
+            // [NOCPP[
+            maybeWarnPrivateUse(ch);
+            // ]NOCPP]
+            bmpChar[0] = ch;
+            emitOrAppendOne(bmpChar, returnState);
+        } else if (value <= 0x10FFFF) {
+            // [NOCPP[
+            maybeWarnPrivateUseAstral();
+            // ]NOCPP]
+            astralChar[0] = (char) (Tokenizer.LEAD_OFFSET + (value >> 10));
+            astralChar[1] = (char) (0xDC00 + (value & 0x3FF));
+            emitOrAppend(astralChar, returnState);
+        } else {
+            errNcrOutOfRange();
+            emitOrAppendOne(Tokenizer.REPLACEMENT_CHARACTER, returnState);
+        }
+    }
+
+    public void eof() throws SAXException {
+        int state = stateSave;
+        int returnState = returnStateSave;
+
+        eofloop: for (;;) {
+            switch (state) {
+                case TAG_OPEN_NON_PCDATA:
+                    /*
+                     * Otherwise, emit a U+003C LESS-THAN SIGN character token
+                     */
+                    tokenHandler.characters(Tokenizer.LT_GT, 0, 1);
+                    /*
+                     * and reconsume the current input character in the data
+                     * state.
+                     */
+                    break eofloop;
+                case TAG_OPEN:
+                    /*
+                     * The behavior of this state depends on the content model
+                     * flag.
+                     */
+                    /*
+                     * Anything else Parse error.
+                     */
+                    errEofAfterLt();
+                    /*
+                     * Emit a U+003C LESS-THAN SIGN character token
+                     */
+                    tokenHandler.characters(Tokenizer.LT_GT, 0, 1);
+                    /*
+                     * and reconsume the current input character in the data
+                     * state.
+                     */
+                    break eofloop;
+                case CLOSE_TAG_OPEN_NOT_PCDATA:
+                    if (index < contentModelElementNameAsArray.length) {
+                        break eofloop;
+                    } else {
+                        errEofInEndTag();
+                        /*
+                         * Reconsume the EOF character in the data state.
+                         */
+                        break eofloop;
+                    }
+                case CLOSE_TAG_OPEN_PCDATA:
+                    /* EOF Parse error. */
+                    errEofAfterLt();
+                    /*
+                     * Emit a U+003C LESS-THAN SIGN character token and a U+002F
+                     * SOLIDUS character token.
+                     */
+                    tokenHandler.characters(Tokenizer.LT_SOLIDUS, 0, 2);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case TAG_NAME:
+                    /*
+                     * EOF Parse error.
+                     */
+                    errEofInTagName();
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case BEFORE_ATTRIBUTE_NAME:
+                case AFTER_ATTRIBUTE_VALUE_QUOTED:
+                case SELF_CLOSING_START_TAG:
+                    /* EOF Parse error. */
+                    errEofWithoutGt();
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case ATTRIBUTE_NAME:
+                    /*
+                     * EOF Parse error.
+                     */
+                    errEofInAttributeName();
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case AFTER_ATTRIBUTE_NAME:
+                case BEFORE_ATTRIBUTE_VALUE:
+                    /* EOF Parse error. */
+                    errEofWithoutGt();
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case ATTRIBUTE_VALUE_DOUBLE_QUOTED:
+                case ATTRIBUTE_VALUE_SINGLE_QUOTED:
+                case ATTRIBUTE_VALUE_UNQUOTED:
+                    /* EOF Parse error. */
+                    errEofInAttributeValue();
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case BOGUS_COMMENT:
+                    emitComment(0, 0);
+                    break eofloop;
+                case BOGUS_COMMENT_HYPHEN:
+                    // [NOCPP[
+                    maybeAppendSpaceToBogusComment();
+                    // ]NOCPP]
+                    emitComment(0, 0);
+                    break eofloop;
+                case MARKUP_DECLARATION_OPEN:
+                    errBogusComment();
+                    clearLongStrBuf();
+                    emitComment(0, 0);
+                    break eofloop;
+                case MARKUP_DECLARATION_HYPHEN:
+                    errBogusComment();
+                    emitComment(0, 0);
+                    break eofloop;
+                case MARKUP_DECLARATION_OCTYPE:
+                    if (index < 6) {
+                        errBogusComment();
+                        emitComment(0, 0);
+                    } else {
+                        /* EOF Parse error. */
+                        errEofInDoctype();
+                        /*
+                         * Create a new DOCTYPE token. Set its force-quirks flag
+                         * to on.
+                         */
+                        doctypeName = "";
+                        publicIdentifier = null;
+                        systemIdentifier = null;
+                        forceQuirks = true;
+                        /*
+                         * Emit the token.
+                         */
+                        emitDoctypeToken(0);
+                        /*
+                         * Reconsume the EOF character in the data state.
+                         */
+                        break eofloop;
+                    }
+                    break eofloop;
+                case COMMENT_START:
+                case COMMENT:
+                case COMMENT_END_SPACE:
+                    /*
+                     * EOF Parse error.
+                     */
+                    errEofInComment();
+                    /* Emit the comment token. */
+                    emitComment(0, 0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case COMMENT_END:
+                    errEofInComment();
+                    /* Emit the comment token. */
+                    emitComment(2, 0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case COMMENT_END_DASH:
+                case COMMENT_START_DASH:
+                    errEofInComment();
+                    /* Emit the comment token. */
+                    emitComment(1, 0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case COMMENT_END_BANG:
+                    errEofInComment();
+                    /* Emit the comment token. */
+                    emitComment(3, 0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case DOCTYPE:
+                case BEFORE_DOCTYPE_NAME:
+                    errEofInDoctype();
+                    /*
+                     * Create a new DOCTYPE token. Set its force-quirks flag to
+                     * on.
+                     */
+                    forceQuirks = true;
+                    /*
+                     * Emit the token.
+                     */
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case DOCTYPE_NAME:
+                    errEofInDoctype();
+                    strBufToDoctypeName();
+                    /*
+                     * Set the DOCTYPE token's force-quirks flag to on.
+                     */
+                    forceQuirks = true;
+                    /*
+                     * Emit that DOCTYPE token.
+                     */
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case DOCTYPE_UBLIC:
+                case DOCTYPE_YSTEM:
+                case AFTER_DOCTYPE_NAME:
+                case BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:
+                    errEofInDoctype();
+                    /*
+                     * Set the DOCTYPE token's force-quirks flag to on.
+                     */
+                    forceQuirks = true;
+                    /*
+                     * Emit that DOCTYPE token.
+                     */
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:
+                case DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:
+                    /* EOF Parse error. */
+                    errEofInPublicId();
+                    /*
+                     * Set the DOCTYPE token's force-quirks flag to on.
+                     */
+                    forceQuirks = true;
+                    /*
+                     * Emit that DOCTYPE token.
+                     */
+                    publicIdentifier = longStrBufToString();
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case AFTER_DOCTYPE_PUBLIC_IDENTIFIER:
+                case BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:
+                    errEofInDoctype();
+                    /*
+                     * Set the DOCTYPE token's force-quirks flag to on.
+                     */
+                    forceQuirks = true;
+                    /*
+                     * Emit that DOCTYPE token.
+                     */
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:
+                case DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:
+                    /* EOF Parse error. */
+                    errEofInSystemId();
+                    /*
+                     * Set the DOCTYPE token's force-quirks flag to on.
+                     */
+                    forceQuirks = true;
+                    /*
+                     * Emit that DOCTYPE token.
+                     */
+                    systemIdentifier = longStrBufToString();
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case AFTER_DOCTYPE_SYSTEM_IDENTIFIER:
+                    errEofInDoctype();
+                    /*
+                     * Set the DOCTYPE token's force-quirks flag to on.
+                     */
+                    forceQuirks = true;
+                    /*
+                     * Emit that DOCTYPE token.
+                     */
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case BOGUS_DOCTYPE:
+                    /*
+                     * Emit that DOCTYPE token.
+                     */
+                    emitDoctypeToken(0);
+                    /*
+                     * Reconsume the EOF character in the data state.
+                     */
+                    break eofloop;
+                case CONSUME_CHARACTER_REFERENCE:
+                    /*
+                     * Unlike the definition is the spec, this state does not
+                     * return a value and never requires the caller to
+                     * backtrack. This state takes care of emitting characters
+                     * or appending to the current attribute value. It also
+                     * takes care of that in the case when consuming the entity
+                     * fails.
+                     */
+                    /*
+                     * This section defines how to consume an entity. This
+                     * definition is used when parsing entities in text and in
+                     * attributes.
+                     * 
+                     * The behavior depends on the identity of the next
+                     * character (the one immediately after the U+0026 AMPERSAND
+                     * character):
+                     */
+
+                    emitOrAppendStrBuf(returnState);
+                    state = returnState;
+                    continue;
+                case CHARACTER_REFERENCE_LOOP:
+                    outer: for (;;) {
+                        char c = '\u0000';
+                        entCol++;
+                        /*
+                         * Consume the maximum number of characters possible,
+                         * with the consumed characters matching one of the
+                         * identifiers in the first column of the named
+                         * character references table (in a case-sensitive
+                         * manner).
+                         */
+                        hiloop: for (;;) {
+                            if (hi == -1) {
+                                break hiloop;
+                            }
+                            if (entCol == NamedCharacters.NAMES[hi].length) {
+                                break hiloop;
+                            }
+                            if (entCol > NamedCharacters.NAMES[hi].length) {
+                                break outer;
+                            } else if (c < NamedCharacters.NAMES[hi][entCol]) {
+                                hi--;
+                            } else {
+                                break hiloop;
+                            }
+                        }
+
+                        loloop: for (;;) {
+                            if (hi < lo) {
+                                break outer;
+                            }
+                            if (entCol == NamedCharacters.NAMES[lo].length) {
+                                candidate = lo;
+                                strBufMark = strBufLen;
+                                lo++;
+                            } else if (entCol > NamedCharacters.NAMES[lo].length) {
+                                break outer;
+                            } else if (c > NamedCharacters.NAMES[lo][entCol]) {
+                                lo++;
+                            } else {
+                                break loloop;
+                            }
+                        }
+                        if (hi < lo) {
+                            break outer;
+                        }
+                        continue;
+                    }
+
+                    // TODO warn about apos (IE) and TRADE (Opera)
+                    if (candidate == -1) {
+                        /*
+                         * If no match can be made, then this is a parse error.
+                         */
+                        errNoNamedCharacterMatch();
+                        emitOrAppendStrBuf(returnState);
+                        state = returnState;
+                        continue eofloop;
+                    } else {
+                        char[] candidateArr = NamedCharacters.NAMES[candidate];
+                        if (candidateArr[candidateArr.length - 1] != ';') {
+                            /*
+                             * If the last character matched is not a U+003B
+                             * SEMICOLON (;), there is a parse error.
+                             */
+                            if ((returnState & (~1)) != 0) {
+                                /*
+                                 * If the entity is being consumed as part of an
+                                 * attribute, and the last character matched is
+                                 * not a U+003B SEMICOLON (;),
+                                 */
+                                char ch;
+                                if (strBufMark == strBufLen) {
+                                    ch = '\u0000';
+                                } else {
+                                    ch = strBuf[strBufMark];
+                                }
+                                if ((ch >= '0' && ch <= '9')
+                                        || (ch >= 'A' && ch <= 'Z')
+                                        || (ch >= 'a' && ch <= 'z')) {
+                                    /*
+                                     * and the next character is in the range
+                                     * U+0030 DIGIT ZERO to U+0039 DIGIT NINE,
+                                     * U+0041 LATIN CAPITAL LETTER A to U+005A
+                                     * LATIN CAPITAL LETTER Z, or U+0061 LATIN
+                                     * SMALL LETTER A to U+007A LATIN SMALL
+                                     * LETTER Z, then, for historical reasons,
+                                     * all the characters that were matched
+                                     * after the U+0026 AMPERSAND (&) must be
+                                     * unconsumed, and nothing is returned.
+                                     */
+                                    errNoNamedCharacterMatch();
+                                    appendStrBufToLongStrBuf();
+                                    state = returnState;
+                                    continue eofloop;
+                                }
+                            }
+                            if ((returnState & (~1)) != 0) {
+                                errUnescapedAmpersandInterpretedAsCharacterReference();
+                            } else {
+                                errNotSemicolonTerminated();
+                            }
+                        }
+
+                        /*
+                         * Otherwise, return a character token for the character
+                         * corresponding to the entity name (as given by the
+                         * second column of the named character references
+                         * table).
+                         */
+                        char[] val = NamedCharacters.VALUES[candidate];
+                        emitOrAppend(val, returnState);
+                        // this is so complicated!
+                        if (strBufMark < strBufLen) {
+                            if ((returnState & (~1)) != 0) {
+                                for (int i = strBufMark; i < strBufLen; i++) {
+                                    appendLongStrBuf(strBuf[i]);
+                                }
+                            } else {
+                                tokenHandler.characters(strBuf, strBufMark,
+                                        strBufLen - strBufMark);
+                            }
+                        }
+                        state = returnState;
+                        continue eofloop;
+                        /*
+                         * If the markup contains I'm &notit; I tell you, the
+                         * entity is parsed as "not", as in, I'm it; I tell
+                         * you. But if the markup was I'm &notin; I tell you,
+                         * the entity would be parsed as "notin;", resulting in
+                         * I'm  I tell you.
+                         */
+                    }
+                case CONSUME_NCR:
+                case DECIMAL_NRC_LOOP:
+                case HEX_NCR_LOOP:
+                    /*
+                     * If no characters match the range, then don't consume any
+                     * characters (and unconsume the U+0023 NUMBER SIGN
+                     * character and, if appropriate, the X character). This is
+                     * a parse error; nothing is returned.
+                     * 
+                     * Otherwise, if the next character is a U+003B SEMICOLON,
+                     * consume that too. If it isn't, there is a parse error.
+                     */
+                    if (!seenDigits) {
+                        errNoDigitsInNCR();
+                        emitOrAppendStrBuf(returnState);
+                        state = returnState;
+                        continue;
+                    } else {
+                        errCharRefLacksSemicolon();
+                    }
+                    // WARNING previous state sets reconsume
+                    handleNcrValue(returnState);
+                    state = returnState;
+                    continue;
+                case DATA:
+                default:
+                    break eofloop;
+            }
+        }
+        // case DATA:
+        /*
+         * EOF Emit an end-of-file token.
+         */
+        tokenHandler.eof();
+        return;
+    }
+
+    private void emitDoctypeToken(int pos) throws SAXException {
+        cstart = pos + 1;
+        tokenHandler.doctype(doctypeName, publicIdentifier, systemIdentifier,
+                forceQuirks);
+        // It is OK and sufficient to release these here, since
+        // there's no way out of the doctype states than through paths
+        // that call this method.
+        Portability.releaseLocal(doctypeName);
+        Portability.releaseString(publicIdentifier);
+        Portability.releaseString(systemIdentifier);
+    }
+
+    @Inline protected char checkChar(@NoLength char[] buf, int pos)
+            throws SAXException {
+        return buf[pos];
+    }
+
+    // [NOCPP[
+
+    /**
+     * Returns the alreadyComplainedAboutNonAscii.
+     * 
+     * @return the alreadyComplainedAboutNonAscii
+     */
+    public boolean isAlreadyComplainedAboutNonAscii() {
+        return true;
+    }
+
+    // ]NOCPP]
+
+    public void internalEncodingDeclaration(String internalCharset)
+            throws SAXException {
+        if (encodingDeclarationHandler != null) {
+            encodingDeclarationHandler.internalEncodingDeclaration(internalCharset);
+        }
+    }
+
+    /**
+     * @param val
+     * @throws SAXException
+     */
+    private void emitOrAppend(char[] val, int returnState) throws SAXException {
+        if ((returnState & (~1)) != 0) {
+            appendLongStrBuf(val);
+        } else {
+            tokenHandler.characters(val, 0, val.length);
+        }
+    }
+
+    private void emitOrAppendOne(@NoLength char[] val, int returnState)
+            throws SAXException {
+        if ((returnState & (~1)) != 0) {
+            appendLongStrBuf(val[0]);
+        } else {
+            tokenHandler.characters(val, 0, 1);
+        }
+    }
+
+    public void end() throws SAXException {
+        strBuf = null;
+        longStrBuf = null;
+        systemIdentifier = null;
+        publicIdentifier = null;
+        doctypeName = null;
+        tagName = null;
+        attributeName = null;
+        tokenHandler.endTokenization();
+        if (attributes != null) {
+            attributes.clear(mappingLangToXmlLang);
+            Portability.delete(attributes);
+            attributes = null;
+        }
+    }
+
+    public void requestSuspension() {
+        shouldSuspend = true;
+    }
+
+    public void becomeConfident() {
+        confident = true;
+    }
+
+    /**
+     * Returns the nextCharOnNewLine.
+     * 
+     * @return the nextCharOnNewLine
+     */
+    public boolean isNextCharOnNewLine() {
+        return false;
+    }
+
+    public boolean isPrevCR() {
+        return lastCR;
+    }
+
+    /**
+     * Returns the line.
+     * 
+     * @return the line
+     */
+    public int getLine() {
+        return -1;
+    }
+
+    /**
+     * Returns the col.
+     * 
+     * @return the col
+     */
+    public int getCol() {
+        return -1;
+    }
+
+    public boolean isInDataState() {
+        return (stateSave == DATA);
+    }
+
+    protected void errGarbageAfterLtSlash() throws SAXException {
+    }
+
+    protected void errLtSlashGt() throws SAXException {
+    }
+
+    protected void errWarnLtSlashInRcdata() throws SAXException {
+    }
+
+    protected void errHtml4LtSlashInRcdata(char folded) throws SAXException {
+    }
+
+    protected void errCharRefLacksSemicolon() throws SAXException {
+    }
+
+    protected void errNoDigitsInNCR() throws SAXException {
+    }
+
+    protected void errGtInSystemId() throws SAXException {
+    }
+
+    protected void errGtInPublicId() throws SAXException {
+    }
+
+    protected void errNamelessDoctype() throws SAXException {
+    }
+
+    protected void errConsecutiveHyphens() throws SAXException {
+    }
+
+    protected void errPrematureEndOfComment() throws SAXException {
+    }
+
+    protected void errBogusComment() throws SAXException {
+    }
+
+    protected void errUnquotedAttributeValOrNull(char c) throws SAXException {
+    }
+
+    protected void errSlashNotFollowedByGt() throws SAXException {
+    }
+
+    protected void errHtml4XmlVoidSyntax() throws SAXException {
+    }
+
+    protected void errNoSpaceBetweenAttributes() throws SAXException {
+    }
+
+    protected void errHtml4NonNameInUnquotedAttribute(char c)
+            throws SAXException {
+    }
+
+    protected void errLtOrEqualsInUnquotedAttributeOrNull(char c)
+            throws SAXException {
+    }
+
+    protected void errAttributeValueMissing() throws SAXException {
+    }
+
+    protected void errBadCharBeforeAttributeNameOrNull(char c)
+            throws SAXException {
+    }
+
+    protected void errEqualsSignBeforeAttributeName() throws SAXException {
+    }
+
+    protected void errBadCharAfterLt(char c) throws SAXException {
+    }
+
+    protected void errLtGt() throws SAXException {
+    }
+
+    protected void errProcessingInstruction() throws SAXException {
+    }
+
+    protected void errUnescapedAmpersandInterpretedAsCharacterReference()
+            throws SAXException {
+    }
+
+    protected void errNotSemicolonTerminated() throws SAXException {
+    }
+
+    protected void errNoNamedCharacterMatch() throws SAXException {
+    }
+
+    protected void errQuoteBeforeAttributeName(char c) throws SAXException {
+    }
+
+    protected void errQuoteOrLtInAttributeNameOrNull(char c) throws SAXException {
+    }
+
+    protected void errExpectedPublicId() throws SAXException {
+    }
+
+    protected void errBogusDoctype() throws SAXException {
+    }
+
+    protected void maybeWarnPrivateUseAstral() throws SAXException {
+    }
+
+    protected void maybeWarnPrivateUse(char ch) throws SAXException {
+    }
+
+    protected void maybeErrAttributesOnEndTag(HtmlAttributes attrs)
+            throws SAXException {
+    }
+
+    protected void maybeErrSlashInEndTag(boolean selfClosing)
+            throws SAXException {
+    }
+
+    protected void errNcrNonCharacter() throws SAXException {
+    }
+
+    protected void errNcrSurrogate() throws SAXException {
+    }
+
+    protected void errNcrControlChar() throws SAXException {
+    }
+
+    protected void errRcnCr() throws SAXException {
+    }
+
+    protected void errNcrInC1Range() throws SAXException {
+    }
+
+    protected void errEofInPublicId() throws SAXException {
+    }
+
+    protected void errEofInComment() throws SAXException {
+    }
+
+    protected void errEofInDoctype() throws SAXException {
+    }
+
+    protected void errEofInAttributeValue() throws SAXException {
+    }
+
+    protected void errEofInAttributeName() throws SAXException {
+    }
+
+    protected void errEofWithoutGt() throws SAXException {
+    }
+
+    protected void errEofInTagName() throws SAXException {
+    }
+
+    protected void errEofInEndTag() throws SAXException {
+    }
+
+    protected void errEofAfterLt() throws SAXException {
+    }
+
+    protected void errNcrOutOfRange() throws SAXException {
+    }
+
+    protected void errNcrUnassigned() throws SAXException {
+    }
+
+    protected void errDuplicateAttribute() throws SAXException {
+    }
+
+    protected void errEofInSystemId() throws SAXException {
+    }
+
+    protected void errExpectedSystemId() throws SAXException {
+    }
+
+    protected void errMissingSpaceBeforeDoctypeName() throws SAXException {
+    }
+
+    protected void errHyphenHyphenBang() throws SAXException {
+    }
+
+    /**
+     * Sets the encodingDeclarationHandler.
+     * 
+     * @param encodingDeclarationHandler
+     *            the encodingDeclarationHandler to set
+     */
+    public void setEncodingDeclarationHandler(
+            EncodingDeclarationHandler encodingDeclarationHandler) {
+        this.encodingDeclarationHandler = encodingDeclarationHandler;
+    }
+
+}
diff --git a/parser/html/java/htmlparser/src/TreeBuilder.java b/parser/html/java/htmlparser/src/TreeBuilder.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/TreeBuilder.java
@@ -0,0 +1,5088 @@
+/*
+ * Copyright (c) 2007 Henri Sivonen
+ * Copyright (c) 2007-2009 Mozilla Foundation
+ * Portions of comments Copyright 2004-2008 Apple Computer, Inc., Mozilla 
+ * Foundation, and Opera Software ASA.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * The comments following this one that use the same comment syntax as this 
+ * comment are quotes from the WHATWG HTML 5 spec as of 27 June 2007 
+ * amended as of June 28 2007.
+ * That document came with this statement:
+ * " Copyright 2004-2007 Apple Computer, Inc., Mozilla Foundation, and 
+ * Opera Software ASA. You are granted a license to use, reproduce and 
+ * create derivative works of this document."
+ */
+
+package nu.validator.htmlparser.impl;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+import nu.validator.htmlparser.annotation.IdType;
+import nu.validator.htmlparser.annotation.Inline;
+import nu.validator.htmlparser.annotation.Literal;
+import nu.validator.htmlparser.annotation.Local;
+import nu.validator.htmlparser.annotation.NoLength;
+import nu.validator.htmlparser.annotation.NsUri;
+import nu.validator.htmlparser.common.DoctypeExpectation;
+import nu.validator.htmlparser.common.DocumentMode;
+import nu.validator.htmlparser.common.DocumentModeHandler;
+import nu.validator.htmlparser.common.TokenHandler;
+import nu.validator.htmlparser.common.XmlViolationPolicy;
+
+import org.xml.sax.ErrorHandler;
+import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
+
+public abstract class TreeBuilder<T> implements TokenHandler {
+
+    // Start dispatch groups
+
+    final static int OTHER = 0;
+
+    final static int A = 1;
+
+    final static int BASE = 2;
+
+    final static int BODY = 3;
+
+    final static int BR = 4;
+
+    final static int BUTTON = 5;
+
+    final static int CAPTION = 6;
+
+    final static int COL = 7;
+
+    final static int COLGROUP = 8;
+
+    final static int FORM = 9;
+
+    final static int FRAME = 10;
+
+    final static int FRAMESET = 11;
+
+    final static int IMAGE = 12;
+
+    final static int INPUT = 13;
+
+    final static int ISINDEX = 14;
+
+    final static int LI = 15;
+
+    final static int LINK = 16;
+
+    final static int MATH = 17;
+
+    final static int META = 18;
+
+    final static int SVG = 19;
+
+    final static int HEAD = 20;
+
+    final static int HR = 22;
+
+    final static int HTML = 23;
+
+    final static int NOBR = 24;
+
+    final static int NOFRAMES = 25;
+
+    final static int NOSCRIPT = 26;
+
+    final static int OPTGROUP = 27;
+
+    final static int OPTION = 28;
+
+    final static int P = 29;
+
+    final static int PLAINTEXT = 30;
+
+    final static int SCRIPT = 31;
+
+    final static int SELECT = 32;
+
+    final static int STYLE = 33;
+
+    final static int TABLE = 34;
+
+    final static int TEXTAREA = 35;
+
+    final static int TITLE = 36;
+
+    final static int TR = 37;
+
+    final static int XMP = 38;
+
+    final static int TBODY_OR_THEAD_OR_TFOOT = 39;
+
+    final static int TD_OR_TH = 40;
+
+    final static int DD_OR_DT = 41;
+
+    final static int H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6 = 42;
+
+    final static int MARQUEE_OR_APPLET = 43;
+
+    final static int PRE_OR_LISTING = 44;
+
+    final static int B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U = 45;
+
+    final static int UL_OR_OL_OR_DL = 46;
+
+    final static int IFRAME = 47;
+
+    final static int EMBED_OR_IMG = 48;
+
+    final static int AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR = 49;
+
+    final static int DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU = 50;
+
+    final static int ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION = 51;
+
+    final static int RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR = 52;
+
+    final static int RT_OR_RP = 53;
+
+    final static int COMMAND_OR_EVENT_SOURCE = 54;
+
+    final static int PARAM_OR_SOURCE = 55;
+
+    final static int MGLYPH_OR_MALIGNMARK = 56;
+
+    final static int MI_MO_MN_MS_MTEXT = 57;
+
+    final static int ANNOTATION_XML = 58;
+
+    final static int FOREIGNOBJECT_OR_DESC = 59;
+
+    final static int NOEMBED = 60;
+
+    final static int FIELDSET = 61;
+
+    final static int OUTPUT_OR_LABEL = 62;
+
+    final static int OBJECT = 63;
+
+    final static int FONT = 64;
+
+    final static int KEYGEN = 65;
+    
+    // start insertion modes
+
+    private static final int INITIAL = 0;
+
+    private static final int BEFORE_HTML = 1;
+
+    private static final int BEFORE_HEAD = 2;
+
+    private static final int IN_HEAD = 3;
+
+    private static final int IN_HEAD_NOSCRIPT = 4;
+
+    private static final int AFTER_HEAD = 5;
+
+    private static final int IN_BODY = 6;
+
+    private static final int IN_TABLE = 7;
+
+    private static final int IN_CAPTION = 8;
+
+    private static final int IN_COLUMN_GROUP = 9;
+
+    private static final int IN_TABLE_BODY = 10;
+
+    private static final int IN_ROW = 11;
+
+    private static final int IN_CELL = 12;
+
+    private static final int IN_SELECT = 13;
+
+    private static final int IN_SELECT_IN_TABLE = 14;
+
+    private static final int AFTER_BODY = 15;
+
+    private static final int IN_FRAMESET = 16;
+
+    private static final int AFTER_FRAMESET = 17;
+
+    private static final int AFTER_AFTER_BODY = 18;
+
+    private static final int AFTER_AFTER_FRAMESET = 19;
+
+    private static final int IN_CDATA_RCDATA = 20;
+
+    private static final int FRAMESET_OK = 21;
+    
+    // start charset states
+
+    private static final int CHARSET_INITIAL = 0;
+
+    private static final int CHARSET_C = 1;
+
+    private static final int CHARSET_H = 2;
+
+    private static final int CHARSET_A = 3;
+
+    private static final int CHARSET_R = 4;
+
+    private static final int CHARSET_S = 5;
+
+    private static final int CHARSET_E = 6;
+
+    private static final int CHARSET_T = 7;
+
+    private static final int CHARSET_EQUALS = 8;
+
+    private static final int CHARSET_SINGLE_QUOTED = 9;
+
+    private static final int CHARSET_DOUBLE_QUOTED = 10;
+
+    private static final int CHARSET_UNQUOTED = 11;
+
+    // end pseudo enums
+
+    private final static char[] ISINDEX_PROMPT = Portability.isIndexPrompt();
+
+    // [NOCPP[
+
+    private final static String[] HTML4_PUBLIC_IDS = {
+            "-//W3C//DTD HTML 4.0 Frameset//EN",
+            "-//W3C//DTD HTML 4.0 Transitional//EN",
+            "-//W3C//DTD HTML 4.0//EN", "-//W3C//DTD HTML 4.01 Frameset//EN",
+            "-//W3C//DTD HTML 4.01 Transitional//EN",
+            "-//W3C//DTD HTML 4.01//EN" };
+
+    // ]NOCPP]
+
+    @Literal private final static String[] QUIRKY_PUBLIC_IDS = {
+            "+//silmaril//dtd html pro v0r11 19970101//",
+            "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
+            "-//as//dtd html 3.0 aswedit + extensions//",
+            "-//ietf//dtd html 2.0 level 1//",
+            "-//ietf//dtd html 2.0 level 2//",
+            "-//ietf//dtd html 2.0 strict level 1//",
+            "-//ietf//dtd html 2.0 strict level 2//",
+            "-//ietf//dtd html 2.0 strict//",
+            "-//ietf//dtd html 2.0//",
+            "-//ietf//dtd html 2.1e//",
+            "-//ietf//dtd html 3.0//",
+            "-//ietf//dtd html 3.2 final//",
+            "-//ietf//dtd html 3.2//",
+            "-//ietf//dtd html 3//",
+            "-//ietf//dtd html level 0//",
+            "-//ietf//dtd html level 1//",
+            "-//ietf//dtd html level 2//",
+            "-//ietf//dtd html level 3//",
+            "-//ietf//dtd html strict level 0//",
+            "-//ietf//dtd html strict level 1//",
+            "-//ietf//dtd html strict level 2//",
+            "-//ietf//dtd html strict level 3//",
+            "-//ietf//dtd html strict//",
+            "-//ietf//dtd html//",
+            "-//metrius//dtd metrius presentational//",
+            "-//microsoft//dtd internet explorer 2.0 html strict//",
+            "-//microsoft//dtd internet explorer 2.0 html//",
+            "-//microsoft//dtd internet explorer 2.0 tables//",
+            "-//microsoft//dtd internet explorer 3.0 html strict//",
+            "-//microsoft//dtd internet explorer 3.0 html//",
+            "-//microsoft//dtd internet explorer 3.0 tables//",
+            "-//netscape comm. corp.//dtd html//",
+            "-//netscape comm. corp.//dtd strict html//",
+            "-//o'reilly and associates//dtd html 2.0//",
+            "-//o'reilly and associates//dtd html extended 1.0//",
+            "-//o'reilly and associates//dtd html extended relaxed 1.0//",
+            "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
+            "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
+            "-//spyglass//dtd html 2.0 extended//",
+            "-//sq//dtd html 2.0 hotmetal + extensions//",
+            "-//sun microsystems corp.//dtd hotjava html//",
+            "-//sun microsystems corp.//dtd hotjava strict html//",
+            "-//w3c//dtd html 3 1995-03-24//", "-//w3c//dtd html 3.2 draft//",
+            "-//w3c//dtd html 3.2 final//", "-//w3c//dtd html 3.2//",
+            "-//w3c//dtd html 3.2s draft//", "-//w3c//dtd html 4.0 frameset//",
+            "-//w3c//dtd html 4.0 transitional//",
+            "-//w3c//dtd html experimental 19960712//",
+            "-//w3c//dtd html experimental 970421//", "-//w3c//dtd w3 html//",
+            "-//w3o//dtd w3 html 3.0//", "-//webtechs//dtd mozilla html 2.0//",
+            "-//webtechs//dtd mozilla html//" };
+
+    private static final int NOT_FOUND_ON_STACK = Integer.MAX_VALUE;
+
+    private static final int IN_FOREIGN = 0;
+
+    private static final int NOT_IN_FOREIGN = 1;
+
+    // [NOCPP[
+    
+    private static final @Local String HTML_LOCAL = "html";
+    
+    // ]NOCPP]
+    
+    private int mode = INITIAL;
+
+    private int originalMode = INITIAL;
+
+    private int foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+
+    protected Tokenizer tokenizer;
+
+    // [NOCPP[
+
+    protected ErrorHandler errorHandler;
+
+    // ]NOCPP]
+
+    private DocumentModeHandler documentModeHandler;
+
+    // [NOCPP[
+
+    private DoctypeExpectation doctypeExpectation = DoctypeExpectation.HTML;
+
+    // ]NOCPP]
+
+    private boolean scriptingEnabled = false;
+
+    private boolean needToDropLF;
+
+    // [NOCPP[
+
+    private boolean wantingComments;
+
+    // ]NOCPP]
+
+    private boolean fragment;
+
+    private @Local String contextName;
+
+    private @NsUri String contextNamespace;
+
+    private T contextNode;
+    
+    private StackNode<T>[] stack;
+
+    private int currentPtr = -1;
+
+    private StackNode<T>[] listOfActiveFormattingElements;
+
+    private int listPtr = -1;
+
+    private T formPointer;
+
+    private T headPointer;
+    
+    protected char[] charBuffer;
+
+    protected int charBufferLen = 0;
+    
+    private boolean quirks = false;
+
+    // [NOCPP[
+
+    private boolean reportingDoctype = true;
+
+    private XmlViolationPolicy namePolicy = XmlViolationPolicy.ALTER_INFOSET;
+
+    private final Map<String, LocatorImpl> idLocations = new HashMap<String, LocatorImpl>();
+
+    private boolean html4;
+
+    // ]NOCPP]
+
+    protected TreeBuilder() {
+        fragment = false;
+    }
+
+    /**
+     * Reports an condition that would make the infoset incompatible with XML
+     * 1.0 as fatal.
+     * 
+     * @throws SAXException
+     * @throws SAXParseException
+     */
+    protected void fatal() throws SAXException {
+    }
+
+    // [NOCPP[
+
+    protected final void fatal(Exception e) throws SAXException {
+        SAXParseException spe = new SAXParseException(e.getMessage(),
+                tokenizer, e);
+        if (errorHandler != null) {
+            errorHandler.fatalError(spe);
+        }
+        throw spe;
+    }
+
+    final void fatal(String s) throws SAXException {
+        SAXParseException spe = new SAXParseException(s, tokenizer);
+        if (errorHandler != null) {
+            errorHandler.fatalError(spe);
+        }
+        throw spe;
+    }
+
+    // ]NOCPP]
+
+    /**
+     * Reports a Parse Error.
+     * 
+     * @param message
+     *            the message
+     * @throws SAXException
+     */
+    final void err(String message) throws SAXException {
+        // [NOCPP[
+        if (errorHandler == null) {
+            return;
+        }
+        SAXParseException spe = new SAXParseException(message, tokenizer);
+        errorHandler.error(spe);
+        // ]NOCPP]
+    }
+
+    /**
+     * Reports a warning
+     * 
+     * @param message
+     *            the message
+     * @throws SAXException
+     */
+    final void warn(String message) throws SAXException {
+        // [NOCPP[
+        if (errorHandler == null) {
+            return;
+        }
+        SAXParseException spe = new SAXParseException(message, tokenizer);
+        errorHandler.warning(spe);
+        // ]NOCPP]
+    }
+
+    public final void startTokenization(Tokenizer self) throws SAXException {
+        tokenizer = self;
+        stack = new StackNode[64];
+        listOfActiveFormattingElements = new StackNode[64];
+        needToDropLF = false;
+        originalMode = INITIAL;
+        currentPtr = -1;
+        listPtr = -1;
+        Portability.releaseElement(formPointer);
+        formPointer = null;
+        Portability.releaseElement(headPointer);
+        headPointer = null;
+        // [NOCPP[
+        html4 = false;
+        idLocations.clear();
+        wantingComments = wantsComments();
+        // ]NOCPP]
+        start(fragment);
+        charBufferLen = 0;
+        charBuffer = new char[1024];
+        if (fragment) {
+            T elt;
+            if (contextNode != null) {
+                elt = contextNode;
+                Portability.retainElement(elt);
+            } else {
+                elt = createHtmlElementSetAsRoot(tokenizer.emptyAttributes());
+            }
+            StackNode<T> node = new StackNode<T>(
+                    "http://www.w3.org/1999/xhtml", ElementName.HTML, elt);
+            currentPtr++;
+            stack[currentPtr] = node;
+            resetTheInsertionMode();
+            if ("title" == contextName || "textarea" == contextName) {
+                tokenizer.setContentModelFlag(Tokenizer.RCDATA, contextName);
+            } else if ("style" == contextName || "script" == contextName
+                    || "xmp" == contextName || "iframe" == contextName
+                    || "noembed" == contextName || "noframes" == contextName
+                    || (scriptingEnabled && "noscript" == contextName)) {
+                tokenizer.setContentModelFlag(Tokenizer.CDATA, contextName);
+            } else if ("plaintext" == contextName) {
+                tokenizer.setContentModelFlag(Tokenizer.PLAINTEXT, contextName);
+            } else {
+                tokenizer.setContentModelFlag(Tokenizer.DATA, contextName);
+            }
+            Portability.releaseLocal(contextName);
+            contextName = null;
+            Portability.releaseElement(contextNode);
+            contextNode = null;
+            Portability.releaseElement(elt);
+        } else {
+            mode = INITIAL;
+            foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+        }
+    }
+
+    public final void doctype(@Local String name, String publicIdentifier,
+            String systemIdentifier, boolean forceQuirks) throws SAXException {
+        needToDropLF = false;
+        doctypeloop: for (;;) {
+            switch (foreignFlag) {
+                case IN_FOREIGN:
+                    break doctypeloop;
+                default:
+                    switch (mode) {
+                        case INITIAL:
+                            // [NOCPP[
+                            if (reportingDoctype) {
+                                // ]NOCPP]
+                                String emptyString = Portability.newEmptyString();
+                                appendDoctypeToDocument(name == null ? ""
+                                        : name,
+                                        publicIdentifier == null ? emptyString
+                                                : publicIdentifier,
+                                        systemIdentifier == null ? emptyString
+                                                : systemIdentifier);
+                                Portability.releaseString(emptyString);
+                                // [NOCPP[
+                            }
+                            switch (doctypeExpectation) {
+                                case HTML:
+                                    // ]NOCPP]
+                                    if (isQuirky(name, publicIdentifier,
+                                            systemIdentifier, forceQuirks)) {
+                                        err("Quirky doctype. Expected \u201C<!DOCTYPE html>\u201D.");
+                                        documentModeInternal(
+                                                DocumentMode.QUIRKS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, false);
+                                    } else if (isAlmostStandards(
+                                            publicIdentifier, systemIdentifier)) {
+                                        err("Almost standards mode doctype. Expected \u201C<!DOCTYPE html>\u201D.");
+                                        documentModeInternal(
+                                                DocumentMode.ALMOST_STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, false);
+                                    } else {
+                                        // [NOCPP[
+                                        if (!((systemIdentifier == null || Portability.literalEqualsString(
+                                                "about:legacy-compat",
+                                                systemIdentifier)) && publicIdentifier == null)) {
+                                            err("Legacy doctype. Expected \u201C<!DOCTYPE html>\u201D.");
+                                        }
+                                        // ]NOCPP]
+                                        documentModeInternal(
+                                                DocumentMode.STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, false);
+                                    }
+                                    // [NOCPP[
+                                    break;
+                                case HTML401_STRICT:
+                                    html4 = true;
+                                    tokenizer.turnOnAdditionalHtml4Errors();
+                                    if (isQuirky(name, publicIdentifier,
+                                            systemIdentifier, forceQuirks)) {
+                                        err("Quirky doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                                        documentModeInternal(
+                                                DocumentMode.QUIRKS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, true);
+                                    } else if (isAlmostStandards(
+                                            publicIdentifier, systemIdentifier)) {
+                                        err("Almost standards mode doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                                        documentModeInternal(
+                                                DocumentMode.ALMOST_STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, true);
+                                    } else {
+                                        if ("-//W3C//DTD HTML 4.01//EN".equals(publicIdentifier)) {
+                                            if (!"http://www.w3.org/TR/html4/strict.dtd".equals(systemIdentifier)) {
+                                                warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                                            }
+                                        } else {
+                                            err("The doctype was not the HTML 4.01 Strict doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                                        }
+                                        documentModeInternal(
+                                                DocumentMode.STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, true);
+                                    }
+                                    break;
+                                case HTML401_TRANSITIONAL:
+                                    html4 = true;
+                                    tokenizer.turnOnAdditionalHtml4Errors();
+                                    if (isQuirky(name, publicIdentifier,
+                                            systemIdentifier, forceQuirks)) {
+                                        err("Quirky doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                                        documentModeInternal(
+                                                DocumentMode.QUIRKS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, true);
+                                    } else if (isAlmostStandards(
+                                            publicIdentifier, systemIdentifier)) {
+                                        if ("-//W3C//DTD HTML 4.01 Transitional//EN".equals(publicIdentifier)
+                                                && systemIdentifier != null) {
+                                            if (!"http://www.w3.org/TR/html4/loose.dtd".equals(systemIdentifier)) {
+                                                warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                                            }
+                                        } else {
+                                            err("The doctype was not a non-quirky HTML 4.01 Transitional doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                                        }
+                                        documentModeInternal(
+                                                DocumentMode.ALMOST_STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, true);
+                                    } else {
+                                        err("The doctype was not the HTML 4.01 Transitional doctype. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                                        documentModeInternal(
+                                                DocumentMode.STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, true);
+                                    }
+                                    break;
+                                case AUTO:
+                                    html4 = isHtml4Doctype(publicIdentifier);
+                                    if (html4) {
+                                        tokenizer.turnOnAdditionalHtml4Errors();
+                                    }
+                                    if (isQuirky(name, publicIdentifier,
+                                            systemIdentifier, forceQuirks)) {
+                                        err("Quirky doctype. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
+                                        documentModeInternal(
+                                                DocumentMode.QUIRKS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, html4);
+                                    } else if (isAlmostStandards(
+                                            publicIdentifier, systemIdentifier)) {
+                                        if ("-//W3C//DTD HTML 4.01 Transitional//EN".equals(publicIdentifier)) {
+                                            if (!"http://www.w3.org/TR/html4/loose.dtd".equals(systemIdentifier)) {
+                                                warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                                            }
+                                        } else {
+                                            err("Almost standards mode doctype. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
+                                        }
+                                        documentModeInternal(
+                                                DocumentMode.ALMOST_STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, html4);
+                                    } else {
+                                        if ("-//W3C//DTD HTML 4.01//EN".equals(publicIdentifier)) {
+                                            if (!"http://www.w3.org/TR/html4/strict.dtd".equals(systemIdentifier)) {
+                                                warn("The doctype did not contain the system identifier prescribed by the HTML 4.01 specification. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                                            }
+                                        } else {
+                                            if (!(publicIdentifier == null && systemIdentifier == null)) {
+                                                err("Legacy doctype. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
+                                            }
+                                        }
+                                        documentModeInternal(
+                                                DocumentMode.STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, html4);
+                                    }
+                                    break;
+                                case NO_DOCTYPE_ERRORS:
+                                    if (isQuirky(name, publicIdentifier,
+                                            systemIdentifier, forceQuirks)) {
+                                        documentModeInternal(
+                                                DocumentMode.QUIRKS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, false);
+                                    } else if (isAlmostStandards(
+                                            publicIdentifier, systemIdentifier)) {
+                                        documentModeInternal(
+                                                DocumentMode.ALMOST_STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, false);
+                                    } else {
+                                        documentModeInternal(
+                                                DocumentMode.STANDARDS_MODE,
+                                                publicIdentifier,
+                                                systemIdentifier, false);
+                                    }
+                                    break;
+                            }
+                            // ]NOCPP]
+
+                            /*
+                             * 
+                             * Then, switch to the root element mode of the tree
+                             * construction stage.
+                             */
+                            mode = BEFORE_HTML;
+                            return;
+                        default:
+                            break doctypeloop;
+                    }
+            }
+
+        }
+        /*
+         * A DOCTYPE token Parse error.
+         */
+        err("Stray doctype.");
+        /*
+         * Ignore the token.
+         */
+        return;
+    }
+
+    // [NOCPP[
+
+    private boolean isHtml4Doctype(String publicIdentifier) {
+        if (publicIdentifier != null
+                && (Arrays.binarySearch(TreeBuilder.HTML4_PUBLIC_IDS,
+                        publicIdentifier) > -1)) {
+            return true;
+        }
+        return false;
+    }
+
+    // ]NOCPP]
+
+    public final void comment(@NoLength char[] buf, int start, int length)
+            throws SAXException {
+        needToDropLF = false;
+        // [NOCPP[
+        if (!wantingComments) {
+            return;
+        }
+        // ]NOCPP]
+        commentloop: for (;;) {
+            switch (foreignFlag) {
+                case IN_FOREIGN:
+                    break commentloop;
+                default:
+                    switch (mode) {
+                        case INITIAL:
+                        case BEFORE_HTML:
+                        case AFTER_AFTER_BODY:
+                        case AFTER_AFTER_FRAMESET:
+                            /*
+                             * A comment token Append a Comment node to the
+                             * Document object with the data attribute set to
+                             * the data given in the comment token.
+                             */
+                            appendCommentToDocument(buf, start, length);
+                            return;
+                        case AFTER_BODY:
+                            /*
+                             * A comment token Append a Comment node to the
+                             * first element in the stack of open elements (the
+                             * html element), with the data attribute set to the
+                             * data given in the comment token.
+                             */
+                            flushCharacters();
+                            appendComment(stack[0].node, buf, start, length);
+                            return;
+                        default:
+                            break commentloop;
+                    }
+            }
+        }
+        /*
+         * A comment token Append a Comment node to the current node with the
+         * data attribute set to the data given in the comment token.
+         */
+        flushCharacters();
+        appendComment(stack[currentPtr].node, buf, start, length);
+        return;
+    }
+
+    /**
+     * @see nu.validator.htmlparser.common.TokenHandler#characters(char[], int,
+     *      int)
+     */
+    public final void characters(@NoLength char[] buf, int start, int length)
+            throws SAXException {
+        if (needToDropLF) {
+            if (buf[start] == '\n') {
+                start++;
+                length--;
+                if (length == 0) {
+                    return;
+                }
+            }
+            needToDropLF = false;
+        }
+
+        // optimize the most common case
+        // XXX should there be an IN FOREIGN check here?
+        switch (mode) {
+            case IN_BODY:
+            case IN_CELL:
+            case IN_CAPTION:
+                reconstructTheActiveFormattingElements();
+                // fall through
+            case IN_CDATA_RCDATA:
+                accumulateCharacters(buf, start, length);
+                return;
+            default:
+                int end = start + length;
+                charactersloop: for (int i = start; i < end; i++) {
+                    switch (buf[i]) {
+                        case ' ':
+                        case '\t':
+                        case '\n':
+                        case '\u000C':
+                            /*
+                             * A character token that is one of one of U+0009
+                             * CHARACTER TABULATION, U+000A LINE FEED (LF),
+                             * U+000C FORM FEED (FF), or U+0020 SPACE
+                             */
+                            switch (mode) {
+                                case INITIAL:
+                                case BEFORE_HTML:
+                                case BEFORE_HEAD:
+                                    /*
+                                     * Ignore the token.
+                                     */
+                                    start = i + 1;
+                                    continue;
+                                case FRAMESET_OK:
+                                case IN_HEAD:
+                                case IN_HEAD_NOSCRIPT:
+                                case AFTER_HEAD:
+                                case IN_COLUMN_GROUP:
+                                case IN_FRAMESET:
+                                case AFTER_FRAMESET:
+                                    /*
+                                     * Append the character to the current node.
+                                     */
+                                    continue;
+                                case IN_BODY:
+                                case IN_CELL:
+                                case IN_CAPTION:
+                                    // XXX is this dead code?
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+
+                                    /*
+                                     * Reconstruct the active formatting
+                                     * elements, if any.
+                                     */
+                                    reconstructTheActiveFormattingElements();
+                                    /*
+                                     * Append the token's character to the
+                                     * current node.
+                                     */
+                                    break charactersloop;
+                                case IN_SELECT:
+                                case IN_SELECT_IN_TABLE:
+                                    break charactersloop;
+                                case IN_TABLE:
+                                case IN_TABLE_BODY:
+                                case IN_ROW:
+                                    reconstructTheActiveFormattingElements();
+                                    accumulateCharacter(buf[i]);
+                                    start = i + 1;
+                                    continue;
+                                case AFTER_BODY:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Reconstruct the active formatting
+                                     * elements, if any.
+                                     */
+                                    reconstructTheActiveFormattingElements();
+                                    /*
+                                     * Append the token's character to the
+                                     * current node.
+                                     */
+                                    continue;
+                                case AFTER_AFTER_BODY:
+                                case AFTER_AFTER_FRAMESET:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Reconstruct the active formatting
+                                     * elements, if any.
+                                     */
+                                    reconstructTheActiveFormattingElements();
+                                    /*
+                                     * Append the token's character to the
+                                     * current node.
+                                     */
+                                    continue;
+                            }
+                        default:
+                            /*
+                             * A character token that is not one of one of
+                             * U+0009 CHARACTER TABULATION, U+000A LINE FEED
+                             * (LF), U+000C FORM FEED (FF), or U+0020 SPACE
+                             */
+                            switch (mode) {
+                                case INITIAL:
+                                    /*
+                                     * Parse error.
+                                     */
+                                    // [NOCPP[
+                                    switch (doctypeExpectation) {
+                                        case AUTO:
+                                            err("Non-space characters found without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
+                                            break;
+                                        case HTML:
+                                            err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D.");
+                                            break;
+                                        case HTML401_STRICT:
+                                            err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                                            break;
+                                        case HTML401_TRANSITIONAL:
+                                            err("Non-space characters found without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                                            break;
+                                        case NO_DOCTYPE_ERRORS:
+                                    }
+                                    // ]NOCPP]
+                                    /*
+                                     * 
+                                     * Set the document to quirks mode.
+                                     */
+                                    documentModeInternal(
+                                            DocumentMode.QUIRKS_MODE, null,
+                                            null, false);
+                                    /*
+                                     * Then, switch to the root element mode of
+                                     * the tree construction stage
+                                     */
+                                    mode = BEFORE_HTML;
+                                    /*
+                                     * and reprocess the current token.
+                                     */
+                                    i--;
+                                    continue;
+                                case BEFORE_HTML:
+                                    /*
+                                     * Create an HTMLElement node with the tag
+                                     * name html, in the HTML namespace. Append
+                                     * it to the Document object.
+                                     */
+                                    appendHtmlElementToDocumentAndPush();
+                                    /* Switch to the main mode */
+                                    mode = BEFORE_HEAD;
+                                    /*
+                                     * reprocess the current token.
+                                     */
+                                    i--;
+                                    continue;
+                                case BEFORE_HEAD:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * /Act as if a start tag token with the tag
+                                     * name "head" and no attributes had been
+                                     * seen,
+                                     */
+                                    appendToCurrentNodeAndPushHeadElement(HtmlAttributes.EMPTY_ATTRIBUTES);
+                                    mode = IN_HEAD;
+                                    /*
+                                     * then reprocess the current token.
+                                     * 
+                                     * This will result in an empty head element
+                                     * being generated, with the current token
+                                     * being reprocessed in the "after head"
+                                     * insertion mode.
+                                     */
+                                    i--;
+                                    continue;
+                                case IN_HEAD:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Act as if an end tag token with the tag
+                                     * name "head" had been seen,
+                                     */
+                                    pop();
+                                    mode = AFTER_HEAD;
+                                    /*
+                                     * and reprocess the current token.
+                                     */
+                                    i--;
+                                    continue;
+                                case IN_HEAD_NOSCRIPT:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Parse error. Act as if an end tag with
+                                     * the tag name "noscript" had been seen
+                                     */
+                                    err("Non-space character inside \u201Cnoscript\u201D inside \u201Chead\u201D.");
+                                    pop();
+                                    mode = IN_HEAD;
+                                    /*
+                                     * and reprocess the current token.
+                                     */
+                                    i--;
+                                    continue;
+                                case AFTER_HEAD:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Act as if a start tag token with the tag
+                                     * name "body" and no attributes had been
+                                     * seen,
+                                     */
+                                    appendToCurrentNodeAndPushBodyElement();
+                                    mode = FRAMESET_OK;
+                                    /*
+                                     * and then reprocess the current token.
+                                     */
+                                    i--;
+                                    continue;
+                                case FRAMESET_OK:
+                                    mode = IN_BODY;
+                                    i--;
+                                    continue;
+                                case IN_BODY:
+                                case IN_CELL:
+                                case IN_CAPTION:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Reconstruct the active formatting
+                                     * elements, if any.
+                                     */
+                                    reconstructTheActiveFormattingElements();
+                                    /*
+                                     * Append the token's character to the
+                                     * current node.
+                                     */
+                                    break charactersloop;
+                                case IN_TABLE:
+                                case IN_TABLE_BODY:
+                                case IN_ROW:
+                                    reconstructTheActiveFormattingElements();
+                                    accumulateCharacter(buf[i]);
+                                    start = i + 1;
+                                    continue;
+                                case IN_COLUMN_GROUP:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Act as if an end tag with the tag name
+                                     * "colgroup" had been seen, and then, if
+                                     * that token wasn't ignored, reprocess the
+                                     * current token.
+                                     */
+                                    if (currentPtr == 0) {
+                                        err("Non-space in \u201Ccolgroup\u201D when parsing fragment.");
+                                        start = i + 1;
+                                        continue;
+                                    }
+                                    pop();
+                                    mode = IN_TABLE;
+                                    i--;
+                                    continue;
+                                case IN_SELECT:
+                                case IN_SELECT_IN_TABLE:
+                                    break charactersloop;
+                                case AFTER_BODY:
+                                    err("Non-space character after body.");
+                                    fatal();
+                                    mode = IN_BODY;
+                                    i--;
+                                    continue;
+                                case IN_FRAMESET:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Parse error.
+                                     */
+                                    err("Non-space in \u201Cframeset\u201D.");
+                                    /*
+                                     * Ignore the token.
+                                     */
+                                    start = i + 1;
+                                    continue;
+                                case AFTER_FRAMESET:
+                                    if (start < i) {
+                                        accumulateCharacters(buf, start, i
+                                                - start);
+                                        start = i;
+                                    }
+                                    /*
+                                     * Parse error.
+                                     */
+                                    err("Non-space after \u201Cframeset\u201D.");
+                                    /*
+                                     * Ignore the token.
+                                     */
+                                    start = i + 1;
+                                    continue;
+                                case AFTER_AFTER_BODY:
+                                    /*
+                                     * Parse error.
+                                     */
+                                    err("Non-space character in page trailer.");
+                                    /*
+                                     * Switch back to the main mode and
+                                     * reprocess the token.
+                                     */
+                                    mode = IN_BODY;
+                                    i--;
+                                    continue;
+                                case AFTER_AFTER_FRAMESET:
+                                    /*
+                                     * Parse error.
+                                     */
+                                    err("Non-space character in page trailer.");
+                                    /*
+                                     * Switch back to the main mode and
+                                     * reprocess the token.
+                                     */
+                                    mode = IN_FRAMESET;
+                                    i--;
+                                    continue;
+                            }
+                    }
+                }
+                if (start < end) {
+                    accumulateCharacters(buf, start, end - start);
+                }
+        }
+    }
+
+    public final void eof() throws SAXException {
+        flushCharacters();
+        switch (foreignFlag) {
+            case IN_FOREIGN:
+                err("End of file in a foreign namespace context.");
+                while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
+                    popOnEof();
+                }
+                foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+            default:
+                // fall through
+        }
+        eofloop: for (;;) {
+            switch (mode) {
+                case INITIAL:
+                    /*
+                     * Parse error.
+                     */
+                    // [NOCPP[
+                    switch (doctypeExpectation) {
+                        case AUTO:
+                            err("End of file seen without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
+                            break;
+                        case HTML:
+                            err("End of file seen without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D.");
+                            break;
+                        case HTML401_STRICT:
+                            err("End of file seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                            break;
+                        case HTML401_TRANSITIONAL:
+                            err("End of file seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                            break;
+                        case NO_DOCTYPE_ERRORS:
+                    }
+                    // ]NOCPP]
+                    /*
+                     * 
+                     * Set the document to quirks mode.
+                     */
+                    documentModeInternal(DocumentMode.QUIRKS_MODE, null, null,
+                            false);
+                    /*
+                     * Then, switch to the root element mode of the tree
+                     * construction stage
+                     */
+                    mode = BEFORE_HTML;
+                    /*
+                     * and reprocess the current token.
+                     */
+                    continue;
+                case BEFORE_HTML:
+                    /*
+                     * Create an HTMLElement node with the tag name html, in the
+                     * HTML namespace. Append it to the Document object.
+                     */
+                    appendHtmlElementToDocumentAndPush();
+                    // XXX application cache manifest
+                    /* Switch to the main mode */
+                    mode = BEFORE_HEAD;
+                    /*
+                     * reprocess the current token.
+                     */
+                    continue;
+                case BEFORE_HEAD:
+                    appendToCurrentNodeAndPushHeadElement(HtmlAttributes.EMPTY_ATTRIBUTES);
+                    mode = IN_HEAD;
+                    continue;
+                case IN_HEAD:
+                    if (currentPtr > 1) {
+                        err("End of file seen and there were open elements.");
+                    }
+                    while (currentPtr > 0) {
+                        popOnEof();
+                    }
+                    mode = AFTER_HEAD;
+                    continue;
+                case IN_HEAD_NOSCRIPT:
+                    err("End of file seen and there were open elements.");
+                    while (currentPtr > 1) {
+                        popOnEof();
+                    }
+                    mode = IN_HEAD;
+                    continue;
+                case AFTER_HEAD:
+                    appendToCurrentNodeAndPushBodyElement();
+                    mode = IN_BODY;
+                    continue;
+                case IN_COLUMN_GROUP:
+                    if (currentPtr == 0) {
+                        assert fragment;
+                        break eofloop;
+                    } else {
+                        popOnEof();
+                        mode = IN_TABLE;
+                        continue;
+                    }
+                case FRAMESET_OK:
+                case IN_CAPTION:
+                case IN_CELL:
+                case IN_BODY:
+                    // [NOCPP[
+                    openelementloop: for (int i = currentPtr; i >= 0; i--) {
+                        int group = stack[i].group;
+                        switch (group) {
+                            case DD_OR_DT:
+                            case LI:
+                            case P:
+                            case TBODY_OR_THEAD_OR_TFOOT:
+                            case TD_OR_TH:
+                            case BODY:
+                            case HTML:
+                                break;
+                            default:
+                                err("End of file seen and there were open elements.");
+                                break openelementloop;
+                        }
+                    }
+                    // ]NOCPP]
+                    break eofloop;
+                case IN_CDATA_RCDATA:
+                    err("End of file seen inside an [R]CDATA element.");
+                    // XXX mark script as already executed
+                    if (originalMode == AFTER_HEAD) {
+                        popOnEof();
+                    }
+                    popOnEof();
+                    mode = originalMode;
+                    continue;
+                case IN_TABLE_BODY:
+                case IN_ROW:
+                case IN_TABLE:
+                case IN_SELECT:
+                case IN_SELECT_IN_TABLE:
+                case IN_FRAMESET:
+                    if (currentPtr > 0) {
+                        err("End of file seen and there were open elements.");
+                    }
+                    break eofloop;
+                case AFTER_BODY:
+                case AFTER_FRAMESET:
+                case AFTER_AFTER_BODY:
+                case AFTER_AFTER_FRAMESET:
+                default:
+                    // [NOCPP[
+                    if (currentPtr == 0) { // This silliness is here to poison
+                        // buggy compiler optimizations in
+                        // GWT
+                        System.currentTimeMillis();
+                    }
+                    // ]NOCPP]
+                    break eofloop;
+            }
+        }
+        while (currentPtr > 0) {
+            popOnEof();
+        }
+        if (!fragment) {
+            popOnEof();
+        }
+        /* Stop parsing. */
+    }
+
+    /**
+     * @see nu.validator.htmlparser.common.TokenHandler#endTokenization()
+     */
+    public final void endTokenization() throws SAXException {
+        Portability.releaseElement(formPointer);
+        formPointer = null;
+        Portability.releaseElement(headPointer);
+        headPointer = null;
+        while (currentPtr > -1) {
+            stack[currentPtr].release();
+            currentPtr--;
+        }
+        Portability.releaseArray(stack);
+        stack = null;
+        while (listPtr > -1) {
+            if (listOfActiveFormattingElements[listPtr] != null) {
+                listOfActiveFormattingElements[listPtr].release();
+            }
+            listPtr--;
+        }
+        Portability.releaseArray(listOfActiveFormattingElements);        
+        listOfActiveFormattingElements = null;
+        // [NOCPP[
+        idLocations.clear();
+        // ]NOCPP]
+        Portability.releaseArray(charBuffer);
+        charBuffer = null;
+        end();
+    }
+
+    public final void startTag(ElementName elementName,
+            HtmlAttributes attributes, boolean selfClosing) throws SAXException {
+        // [NOCPP[
+        if (errorHandler != null) {
+            // ID uniqueness
+            @IdType String id = attributes.getId();
+            if (id != null) {
+                LocatorImpl oldLoc = idLocations.get(id);
+                if (oldLoc != null) {
+                    err("Duplicate ID \u201C" + id + "\u201D.");
+                    errorHandler.warning(new SAXParseException(
+                            "The first occurrence of ID \u201C" + id
+                                    + "\u201D was here.", oldLoc));
+                } else {
+                    idLocations.put(id, new LocatorImpl(tokenizer));
+                }
+            }
+        }
+        // ]NOCPP]
+
+        int eltPos;
+        needToDropLF = false;
+        boolean needsPostProcessing = false;
+        starttagloop: for (;;) {
+            int group = elementName.group;
+            @Local String name = elementName.name;
+            switch (foreignFlag) {
+                case IN_FOREIGN:
+                    StackNode<T> currentNode = stack[currentPtr];
+                    @NsUri String currNs = currentNode.ns;
+                    int currGroup = currentNode.group;
+                    if (("http://www.w3.org/1999/xhtml" == currNs)
+                            || ("http://www.w3.org/1998/Math/MathML" == currNs && ((MGLYPH_OR_MALIGNMARK != group && MI_MO_MN_MS_MTEXT == currGroup) || (SVG == group && ANNOTATION_XML == currGroup)))
+                            || ("http://www.w3.org/2000/svg" == currNs && (TITLE == currGroup || (FOREIGNOBJECT_OR_DESC == currGroup)))) {
+                        needsPostProcessing = true;
+                        // fall through to non-foreign behavior
+                    } else {
+                        switch (group) {
+                            case B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U:
+                            case DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU:
+                            case BODY:
+                            case BR:
+                            case RUBY_OR_SPAN_OR_SUB_OR_SUP_OR_VAR:
+                            case DD_OR_DT:
+                            case UL_OR_OL_OR_DL:
+                            case EMBED_OR_IMG:
+                            case H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6:
+                            case HEAD:
+                            case HR:
+                            case LI:
+                            case META:
+                            case NOBR:
+                            case P:
+                            case PRE_OR_LISTING:
+                            case TABLE:
+                                err("HTML start tag \u201C"
+                                        + name
+                                        + "\u201D in a foreign namespace context.");
+                                while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
+                                    pop();
+                                }
+                                foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+                                continue starttagloop;
+                            case FONT:
+                                if (attributes.contains(AttributeName.COLOR) || attributes.contains(AttributeName.FACE) || attributes.contains(AttributeName.SIZE)) {
+                                    err("HTML start tag \u201C"
+                                            + name
+                                            + "\u201D in a foreign namespace context.");
+                                    while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
+                                        pop();
+                                    }
+                                    foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+                                    continue starttagloop;                                    
+                                }
+                                // else fall thru
+                            default:
+                                if ("http://www.w3.org/2000/svg" == currNs) {
+                                    attributes.adjustForSvg();
+                                    if (selfClosing) {
+                                        appendVoidElementToCurrentMayFosterCamelCase(
+                                                currNs, elementName, attributes);
+                                        selfClosing = false;
+                                    } else {
+                                        appendToCurrentNodeAndPushElementMayFosterCamelCase(
+                                                currNs, elementName, attributes);
+                                    }
+                                    break starttagloop;
+                                } else {
+                                    attributes.adjustForMath();
+                                    if (selfClosing) {
+                                        appendVoidElementToCurrentMayFoster(
+                                                currNs, elementName, attributes);
+                                        selfClosing = false;
+                                    } else {
+                                        appendToCurrentNodeAndPushElementMayFosterNoScoping(
+                                                currNs, elementName, attributes);
+                                    }
+                                    break starttagloop;
+                                }
+                        }
+                    }
+                default:
+                    switch (mode) {
+                        case IN_TABLE_BODY:
+                            switch (group) {
+                                case TR:
+                                    clearStackBackTo(findLastInTableScopeOrRootTbodyTheadTfoot());
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    mode = IN_ROW;
+                                    break starttagloop;
+                                case TD_OR_TH:
+                                    err("\u201C" + name
+                                            + "\u201D start tag in table body.");
+                                    clearStackBackTo(findLastInTableScopeOrRootTbodyTheadTfoot());
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            ElementName.TR,
+                                            HtmlAttributes.EMPTY_ATTRIBUTES);
+                                    mode = IN_ROW;
+                                    continue;
+                                case CAPTION:
+                                case COL:
+                                case COLGROUP:
+                                case TBODY_OR_THEAD_OR_TFOOT:
+                                    eltPos = findLastInTableScopeOrRootTbodyTheadTfoot();
+                                    if (eltPos == 0) {
+                                        err("Stray \u201C" + name
+                                                + "\u201D start tag.");
+                                        break starttagloop;
+                                    } else {
+                                        clearStackBackTo(eltPos);
+                                        pop();
+                                        mode = IN_TABLE;
+                                        continue;
+                                    }
+                                default:
+                                    // fall through to IN_TABLE
+                            }
+                        case IN_ROW:
+                            switch (group) {
+                                case TD_OR_TH:
+                                    clearStackBackTo(findLastOrRoot(TreeBuilder.TR));
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    mode = IN_CELL;
+                                    insertMarker();
+                                    break starttagloop;
+                                case CAPTION:
+                                case COL:
+                                case COLGROUP:
+                                case TBODY_OR_THEAD_OR_TFOOT:
+                                case TR:
+                                    eltPos = findLastOrRoot(TreeBuilder.TR);
+                                    if (eltPos == 0) {
+                                        assert fragment;
+                                        err("No table row to close.");
+                                        break starttagloop;
+                                    }
+                                    clearStackBackTo(eltPos);
+                                    pop();
+                                    mode = IN_TABLE_BODY;
+                                    continue;
+                                default:
+                                    // fall through to IN_TABLE
+                            }
+                        case IN_TABLE:
+                            intableloop: for (;;) {
+                                switch (group) {
+                                    case CAPTION:
+                                        clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
+                                        insertMarker();
+                                        appendToCurrentNodeAndPushElement(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        mode = IN_CAPTION;
+                                        break starttagloop;
+                                    case COLGROUP:
+                                        clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
+                                        appendToCurrentNodeAndPushElement(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        mode = IN_COLUMN_GROUP;
+                                        break starttagloop;
+                                    case COL:
+                                        clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
+                                        appendToCurrentNodeAndPushElement(
+                                                "http://www.w3.org/1999/xhtml",
+                                                ElementName.COLGROUP,
+                                                HtmlAttributes.EMPTY_ATTRIBUTES);
+                                        mode = IN_COLUMN_GROUP;
+                                        continue starttagloop;
+                                    case TBODY_OR_THEAD_OR_TFOOT:
+                                        clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
+                                        appendToCurrentNodeAndPushElement(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        mode = IN_TABLE_BODY;
+                                        break starttagloop;
+                                    case TR:
+                                    case TD_OR_TH:
+                                        clearStackBackTo(findLastOrRoot(TreeBuilder.TABLE));
+                                        appendToCurrentNodeAndPushElement(
+                                                "http://www.w3.org/1999/xhtml",
+                                                ElementName.TBODY,
+                                                HtmlAttributes.EMPTY_ATTRIBUTES);
+                                        mode = IN_TABLE_BODY;
+                                        continue starttagloop;
+                                    case TABLE:
+                                        err("Start tag for \u201Ctable\u201D seen but the previous \u201Ctable\u201D is still open.");
+                                        eltPos = findLastInTableScope(name);
+                                        if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                            assert fragment;
+                                            break starttagloop;
+                                        }
+                                        generateImpliedEndTags();
+                                        // XXX is the next if dead code?
+                                        if (!isCurrent("table")) {
+                                            err("Unclosed elements on stack.");
+                                        }
+                                        while (currentPtr >= eltPos) {
+                                            pop();
+                                        }
+                                        resetTheInsertionMode();
+                                        continue starttagloop;
+                                    case SCRIPT:
+                                    case STYLE:
+                                        // XXX need to manage much more stuff
+                                        // here if
+                                        // supporting
+                                        // document.write()
+                                        appendToCurrentNodeAndPushElement(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        originalMode = mode;
+                                        mode = IN_CDATA_RCDATA;
+                                        tokenizer.setContentModelFlag(
+                                                Tokenizer.CDATA, elementName);
+                                        break starttagloop;
+                                    case INPUT:
+                                        if (!Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                                                        "hidden",
+                                                        attributes.getValue(AttributeName.TYPE))) {
+                                            break intableloop;
+                                        }
+                                        appendVoidElementToCurrent(
+                                                "http://www.w3.org/1999/xhtml",
+                                                name, attributes, formPointer);
+                                        selfClosing = false;
+                                        break starttagloop;
+                                    default:
+                                        err("Start tag \u201C"
+                                                + name
+                                                + "\u201D seen in \u201Ctable\u201D.");
+                                        // fall through to IN_BODY
+                                        break intableloop;
+                                }
+                            }
+                        case IN_CAPTION:
+                            switch (group) {
+                                case CAPTION:
+                                case COL:
+                                case COLGROUP:
+                                case TBODY_OR_THEAD_OR_TFOOT:
+                                case TR:
+                                case TD_OR_TH:
+                                    err("Stray \u201C"
+                                            + name
+                                            + "\u201D start tag in \u201Ccaption\u201D.");
+                                    eltPos = findLastInTableScope("caption");
+                                    if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                        break starttagloop;
+                                    }
+                                    generateImpliedEndTags();
+                                    if (currentPtr != eltPos) {
+                                        err("Unclosed elements on stack.");
+                                    }
+                                    while (currentPtr >= eltPos) {
+                                        pop();
+                                    }
+                                    clearTheListOfActiveFormattingElementsUpToTheLastMarker();
+                                    mode = IN_TABLE;
+                                    continue;
+                                default:
+                                    // fall through to IN_BODY
+                            }
+                        case IN_CELL:
+                            switch (group) {
+                                case CAPTION:
+                                case COL:
+                                case COLGROUP:
+                                case TBODY_OR_THEAD_OR_TFOOT:
+                                case TR:
+                                case TD_OR_TH:
+                                    eltPos = findLastInTableScopeTdTh();
+                                    if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                        err("No cell to close.");
+                                        break starttagloop;
+                                    } else {
+                                        closeTheCell(eltPos);
+                                        continue;
+                                    }
+                                default:
+                                    // fall through to IN_BODY
+                            }
+                        case FRAMESET_OK:
+                            switch (group) {
+                                case FRAMESET:
+                                    if (mode == FRAMESET_OK) {
+                                        if (currentPtr == 0 || stack[1].group != BODY) {
+                                            assert fragment;
+                                            err("Stray \u201Cframeset\u201D start tag.");                                            
+                                            break starttagloop;
+                                        } else {
+                                            err("\u201Cframeset\u201D start tag after \u201Cbody\u201D already open.");
+                                            detachFromParent(stack[1].node);
+                                            while (currentPtr > 0) {
+                                                pop();
+                                            }
+                                            appendToCurrentNodeAndPushElement(
+                                                    "http://www.w3.org/1999/xhtml",
+                                                    elementName, attributes);
+                                            mode = IN_FRAMESET;
+                                            break starttagloop;                                            
+                                        }
+                                    } else {
+                                        err("Stray \u201Cframeset\u201D start tag.");                                            
+                                        break starttagloop;
+                                    }
+                                    // NOT falling through!
+                                case PRE_OR_LISTING:
+                                case LI:
+                                case DD_OR_DT:
+                                case BUTTON:
+                                case MARQUEE_OR_APPLET:
+                                case OBJECT:
+                                case TABLE:
+                                case AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR:
+                                case BR:
+                                case EMBED_OR_IMG:
+                                case INPUT:
+                                case KEYGEN:
+                                case HR:
+                                case TEXTAREA:
+                                case XMP:
+                                case IFRAME:
+                                case SELECT:
+                                    if (mode == FRAMESET_OK) {
+                                        mode = IN_BODY;
+                                    }
+                                    // fall through to IN_BODY 
+                                default:
+                                    // fall through to IN_BODY                                
+                            }
+                        case IN_BODY:
+                            inbodyloop: for (;;) {
+                                switch (group) {
+                                    case HTML:
+                                        err("Stray \u201Chtml\u201D start tag.");
+                                        addAttributesToHtml(attributes);
+                                        break starttagloop;
+                                    case BASE:
+                                    case LINK:
+                                    case META:
+                                    case STYLE:
+                                    case SCRIPT:
+                                    case TITLE:
+                                    case COMMAND_OR_EVENT_SOURCE:
+                                        // Fall through to IN_HEAD
+                                        break inbodyloop;
+                                    case BODY:
+                                        err("\u201Cbody\u201D start tag found but the \u201Cbody\u201D element is already open.");
+                                        addAttributesToBody(attributes);
+                                        break starttagloop;
+                                    case P:
+                                    case DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU:
+                                    case UL_OR_OL_OR_DL:
+                                    case ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION:
+                                        implicitlyCloseP();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6:
+                                        implicitlyCloseP();
+                                        if(stack[currentPtr].group == H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6) {
+                                            err("Heading cannot be a child of another heading.");
+                                            pop();
+                                        }
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case FIELDSET:
+                                        implicitlyCloseP();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes,
+                                                formPointer);
+                                        break starttagloop;
+                                    case PRE_OR_LISTING:
+                                        implicitlyCloseP();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        needToDropLF = true;
+                                        break starttagloop;
+                                    case FORM:
+                                        if (formPointer != null) {
+                                            err("Saw a \u201Cform\u201D start tag, but there was already an active \u201Cform\u201D element. Nested forms are not allowed. Ignoring the tag.");
+                                            break starttagloop;
+                                        } else {
+                                            implicitlyCloseP();
+                                            appendToCurrentNodeAndPushFormElementMayFoster(attributes);
+                                            break starttagloop;
+                                        }
+                                    case LI:
+                                    case DD_OR_DT:
+                                        eltPos = currentPtr;
+                                        for (;;) {
+                                            StackNode<T> node = stack[eltPos]; // weak ref
+                                            if (node.group == group) { // LI or
+                                                // DD_OR_DT
+                                                generateImpliedEndTagsExceptFor(node.name);
+                                                if (eltPos != currentPtr) {
+                                                    err("Unclosed elements inside a list.");
+                                                }
+                                                while (currentPtr >= eltPos) {
+                                                    pop();
+                                                }
+                                                break;
+                                            } else if (node.scoping
+                                                    || (node.special
+                                                            && node.name != "p"
+                                                            && node.name != "address" && node.name != "div")) {
+                                                break;
+                                            }
+                                            eltPos--;
+                                        }
+                                        implicitlyCloseP();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case PLAINTEXT:
+                                        implicitlyCloseP();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        tokenizer.setContentModelFlag(
+                                                Tokenizer.PLAINTEXT,
+                                                elementName);
+                                        break starttagloop;
+                                    case A:
+                                        int activeAPos = findInListOfActiveFormattingElementsContainsBetweenEndAndLastMarker("a");
+                                        if (activeAPos != -1) {
+                                            err("An \u201Ca\u201D start tag seen with already an active \u201Ca\u201D element.");
+                                            StackNode<T> activeA = listOfActiveFormattingElements[activeAPos];
+                                            activeA.retain();
+                                            adoptionAgencyEndTag("a");
+                                            removeFromStack(activeA);
+                                            activeAPos = findInListOfActiveFormattingElements(activeA);
+                                            if (activeAPos != -1) {
+                                                removeFromListOfActiveFormattingElements(activeAPos);
+                                            }
+                                            activeA.release();
+                                        }
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushFormattingElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U:
+                                    case FONT:
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushFormattingElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case NOBR:
+                                        reconstructTheActiveFormattingElements();
+                                        if (TreeBuilder.NOT_FOUND_ON_STACK != findLastInScope("nobr")) {
+                                            err("\u201Cnobr\u201D start tag seen when there was an open \u201Cnobr\u201D element in scope.");
+                                            adoptionAgencyEndTag("nobr");
+                                        }
+                                        appendToCurrentNodeAndPushFormattingElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case BUTTON:
+                                        eltPos = findLastInScope(name);
+                                        if (eltPos != TreeBuilder.NOT_FOUND_ON_STACK) {
+                                            err("\u201Cbutton\u201D start tag seen when there was an open \u201Cbutton\u201D element in scope.");
+                                            generateImpliedEndTags();
+                                            if (!isCurrent("button")) {
+                                                err("There was an open \u201Cbutton\u201D element in scope with unclosed children.");
+                                            }
+                                            while (currentPtr >= eltPos) {
+                                                pop();
+                                            }
+                                            clearTheListOfActiveFormattingElementsUpToTheLastMarker();
+                                            continue starttagloop;
+                                        } else {
+                                            reconstructTheActiveFormattingElements();
+                                            appendToCurrentNodeAndPushElementMayFoster(
+                                                    "http://www.w3.org/1999/xhtml",
+                                                    elementName, attributes,
+                                                    formPointer);
+                                            insertMarker();
+                                            break starttagloop;
+                                        }
+                                    case OBJECT:
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes,
+                                                formPointer);
+                                        insertMarker();
+                                        break starttagloop;
+                                    case MARQUEE_OR_APPLET:
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        insertMarker();
+                                        break starttagloop;
+                                    case XMP:
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        originalMode = mode;
+                                        mode = IN_CDATA_RCDATA;
+                                        tokenizer.setContentModelFlag(
+                                                Tokenizer.CDATA, elementName);
+                                        break starttagloop;
+                                    case TABLE:
+                                        // The only quirk. Blame Hixie and Acid2.
+                                        if (!quirks) {
+                                            implicitlyCloseP();                                            
+                                        }
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        mode = IN_TABLE;
+                                        break starttagloop;
+                                    case BR:
+                                    case EMBED_OR_IMG:
+                                    case AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR:
+                                        reconstructTheActiveFormattingElements();
+                                        // FALL THROUGH to PARAM_OR_SOURCE
+                                    case PARAM_OR_SOURCE:
+                                        appendVoidElementToCurrentMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        selfClosing = false;
+                                        break starttagloop;
+                                    case HR:
+                                        implicitlyCloseP();
+                                        appendVoidElementToCurrentMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        selfClosing = false;
+                                        break starttagloop;
+                                    case IMAGE:
+                                        err("Saw a start tag \u201Cimage\u201D.");
+                                        elementName = ElementName.IMG;
+                                        continue starttagloop;
+                                    case KEYGEN:
+                                    case INPUT:
+                                        reconstructTheActiveFormattingElements();
+                                        appendVoidElementToCurrentMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                name, attributes, formPointer);
+                                        selfClosing = false;
+                                        break starttagloop;
+                                    case ISINDEX:
+                                        err("\u201Cisindex\u201D seen.");
+                                        if (formPointer != null) {
+                                            break starttagloop;
+                                        }
+                                        implicitlyCloseP();
+                                        HtmlAttributes formAttrs = new HtmlAttributes(0);
+                                        int actionIndex = attributes.getIndex(AttributeName.ACTION);
+                                        if (actionIndex > -1) {
+                                            formAttrs.addAttribute(
+                                                    AttributeName.ACTION,
+                                                    attributes.getValue(actionIndex)
+                                                    // [NOCPP[
+                                                    , XmlViolationPolicy.ALLOW
+                                            // ]NOCPP]
+                                            );
+                                        }
+                                        appendToCurrentNodeAndPushFormElementMayFoster(formAttrs);
+                                        appendVoidElementToCurrentMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                ElementName.HR,
+                                                HtmlAttributes.EMPTY_ATTRIBUTES);
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                ElementName.P,
+                                                HtmlAttributes.EMPTY_ATTRIBUTES);
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                ElementName.LABEL,
+                                                HtmlAttributes.EMPTY_ATTRIBUTES);
+                                        int promptIndex = attributes.getIndex(AttributeName.PROMPT);
+                                        if (promptIndex > -1) {
+                                            char[] prompt = Portability.newCharArrayFromString(attributes.getValue(promptIndex));
+                                            appendCharacters(
+                                                    stack[currentPtr].node,
+                                                    prompt, 0, prompt.length);
+                                            Portability.releaseArray(prompt);
+                                        } else {
+                                            // XXX localization
+                                            appendCharacters(
+                                                    stack[currentPtr].node,
+                                                    TreeBuilder.ISINDEX_PROMPT,
+                                                    0,
+                                                    TreeBuilder.ISINDEX_PROMPT.length);
+                                        }
+                                        HtmlAttributes inputAttributes = new HtmlAttributes(0);
+                                        inputAttributes.addAttribute(
+                                                AttributeName.NAME, Portability.newStringFromLiteral("isindex")
+                                                // [NOCPP[
+                                                , XmlViolationPolicy.ALLOW
+                                        // ]NOCPP]
+                                        );
+                                        for (int i = 0; i < attributes.getLength(); i++) {
+                                            AttributeName attributeQName = attributes.getAttributeName(i);
+                                            if (AttributeName.NAME == attributeQName || AttributeName.PROMPT == attributeQName) {
+                                                attributes.releaseValue(i);                                                
+                                            } else if (AttributeName.ACTION != attributeQName) {
+                                                inputAttributes.addAttribute(
+                                                        attributeQName,
+                                                        attributes.getValue(i)
+                                                        // [NOCPP[
+                                                        ,
+                                                        XmlViolationPolicy.ALLOW
+                                                // ]NOCPP]
+
+                                                );
+                                            }
+                                        }
+                                        attributes.clearWithoutReleasingContents();
+                                        appendVoidElementToCurrentMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                "input", inputAttributes,
+                                                formPointer);
+                                        // XXX localization
+                                        pop(); // label
+                                        pop(); // p
+                                        appendVoidElementToCurrentMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                ElementName.HR,
+                                                HtmlAttributes.EMPTY_ATTRIBUTES);
+                                        pop(); // form
+                                        selfClosing = false;
+                                        Portability.delete(formAttrs);
+                                        Portability.delete(inputAttributes);
+                                        break starttagloop;
+                                    case TEXTAREA:
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes,
+                                                formPointer);
+                                        tokenizer.setContentModelFlag(
+                                                Tokenizer.RCDATA, elementName);
+                                        originalMode = mode;
+                                        mode = IN_CDATA_RCDATA;
+                                        needToDropLF = true;
+                                        break starttagloop;
+                                    case NOSCRIPT:
+                                        if (!scriptingEnabled) {
+                                            reconstructTheActiveFormattingElements();
+                                            appendToCurrentNodeAndPushElementMayFoster(
+                                                    "http://www.w3.org/1999/xhtml",
+                                                    elementName, attributes);
+                                            break starttagloop;
+                                        } else {
+                                            // fall through
+                                        }
+                                    case NOFRAMES:
+                                    case IFRAME:
+                                    case NOEMBED:
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        originalMode = mode;
+                                        mode = IN_CDATA_RCDATA;
+                                        tokenizer.setContentModelFlag(
+                                                Tokenizer.CDATA, elementName);
+                                        break starttagloop;
+                                    case SELECT:
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes,
+                                                formPointer);
+                                        switch (mode) {
+                                            case IN_TABLE:
+                                            case IN_CAPTION:
+                                            case IN_COLUMN_GROUP:
+                                            case IN_TABLE_BODY:
+                                            case IN_ROW:
+                                            case IN_CELL:
+                                                mode = IN_SELECT_IN_TABLE;
+                                                break;
+                                            default:
+                                                mode = IN_SELECT;
+                                                break;
+                                        }
+                                        break starttagloop;
+                                    case OPTGROUP:
+                                    case OPTION:
+                                        /*
+                                         * If the stack of open elements has an
+                                         * option element in scope, then act as
+                                         * if an end tag with the tag name
+                                         * "option" had been seen.
+                                         */
+                                        if (findLastInScope("option") != TreeBuilder.NOT_FOUND_ON_STACK) {
+                                            optionendtagloop: for (;;) {
+                                                if (isCurrent("option")) {
+                                                    pop();
+                                                    break optionendtagloop;
+                                                }
+
+                                                eltPos = currentPtr;
+                                                for (;;) {
+                                                    if (stack[eltPos].name == "option") {
+                                                        generateImpliedEndTags();
+                                                        if (!isCurrent("option")) {
+                                                            err("End tag \u201C"
+                                                                    + name
+                                                                    + "\u201D seen but there were unclosed elements.");
+                                                        }
+                                                        while (currentPtr >= eltPos) {
+                                                            pop();
+                                                        }
+                                                        break optionendtagloop;
+                                                    }
+                                                    eltPos--;
+                                                }
+                                            }
+                                        }
+                                        /*
+                                         * Reconstruct the active formatting
+                                         * elements, if any.
+                                         */
+                                        reconstructTheActiveFormattingElements();
+                                        /*
+                                         * Insert an HTML element for the token.
+                                         */
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case RT_OR_RP:
+                                        /*
+                                         * If the stack of open elements has a
+                                         * ruby element in scope, then generate
+                                         * implied end tags. If the current node
+                                         * is not then a ruby element, this is a
+                                         * parse error; pop all the nodes from
+                                         * the current node up to the node
+                                         * immediately before the bottommost
+                                         * ruby element on the stack of open
+                                         * elements.
+                                         * 
+                                         * Insert an HTML element for the token.
+                                         */
+                                        eltPos = findLastInScope("ruby");
+                                        if (eltPos != NOT_FOUND_ON_STACK) {
+                                            generateImpliedEndTags();
+                                        }
+                                        if (eltPos != currentPtr) {
+                                            err("Unclosed children in \u201Cruby\u201D.");
+                                            while (currentPtr > eltPos) {
+                                                pop();
+                                            }
+                                        }
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                    case MATH:
+                                        reconstructTheActiveFormattingElements();
+                                        attributes.adjustForMath();
+                                        if (selfClosing) {
+                                            appendVoidElementToCurrentMayFoster(
+                                                    "http://www.w3.org/1998/Math/MathML",
+                                                    elementName, attributes);
+                                            selfClosing = false;
+                                        } else {
+                                            appendToCurrentNodeAndPushElementMayFoster(
+                                                    "http://www.w3.org/1998/Math/MathML",
+                                                    elementName, attributes);
+                                            foreignFlag = TreeBuilder.IN_FOREIGN;
+                                        }
+                                        break starttagloop;
+                                    case SVG:
+                                        reconstructTheActiveFormattingElements();
+                                        attributes.adjustForSvg();
+                                        if (selfClosing) {
+                                            appendVoidElementToCurrentMayFosterCamelCase(
+                                                    "http://www.w3.org/2000/svg",
+                                                    elementName, attributes);
+                                            selfClosing = false;
+                                        } else {
+                                            appendToCurrentNodeAndPushElementMayFoster(
+                                                    "http://www.w3.org/2000/svg",
+                                                    elementName, attributes);
+                                            foreignFlag = TreeBuilder.IN_FOREIGN;
+                                        }
+                                        break starttagloop;
+                                    case CAPTION:
+                                    case COL:
+                                    case COLGROUP:
+                                    case TBODY_OR_THEAD_OR_TFOOT:
+                                    case TR:
+                                    case TD_OR_TH:
+                                    case FRAME:
+                                    case FRAMESET:
+                                    case HEAD:
+                                        err("Stray start tag \u201C" + name
+                                                + "\u201D.");
+                                        break starttagloop;
+                                    case OUTPUT_OR_LABEL:
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes,
+                                                formPointer);
+                                        break starttagloop;
+                                    default:
+                                        reconstructTheActiveFormattingElements();
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        break starttagloop;
+                                }
+                            }
+                        case IN_HEAD:
+                            inheadloop: for (;;) {
+                                switch (group) {
+                                    case HTML:
+                                        err("Stray \u201Chtml\u201D start tag.");
+                                        addAttributesToHtml(attributes);
+                                        break starttagloop;
+                                    case BASE:
+                                    case COMMAND_OR_EVENT_SOURCE:
+                                        appendVoidElementToCurrentMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        selfClosing = false;
+                                        break starttagloop;
+                                    case META:
+                                    case LINK:
+                                        // Fall through to IN_HEAD_NOSCRIPT
+                                        break inheadloop;
+                                    case TITLE:
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        originalMode = mode;
+                                        mode = IN_CDATA_RCDATA;
+                                        tokenizer.setContentModelFlag(
+                                                Tokenizer.RCDATA, elementName);
+                                        break starttagloop;
+                                    case NOSCRIPT:
+                                        if (scriptingEnabled) {
+                                            appendToCurrentNodeAndPushElement(
+                                                    "http://www.w3.org/1999/xhtml",
+                                                    elementName, attributes);
+                                            originalMode = mode;
+                                            mode = IN_CDATA_RCDATA;
+                                            tokenizer.setContentModelFlag(
+                                                    Tokenizer.CDATA,
+                                                    elementName);
+                                        } else {
+                                            appendToCurrentNodeAndPushElementMayFoster(
+                                                    "http://www.w3.org/1999/xhtml",
+                                                    elementName, attributes);
+                                            mode = IN_HEAD_NOSCRIPT;
+                                        }
+                                        break starttagloop;
+                                    case SCRIPT:
+                                    case STYLE:
+                                    case NOFRAMES:
+                                        // XXX need to manage much more stuff
+                                        // here if
+                                        // supporting
+                                        // document.write()
+                                        appendToCurrentNodeAndPushElementMayFoster(
+                                                "http://www.w3.org/1999/xhtml",
+                                                elementName, attributes);
+                                        originalMode = mode;
+                                        mode = IN_CDATA_RCDATA;
+                                        tokenizer.setContentModelFlag(
+                                                Tokenizer.CDATA, elementName);
+                                        break starttagloop;
+                                    case HEAD:
+                                        /* Parse error. */
+                                        err("Start tag for \u201Chead\u201D seen when \u201Chead\u201D was already open.");
+                                        /* Ignore the token. */
+                                        break starttagloop;
+                                    default:
+                                        pop();
+                                        mode = AFTER_HEAD;
+                                        continue starttagloop;
+                                }
+                            }
+                        case IN_HEAD_NOSCRIPT:
+                            switch (group) {
+                                case HTML:
+                                    // XXX did Hixie really mean to omit "base"
+                                    // here?
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                case LINK:
+                                    appendVoidElementToCurrentMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    selfClosing = false;
+                                    break starttagloop;
+                                case META:
+                                    checkMetaCharset(attributes);
+                                    appendVoidElementToCurrentMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    selfClosing = false;
+                                    break starttagloop;
+                                case STYLE:
+                                case NOFRAMES:
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    originalMode = mode;
+                                    mode = IN_CDATA_RCDATA;
+                                    tokenizer.setContentModelFlag(
+                                            Tokenizer.CDATA, elementName);
+                                    break starttagloop;
+                                case HEAD:
+                                    err("Start tag for \u201Chead\u201D seen when \u201Chead\u201D was already open.");
+                                    break starttagloop;
+                                case NOSCRIPT:
+                                    err("Start tag for \u201Cnoscript\u201D seen when \u201Cnoscript\u201D was already open.");
+                                    break starttagloop;
+                                default:
+                                    err("Bad start tag in \u201C" + name
+                                            + "\u201D in \u201Chead\u201D.");
+                                    pop();
+                                    mode = IN_HEAD;
+                                    continue;
+                            }
+                        case IN_COLUMN_GROUP:
+                            switch (group) {
+                                case HTML:
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                case COL:
+                                    appendVoidElementToCurrentMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    selfClosing = false;
+                                    break starttagloop;
+                                default:
+                                    if (currentPtr == 0) {
+                                        assert fragment;
+                                        err("Garbage in \u201Ccolgroup\u201D fragment.");
+                                        break starttagloop;
+                                    }
+                                    pop();
+                                    mode = IN_TABLE;
+                                    continue;
+                            }
+                        case IN_SELECT_IN_TABLE:
+                            switch (group) {
+                                case CAPTION:
+                                case TBODY_OR_THEAD_OR_TFOOT:
+                                case TR:
+                                case TD_OR_TH:
+                                case TABLE:
+                                    err("\u201C"
+                                            + name
+                                            + "\u201D start tag with \u201Cselect\u201D open.");
+                                    endSelect();
+                                    continue;
+                                default:
+                                    // fall through to IN_SELECT
+                            }
+                        case IN_SELECT:
+                            switch (group) {
+                                case HTML:
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                case OPTION:
+                                    if (isCurrent("option")) {
+                                        pop();
+                                    }
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    break starttagloop;
+                                case OPTGROUP:
+                                    if (isCurrent("option")) {
+                                        pop();
+                                    }
+                                    if (isCurrent("optgroup")) {
+                                        pop();
+                                    }
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    break starttagloop;
+                                case SELECT:
+                                    err("\u201Cselect\u201D start tag where end tag expected.");
+                                    eltPos = findLastInTableScope(name);
+                                    if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                        assert fragment;
+                                        err("No \u201Cselect\u201D in table scope.");
+                                        break starttagloop;
+                                    } else {
+                                        while (currentPtr >= eltPos) {
+                                            pop();
+                                        }
+                                        resetTheInsertionMode();
+                                        break starttagloop;
+                                    }
+                                case INPUT: // XXX keygen?
+                                case TEXTAREA:
+                                    err("\u201C"
+                                            + name
+                                            + "\u201D start tag seen in \u201Cselect\2201D.");
+                                    endSelect();
+                                    continue;
+                                case SCRIPT:
+                                    // XXX need to manage much more stuff
+                                    // here if
+                                    // supporting
+                                    // document.write()
+                                    appendToCurrentNodeAndPushElementMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    originalMode = mode;
+                                    mode = IN_CDATA_RCDATA;
+                                    tokenizer.setContentModelFlag(
+                                            Tokenizer.CDATA, elementName);
+                                    break starttagloop;
+                                default:
+                                    err("Stray \u201C" + name
+                                            + "\u201D start tag.");
+                                    break starttagloop;
+                            }
+                        case AFTER_BODY:
+                            switch (group) {
+                                case HTML:
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                default:
+                                    err("Stray \u201C" + name
+                                            + "\u201D start tag.");
+                                    mode = IN_BODY;
+                                    continue;
+                            }
+                        case IN_FRAMESET:
+                            switch (group) {
+                                case FRAMESET:
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    break starttagloop;
+                                case FRAME:
+                                    appendVoidElementToCurrentMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    selfClosing = false;
+                                    break starttagloop;
+                                default:
+                                    // fall through to AFTER_FRAMESET
+                            }
+                        case AFTER_FRAMESET:
+                            switch (group) {
+                                case HTML:
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                case NOFRAMES:
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    originalMode = mode;
+                                    mode = IN_CDATA_RCDATA;
+                                    tokenizer.setContentModelFlag(
+                                            Tokenizer.CDATA, elementName);
+                                    break starttagloop;
+                                default:
+                                    err("Stray \u201C" + name
+                                            + "\u201D start tag.");
+                                    break starttagloop;
+                            }
+                        case INITIAL:
+                            /*
+                             * Parse error.
+                             */
+                            // [NOCPP[
+                            switch (doctypeExpectation) {
+                                case AUTO:
+                                    err("Start tag seen without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
+                                    break;
+                                case HTML:
+                                    err("Start tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D.");
+                                    break;
+                                case HTML401_STRICT:
+                                    err("Start tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                                    break;
+                                case HTML401_TRANSITIONAL:
+                                    err("Start tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                                    break;
+                                case NO_DOCTYPE_ERRORS:
+                            }
+                            // ]NOCPP]
+                            /*
+                             * 
+                             * Set the document to quirks mode.
+                             */
+                            documentModeInternal(DocumentMode.QUIRKS_MODE,
+                                    null, null, false);
+                            /*
+                             * Then, switch to the root element mode of the tree
+                             * construction stage
+                             */
+                            mode = BEFORE_HTML;
+                            /*
+                             * and reprocess the current token.
+                             */
+                            continue;
+                        case BEFORE_HTML:
+                            switch (group) {
+                                case HTML:
+                                    // optimize error check and streaming SAX by
+                                    // hoisting
+                                    // "html" handling here.
+                                    if (attributes == HtmlAttributes.EMPTY_ATTRIBUTES) {
+                                        // This has the right magic side effect
+                                        // that
+                                        // it
+                                        // makes attributes in SAX Tree mutable.
+                                        appendHtmlElementToDocumentAndPush();
+                                    } else {
+                                        appendHtmlElementToDocumentAndPush(attributes);
+                                    }
+                                    // XXX application cache should fire here
+                                    mode = BEFORE_HEAD;
+                                    break starttagloop;
+                                default:
+                                    /*
+                                     * Create an HTMLElement node with the tag
+                                     * name html, in the HTML namespace. Append
+                                     * it to the Document object.
+                                     */
+                                    appendHtmlElementToDocumentAndPush();
+                                    /* Switch to the main mode */
+                                    mode = BEFORE_HEAD;
+                                    /*
+                                     * reprocess the current token.
+                                     */
+                                    continue;
+                            }
+                        case BEFORE_HEAD:
+                            switch (group) {
+                                case HTML:
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                case HEAD:
+                                    /*
+                                     * A start tag whose tag name is "head"
+                                     * 
+                                     * Create an element for the token.
+                                     * 
+                                     * Set the head element pointer to this new
+                                     * element node.
+                                     * 
+                                     * Append the new element to the current
+                                     * node and push it onto the stack of open
+                                     * elements.
+                                     */
+                                    appendToCurrentNodeAndPushHeadElement(attributes);
+                                    /*
+                                     * 
+                                     * Change the insertion mode to "in head".
+                                     */
+                                    mode = IN_HEAD;
+                                    break starttagloop;
+                                default:
+
+                                    /*
+                                     * Any other start tag token
+                                     */
+
+                                    /*
+                                     * Act as if a start tag token with the tag
+                                     * name "head" and no attributes had been
+                                     * seen,
+                                     */
+                                    appendToCurrentNodeAndPushHeadElement(HtmlAttributes.EMPTY_ATTRIBUTES);
+                                    mode = IN_HEAD;
+                                    /*
+                                     * then reprocess the current token.
+                                     * 
+                                     * This will result in an empty head element
+                                     * being generated, with the current token
+                                     * being reprocessed in the "after head"
+                                     * insertion mode.
+                                     */
+                                    continue;
+                            }
+                        case AFTER_HEAD:
+                            switch (group) {
+                                case HTML:
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                case BODY:
+                                    if (attributes.getLength() == 0) {
+                                        // This has the right magic side effect
+                                        // that
+                                        // it
+                                        // makes attributes in SAX Tree mutable.
+                                        appendToCurrentNodeAndPushBodyElement();
+                                    } else {
+                                        appendToCurrentNodeAndPushBodyElement(attributes);
+                                    }
+                                    mode = FRAMESET_OK;
+                                    break starttagloop;
+                                case FRAMESET:
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    mode = IN_FRAMESET;
+                                    break starttagloop;
+                                case BASE:
+                                    err("\u201Cbase\u201D element outside \u201Chead\u201D.");
+                                    pushHeadPointerOntoStack();
+                                    appendVoidElementToCurrentMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    selfClosing = false;
+                                    pop(); // head
+                                    break starttagloop;
+                                case LINK:
+                                    err("\u201Clink\u201D element outside \u201Chead\u201D.");
+                                    pushHeadPointerOntoStack();
+                                    appendVoidElementToCurrentMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    selfClosing = false;
+                                    pop(); // head
+                                    break starttagloop;
+                                case META:
+                                    err("\u201Cmeta\u201D element outside \u201Chead\u201D.");
+                                    checkMetaCharset(attributes);
+                                    pushHeadPointerOntoStack();
+                                    appendVoidElementToCurrentMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    selfClosing = false;
+                                    pop(); // head
+                                    break starttagloop;
+                                case SCRIPT:
+                                    err("\u201Cscript\u201D element between \u201Chead\u201D and \u201Cbody\u201D.");
+                                    pushHeadPointerOntoStack();
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    originalMode = mode;
+                                    mode = IN_CDATA_RCDATA;
+                                    tokenizer.setContentModelFlag(
+                                            Tokenizer.CDATA, elementName);
+                                    break starttagloop;
+                                case STYLE:
+                                case NOFRAMES:
+                                    err("\u201C"
+                                            + name
+                                            + "\u201D element between \u201Chead\u201D and \u201Cbody\u201D.");
+                                    pushHeadPointerOntoStack();
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    originalMode = mode;
+                                    mode = IN_CDATA_RCDATA;
+                                    tokenizer.setContentModelFlag(
+                                            Tokenizer.CDATA, elementName);
+                                    break starttagloop;
+                                case TITLE:
+                                    err("\u201Ctitle\u201D element outside \u201Chead\u201D.");
+                                    pushHeadPointerOntoStack();
+                                    appendToCurrentNodeAndPushElement(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    originalMode = mode;
+                                    mode = IN_CDATA_RCDATA;
+                                    tokenizer.setContentModelFlag(
+                                            Tokenizer.RCDATA, elementName);
+                                    break starttagloop;
+                                case HEAD:
+                                    err("Stray start tag \u201Chead\u201D.");
+                                    break starttagloop;
+                                default:
+                                    appendToCurrentNodeAndPushBodyElement();
+                                    mode = FRAMESET_OK;
+                                    continue;
+                            }
+                        case AFTER_AFTER_BODY:
+                            switch (group) {
+                                case HTML:
+                                    err("Stray \u201Chtml\u201D start tag.");
+                                    addAttributesToHtml(attributes);
+                                    break starttagloop;
+                                default:
+                                    err("Stray \u201C" + name
+                                            + "\u201D start tag.");
+                                    fatal();
+                                    mode = IN_BODY;
+                                    continue;
+                            }
+                        case AFTER_AFTER_FRAMESET:
+                            switch (group) {
+                                case NOFRAMES:
+                                    appendToCurrentNodeAndPushElementMayFoster(
+                                            "http://www.w3.org/1999/xhtml",
+                                            elementName, attributes);
+                                    originalMode = mode;
+                                    mode = IN_CDATA_RCDATA;
+                                    tokenizer.setContentModelFlag(
+                                            Tokenizer.CDATA, elementName);
+                                    break starttagloop;
+                                default:
+                                    err("Stray \u201C" + name
+                                            + "\u201D start tag.");
+                                    break starttagloop;
+                            }
+                            // [NOCPP[
+                        case IN_CDATA_RCDATA:
+                            assert false;
+                            // ]NOCPP]
+                    }
+            }
+        }
+        if (needsPostProcessing && foreignFlag == TreeBuilder.IN_FOREIGN
+                && !hasForeignInScope()) {
+            /*
+             * If, after doing so, the insertion mode is still "in foreign
+             * content", but there is no element in scope that has a namespace
+             * other than the HTML namespace, switch the insertion mode to the
+             * secondary insertion mode.
+             */
+            foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+        }
+        if (selfClosing) {
+            err("Self-closing syntax (\u201C/>\u201D) used on a non-void HTML element. Ignoring the slash and treating as a start tag.");
+        }
+    }
+
+    /**
+     * 
+     * <p>
+     * C++ memory note: The return value must be released.
+     * 
+     * @return
+     * @throws SAXException
+     * @throws StopSniffingException
+     */
+    public static String extractCharsetFromContent(String attributeValue) {
+        // This is a bit ugly. Converting the string to char array in order to
+        // make the portability layer smaller.
+        int charsetState = CHARSET_INITIAL;
+        int start = -1;
+        int end = -1;
+        char[] buffer = Portability.newCharArrayFromString(attributeValue);
+
+        charsetloop: for (int i = 0; i < buffer.length; i++) {
+            char c = buffer[i];
+            switch (charsetState) {
+                case CHARSET_INITIAL:
+                    switch (c) {
+                        case 'c':
+                        case 'C':
+                            charsetState = CHARSET_C;
+                            continue;
+                        default:
+                            continue;
+                    }
+                case CHARSET_C:
+                    switch (c) {
+                        case 'h':
+                        case 'H':
+                            charsetState = CHARSET_H;
+                            continue;
+                        default:
+                            charsetState = CHARSET_INITIAL;
+                            continue;
+                    }
+                case CHARSET_H:
+                    switch (c) {
+                        case 'a':
+                        case 'A':
+                            charsetState = CHARSET_A;
+                            continue;
+                        default:
+                            charsetState = CHARSET_INITIAL;
+                            continue;
+                    }
+                case CHARSET_A:
+                    switch (c) {
+                        case 'r':
+                        case 'R':
+                            charsetState = CHARSET_R;
+                            continue;
+                        default:
+                            charsetState = CHARSET_INITIAL;
+                            continue;
+                    }
+                case CHARSET_R:
+                    switch (c) {
+                        case 's':
+                        case 'S':
+                            charsetState = CHARSET_S;
+                            continue;
+                        default:
+                            charsetState = CHARSET_INITIAL;
+                            continue;
+                    }
+                case CHARSET_S:
+                    switch (c) {
+                        case 'e':
+                        case 'E':
+                            charsetState = CHARSET_E;
+                            continue;
+                        default:
+                            charsetState = CHARSET_INITIAL;
+                            continue;
+                    }
+                case CHARSET_E:
+                    switch (c) {
+                        case 't':
+                        case 'T':
+                            charsetState = CHARSET_T;
+                            continue;
+                        default:
+                            charsetState = CHARSET_INITIAL;
+                            continue;
+                    }
+                case CHARSET_T:
+                    switch (c) {
+                        case '\t':
+                        case '\n':
+                        case '\u000C':
+                        case '\r':
+                        case ' ':
+                            continue;
+                        case '=':
+                            charsetState = CHARSET_EQUALS;
+                            continue;
+                        default:
+                            return null;
+                    }
+                case CHARSET_EQUALS:
+                    switch (c) {
+                        case '\t':
+                        case '\n':
+                        case '\u000C':
+                        case '\r':
+                        case ' ':
+                            continue;
+                        case '\'':
+                            start = i + 1;
+                            charsetState = CHARSET_SINGLE_QUOTED;
+                            continue;
+                        case '\"':
+                            start = i + 1;
+                            charsetState = CHARSET_DOUBLE_QUOTED;
+                            continue;
+                        default:
+                            start = i;
+                            charsetState = CHARSET_UNQUOTED;
+                            continue;
+                    }
+                case CHARSET_SINGLE_QUOTED:
+                    switch (c) {
+                        case '\'':
+                            end = i;
+                            break charsetloop;
+                        default:
+                            continue;
+                    }
+                case CHARSET_DOUBLE_QUOTED:
+                    switch (c) {
+                        case '\"':
+                            end = i;
+                            break charsetloop;
+                        default:
+                            continue;
+                    }
+                case CHARSET_UNQUOTED:
+                    switch (c) {
+                        case '\t':
+                        case '\n':
+                        case '\u000C':
+                        case '\r':
+                        case ' ':
+                        case ';':
+                            end = i;
+                            break charsetloop;
+                        default:
+                            continue;
+                    }
+            }
+        }
+        String charset = null;
+        if (start != -1) {
+            if (end == -1) {
+                end = buffer.length;
+            }
+            charset = Portability.newStringFromBuffer(buffer, start, end - start);
+        }
+        Portability.releaseArray(buffer);
+        return charset;
+    }
+
+    private void checkMetaCharset(HtmlAttributes attributes)
+            throws SAXException {
+        String content = attributes.getValue(AttributeName.CONTENT);
+        String internalCharsetLegacy = null;
+        if (content != null) {
+            internalCharsetLegacy = TreeBuilder.extractCharsetFromContent(content);
+            // [NOCPP[
+            if (errorHandler != null
+                    && internalCharsetLegacy != null
+                    && !Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                            "content-type",
+                            attributes.getValue(AttributeName.HTTP_EQUIV))) {
+                warn("Attribute \u201Ccontent\u201D would be sniffed as an internal character encoding declaration but there was no matching \u201Chttp-equiv='Content-Type'\u201D attribute.");
+            }
+            // ]NOCPP]
+        }
+        if (internalCharsetLegacy == null) {
+            String internalCharsetHtml5 = attributes.getValue(AttributeName.CHARSET);
+            if (internalCharsetHtml5 != null) {
+                tokenizer.internalEncodingDeclaration(internalCharsetHtml5);
+                requestSuspension();
+            }
+        } else {
+            tokenizer.internalEncodingDeclaration(internalCharsetLegacy);
+            Portability.releaseString(internalCharsetLegacy);
+            requestSuspension();
+        }
+    }
+
+    public final void endTag(ElementName elementName) throws SAXException {
+        needToDropLF = false;
+        int eltPos;
+        endtagloop: for (;;) {
+            int group = elementName.group;
+            @Local String name = elementName.name;
+            switch (mode) {
+                case IN_ROW:
+                    switch (group) {
+                        case TR:
+                            eltPos = findLastOrRoot(TreeBuilder.TR);
+                            if (eltPos == 0) {
+                                assert fragment;
+                                err("No table row to close.");
+                                break endtagloop;
+                            }
+                            clearStackBackTo(eltPos);
+                            pop();
+                            mode = IN_TABLE_BODY;
+                            break endtagloop;
+                        case TABLE:
+                            eltPos = findLastOrRoot(TreeBuilder.TR);
+                            if (eltPos == 0) {
+                                assert fragment;
+                                err("No table row to close.");
+                                break endtagloop;
+                            }
+                            clearStackBackTo(eltPos);
+                            pop();
+                            mode = IN_TABLE_BODY;
+                            continue;
+                        case TBODY_OR_THEAD_OR_TFOOT:
+                            if (findLastInTableScope(name) == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                                break endtagloop;
+                            }
+                            eltPos = findLastOrRoot(TreeBuilder.TR);
+                            if (eltPos == 0) {
+                                assert fragment;
+                                err("No table row to close.");
+                                break endtagloop;
+                            }
+                            clearStackBackTo(eltPos);
+                            pop();
+                            mode = IN_TABLE_BODY;
+                            continue;
+                        case BODY:
+                        case CAPTION:
+                        case COL:
+                        case COLGROUP:
+                        case HTML:
+                        case TD_OR_TH:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                        default:
+                            // fall through to IN_TABLE
+                    }
+                case IN_TABLE_BODY:
+                    switch (group) {
+                        case TBODY_OR_THEAD_OR_TFOOT:
+                            eltPos = findLastOrRoot(name);
+                            if (eltPos == 0) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                                break endtagloop;
+                            }
+                            clearStackBackTo(eltPos);
+                            pop();
+                            mode = IN_TABLE;
+                            break endtagloop;
+                        case TABLE:
+                            eltPos = findLastInTableScopeOrRootTbodyTheadTfoot();
+                            if (eltPos == 0) {
+                                assert fragment;
+                                err("Stray end tag \u201Ctable\u201D.");
+                                break endtagloop;
+                            }
+                            clearStackBackTo(eltPos);
+                            pop();
+                            mode = IN_TABLE;
+                            continue;
+                        case BODY:
+                        case CAPTION:
+                        case COL:
+                        case COLGROUP:
+                        case HTML:
+                        case TD_OR_TH:
+                        case TR:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                        default:
+                            // fall through to IN_TABLE
+                    }
+                case IN_TABLE:
+                    switch (group) {
+                        case TABLE:
+                            eltPos = findLast("table");
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                assert fragment;
+                                err("Stray end tag \u201Ctable\u201D.");
+                                break endtagloop;
+                            }
+                            while (currentPtr >= eltPos) {
+                                pop();
+                            }
+                            resetTheInsertionMode();
+                            break endtagloop;
+                        case BODY:
+                        case CAPTION:
+                        case COL:
+                        case COLGROUP:
+                        case HTML:
+                        case TBODY_OR_THEAD_OR_TFOOT:
+                        case TD_OR_TH:
+                        case TR:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            // fall through to IN_BODY
+                    }
+                case IN_CAPTION:
+                    switch (group) {
+                        case CAPTION:
+                            eltPos = findLastInTableScope("caption");
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                break endtagloop;
+                            }
+                            generateImpliedEndTags();
+                            if (currentPtr != eltPos) {
+                                err("Unclosed elements on stack.");
+                            }
+                            while (currentPtr >= eltPos) {
+                                pop();
+                            }
+                            clearTheListOfActiveFormattingElementsUpToTheLastMarker();
+                            mode = IN_TABLE;
+                            break endtagloop;
+                        case TABLE:
+                            err("\u201Ctable\u201D closed but \u201Ccaption\u201D was still open.");
+                            eltPos = findLastInTableScope("caption");
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                break endtagloop;
+                            }
+                            generateImpliedEndTags();
+                            if (currentPtr != eltPos) {
+                                err("Unclosed elements on stack.");
+                            }
+                            while (currentPtr >= eltPos) {
+                                pop();
+                            }
+                            clearTheListOfActiveFormattingElementsUpToTheLastMarker();
+                            mode = IN_TABLE;
+                            continue;
+                        case BODY:
+                        case COL:
+                        case COLGROUP:
+                        case HTML:
+                        case TBODY_OR_THEAD_OR_TFOOT:
+                        case TD_OR_TH:
+                        case TR:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                        default:
+                            // fall through to IN_BODY
+                    }
+                case IN_CELL:
+                    switch (group) {
+                        case TD_OR_TH:
+                            eltPos = findLastInTableScope(name);
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                                break endtagloop;
+                            }
+                            generateImpliedEndTags();
+                            if (!isCurrent(name)) {
+                                err("Unclosed elements.");
+                            }
+                            while (currentPtr >= eltPos) {
+                                pop();
+                            }
+                            clearTheListOfActiveFormattingElementsUpToTheLastMarker();
+                            mode = IN_ROW;
+                            break endtagloop;
+                        case TABLE:
+                        case TBODY_OR_THEAD_OR_TFOOT:
+                        case TR:
+                            if (findLastInTableScope(name) == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                                break endtagloop;
+                            }
+                            closeTheCell(findLastInTableScopeTdTh());
+                            continue;
+                        case BODY:
+                        case CAPTION:
+                        case COL:
+                        case COLGROUP:
+                        case HTML:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                        default:
+                            // fall through to IN_BODY
+                    }
+                case FRAMESET_OK:
+                case IN_BODY:
+                    switch (group) {
+                        case BODY:
+                            if (!isSecondOnStackBody()) {
+                                assert fragment;
+                                err("Stray end tag \u201Cbody\u201D.");
+                                break endtagloop;
+                            }
+                            assert currentPtr >= 1;
+                            if (errorHandler != null) {
+                                uncloseloop1: for (int i = 2; i <= currentPtr; i++) {
+                                    switch (stack[i].group) {
+                                        case DD_OR_DT:
+                                        case LI:
+                                        case OPTGROUP:
+                                        case OPTION: // is this possible?
+                                        case P:
+                                        case RT_OR_RP:
+                                        case TD_OR_TH:
+                                        case TBODY_OR_THEAD_OR_TFOOT:
+                                            break;
+                                        default:
+                                            err("End tag for \u201Cbody\u201D seen but there were unclosed elements.");
+                                            break uncloseloop1;
+                                    }
+                                }
+                            }
+                            mode = AFTER_BODY;
+                            break endtagloop;
+                        case HTML:
+                            if (!isSecondOnStackBody()) {
+                                assert fragment;
+                                err("Stray end tag \u201Chtml\u201D.");
+                                break endtagloop;
+                            }
+                            if (errorHandler != null) {
+                                uncloseloop2: for (int i = 0; i <= currentPtr; i++) {
+                                    switch (stack[i].group) {
+                                        case DD_OR_DT:
+                                        case LI:
+                                        case P:
+                                        case TBODY_OR_THEAD_OR_TFOOT:
+                                        case TD_OR_TH:
+                                        case BODY:
+                                        case HTML:
+                                            break;
+                                        default:
+                                            err("End tag for \u201Chtml\u201D seen but there were unclosed elements.");
+                                            break uncloseloop2;
+                                    }
+                                }
+                            }
+                            mode = AFTER_BODY;
+                            continue;
+                        case DIV_OR_BLOCKQUOTE_OR_CENTER_OR_MENU:
+                        case UL_OR_OL_OR_DL:
+                        case PRE_OR_LISTING:
+                        case FIELDSET:
+                        case ADDRESS_OR_DIR_OR_ARTICLE_OR_ASIDE_OR_DATAGRID_OR_DETAILS_OR_DIALOG_OR_FIGURE_OR_FOOTER_OR_HEADER_OR_NAV_OR_SECTION:
+                            eltPos = findLastInScope(name);
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                            } else {
+                                generateImpliedEndTags();
+                                if (!isCurrent(name)) {
+                                    err("End tag \u201C"
+                                            + name
+                                            + "\u201D seen but there were unclosed elements.");
+                                }
+                                while (currentPtr >= eltPos) {
+                                    pop();
+                                }
+                            }
+                            break endtagloop;
+                        case FORM:
+                            if (formPointer == null) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                                break endtagloop;
+                            }
+                            Portability.releaseElement(formPointer);
+                            formPointer = null;
+                            eltPos = findLastInScope(name);
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                                break endtagloop;
+                            }
+                            generateImpliedEndTags();
+                            if (!isCurrent(name)) {
+                                err("End tag \u201C"
+                                        + name
+                                        + "\u201D seen but there were unclosed elements.");
+                            }
+                            removeFromStack(eltPos);
+                            break endtagloop;
+                        case P:
+                            eltPos = findLastInScope("p");
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("No \u201Cp\u201D element in scope but a \u201Cp\u201D end tag seen.");
+                                // XXX inline this case
+                                if (foreignFlag == TreeBuilder.IN_FOREIGN) {
+                                    err("HTML start tag \u201C"
+                                            + name
+                                            + "\u201D in a foreign namespace context.");
+                                    while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
+                                        pop();
+                                    }
+                                    foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+                                }
+                                appendVoidElementToCurrentMayFoster(
+                                        "http://www.w3.org/1999/xhtml",
+                                        elementName,
+                                        HtmlAttributes.EMPTY_ATTRIBUTES);
+                                break endtagloop;
+                            }
+                            generateImpliedEndTagsExceptFor("p");
+                            assert eltPos != TreeBuilder.NOT_FOUND_ON_STACK;
+                            if (eltPos != currentPtr) {
+                                err("End tag for \u201Cp\u201D seen, but there were unclosed elements.");
+                            }
+                            while (currentPtr >= eltPos) {
+                                pop();
+                            }
+                            break endtagloop;
+                        case DD_OR_DT:
+                        case LI:
+                            eltPos = findLastInScope(name);
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("No \u201C"
+                                        + name
+                                        + "\u201D element in scope but a \u201C"
+                                        + name + "\u201D end tag seen.");
+                            } else {
+                                generateImpliedEndTagsExceptFor(name);
+                                if (eltPos != currentPtr) {
+                                    err("End tag for \u201C"
+                                            + name
+                                            + "\u201D seen, but there were unclosed elements.");
+                                }
+                                while (currentPtr >= eltPos) {
+                                    pop();
+                                }
+                            }
+                            break endtagloop;
+                        case H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6:
+                            eltPos = findLastInScopeHn();
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                            } else {
+                                generateImpliedEndTags();
+                                if (!isCurrent(name)) {
+                                    err("End tag \u201C"
+                                            + name
+                                            + "\u201D seen but there were unclosed elements.");
+                                }
+                                while (currentPtr >= eltPos) {
+                                    pop();
+                                }
+                            }
+                            break endtagloop;
+                        case A:
+                        case B_OR_BIG_OR_CODE_OR_EM_OR_I_OR_S_OR_SMALL_OR_STRIKE_OR_STRONG_OR_TT_OR_U:
+                        case FONT:
+                        case NOBR:
+                            adoptionAgencyEndTag(name);
+                            break endtagloop;
+                        case BUTTON:
+                        case OBJECT:
+                        case MARQUEE_OR_APPLET:
+                            eltPos = findLastInScope(name);
+                            if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+                                err("Stray end tag \u201C" + name + "\u201D.");
+                            } else {
+                                generateImpliedEndTags();
+                                if (!isCurrent(name)) {
+                                    err("End tag \u201C"
+                                            + name
+                                            + "\u201D seen but there were unclosed elements.");
+                                }
+                                while (currentPtr >= eltPos) {
+                                    pop();
+                                }
+                                clearTheListOfActiveFormattingElementsUpToTheLastMarker();
+                            }
+                            break endtagloop;
+                        case BR:
+                            err("End tag \u201Cbr\u201D.");
+                            if (foreignFlag == TreeBuilder.IN_FOREIGN) {
+                                err("HTML start tag \u201C"
+                                        + name
+                                        + "\u201D in a foreign namespace context.");
+                                while (stack[currentPtr].ns != "http://www.w3.org/1999/xhtml") {
+                                    pop();
+                                }
+                                foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+                            }
+                            reconstructTheActiveFormattingElements();
+                            appendVoidElementToCurrentMayFoster(
+                                    "http://www.w3.org/1999/xhtml",
+                                    elementName,
+                                    HtmlAttributes.EMPTY_ATTRIBUTES);
+                            break endtagloop;
+                        case AREA_OR_BASEFONT_OR_BGSOUND_OR_SPACER_OR_WBR:
+                        case PARAM_OR_SOURCE:
+                        case EMBED_OR_IMG:
+                        case IMAGE:
+                        case INPUT:
+                        case KEYGEN: // XXX??
+                        case HR:
+                        case ISINDEX:
+                        case IFRAME:
+                        case NOEMBED: // XXX???
+                        case NOFRAMES: // XXX??
+                        case SELECT:
+                        case TABLE:
+                        case TEXTAREA: // XXX??
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                        case NOSCRIPT:
+                            if (scriptingEnabled) {
+                                err("Stray end tag \u201Cnoscript\u201D.");
+                                break endtagloop;
+                            } else {
+                                // fall through
+                            }
+                        default:
+                            if (isCurrent(name)) {
+                                pop();
+                                break endtagloop;
+                            }
+
+                            eltPos = currentPtr;
+                            for (;;) {
+                                StackNode<T> node = stack[eltPos];
+                                if (node.name == name) {
+                                    generateImpliedEndTags();
+                                    if (!isCurrent(name)) {
+                                        err("End tag \u201C"
+                                                + name
+                                                + "\u201D seen but there were unclosed elements.");
+                                    }
+                                    while (currentPtr >= eltPos) {
+                                        pop();
+                                    }
+                                    break endtagloop;
+                                } else if (node.scoping || node.special) {
+                                    err("Stray end tag \u201C" + name
+                                            + "\u201D.");
+                                    break endtagloop;
+                                }
+                                eltPos--;
+                            }
+                    }
+                case IN_COLUMN_GROUP:
+                    switch (group) {
+                        case COLGROUP:
+                            if (currentPtr == 0) {
+                                assert fragment;
+                                err("Garbage in \u201Ccolgroup\u201D fragment.");
+                                break endtagloop;
+                            }
+                            pop();
+                            mode = IN_TABLE;
+                            break endtagloop;
+                        case COL:
+                            err("Stray end tag \u201Ccol\u201D.");
+                            break endtagloop;
+                        default:
+                            if (currentPtr == 0) {
+                                assert fragment;
+                                err("Garbage in \u201Ccolgroup\u201D fragment.");
+                                break endtagloop;
+                            }
+                            pop();
+                            mode = IN_TABLE;
+                            continue;
+                    }
+                case IN_SELECT_IN_TABLE:
+                    switch (group) {
+                        case CAPTION:
+                        case TABLE:
+                        case TBODY_OR_THEAD_OR_TFOOT:
+                        case TR:
+                        case TD_OR_TH:
+                            err("\u201C"
+                                    + name
+                                    + "\u201D end tag with \u201Cselect\u201D open.");
+                            if (findLastInTableScope(name) != TreeBuilder.NOT_FOUND_ON_STACK) {
+                                endSelect();
+                                continue;
+                            } else {
+                                break endtagloop;
+                            }
+                        default:
+                            // fall through to IN_SELECT
+                    }
+                case IN_SELECT:
+                    switch (group) {
+                        case OPTION:
+                            if (isCurrent("option")) {
+                                pop();
+                                break endtagloop;
+                            } else {
+                                err("Stray end tag \u201Coption\u201D");
+                                break endtagloop;
+                            }
+                        case OPTGROUP:
+                            if (isCurrent("option")
+                                    && "optgroup" == stack[currentPtr - 1].name) {
+                                pop();
+                            }
+                            if (isCurrent("optgroup")) {
+                                pop();
+                            } else {
+                                err("Stray end tag \u201Coptgroup\u201D");
+                            }
+                            break endtagloop;
+                        case SELECT:
+                            endSelect();
+                            break endtagloop;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D");
+                            break endtagloop;
+                    }
+                case AFTER_BODY:
+                    switch (group) {
+                        case HTML:
+                            if (fragment) {
+                                err("Stray end tag \u201Chtml\u201D");
+                                break endtagloop;
+                            } else {
+                                mode = AFTER_AFTER_BODY;
+                                break endtagloop;
+                            }
+                        default:
+                            err("Saw an end tag after \u201Cbody\u201D had been closed.");
+                            mode = IN_BODY;
+                            continue;
+                    }
+                case IN_FRAMESET:
+                    switch (group) {
+                        case FRAMESET:
+                            if (currentPtr == 0) {
+                                assert fragment;
+                                err("Stray end tag \u201Cframeset\u201D");
+                                break endtagloop;
+                            }
+                            pop();
+                            if ((!fragment) && !isCurrent("frameset")) {
+                                mode = AFTER_FRAMESET;
+                            }
+                            break endtagloop;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D");
+                            break endtagloop;
+                    }
+                case AFTER_FRAMESET:
+                    switch (group) {
+                        case HTML:
+                            mode = AFTER_AFTER_FRAMESET;
+                            break endtagloop;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D");
+                            break endtagloop;
+                    }
+                case INITIAL:
+                    /*
+                     * Parse error.
+                     */
+                    // [NOCPP[
+                    switch (doctypeExpectation) {
+                        case AUTO:
+                            err("End tag seen without seeing a doctype first. Expected e.g. \u201C<!DOCTYPE html>\u201D.");
+                            break;
+                        case HTML:
+                            err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE html>\u201D.");
+                            break;
+                        case HTML401_STRICT:
+                            err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\u201D.");
+                            break;
+                        case HTML401_TRANSITIONAL:
+                            err("End tag seen without seeing a doctype first. Expected \u201C<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\u201D.");
+                            break;
+                        case NO_DOCTYPE_ERRORS:
+                    }
+                    // ]NOCPP]
+                    /*
+                     * 
+                     * Set the document to quirks mode.
+                     */
+                    documentModeInternal(DocumentMode.QUIRKS_MODE, null, null,
+                            false);
+                    /*
+                     * Then, switch to the root element mode of the tree
+                     * construction stage
+                     */
+                    mode = BEFORE_HTML;
+                    /*
+                     * and reprocess the current token.
+                     */
+                    continue;
+                case BEFORE_HTML:
+                    /*
+                     * Create an HTMLElement node with the tag name html, in the
+                     * HTML namespace. Append it to the Document object.
+                     */
+                    appendHtmlElementToDocumentAndPush();
+                    /* Switch to the main mode */
+                    mode = BEFORE_HEAD;
+                    /*
+                     * reprocess the current token.
+                     */
+                    continue;
+                case BEFORE_HEAD:
+                    switch (group) {
+                        case HEAD:
+                        case BR:
+                        case HTML:
+                        case BODY:
+                            appendToCurrentNodeAndPushHeadElement(HtmlAttributes.EMPTY_ATTRIBUTES);
+                            mode = IN_HEAD;
+                            continue;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                    }
+                case IN_HEAD:
+                    switch (group) {
+                        case HEAD:
+                            pop();
+                            mode = AFTER_HEAD;
+                            break endtagloop;
+                        case BR:
+                        case HTML:
+                        case BODY:
+                            pop();
+                            mode = AFTER_HEAD;
+                            continue;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                    }
+                case IN_HEAD_NOSCRIPT:
+                    switch (group) {
+                        case NOSCRIPT:
+                            pop();
+                            mode = IN_HEAD;
+                            break endtagloop;
+                        case BR:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            pop();
+                            mode = IN_HEAD;
+                            continue;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                    }
+                case AFTER_HEAD:
+                    switch (group) {
+                        case HTML:
+                        case BODY:
+                        case BR:
+                            appendToCurrentNodeAndPushBodyElement();
+                            mode = FRAMESET_OK;
+                            continue;
+                        default:
+                            err("Stray end tag \u201C" + name + "\u201D.");
+                            break endtagloop;
+                    }
+                case AFTER_AFTER_BODY:
+                    err("Stray \u201C" + name + "\u201D end tag.");
+                    mode = IN_BODY;
+                    continue;
+                case AFTER_AFTER_FRAMESET:
+                    err("Stray \u201C" + name + "\u201D end tag.");
+                    mode = IN_FRAMESET;
+                    continue;
+                case IN_CDATA_RCDATA:
+                    // XXX need to manage insertion point here
+                    if (originalMode == AFTER_HEAD) {
+                        pop();
+                    }
+                    pop();
+                    mode = originalMode;
+                    break endtagloop;
+            }
+        }
+        if (foreignFlag == TreeBuilder.IN_FOREIGN && !hasForeignInScope()) {
+            /*
+             * If, after doing so, the insertion mode is still "in foreign
+             * content", but there is no element in scope that has a namespace
+             * other than the HTML namespace, switch the insertion mode to the
+             * secondary insertion mode.
+             */
+            foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+        }
+    }
+
+    /**
+     * @throws SAXException
+     */
+    private void endSelect() throws SAXException {
+        int eltPos = findLastInTableScope("select");
+        if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+            assert fragment;
+            err("Stray end tag \u201Cselect\u201D");
+            return;
+        }
+        while (currentPtr >= eltPos) {
+            pop();
+        }
+        resetTheInsertionMode();
+    }
+
+    private int findLastInTableScopeOrRootTbodyTheadTfoot() {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].group == TreeBuilder.TBODY_OR_THEAD_OR_TFOOT) {
+                return i;
+            }
+        }
+        return 0;
+    }
+
+    private int findLast(@Local String name) {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].name == name) {
+                return i;
+            }
+        }
+        return TreeBuilder.NOT_FOUND_ON_STACK;
+    }
+
+    private int findLastInTableScope(@Local String name) {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].name == name) {
+                return i;
+            } else if (stack[i].name == "table") {
+                return TreeBuilder.NOT_FOUND_ON_STACK;
+            }
+        }
+        return TreeBuilder.NOT_FOUND_ON_STACK;
+    }
+
+    private int findLastInScope(@Local String name) {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].name == name) {
+                return i;
+            } else if (stack[i].scoping) {
+                return TreeBuilder.NOT_FOUND_ON_STACK;
+            }
+        }
+        return TreeBuilder.NOT_FOUND_ON_STACK;
+    }
+
+    private int findLastInScopeHn() {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].group == TreeBuilder.H1_OR_H2_OR_H3_OR_H4_OR_H5_OR_H6) {
+                return i;
+            } else if (stack[i].scoping) {
+                return TreeBuilder.NOT_FOUND_ON_STACK;
+            }
+        }
+        return TreeBuilder.NOT_FOUND_ON_STACK;
+    }
+
+    private boolean hasForeignInScope() {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].ns != "http://www.w3.org/1999/xhtml") {
+                return true;
+            } else if (stack[i].scoping) {
+                return false;
+            }
+        }
+        return false;
+    }
+
+    private void generateImpliedEndTagsExceptFor(@Local String name)
+            throws SAXException {
+        for (;;) {
+            StackNode<T> node = stack[currentPtr];
+            switch (node.group) {
+                case P:
+                case LI:
+                case DD_OR_DT:
+                case OPTION:
+                case OPTGROUP:
+                case RT_OR_RP:
+                    if (node.name == name) {
+                        return;
+                    }
+                    pop();
+                    continue;
+                default:
+                    return;
+            }
+        }
+    }
+
+    private void generateImpliedEndTags() throws SAXException {
+        for (;;) {
+            switch (stack[currentPtr].group) {
+                case P:
+                case LI:
+                case DD_OR_DT:
+                case OPTION:
+                case OPTGROUP:
+                case RT_OR_RP:
+                    pop();
+                    continue;
+                default:
+                    return;
+            }
+        }
+    }
+
+    private boolean isSecondOnStackBody() {
+        return currentPtr >= 1 && stack[1].group == TreeBuilder.BODY;
+    }
+
+    private void documentModeInternal(DocumentMode m, String publicIdentifier,
+            String systemIdentifier, boolean html4SpecificAdditionalErrorChecks)
+            throws SAXException {
+        quirks = (m == DocumentMode.QUIRKS_MODE);
+        if (documentModeHandler != null) {
+            documentModeHandler.documentMode(
+                    m
+                    // [NOCPP[
+                    , publicIdentifier, systemIdentifier,
+                    html4SpecificAdditionalErrorChecks
+            // ]NOCPP]
+            );
+        }
+        // [NOCPP[
+        documentMode(m, publicIdentifier, systemIdentifier,
+                html4SpecificAdditionalErrorChecks);
+        // ]NOCPP]
+    }
+
+    private boolean isAlmostStandards(String publicIdentifier,
+            String systemIdentifier) {
+        if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                "-//w3c//dtd xhtml 1.0 transitional//en", publicIdentifier)) {
+            return true;
+        }
+        if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                "-//w3c//dtd xhtml 1.0 frameset//en", publicIdentifier)) {
+            return true;
+        }
+        if (systemIdentifier != null) {
+            if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                    "-//w3c//dtd html 4.01 transitional//en", publicIdentifier)) {
+                return true;
+            }
+            if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                    "-//w3c//dtd html 4.01 frameset//en", publicIdentifier)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean isQuirky(@Local String name, String publicIdentifier,
+            String systemIdentifier, boolean forceQuirks) {
+        if (forceQuirks) {
+            return true;
+        }
+        if (name != HTML_LOCAL) {
+            return true;
+        }
+        if (publicIdentifier != null) {
+            for (int i = 0; i < TreeBuilder.QUIRKY_PUBLIC_IDS.length; i++) {
+                if (Portability.lowerCaseLiteralIsPrefixOfIgnoreAsciiCaseString(
+                        TreeBuilder.QUIRKY_PUBLIC_IDS[i], publicIdentifier)) {
+                    return true;
+                }
+            }
+            if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                    "-//w3o//dtd w3 html strict 3.0//en//", publicIdentifier)
+                    || Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                            "-/w3c/dtd html 4.0 transitional/en",
+                            publicIdentifier)
+                    || Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                            "html", publicIdentifier)) {
+                return true;
+            }
+        }
+        if (systemIdentifier == null) {
+            if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                    "-//w3c//dtd html 4.01 transitional//en", publicIdentifier)) {
+                return true;
+            } else if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                    "-//w3c//dtd html 4.01 frameset//en", publicIdentifier)) {
+                return true;
+            }
+        } else if (Portability.lowerCaseLiteralEqualsIgnoreAsciiCaseString(
+                "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd",
+                systemIdentifier)) {
+            return true;
+        }
+        return false;
+    }
+
+    private void closeTheCell(int eltPos) throws SAXException {
+        generateImpliedEndTags();
+        if (eltPos != currentPtr) {
+            err("Unclosed elements.");
+        }
+        while (currentPtr >= eltPos) {
+            pop();
+        }
+        clearTheListOfActiveFormattingElementsUpToTheLastMarker();
+        mode = IN_ROW;
+        return;
+    }
+
+    private int findLastInTableScopeTdTh() {
+        for (int i = currentPtr; i > 0; i--) {
+            @Local String name = stack[i].name;
+            if ("td" == name || "th" == name) {
+                return i;
+            } else if (name == "table") {
+                return TreeBuilder.NOT_FOUND_ON_STACK;
+            }
+        }
+        return TreeBuilder.NOT_FOUND_ON_STACK;
+    }
+
+    private void clearStackBackTo(int eltPos) throws SAXException {
+        while (currentPtr > eltPos) { // > not >= intentional
+            pop();
+        }
+    }
+
+    private void resetTheInsertionMode() {
+        foreignFlag = TreeBuilder.NOT_IN_FOREIGN;
+        StackNode<T> node;
+        @Local String name;
+        @NsUri String ns;
+        for (int i = currentPtr; i >= 0; i--) {
+            node = stack[i];
+            name = node.name;
+            ns = node.ns;
+            if (i == 0) {
+                if (!(contextNamespace == "http://www.w3.org/1999/xhtml" && (contextName == "td" || contextName == "th"))) {
+                    name = contextName;
+                    ns = contextNamespace;
+                } else {
+                    mode = IN_BODY; // XXX from Hixie's email
+                    return;
+                }
+            }
+            if ("select" == name) {
+                mode = IN_SELECT;
+                return;
+            } else if ("td" == name || "th" == name) {
+                mode = IN_CELL;
+                return;
+            } else if ("tr" == name) {
+                mode = IN_ROW;
+                return;
+            } else if ("tbody" == name || "thead" == name || "tfoot" == name) {
+                mode = IN_TABLE_BODY;
+                return;
+            } else if ("caption" == name) {
+                mode = IN_CAPTION;
+                return;
+            } else if ("colgroup" == name) {
+                mode = IN_COLUMN_GROUP;
+                return;
+            } else if ("table" == name) {
+                mode = IN_TABLE;
+                return;
+            } else if ("http://www.w3.org/1999/xhtml" != node.ns) {
+                foreignFlag = TreeBuilder.IN_FOREIGN;
+                mode = IN_BODY;
+                return;
+            } else if ("head" == name) {
+                mode = IN_BODY; // really
+                return;
+            } else if ("body" == name) {
+                mode = IN_BODY;
+                return;
+            } else if ("frameset" == name) {
+                mode = IN_FRAMESET;
+                return;
+            } else if ("html" == name) {
+                if (headPointer == null) {
+                    mode = BEFORE_HEAD;
+                } else {
+                    mode = AFTER_HEAD;
+                }
+                return;
+            } else if (i == 0) {
+                mode = IN_BODY;
+                return;
+            }
+        }
+    }
+
+    /**
+     * @throws SAXException
+     * 
+     */
+    private void implicitlyCloseP() throws SAXException {
+        int eltPos = findLastInScope("p");
+        if (eltPos == TreeBuilder.NOT_FOUND_ON_STACK) {
+            return;
+        }
+        generateImpliedEndTagsExceptFor("p");
+        if (eltPos != currentPtr) {
+            err("Unclosed elements.");
+        }
+        while (currentPtr >= eltPos) {
+            pop();
+        }
+    }
+
+    private boolean clearLastStackSlot() {
+        stack[currentPtr] = null;
+        return true;
+    }
+
+    private boolean clearLastListSlot() {
+        listOfActiveFormattingElements[listPtr] = null;
+        return true;
+    }
+
+    private void push(StackNode<T> node) throws SAXException {
+        currentPtr++;
+        if (currentPtr == stack.length) {
+            StackNode<T>[] newStack = new StackNode[stack.length + 64];
+            System.arraycopy(stack, 0, newStack, 0, stack.length);
+            Portability.releaseArray(stack);
+            stack = newStack;
+        }
+        stack[currentPtr] = node;
+        elementPushed(node.ns, node.popName, node.node);
+    }
+
+    private void append(StackNode<T> node) {
+        listPtr++;
+        if (listPtr == listOfActiveFormattingElements.length) {
+            StackNode<T>[] newList = new StackNode[listOfActiveFormattingElements.length + 64];
+            System.arraycopy(listOfActiveFormattingElements, 0, newList, 0,
+                    listOfActiveFormattingElements.length);
+            Portability.releaseArray(listOfActiveFormattingElements);
+            listOfActiveFormattingElements = newList;
+        }
+        listOfActiveFormattingElements[listPtr] = node;
+    }
+
+    @Inline private void insertMarker() {
+        append(null);
+    }
+
+    private void clearTheListOfActiveFormattingElementsUpToTheLastMarker() {
+        while (listPtr > -1) {
+            if (listOfActiveFormattingElements[listPtr] == null) {
+                --listPtr;
+                return;
+            }
+            listOfActiveFormattingElements[listPtr].release();
+            --listPtr;
+        }
+    }
+
+    @Inline private boolean isCurrent(@Local String name) {
+        return name == stack[currentPtr].name;
+    }
+
+    private void removeFromStack(int pos) throws SAXException {
+        if (currentPtr == pos) {
+            pop();
+        } else {
+            fatal();
+            stack[pos].release();
+            System.arraycopy(stack, pos + 1, stack, pos, currentPtr - pos);
+            assert clearLastStackSlot();
+            currentPtr--;
+        }
+    }
+
+    private void removeFromStack(StackNode<T> node) throws SAXException {
+        if (stack[currentPtr] == node) {
+            pop();
+        } else {
+            int pos = currentPtr - 1;
+            while (pos >= 0 && stack[pos] != node) {
+                pos--;
+            }
+            if (pos == -1) {
+                // dead code?
+                return;
+            }
+            fatal();
+            node.release();
+            System.arraycopy(stack, pos + 1, stack, pos, currentPtr - pos);
+            currentPtr--;
+        }
+    }
+
+    private void removeFromListOfActiveFormattingElements(int pos) {
+        assert listOfActiveFormattingElements[pos] != null;
+        listOfActiveFormattingElements[pos].release();            
+        if (pos == listPtr) {
+            assert clearLastListSlot();
+            listPtr--;
+            return;
+        }
+        assert pos < listPtr;
+        System.arraycopy(listOfActiveFormattingElements, pos + 1,
+                listOfActiveFormattingElements, pos, listPtr - pos);
+        assert clearLastListSlot();
+        listPtr--;
+    }
+
+    private void adoptionAgencyEndTag(@Local String name) throws SAXException {
+        // If you crash around here, perhaps some stack node variable claimed to
+        // be a weak ref isn't.
+        flushCharacters();
+        for (;;) {
+            int formattingEltListPos = listPtr;
+            while (formattingEltListPos > -1) {
+                StackNode<T> listNode = listOfActiveFormattingElements[formattingEltListPos]; // weak ref
+                if (listNode == null) {
+                    formattingEltListPos = -1;
+                    break;
+                } else if (listNode.name == name) {
+                    break;
+                }
+                formattingEltListPos--;
+            }
+            if (formattingEltListPos == -1) {
+                err("No element \u201C" + name + "\u201D to close.");
+                return;
+            }
+            StackNode<T> formattingElt = listOfActiveFormattingElements[formattingEltListPos]; // this
+                                                                                               // *looks*
+                                                                                               // like
+                                                                                               // a
+                                                                                               // weak
+                                                                                               // ref
+                                                                                               // to
+                                                                                               // the
+                                                                                               // list
+                                                                                               // of
+                                                                                               // formatting
+                                                                                               // elements
+            int formattingEltStackPos = currentPtr;
+            boolean inScope = true;
+            while (formattingEltStackPos > -1) {
+                StackNode<T> node = stack[formattingEltStackPos]; // weak ref
+                if (node == formattingElt) {
+                    break;
+                } else if (node.scoping) {
+                    inScope = false;
+                }
+                formattingEltStackPos--;
+            }
+            if (formattingEltStackPos == -1) {
+                err("No element \u201C" + name + "\u201D to close.");
+                removeFromListOfActiveFormattingElements(formattingEltListPos);
+                return;
+            }
+            if (!inScope) {
+                err("No element \u201C" + name + "\u201D to close.");
+                return;
+            }
+            // stackPos now points to the formatting element and it is in scope
+            if (formattingEltStackPos != currentPtr) {
+                err("End tag \u201C" + name + "\u201D violates nesting rules.");
+            }
+            int furthestBlockPos = formattingEltStackPos + 1;
+            while (furthestBlockPos <= currentPtr) {
+                StackNode<T> node = stack[furthestBlockPos]; // weak ref
+                if (node.scoping || node.special) {
+                    break;
+                }
+                furthestBlockPos++;
+            }
+            if (furthestBlockPos > currentPtr) {
+                // no furthest block
+                while (currentPtr >= formattingEltStackPos) {
+                    pop();
+                }
+                removeFromListOfActiveFormattingElements(formattingEltListPos);
+                return;
+            }
+            StackNode<T> commonAncestor = stack[formattingEltStackPos - 1]; // weak
+                                                                            // ref
+            StackNode<T> furthestBlock = stack[furthestBlockPos]; // weak ref
+            // detachFromParent(furthestBlock.node); XXX AAA CHANGE
+            int bookmark = formattingEltListPos;
+            int nodePos = furthestBlockPos;
+            StackNode<T> lastNode = furthestBlock; // weak ref
+            for (;;) {
+                nodePos--;
+                StackNode<T> node = stack[nodePos]; // weak ref
+                int nodeListPos = findInListOfActiveFormattingElements(node);
+                if (nodeListPos == -1) {
+                    assert formattingEltStackPos < nodePos;
+                    assert bookmark < nodePos;
+                    assert furthestBlockPos > nodePos;
+                    removeFromStack(nodePos); // node is now a bad pointer in
+                                              // C++
+                    furthestBlockPos--;
+                    continue;
+                }
+                // now node is both on stack and in the list
+                if (nodePos == formattingEltStackPos) {
+                    break;
+                }
+                if (nodePos == furthestBlockPos) {
+                    bookmark = nodeListPos + 1;
+                }
+                // if (hasChildren(node.node)) { XXX AAA CHANGE
+                assert node == listOfActiveFormattingElements[nodeListPos];
+                assert node == stack[nodePos];
+                T clone = shallowClone(node.node);
+                StackNode<T> newNode = new StackNode<T>(node.group, node.ns,
+                        node.name, clone, node.scoping, node.special,
+                        node.fosterParenting, node.popName); // creation
+                // ownership
+                // goes
+                // to
+                // stack
+                stack[nodePos] = newNode;
+                newNode.retain(); // retain for list
+                listOfActiveFormattingElements[nodeListPos] = newNode;
+                node.release(); // release from stack
+                node.release(); // release from list
+                node = newNode;
+                Portability.releaseElement(clone);
+                // } XXX AAA CHANGE
+                detachFromParent(lastNode.node);
+                appendElement(lastNode.node, node.node);
+                lastNode = node;
+            }
+            if (commonAncestor.fosterParenting) {
+                fatal();
+                detachFromParent(lastNode.node);
+                insertIntoFosterParent(lastNode.node);
+            } else {
+                detachFromParent(lastNode.node);
+                appendElement(lastNode.node, commonAncestor.node);
+            }
+            T clone = shallowClone(formattingElt.node);
+            StackNode<T> formattingClone = new StackNode<T>(
+                    formattingElt.group, formattingElt.ns, formattingElt.name,
+                    clone, formattingElt.scoping, formattingElt.special,
+                    formattingElt.fosterParenting, formattingElt.popName); // Ownership
+                                                                           // transfers
+                                                                           // to
+                                                                           // stack
+                                                                           // below
+            appendChildrenToNewParent(furthestBlock.node, clone);
+            appendElement(clone, furthestBlock.node);
+            removeFromListOfActiveFormattingElements(formattingEltListPos);
+            insertIntoListOfActiveFormattingElements(formattingClone, bookmark);
+            assert formattingEltStackPos < furthestBlockPos;
+            removeFromStack(formattingEltStackPos);
+            // furthestBlockPos is now off by one and points to the slot after
+            // it
+            insertIntoStack(formattingClone, furthestBlockPos);
+            Portability.releaseElement(clone);
+        }
+    }
+
+    private void insertIntoStack(StackNode<T> node, int position)
+            throws SAXException {
+        assert currentPtr + 1 < stack.length;
+        assert position <= currentPtr + 1;
+        if (position == currentPtr + 1) {
+            flushCharacters();
+            push(node);
+        } else {
+            System.arraycopy(stack, position, stack, position + 1,
+                    (currentPtr - position) + 1);
+            currentPtr++;
+            stack[position] = node;
+        }
+    }
+
+    private void insertIntoListOfActiveFormattingElements(
+            StackNode<T> formattingClone, int bookmark) {
+        formattingClone.retain();
+        assert listPtr + 1 < listOfActiveFormattingElements.length;
+        if (bookmark <= listPtr) {
+            System.arraycopy(listOfActiveFormattingElements, bookmark,
+                    listOfActiveFormattingElements, bookmark + 1,
+                    (listPtr - bookmark) + 1);
+        }
+        listPtr++;
+        listOfActiveFormattingElements[bookmark] = formattingClone;
+    }
+
+    private int findInListOfActiveFormattingElements(StackNode<T> node) {
+        for (int i = listPtr; i >= 0; i--) {
+            if (node == listOfActiveFormattingElements[i]) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    private int findInListOfActiveFormattingElementsContainsBetweenEndAndLastMarker(
+            @Local String name) {
+        for (int i = listPtr; i >= 0; i--) {
+            StackNode<T> node = listOfActiveFormattingElements[i];
+            if (node == null) {
+                return -1;
+            } else if (node.name == name) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    private int findLastOrRoot(@Local String name) {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].name == name) {
+                return i;
+            }
+        }
+        return 0;
+    }
+
+    private int findLastOrRoot(int group) {
+        for (int i = currentPtr; i > 0; i--) {
+            if (stack[i].group == group) {
+                return i;
+            }
+        }
+        return 0;
+    }
+
+    private void addAttributesToBody(HtmlAttributes attributes)
+            throws SAXException {
+        // [NOCPP[
+        checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
+        // ]NOCPP]
+        if (currentPtr >= 1) {
+            StackNode<T> body = stack[1];
+            if (body.group == TreeBuilder.BODY) {
+                addAttributesToElement(body.node, attributes);
+            }
+        }
+    }
+
+    private void addAttributesToHtml(HtmlAttributes attributes)
+            throws SAXException {
+        // [NOCPP[
+        checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
+        // ]NOCPP]
+        addAttributesToElement(stack[0].node, attributes);
+    }
+    
+    private void pushHeadPointerOntoStack() throws SAXException {
+        flushCharacters();
+        fatal();
+        if (headPointer == null) {
+            assert fragment;
+            push(stack[currentPtr]);
+        } else {
+            push(new StackNode<T>("http://www.w3.org/1999/xhtml",
+                    ElementName.HEAD, headPointer));
+        }
+    }
+
+    /**
+     * @throws SAXException
+     * 
+     */
+    private void reconstructTheActiveFormattingElements() throws SAXException {
+        if (listPtr == -1) {
+            return;
+        }
+        StackNode<T> mostRecent = listOfActiveFormattingElements[listPtr];
+        if (mostRecent == null || isInStack(mostRecent)) {
+            return;
+        }
+        int entryPos = listPtr;
+        for (;;) {
+            entryPos--;
+            if (entryPos == -1) {
+                break;
+            }
+            if (listOfActiveFormattingElements[entryPos] == null) {
+                break;
+            }
+            if (isInStack(listOfActiveFormattingElements[entryPos])) {
+                break;
+            }
+        }
+        if (entryPos < listPtr) {
+            flushCharacters();
+        }
+        while (entryPos < listPtr) {
+            entryPos++;
+            StackNode<T> entry = listOfActiveFormattingElements[entryPos];
+            T clone = shallowClone(entry.node);
+            StackNode<T> entryClone = new StackNode<T>(entry.group, entry.ns,
+                    entry.name, clone, entry.scoping, entry.special,
+                    entry.fosterParenting, entry.popName);
+            StackNode<T> currentNode = stack[currentPtr];
+            if (currentNode.fosterParenting) {
+                insertIntoFosterParent(clone);
+            } else {
+                appendElement(clone, currentNode.node);
+            }
+            push(entryClone);
+            // stack takes ownership of the local variable
+            listOfActiveFormattingElements[entryPos] = entryClone;
+            // overwriting the old entry on the list, so release & retain
+            entry.release();
+            entryClone.retain();
+        }
+    }
+
+    private void insertIntoFosterParent(T child) throws SAXException {
+        int eltPos = findLastOrRoot(TreeBuilder.TABLE);
+        StackNode<T> node = stack[eltPos];
+        T elt = node.node;
+        if (eltPos == 0) {
+            appendElement(child, elt);
+            return;
+        }
+        insertFosterParentedChild(child, elt, stack[eltPos - 1].node);
+    }
+
+    private boolean isInStack(StackNode<T> node) {
+        for (int i = currentPtr; i >= 0; i--) {
+            if (stack[i] == node) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void pop() throws SAXException {
+        flushCharacters();
+        StackNode<T> node = stack[currentPtr];
+        assert clearLastStackSlot();
+        currentPtr--;
+        elementPopped(node.ns, node.popName, node.node);
+        node.release();
+    }
+
+    private void popOnEof() throws SAXException {
+        flushCharacters();
+        StackNode<T> node = stack[currentPtr];
+        assert clearLastStackSlot();
+        currentPtr--;
+        elementPopped(node.ns, node.popName, node.node);
+        markMalformedIfScript(node.node);
+        node.release();
+    }
+    
+    // [NOCPP[
+    private void checkAttributes(HtmlAttributes attributes, @NsUri String ns)
+            throws SAXException {
+        if (errorHandler != null) {
+            int len = attributes.getXmlnsLength();
+            for (int i = 0; i < len; i++) {
+                AttributeName name = attributes.getXmlnsAttributeName(i);
+                if (name == AttributeName.XMLNS) {
+                    if (html4) {
+                        err("Attribute \u201Cxmlns\u201D not allowed here. (HTML4-only error.)");
+                    } else {
+                        String xmlns = attributes.getXmlnsValue(i);
+                        if (!ns.equals(xmlns)) {
+                            err("Bad value \u201C"
+                                    + xmlns
+                                    + "\u201D for the attribute \u201Cxmlns\u201D (only \u201C"
+                                    + ns + "\u201D permitted here).");
+                            switch (namePolicy) {
+                                case ALTER_INFOSET:
+                                    // fall through
+                                case ALLOW:
+                                    warn("Attribute \u201Cxmlns\u201D is not serializable as XML 1.0.");
+                                    break;
+                                case FATAL:
+                                    fatal("Attribute \u201Cxmlns\u201D is not serializable as XML 1.0.");
+                                    break;
+                            }
+                        }
+                    }
+                } else if (ns != "http://www.w3.org/1999/xhtml" && name == AttributeName.XMLNS_XLINK) {
+                    String xmlns = attributes.getXmlnsValue(i);
+                    if (!"http://www.w3org/1999/xlink".equals(xmlns)) {
+                        err("Bad value \u201C"
+                                + xmlns
+                                + "\u201D for the attribute \u201Cxmlns:link\u201D (only \u201Chttp://www.w3org/1999/xlink\u201D permitted here).");
+                        switch (namePolicy) {
+                            case ALTER_INFOSET:
+                                // fall through
+                            case ALLOW:
+                                warn("Attribute \u201Cxmlns:xlink\u201D with the value \u201Chttp://www.w3org/1999/xlink\u201D is not serializable as XML 1.0 without changing document semantics.");
+                                break;
+                            case FATAL:
+                                fatal("Attribute \u201Cxmlns:xlink\u201D with the value \u201Chttp://www.w3org/1999/xlink\u201D is not serializable as XML 1.0 without changing document semantics.");
+                                break;
+                        }
+                    }                    
+                } else {
+                    err("Attribute \u201C" + attributes.getXmlnsLocalName(i) + "\u201D not allowed here.");                    
+                    switch (namePolicy) {
+                        case ALTER_INFOSET:
+                            // fall through
+                        case ALLOW:
+                            warn("Attribute with the local name \u201C" + attributes.getXmlnsLocalName(i) + "\u201D is not serializable as XML 1.0.");
+                            break;
+                        case FATAL:
+                            fatal("Attribute with the local name \u201C" + attributes.getXmlnsLocalName(i) + "\u201D is not serializable as XML 1.0.");
+                            break;
+                    }
+                }
+            }
+        }
+        attributes.processNonNcNames(this, namePolicy);
+    }
+
+    private String checkPopName(@Local String name) throws SAXException {
+        if (NCName.isNCName(name)) {
+            return name;
+        } else {
+            switch (namePolicy) {
+                case ALLOW:
+                    warn("Element name \u201C" + name
+                            + "\u201D cannot be represented as XML 1.0.");
+                    return name;
+                case ALTER_INFOSET:
+                    warn("Element name \u201C" + name
+                            + "\u201D cannot be represented as XML 1.0.");
+                    return NCName.escapeName(name);
+                case FATAL:
+                    fatal("Element name \u201C" + name
+                            + "\u201D cannot be represented as XML 1.0.");
+            }
+        }
+        return null; // keep compiler happy
+    }
+
+    // ]NOCPP]
+
+    private void appendHtmlElementToDocumentAndPush(HtmlAttributes attributes)
+            throws SAXException {
+        // [NOCPP[
+        checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
+        // ]NOCPP]
+        T elt = createHtmlElementSetAsRoot(attributes);
+        StackNode<T> node = new StackNode<T>("http://www.w3.org/1999/xhtml",
+                ElementName.HTML, elt);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    private void appendHtmlElementToDocumentAndPush() throws SAXException {
+        appendHtmlElementToDocumentAndPush(tokenizer.emptyAttributes());
+    }
+
+    private void appendToCurrentNodeAndPushHeadElement(HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        // [NOCPP[
+        checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
+        // ]NOCPP]
+        T elt = createElement("http://www.w3.org/1999/xhtml", "head",
+                attributes);
+        appendElement(elt, stack[currentPtr].node);
+        headPointer = elt;
+        Portability.retainElement(headPointer);
+        StackNode<T> node = new StackNode<T>("http://www.w3.org/1999/xhtml",
+                ElementName.HEAD, elt);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    private void appendToCurrentNodeAndPushBodyElement(HtmlAttributes attributes)
+            throws SAXException {
+        appendToCurrentNodeAndPushElement("http://www.w3.org/1999/xhtml",
+                ElementName.BODY, attributes);
+    }
+
+    private void appendToCurrentNodeAndPushBodyElement() throws SAXException {
+        appendToCurrentNodeAndPushBodyElement(tokenizer.emptyAttributes());
+    }
+
+    private void appendToCurrentNodeAndPushFormElementMayFoster(
+            HtmlAttributes attributes) throws SAXException {
+        flushCharacters();
+        // [NOCPP[
+        checkAttributes(attributes, "http://www.w3.org/1999/xhtml");
+        // ]NOCPP]
+        T elt = createElement("http://www.w3.org/1999/xhtml", "form",
+                attributes);
+        formPointer = elt;
+        Portability.retainElement(formPointer);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        StackNode<T> node = new StackNode<T>("http://www.w3.org/1999/xhtml",
+                ElementName.FORM, elt);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    private void appendToCurrentNodeAndPushFormattingElementMayFoster(
+            @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        // ]NOCPP]
+        // This method can't be called for custom elements
+        T elt = createElement(ns, elementName.name, attributes);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        StackNode<T> node = new StackNode<T>(ns, elementName, elt);
+        push(node);
+        append(node);
+        node.retain(); // append doesn't retain itself
+        Portability.releaseElement(elt);
+    }
+
+    private void appendToCurrentNodeAndPushElement(@NsUri String ns,
+            ElementName elementName, HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        // ]NOCPP]
+        // This method can't be called for custom elements
+        T elt = createElement(ns, elementName.name, attributes);
+        appendElement(elt, stack[currentPtr].node);
+        StackNode<T> node = new StackNode<T>(ns, elementName, elt);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    private void appendToCurrentNodeAndPushElementMayFoster(@NsUri String ns,
+            ElementName elementName, HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        @Local String popName = elementName.name;
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        if (elementName.custom) {
+            popName = checkPopName(popName);
+        }
+        // ]NOCPP]
+        T elt = createElement(ns, popName, attributes);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        StackNode<T> node = new StackNode<T>(ns, elementName, elt, popName);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    private void appendToCurrentNodeAndPushElementMayFosterNoScoping(
+            @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        @Local String popName = elementName.name;
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        if (elementName.custom) {
+            popName = checkPopName(popName);
+        }
+        // ]NOCPP]
+        T elt = createElement(ns, popName, attributes);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        StackNode<T> node = new StackNode<T>(ns, elementName, elt, popName,
+                false);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    private void appendToCurrentNodeAndPushElementMayFosterCamelCase(
+            @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        @Local String popName = elementName.camelCaseName;
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        if (elementName.custom) {
+            popName = checkPopName(popName);
+        }
+        // ]NOCPP]
+        T elt = createElement(ns, popName, attributes);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        StackNode<T> node = new StackNode<T>(ns, elementName, elt, popName,
+                ElementName.FOREIGNOBJECT == elementName);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    private void appendToCurrentNodeAndPushElementMayFoster(@NsUri String ns,
+            ElementName elementName, HtmlAttributes attributes, T form)
+            throws SAXException {
+        flushCharacters();
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        // ]NOCPP]
+        // Can't be called for custom elements
+        T elt = createElement(ns, elementName.name, attributes, form);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        StackNode<T> node = new StackNode<T>(ns, elementName, elt);
+        push(node);
+        Portability.releaseElement(elt);
+    }
+
+    @SuppressWarnings("unchecked") private void appendVoidElementToCurrentMayFoster(
+            @NsUri String ns, @Local String name, HtmlAttributes attributes,
+            T form) throws SAXException {
+        flushCharacters();
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        // ]NOCPP]
+        // Can't be called for custom elements
+        T elt = createElement(ns, name, attributes, form);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        elementPushed(ns, name, elt);
+        elementPopped(ns, name, elt);
+        Portability.releaseElement(elt);
+    }
+
+    @SuppressWarnings("unchecked") private void appendVoidElementToCurrentMayFoster(
+            @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        @Local String popName = elementName.name;
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        if (elementName.custom) {
+            popName = checkPopName(popName);
+        }
+        // ]NOCPP]
+        T elt = createElement(ns, popName, attributes);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        elementPushed(ns, popName, elt);
+        elementPopped(ns, popName, elt);
+        Portability.releaseElement(elt);
+    }
+
+    @SuppressWarnings("unchecked") private void appendVoidElementToCurrentMayFosterCamelCase(
+            @NsUri String ns, ElementName elementName, HtmlAttributes attributes)
+            throws SAXException {
+        flushCharacters();
+        @Local String popName = elementName.camelCaseName;
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        if (elementName.custom) {
+            popName = checkPopName(popName);
+        }
+        // ]NOCPP]
+        T elt = createElement(ns, popName, attributes);
+        StackNode<T> current = stack[currentPtr];
+        if (current.fosterParenting) {
+            fatal();
+            insertIntoFosterParent(elt);
+        } else {
+            appendElement(elt, current.node);
+        }
+        elementPushed(ns, popName, elt);
+        elementPopped(ns, popName, elt);
+        Portability.releaseElement(elt);
+    }
+
+    @SuppressWarnings("unchecked") private void appendVoidElementToCurrent(
+            @NsUri String ns, @Local String name, HtmlAttributes attributes,
+            T form) throws SAXException {
+        flushCharacters();
+        // [NOCPP[
+        checkAttributes(attributes, ns);
+        // ]NOCPP]
+        // Can't be called for custom elements
+        T elt = createElement(ns, name, attributes, form);
+        StackNode<T> current = stack[currentPtr];
+        appendElement(elt, current.node);
+        elementPushed(ns, name, elt);
+        elementPopped(ns, name, elt);
+        Portability.releaseElement(elt);
+    }
+
+    protected void accumulateCharacters(@NoLength char[] buf, int start,
+            int length) throws SAXException {
+        appendCharacters(stack[currentPtr].node, buf, start, length);
+    }
+    
+    protected final void accumulateCharacter(char c) throws SAXException {
+            int newLen = charBufferLen + 1;
+            if (newLen > charBuffer.length) {
+                char[] newBuf = new char[newLen];
+                System.arraycopy(charBuffer, 0, newBuf, 0, charBufferLen);
+                Portability.releaseArray(charBuffer);
+                charBuffer = newBuf;
+            }
+            charBuffer[charBufferLen] = c;
+            charBufferLen = newLen;
+    }
+
+
+    // ------------------------------- //
+
+    protected final void requestSuspension() {
+        tokenizer.requestSuspension();
+    }
+
+    protected abstract T createElement(@NsUri String ns, @Local String name,
+            HtmlAttributes attributes) throws SAXException;
+
+    protected T createElement(@NsUri String ns, @Local String name,
+            HtmlAttributes attributes, T form) throws SAXException {
+        return createElement("http://www.w3.org/1999/xhtml", name, attributes);
+    }
+
+    protected abstract T createHtmlElementSetAsRoot(HtmlAttributes attributes)
+            throws SAXException;
+
+    protected abstract void detachFromParent(T element) throws SAXException;
+
+    protected abstract boolean hasChildren(T element) throws SAXException;
+
+    protected abstract T shallowClone(T element) throws SAXException;
+
+    protected abstract void appendElement(T child, T newParent)
+            throws SAXException;
+
+    protected abstract void appendChildrenToNewParent(T oldParent, T newParent)
+            throws SAXException;
+
+    protected abstract void insertFosterParentedChild(T child, T table, T stackParent)
+            throws SAXException;
+
+    protected abstract void insertFosterParentedCharacters(@NoLength char[] buf,
+            int start, int length, T table, T stackParent) throws SAXException;
+
+    protected abstract void appendCharacters(T parent, @NoLength char[] buf,
+            int start, int length) throws SAXException;
+
+    protected abstract void appendComment(T parent, @NoLength char[] buf,
+            int start, int length) throws SAXException;
+
+    protected abstract void appendCommentToDocument(@NoLength char[] buf,
+            int start, int length) throws SAXException;
+
+    protected abstract void addAttributesToElement(T element,
+            HtmlAttributes attributes) throws SAXException;
+    
+    protected void markMalformedIfScript(T elt) throws SAXException {
+
+    }
+    
+    protected void start(boolean fragment) throws SAXException {
+
+    }
+
+    protected void end() throws SAXException {
+
+    }
+
+    protected void appendDoctypeToDocument(@Local String name,
+            String publicIdentifier, String systemIdentifier)
+            throws SAXException {
+
+    }
+
+    protected void elementPushed(@NsUri String ns, @Local String name, T node)
+            throws SAXException {
+
+    }
+
+    protected void elementPopped(@NsUri String ns, @Local String name, T node)
+            throws SAXException {
+
+    }
+
+    // [NOCPP[
+
+    protected void documentMode(DocumentMode m, String publicIdentifier,
+            String systemIdentifier, boolean html4SpecificAdditionalErrorChecks)
+            throws SAXException {
+
+    }
+
+    /**
+     * @see nu.validator.htmlparser.common.TokenHandler#wantsComments()
+     */
+    public boolean wantsComments() {
+        return wantingComments;
+    }
+
+    public void setIgnoringComments(boolean ignoreComments) {
+        wantingComments = !ignoreComments;
+    }
+
+    /**
+     * Sets the errorHandler.
+     * 
+     * @param errorHandler
+     *            the errorHandler to set
+     */
+    public final void setErrorHandler(ErrorHandler errorHandler) {
+        this.errorHandler = errorHandler;
+    }
+
+    /**
+     * Returns the errorHandler.
+     * 
+     * @return the errorHandler
+     */
+    public ErrorHandler getErrorHandler() {
+        return errorHandler;
+    }
+
+    /**
+     * The argument MUST be an interned string or <code>null</code>.
+     * 
+     * @param context
+     */
+    public final void setFragmentContext(@Local String context) {
+        this.contextName = context;
+        this.contextNamespace = "http://www.w3.org/1999/xhtml";
+        this.contextNode = null;
+        this.fragment = (contextName != null);
+        this.quirks = false;
+    }
+
+    // ]NOCPP]
+
+    /**
+     * The argument MUST be an interned string or <code>null</code>.
+     * 
+     * @param context
+     */
+    public final void setFragmentContext(@Local String context, @NsUri String ns, T node, boolean quirks) {
+        this.contextName = context;
+        Portability.retainLocal(context);
+        this.contextNamespace = ns;
+        this.contextNode = node;
+        Portability.retainElement(node);
+        this.fragment = (contextName != null);
+        this.quirks = quirks;
+    }
+
+    protected final T currentNode() {
+        return stack[currentPtr].node;
+    }
+
+    /**
+     * Returns the scriptingEnabled.
+     * 
+     * @return the scriptingEnabled
+     */
+    public boolean isScriptingEnabled() {
+        return scriptingEnabled;
+    }
+
+    /**
+     * Sets the scriptingEnabled.
+     * 
+     * @param scriptingEnabled
+     *            the scriptingEnabled to set
+     */
+    public void setScriptingEnabled(boolean scriptingEnabled) {
+        this.scriptingEnabled = scriptingEnabled;
+    }
+
+    // [NOCPP[
+
+    /**
+     * Sets the doctypeExpectation.
+     * 
+     * @param doctypeExpectation
+     *            the doctypeExpectation to set
+     */
+    public void setDoctypeExpectation(DoctypeExpectation doctypeExpectation) {
+        this.doctypeExpectation = doctypeExpectation;
+    }
+
+    public void setNamePolicy(XmlViolationPolicy namePolicy) {
+        this.namePolicy = namePolicy;
+    }
+
+    /**
+     * Sets the documentModeHandler.
+     * 
+     * @param documentModeHandler
+     *            the documentModeHandler to set
+     */
+    public void setDocumentModeHandler(DocumentModeHandler documentModeHandler) {
+        this.documentModeHandler = documentModeHandler;
+    }
+
+    /**
+     * Sets the reportingDoctype.
+     * 
+     * @param reportingDoctype
+     *            the reportingDoctype to set
+     */
+    public void setReportingDoctype(boolean reportingDoctype) {
+        this.reportingDoctype = reportingDoctype;
+    }
+    
+    // ]NOCPP]
+
+    /**
+     * @see nu.validator.htmlparser.common.TokenHandler#inForeign()
+     */
+    public boolean inForeign() throws SAXException {
+        return foreignFlag == IN_FOREIGN;
+    }
+
+    private final void flushCharacters() throws SAXException {
+        if (charBufferLen > 0) {
+            StackNode<T> current = stack[currentPtr];
+            if (current.fosterParenting && charBufferContainsNonWhitespace()) {
+                err("Misplaced non-space characters insided a table.");
+                int eltPos = findLastOrRoot(TreeBuilder.TABLE);
+                StackNode<T> node = stack[eltPos];
+                T elt = node.node;
+                if (eltPos == 0) {
+                    appendCharacters(elt, charBuffer, 0, charBufferLen);
+                    charBufferLen = 0;
+                    return;
+                }
+                insertFosterParentedCharacters(charBuffer, 0, charBufferLen,
+                        elt, stack[eltPos - 1].node);
+                charBufferLen = 0;
+                return;
+            }
+            appendCharacters(currentNode(), charBuffer, 0, charBufferLen);
+            charBufferLen = 0;
+        }
+    }
+
+    private boolean charBufferContainsNonWhitespace() {
+        for (int i = 0; i < charBufferLen; i++) {
+            switch (charBuffer[i]) {
+                case ' ':
+                case '\t':
+                case '\n':
+                case '\u000C':
+                    continue;
+                default:
+                    return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Creates a comparable snapshot of the tree builder state. Snapshot creation
+     * is only supported immediately after a script end tag has been processed. In 
+     * C++ the caller is responsible for calling <code>delete</code> on the returned
+     * object.
+     * 
+     * @return a snapshot.
+     */
+    @SuppressWarnings("unchecked") public StateSnapshot<T> newSnapshot() {
+        StackNode<T>[] stackCopy = new StackNode[currentPtr + 1];
+        for (int i = 0; i < stackCopy.length; i++) {
+            (stackCopy[i] = stack[i]).retain();
+        }
+        StackNode<T>[] listCopy = new StackNode[listPtr + 1];
+        for (int i = 0; i < listCopy.length; i++) {
+            StackNode<T> node = listOfActiveFormattingElements[i];
+            if (node != null) {
+                node.retain();            
+            }
+            listCopy[i] = node;
+        }
+        Portability.retainElement(formPointer);
+        return new StateSnapshot<T>(stackCopy, listCopy, formPointer);
+    }
+    
+    public boolean snapshotMatches(StateSnapshot<T> snapshot) {
+        StackNode<T>[] stackCopy = snapshot.stack;
+        StackNode<T>[] listCopy = snapshot.listOfActiveFormattingElements;
+        if (stackCopy.length != currentPtr + 1 || listCopy.length != listPtr + 1 || formPointer != snapshot.formPointer) {
+            return false;
+        }
+        for (int i = listCopy.length - 1; i >= 0; i--) {
+            if (listCopy[i] != listOfActiveFormattingElements[i]) {
+                return false;
+            }
+        }
+        for (int i = listCopy.length - 1; i >= 0; i--) {
+            if (listCopy[i] != listOfActiveFormattingElements[i]) {
+                return false;
+            }
+        }
+        return true;
+    }
+    
+}
diff --git a/parser/html/java/htmlparser/src/UTF16Buffer.java b/parser/html/java/htmlparser/src/UTF16Buffer.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/UTF16Buffer.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2008 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.impl;
+
+import nu.validator.htmlparser.annotation.NoLength;
+
+public final class UTF16Buffer {
+    private final @NoLength char[] buffer;
+
+    private int start;
+
+    private int end;
+
+    /**
+     * @param buffer
+     * @param start
+     * @param end
+     */
+    public UTF16Buffer(@NoLength char[] buffer, int start, int end) {
+        this.buffer = buffer;
+        this.start = start;
+        this.end = end;
+    }
+
+    /**
+     * Returns the start.
+     * 
+     * @return the start
+     */
+    public int getStart() {
+        return start;
+    }
+
+    /**
+     * Sets the start.
+     * 
+     * @param start the start to set
+     */
+    public void setStart(int start) {
+        this.start = start;
+    }
+
+    /**
+     * Returns the buffer.
+     * 
+     * @return the buffer
+     */
+    public @NoLength char[] getBuffer() {
+        return buffer;
+    }
+
+    /**
+     * Returns the end.
+     * 
+     * @return the end
+     */
+    public int getEnd() {
+        return end;
+    }
+    
+    public boolean hasMore() {
+        return start < end;
+    }
+    
+    public void adjust(boolean lastWasCR) {
+        if (lastWasCR && buffer[start] == '\n') {
+            start++;
+        }
+    }
+
+    /**
+     * Sets the end.
+     * 
+     * @param end the end to set
+     */
+    public void setEnd(int end) {
+        this.end = end;
+    }
+}
diff --git a/parser/html/java/htmlparser/src/package.html b/parser/html/java/htmlparser/src/package.html
new file mode 100644
--- /dev/null
+++ b/parser/html/java/htmlparser/src/package.html
@@ -0,0 +1,30 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head><title>Package Overview</title>
+<!--
+ Copyright (c) 2007 Henri Sivonen
+
+ Permission is hereby granted, free of charge, to any person obtaining a 
+ copy of this software and associated documentation files (the "Software"), 
+ to deal in the Software without restriction, including without limitation 
+ the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ and/or sell copies of the Software, and to permit persons to whom the 
+ Software is furnished to do so, subject to the following conditions:
+
+ The above copyright notice and this permission notice shall be included in 
+ all copies or substantial portions of the Software.
+
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ DEALINGS IN THE SOFTWARE.
+-->
+</head>
+<body bgcolor="white">
+<p>This package contains the bulk of parser internals. Only implementors of 
+additional tree builders or token handlers should look here.</p>
+</body>
+</html>
\ No newline at end of file
diff --git a/parser/html/java/javaparser/COPYING b/parser/html/java/javaparser/COPYING
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/COPYING
@@ -0,0 +1,674 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    Java 1.5 parser and Abstract Syntax Tree
+    Copyright (C) 2007  Jlio Vilmar Gesser
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    Java 1.5 parser and Abstract Syntax Tree  Copyright (C) 2007  Jlio Vilmar Gesser
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff --git a/parser/html/java/javaparser/COPYING.LESSER b/parser/html/java/javaparser/COPYING.LESSER
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/COPYING.LESSER
@@ -0,0 +1,165 @@
+		   GNU LESSER GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+
+  This version of the GNU Lesser General Public License incorporates
+the terms and conditions of version 3 of the GNU General Public
+License, supplemented by the additional permissions listed below.
+
+  0. Additional Definitions. 
+
+  As used herein, "this License" refers to version 3 of the GNU Lesser
+General Public License, and the "GNU GPL" refers to version 3 of the GNU
+General Public License.
+
+  "The Library" refers to a covered work governed by this License,
+other than an Application or a Combined Work as defined below.
+
+  An "Application" is any work that makes use of an interface provided
+by the Library, but which is not otherwise based on the Library.
+Defining a subclass of a class defined by the Library is deemed a mode
+of using an interface provided by the Library.
+
+  A "Combined Work" is a work produced by combining or linking an
+Application with the Library.  The particular version of the Library
+with which the Combined Work was made is also called the "Linked
+Version".
+
+  The "Minimal Corresponding Source" for a Combined Work means the
+Corresponding Source for the Combined Work, excluding any source code
+for portions of the Combined Work that, considered in isolation, are
+based on the Application, and not on the Linked Version.
+
+  The "Corresponding Application Code" for a Combined Work means the
+object code and/or source code for the Application, including any data
+and utility programs needed for reproducing the Combined Work from the
+Application, but excluding the System Libraries of the Combined Work.
+
+  1. Exception to Section 3 of the GNU GPL.
+
+  You may convey a covered work under sections 3 and 4 of this License
+without being bound by section 3 of the GNU GPL.
+
+  2. Conveying Modified Versions.
+
+  If you modify a copy of the Library, and, in your modifications, a
+facility refers to a function or data to be supplied by an Application
+that uses the facility (other than as an argument passed when the
+facility is invoked), then you may convey a copy of the modified
+version:
+
+   a) under this License, provided that you make a good faith effort to
+   ensure that, in the event an Application does not supply the
+   function or data, the facility still operates, and performs
+   whatever part of its purpose remains meaningful, or
+
+   b) under the GNU GPL, with none of the additional permissions of
+   this License applicable to that copy.
+
+  3. Object Code Incorporating Material from Library Header Files.
+
+  The object code form of an Application may incorporate material from
+a header file that is part of the Library.  You may convey such object
+code under terms of your choice, provided that, if the incorporated
+material is not limited to numerical parameters, data structure
+layouts and accessors, or small macros, inline functions and templates
+(ten or fewer lines in length), you do both of the following:
+
+   a) Give prominent notice with each copy of the object code that the
+   Library is used in it and that the Library and its use are
+   covered by this License.
+
+   b) Accompany the object code with a copy of the GNU GPL and this license
+   document.
+
+  4. Combined Works.
+
+  You may convey a Combined Work under terms of your choice that,
+taken together, effectively do not restrict modification of the
+portions of the Library contained in the Combined Work and reverse
+engineering for debugging such modifications, if you also do each of
+the following:
+
+   a) Give prominent notice with each copy of the Combined Work that
+   the Library is used in it and that the Library and its use are
+   covered by this License.
+
+   b) Accompany the Combined Work with a copy of the GNU GPL and this license
+   document.
+
+   c) For a Combined Work that displays copyright notices during
+   execution, include the copyright notice for the Library among
+   these notices, as well as a reference directing the user to the
+   copies of the GNU GPL and this license document.
+
+   d) Do one of the following:
+
+       0) Convey the Minimal Corresponding Source under the terms of this
+       License, and the Corresponding Application Code in a form
+       suitable for, and under terms that permit, the user to
+       recombine or relink the Application with a modified version of
+       the Linked Version to produce a modified Combined Work, in the
+       manner specified by section 6 of the GNU GPL for conveying
+       Corresponding Source.
+
+       1) Use a suitable shared library mechanism for linking with the
+       Library.  A suitable mechanism is one that (a) uses at run time
+       a copy of the Library already present on the user's computer
+       system, and (b) will operate properly with a modified version
+       of the Library that is interface-compatible with the Linked
+       Version. 
+
+   e) Provide Installation Information, but only if you would otherwise
+   be required to provide such information under section 6 of the
+   GNU GPL, and only to the extent that such information is
+   necessary to install and execute a modified version of the
+   Combined Work produced by recombining or relinking the
+   Application with a modified version of the Linked Version. (If
+   you use option 4d0, the Installation Information must accompany
+   the Minimal Corresponding Source and Corresponding Application
+   Code. If you use option 4d1, you must provide the Installation
+   Information in the manner specified by section 6 of the GNU GPL
+   for conveying Corresponding Source.)
+
+  5. Combined Libraries.
+
+  You may place library facilities that are a work based on the
+Library side by side in a single library together with other library
+facilities that are not Applications and are not covered by this
+License, and convey such a combined library under terms of your
+choice, if you do both of the following:
+
+   a) Accompany the combined library with a copy of the same work based
+   on the Library, uncombined with any other library facilities,
+   conveyed under the terms of this License.
+
+   b) Give prominent notice with the combined library that part of it
+   is a work based on the Library, and explaining where to find the
+   accompanying uncombined form of the same work.
+
+  6. Revised Versions of the GNU Lesser General Public License.
+
+  The Free Software Foundation may publish revised and/or new versions
+of the GNU Lesser General Public License from time to time. Such new
+versions will be similar in spirit to the present version, but may
+differ in detail to address new problems or concerns.
+
+  Each version is given a distinguishing version number. If the
+Library as you received it specifies that a certain numbered version
+of the GNU Lesser General Public License "or any later version"
+applies to it, you have the option of following the terms and
+conditions either of that published version or of any later version
+published by the Free Software Foundation. If the Library as you
+received it does not specify a version number of the GNU Lesser
+General Public License, you may choose any version of the GNU Lesser
+General Public License ever published by the Free Software Foundation.
+
+  If the Library as you received it specifies that a proxy can decide
+whether future versions of the GNU Lesser General Public License shall
+apply, that proxy's public statement of acceptance of any version is
+permanent authorization for you to choose that version for the
+Library.
diff --git a/parser/html/java/javaparser/Makefile b/parser/html/java/javaparser/Makefile
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/Makefile
@@ -0,0 +1,58 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Makefile.
+#
+# The Initial Developer of the Original Code is
+#   Ben Newman <b{enjam,newma}n@mozilla.com>
+#
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+SVN_BASE=http://javaparser.googlecode.com/svn/trunk/JavaParser
+
+libs:: \
+; mkdir -p bin ; \
+  find src -name "*.java" | \
+    xargs javac -g -d bin ; \
+  jar cf javaparser.jar -C bin .
+
+sync:: \
+; rm -rf src && \
+  svn co $(SVN_BASE)/src && \
+  find src -name .svn | xargs rm -rf ; \
+  \
+  for file in COPYING COPYING.LESSER readme.txt ; \
+  do \
+    rm -f $$file ; \
+    svn cat $(SVN_BASE)/$$file > $$file ; \
+  done
+
+clean:: \
+; rm -rf bin javaparser.jar
diff --git a/parser/html/java/javaparser/readme.txt b/parser/html/java/javaparser/readme.txt
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/readme.txt
@@ -0,0 +1,142 @@
++-------------------------------------------------------------------------------+
+|  Java 1.5 parser and Abstract Syntax Tree.                                    |
++-------------------------------------------------------------------------------+
+|  Copyright (C) 2007 Jlio Vilmar Gesser                                       |
+|  jgesser@gmail.com                                                            |
+|  http://code.google.com/p/javaparser/                                         |
++-------------------------------------------------------------------------------+
+|  This program is free software: you can redistribute it and/or modify         |
+|  it under the terms of the GNU Lesser General Public License as published by  |
+|  the Free Software Foundation, either version 3 of the License, or            |
+|  (at your option) any later version.                                          |
+|                                                                               |
+|  This program is distributed in the hope that it will be useful,              |
+|  but WITHOUT ANY WARRANTY; without even the implied warranty of               |
+|  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                |
+|  GNU Lesser General Public License for more details.                          |
+|                                                                               |
+|  You should have received a copy of the GNU Lesser General Public License     |
+|  along with this program.  If not, see <http://www.gnu.org/licenses/>.        |
++-------------------------------------------------------------------------------+    
+
+This package contains a Java 1.5 Parser with AST generation and visitor support. 
+The AST records the source code structure, javadoc and comments. Soon will be 
+possible change the AST nodes or create new ones to modify source code like refactoring.
+This parser is based on Sreenivasa Viswanadha Java 1.5 parser.
+
+Visit the project site, there you can get help, view some sample codes, report 
+bugs and feature enhacement and download the latest version:
+ 	http://code.google.com/p/javaparser/
+
+
+Version history
+---------------
+
+1.0.7 (2009-04-12)
+- Issue 19 fixed: 
+- Tests changed to run with junit 4 
+
+1.0.6 (2009-01-11)
+- Issue 11 fixed: changed method get/setPakage to get/setPackage in the class CompilationUnit
+- Created new visitor adapter to help AST modification: ModifierVisitorAdapter
+- Changed visitor adapters to abstract  
+
+1.0.5 (2008-10-26)
+- Created simplified constructors in the nodes of the AST (without positional arguments) 
+- Created ASTHelper class with some helpful methods (more methods are still needed)
+
+1.0.4 (2008-10-07)
+- Moved to javacc 4.1.
+- The java_1_5.jj can be build alone without compilation errors
+
+1.0.3 (2008-09-06)
+- Removed SuperMemberAccessExpr class, it was no longer used
+- Removed the methods get/setTypeArgs() from ArrayCreationExpr, this node shouldn't have these methods.
+- Fixed the bug with start/end position of the nodes IntegerLiteralMinValueExpr and LongLiteralMinValueExpr  
+- The methods get/setAnnotations() from all BodyDeclaration subclasses were pushed down to BodyDeclaration class 
+
+1.0.2 (2008-07-20)
+  Issue fixed: Issue 1: Add support for editing AST nodes or create new ones
+
+1.0.1 (2008-07-01)
+- Issue fixed: Issue 5: end line and end column equal to begin line and begin column
+
+1.0.0 (2008-06-25)
+- Changed version numbering, starting version 1.0.0
+- Javadoc done for packages:
+    - japa.parser
+    - japa.parser.ast
+- Corrected bug when parsing in multithread: 
+    - JavaParser.setCacheParser(false) must be called before to use the parser concurrent 
+
+2008-06-19
+- No code changes, added binary distribution to download page 
+
+2008-06-11
+- Bug corrected: NPE in VoidVisitorAdapter 
+	- http://code.google.com/p/javaparser/issues/detail?id=2
+
+2008-06-09
+- Added Adapters for de visitors
+
+2008-05-28
+- This project now is published at Google Code:
+	- http://code.google.com/p/javaparser/
+
+2008-05-25
+- Added support for comments and javadoc to the tree. 
+	- Javadocs are stored directly to members (BodyDeclaration and all deriveds (classes, methods, fields, etc.)), accessible by the method getJavadoc().
+	- All comments are stored in the CompilationUnit, accessible by the method getComments().
+
+2008-04-01
+- Changed all nodes public attributes to be private and created getters to access them
+- Changed the methods of the Node getLine e getColumn to getBeginLine and getBeginColumn
+- Added the methods getEndLine and getEndColumn to the Node class (works only in the BlockNode)
+
+2007-12-22
+- Corrected ConditionalExpression bug
+
+2007-10-21
+- Added LGPL License
+
+2007-10-21
+- Bugs corrected:  
+  - Created PackageDeclaration member of CompilationUnit to add suport for annotations in the package declaration
+  - Parameterized anonymous constructor invocation
+  - Explicit constructor invotation Type Arguments
+  - ctrl+z ("\u001A") ar end of compilation unit
+
+2007-10-09
+- EnumConstantDeclaration annotation support corrected
+- Parssing Java Unicode escape characters suport added
+
+2007-10-03
+- Bug corrected: "MotifComboPopup.this.super()" statement was generating parser error
+	                    
+2007-10-01
+- Bug corrected: Casting signed primitive values
+	double d = (double) -1;
+	                    ^
+
+2007-08-06
+- Bug with the ingle line comments in the final of the unit corrected
+
+2007-07-31
+- Fixed the bug with the following expression:
+	Class c = (int.class);
+
+2007-06-26
+- Bug fixes from Leon Poyyayil work
+	- suport for hex floating point
+	- unicode digits in indentifier 
+	- MemberValueArrayInitializer
+
+2007-03-09
+- Long and Integer literal MIN_VALUE bug	
+
+2007-02-24
+- '\0' bug fixed	
+
+2007-02-01
+- Many bug fixes
+- Added line/column to nodes
\ No newline at end of file
diff --git a/parser/html/java/javaparser/src/japa/parser/ASTHelper.java b/parser/html/java/javaparser/src/japa/parser/ASTHelper.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ASTHelper.java
@@ -0,0 +1,264 @@
+package japa.parser;
+
+import japa.parser.ast.CompilationUnit;
+import japa.parser.ast.body.BodyDeclaration;
+import japa.parser.ast.body.FieldDeclaration;
+import japa.parser.ast.body.MethodDeclaration;
+import japa.parser.ast.body.Parameter;
+import japa.parser.ast.body.TypeDeclaration;
+import japa.parser.ast.body.VariableDeclarator;
+import japa.parser.ast.body.VariableDeclaratorId;
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.expr.MethodCallExpr;
+import japa.parser.ast.expr.NameExpr;
+import japa.parser.ast.expr.QualifiedNameExpr;
+import japa.parser.ast.expr.VariableDeclarationExpr;
+import japa.parser.ast.stmt.BlockStmt;
+import japa.parser.ast.stmt.ExpressionStmt;
+import japa.parser.ast.stmt.Statement;
+import japa.parser.ast.type.ClassOrInterfaceType;
+import japa.parser.ast.type.PrimitiveType;
+import japa.parser.ast.type.ReferenceType;
+import japa.parser.ast.type.Type;
+import japa.parser.ast.type.VoidType;
+import japa.parser.ast.type.PrimitiveType.Primitive;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * This class helps to construct new nodes.
+ * 
+ * @author Julio Vilmar Gesser
+ */
+public final class ASTHelper {
+
+    public static final PrimitiveType BYTE_TYPE = new PrimitiveType(Primitive.Byte);
+
+    public static final PrimitiveType SHORT_TYPE = new PrimitiveType(Primitive.Short);
+
+    public static final PrimitiveType INT_TYPE = new PrimitiveType(Primitive.Int);
+
+    public static final PrimitiveType LONG_TYPE = new PrimitiveType(Primitive.Long);
+
+    public static final PrimitiveType FLOAT_TYPE = new PrimitiveType(Primitive.Float);
+
+    public static final PrimitiveType DOUBLE_TYPE = new PrimitiveType(Primitive.Double);
+
+    public static final PrimitiveType BOOLEAN_TYPE = new PrimitiveType(Primitive.Boolean);
+
+    public static final PrimitiveType CHAR_TYPE = new PrimitiveType(Primitive.Char);
+
+    public static final VoidType VOID_TYPE = new VoidType();
+
+    private ASTHelper() {
+        // nop
+    }
+
+    /**
+     * Creates a new {@link NameExpr} from a qualified name.<br>
+     * The qualified name can contains "." (dot) characters.
+     * 
+     * @param qualifiedName
+     *            qualified name
+     * @return instanceof {@link NameExpr}
+     */
+    public static NameExpr createNameExpr(String qualifiedName) {
+        String[] split = qualifiedName.split("\\.");
+        NameExpr ret = new NameExpr(split[0]);
+        for (int i = 1; i < split.length; i++) {
+            ret = new QualifiedNameExpr(ret, split[i]);
+        }
+        return ret;
+    }
+
+    /**
+     * Creates a new {@link Parameter}.
+     * 
+     * @param type
+     *            type of the parameter
+     * @param name
+     *            name of the parameter
+     * @return instance of {@link Parameter}
+     */
+    public static Parameter createParameter(Type type, String name) {
+        return new Parameter(type, new VariableDeclaratorId(name));
+    }
+
+    /**
+     * Creates a {@link FieldDeclaration}.
+     * 
+     * @param modifiers
+     *            modifiers
+     * @param type
+     *            type
+     * @param variable
+     *            variable declarator
+     * @return instance of {@link FieldDeclaration}
+     */
+    public static FieldDeclaration createFieldDeclaration(int modifiers, Type type, VariableDeclarator variable) {
+        List<VariableDeclarator> variables = new ArrayList<VariableDeclarator>();
+        variables.add(variable);
+        FieldDeclaration ret = new FieldDeclaration(modifiers, type, variables);
+        return ret;
+    }
+
+    /**
+     * Creates a {@link FieldDeclaration}.
+     * 
+     * @param modifiers
+     *            modifiers
+     * @param type
+     *            type
+     * @param name
+     *            field name
+     * @return instance of {@link FieldDeclaration}
+     */
+    public static FieldDeclaration createFieldDeclaration(int modifiers, Type type, String name) {
+        VariableDeclaratorId id = new VariableDeclaratorId(name);
+        VariableDeclarator variable = new VariableDeclarator(id);
+        return createFieldDeclaration(modifiers, type, variable);
+    }
+
+    /**
+     * Creates a {@link VariableDeclarationExpr}.
+     * 
+     * @param type
+     *            type
+     * @param name
+     *            name
+     * @return instance of {@link VariableDeclarationExpr}
+     */
+    public static VariableDeclarationExpr createVariableDeclarationExpr(Type type, String name) {
+        List<VariableDeclarator> vars = new ArrayList<VariableDeclarator>();
+        vars.add(new VariableDeclarator(new VariableDeclaratorId(name)));
+        return new VariableDeclarationExpr(type, vars);
+    }
+
+    /**
+     * Adds the given parameter to the method. The list of parameters will be
+     * initialized if it is <code>null</code>.
+     * 
+     * @param method
+     *            method
+     * @param parameter
+     *            parameter
+     */
+    public static void addParameter(MethodDeclaration method, Parameter parameter) {
+        List<Parameter> parameters = method.getParameters();
+        if (parameters == null) {
+            parameters = new ArrayList<Parameter>();
+            method.setParameters(parameters);
+        }
+        parameters.add(parameter);
+    }
+
+    /**
+     * Adds the given argument to the method call. The list of arguments will be
+     * initialized if it is <code>null</code>.
+     * 
+     * @param call
+     *            method call
+     * @param arg
+     *            argument value
+     */
+    public static void addArgument(MethodCallExpr call, Expression arg) {
+        List<Expression> args = call.getArgs();
+        if (args == null) {
+            args = new ArrayList<Expression>();
+            call.setArgs(args);
+        }
+        args.add(arg);
+    }
+
+    /**
+     * Adds the given type declaration to the compilation unit. The list of
+     * types will be initialized if it is <code>null</code>.
+     * 
+     * @param cu
+     *            compilation unit
+     * @param type
+     *            type declaration
+     */
+    public static void addTypeDeclaration(CompilationUnit cu, TypeDeclaration type) {
+        List<TypeDeclaration> types = cu.getTypes();
+        if (types == null) {
+            types = new ArrayList<TypeDeclaration>();
+            cu.setTypes(types);
+        }
+        types.add(type);
+
+    }
+
+    /**
+     * Creates a new {@link ReferenceType} for a class or interface.
+     * 
+     * @param name
+     *            name of the class or interface
+     * @param arrayCount
+     *            number os arrays or <code>0</code> if is not a array.
+     * @return instanceof {@link ReferenceType}
+     */
+    public static ReferenceType createReferenceType(String name, int arrayCount) {
+        return new ReferenceType(new ClassOrInterfaceType(name), arrayCount);
+    }
+
+    /**
+     * Creates a new {@link ReferenceType} for the given primitive type.
+     * 
+     * @param type
+     *            primitive type
+     * @param arrayCount
+     *            number os arrays or <code>0</code> if is not a array.
+     * @return instanceof {@link ReferenceType}
+     */
+    public static ReferenceType createReferenceType(PrimitiveType type, int arrayCount) {
+        return new ReferenceType(type, arrayCount);
+    }
+
+    /**
+     * Adds the given statement to the specified block. The list of statements
+     * will be initialized if it is <code>null</code>.
+     * 
+     * @param block
+     * @param stmt
+     */
+    public static void addStmt(BlockStmt block, Statement stmt) {
+        List<Statement> stmts = block.getStmts();
+        if (stmts == null) {
+            stmts = new ArrayList<Statement>();
+            block.setStmts(stmts);
+        }
+        stmts.add(stmt);
+    }
+
+    /**
+     * Adds the given expression to the specified block. The list of statements
+     * will be initialized if it is <code>null</code>.
+     * 
+     * @param block
+     * @param stmt
+     */
+    public static void addStmt(BlockStmt block, Expression expr) {
+        addStmt(block, new ExpressionStmt(expr));
+    }
+
+    /**
+     * Adds the given declaration to the specified type. The list of members
+     * will be initialized if it is <code>null</code>.
+     * 
+     * @param type
+     *            type declaration
+     * @param decl
+     *            member declaration
+     */
+    public static void addMember(TypeDeclaration type, BodyDeclaration decl) {
+        List<BodyDeclaration> members = type.getMembers();
+        if (members == null) {
+            members = new ArrayList<BodyDeclaration>();
+            type.setMembers(members);
+        }
+        members.add(decl);
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ASTParser.java b/parser/html/java/javaparser/src/japa/parser/ASTParser.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ASTParser.java
@@ -0,0 +1,7785 @@
+/* Generated By:JavaCC: Do not edit this line. ASTParser.java */
+/*
+ * Copyright (C) 2008 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package japa.parser;
+
+import java.io.*;
+import java.util.*;
+import japa.parser.ast.*;
+import japa.parser.ast.body.*;
+import japa.parser.ast.expr.*;
+import japa.parser.ast.stmt.*;
+import japa.parser.ast.type.*;
+
+/**
+ * <p>This class was generated automatically by javacc, do not edit.</p>
+ * @author Jlio Vilmar Gesser
+ */
+final class ASTParser implements ASTParserConstants {
+
+    void reset(InputStream in, String encoding) {
+        ReInit(in, encoding);
+        token_source.clearComments();
+    }
+
+    private List add(List list, Object obj) {
+        if (list == null) {
+                list = new LinkedList();
+        }
+        list.add(obj);
+        return list;
+    }
+
+    private List add(int pos, List list, Object obj) {
+        if (list == null) {
+                list = new LinkedList();
+        }
+        list.add(pos, obj);
+        return list;
+    }
+
+        private class Modifier {
+
+                final int modifiers;
+                final List annotations;
+                final int beginLine;
+                final int beginColumn;
+
+                public Modifier(int beginLine, int beginColumn, int modifiers, List annotations) {
+                        this.beginLine = beginLine;
+                        this.beginColumn = beginColumn;
+                        this.modifiers = modifiers;
+                        this.annotations = annotations;
+                }
+        }
+
+    public int addModifier(int modifiers, int mod, Token token) throws ParseException {
+        if ((ModifierSet.hasModifier(modifiers, mod))) {
+            throwParseException(token, "Duplicated modifier");
+        }
+        return ModifierSet.addModifier(modifiers, mod);
+    }
+
+    private void pushJavadoc() {
+        token_source.pushJavadoc();
+    }
+
+    private JavadocComment popJavadoc() {
+        return token_source.popJavadoc();
+    }
+
+    private List<Comment> getComments() {
+        return token_source.getComments();
+    }
+
+    private void throwParseException(Token token, String message) throws ParseException {
+        StringBuilder buf = new StringBuilder();
+        buf.append(message);
+        buf.append(": \"");
+        buf.append(token.image);
+        buf.append("\" at line ");
+        buf.append(token.beginLine);
+        buf.append(", column ");
+        buf.append(token.beginColumn);
+        ParseException e = new ParseException(buf.toString());
+        e.currentToken = token;
+        throw e;
+    }
+
+    static final class GTToken extends Token {
+
+        int realKind = ASTParserConstants.GT;
+
+        GTToken(int kind, String image) {
+            this.kind = kind;
+            this.image = image;
+        }
+
+        public static Token newToken(int kind, String image) {
+            return new GTToken(kind, image);
+        }
+    }
+
+/*****************************************
+ * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
+ *****************************************/
+
+/*
+ * Program structuring syntax follows.
+ */
+  final public CompilationUnit CompilationUnit() throws ParseException {
+        PackageDeclaration pakage = null;
+        List imports = null;
+        ImportDeclaration in = null;
+        List types = null;
+        TypeDeclaration tn = null;
+        int line = -1;
+        int column = 0;
+    if (jj_2_1(2147483647)) {
+      pakage = PackageDeclaration();
+                                                                   line = pakage.getBeginLine(); column = pakage.getBeginColumn();
+    } else {
+      ;
+    }
+    label_1:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case IMPORT:
+        ;
+        break;
+      default:
+        jj_la1[0] = jj_gen;
+        break label_1;
+      }
+      in = ImportDeclaration();
+                               if(line==-1){line = in.getBeginLine(); column = in.getBeginColumn();} imports = add(imports, in);
+    }
+    label_2:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ABSTRACT:
+      case CLASS:
+      case ENUM:
+      case FINAL:
+      case INTERFACE:
+      case NATIVE:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case STATIC:
+      case STRICTFP:
+      case SYNCHRONIZED:
+      case TRANSIENT:
+      case VOLATILE:
+      case SEMICOLON:
+      case AT:
+        ;
+        break;
+      default:
+        jj_la1[1] = jj_gen;
+        break label_2;
+      }
+      tn = TypeDeclaration();
+                             if(line==-1){line = tn.getBeginLine(); column = tn.getBeginColumn();} types = add(types, tn);
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case 0:
+      jj_consume_token(0);
+      break;
+    case 128:
+      jj_consume_token(128);
+      break;
+    default:
+      jj_la1[2] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    {if (true) return new CompilationUnit(line == -1 ? 0 : line, column, token.endLine, token.endColumn,pakage, imports, types, getComments());}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public PackageDeclaration PackageDeclaration() throws ParseException {
+        List annotations = null;
+        AnnotationExpr ann;
+        NameExpr name;
+        int line;
+        int column;
+    label_3:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case AT:
+        ;
+        break;
+      default:
+        jj_la1[3] = jj_gen;
+        break label_3;
+      }
+      ann = Annotation();
+                       annotations = add(annotations, ann);
+    }
+    jj_consume_token(PACKAGE);
+             line=token.beginLine; column=token.beginColumn;
+    name = Name();
+    jj_consume_token(SEMICOLON);
+    {if (true) return new PackageDeclaration(line, column, token.endLine, token.endColumn,annotations, name);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public ImportDeclaration ImportDeclaration() throws ParseException {
+        NameExpr name;
+        boolean isStatic = false;
+        boolean isAsterisk = false;
+        int line;
+        int column;
+    jj_consume_token(IMPORT);
+            line=token.beginLine; column=token.beginColumn;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case STATIC:
+      jj_consume_token(STATIC);
+                                                                          isStatic = true;
+      break;
+    default:
+      jj_la1[4] = jj_gen;
+      ;
+    }
+    name = Name();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case DOT:
+      jj_consume_token(DOT);
+      jj_consume_token(STAR);
+                                                                                                                         isAsterisk = true;
+      break;
+    default:
+      jj_la1[5] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+    {if (true) return new ImportDeclaration(line, column, token.endLine, token.endColumn,name, isStatic, isAsterisk);}
+    throw new Error("Missing return statement in function");
+  }
+
+/*
+ * Modifiers. We match all modifiers in a single rule to reduce the chances of
+ * syntax errors for simple modifier mistakes. It will also enable us to give
+ * better error messages.
+ */
+  final public Modifier Modifiers() throws ParseException {
+    int beginLine = -1;
+    int beginColumn = -1;
+    int modifiers = 0;
+    List annotations = null;
+    AnnotationExpr ann;
+    label_4:
+    while (true) {
+      if (jj_2_2(2)) {
+        ;
+      } else {
+        break label_4;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PUBLIC:
+        jj_consume_token(PUBLIC);
+              modifiers = addModifier(modifiers, ModifierSet.PUBLIC, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;}
+        break;
+      case STATIC:
+        jj_consume_token(STATIC);
+              modifiers = addModifier(modifiers, ModifierSet.STATIC, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;}
+        break;
+      case PROTECTED:
+        jj_consume_token(PROTECTED);
+                 modifiers = addModifier(modifiers, ModifierSet.PROTECTED, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;}
+        break;
+      case PRIVATE:
+        jj_consume_token(PRIVATE);
+               modifiers = addModifier(modifiers, ModifierSet.PRIVATE, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;}
+        break;
+      case FINAL:
+        jj_consume_token(FINAL);
+             modifiers = addModifier(modifiers, ModifierSet.FINAL, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;}
+        break;
+      case ABSTRACT:
+        jj_consume_token(ABSTRACT);
+                modifiers = addModifier(modifiers, ModifierSet.ABSTRACT, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;}
+        break;
+      case SYNCHRONIZED:
+        jj_consume_token(SYNCHRONIZED);
+                    modifiers = addModifier(modifiers, ModifierSet.SYNCHRONIZED, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;}
+        break;
+      case NATIVE:
+        jj_consume_token(NATIVE);
+              modifiers = addModifier(modifiers, ModifierSet.NATIVE, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;}
+        break;
+      case TRANSIENT:
+        jj_consume_token(TRANSIENT);
+                 modifiers = addModifier(modifiers, ModifierSet.TRANSIENT, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;}
+        break;
+      case VOLATILE:
+        jj_consume_token(VOLATILE);
+                modifiers = addModifier(modifiers, ModifierSet.VOLATILE, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;}
+        break;
+      case STRICTFP:
+        jj_consume_token(STRICTFP);
+                modifiers = addModifier(modifiers, ModifierSet.STRICTFP, token);  if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;}
+        break;
+      case AT:
+        ann = Annotation();
+                        annotations = add(annotations, ann); if(beginLine==-1) {beginLine=ann.getBeginLine(); beginColumn=ann.getBeginColumn();}
+        break;
+      default:
+        jj_la1[6] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+    {if (true) return new Modifier(beginLine, beginColumn, modifiers, annotations);}
+    throw new Error("Missing return statement in function");
+  }
+
+/*
+ * Declaration syntax follows.
+ */
+  final public TypeDeclaration TypeDeclaration() throws ParseException {
+   Modifier modifier;
+   TypeDeclaration ret;
+    pushJavadoc();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case SEMICOLON:
+      jj_consume_token(SEMICOLON);
+          ret = new EmptyTypeDeclaration(token.beginLine, token.beginColumn, token.endLine, token.endColumn, popJavadoc());
+      break;
+    case ABSTRACT:
+    case CLASS:
+    case ENUM:
+    case FINAL:
+    case INTERFACE:
+    case NATIVE:
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+    case STATIC:
+    case STRICTFP:
+    case SYNCHRONIZED:
+    case TRANSIENT:
+    case VOLATILE:
+    case AT:
+      modifier = Modifiers();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CLASS:
+      case INTERFACE:
+        ret = ClassOrInterfaceDeclaration(modifier);
+        break;
+      case ENUM:
+        ret = EnumDeclaration(modifier);
+        break;
+      case AT:
+        ret = AnnotationTypeDeclaration(modifier);
+        break;
+      default:
+        jj_la1[7] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[8] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public ClassOrInterfaceDeclaration ClassOrInterfaceDeclaration(Modifier modifier) throws ParseException {
+   boolean isInterface = false;
+   String name;
+   List typePar = null;
+   List extList = null;
+   List impList = null;
+   List members;
+   int line = modifier.beginLine;
+   int column = modifier.beginColumn;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case CLASS:
+      jj_consume_token(CLASS);
+      break;
+    case INTERFACE:
+      jj_consume_token(INTERFACE);
+                            isInterface = true;
+      break;
+    default:
+      jj_la1[9] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+                                                      if (line == -1) {line=token.beginLine; column=token.beginColumn;}
+    jj_consume_token(IDENTIFIER);
+                 name = token.image;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LT:
+      typePar = TypeParameters();
+                                typePar.remove(0);
+      break;
+    default:
+      jj_la1[10] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case EXTENDS:
+      extList = ExtendsList(isInterface);
+      break;
+    default:
+      jj_la1[11] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IMPLEMENTS:
+      impList = ImplementsList(isInterface);
+      break;
+    default:
+      jj_la1[12] = jj_gen;
+      ;
+    }
+    members = ClassOrInterfaceBody(isInterface);
+    {if (true) return new ClassOrInterfaceDeclaration(line, column, token.endLine, token.endColumn,popJavadoc(), modifier.modifiers, modifier.annotations, isInterface, name, typePar, extList, impList, members);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List ExtendsList(boolean isInterface) throws ParseException {
+   boolean extendsMoreThanOne = false;
+   List ret = new LinkedList();
+   ClassOrInterfaceType cit;
+    jj_consume_token(EXTENDS);
+    cit = ClassOrInterfaceType();
+                                            ret.add(cit);
+    label_5:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[13] = jj_gen;
+        break label_5;
+      }
+      jj_consume_token(COMMA);
+      cit = ClassOrInterfaceType();
+                                        ret.add(cit); extendsMoreThanOne = true;
+    }
+      if (extendsMoreThanOne && !isInterface)
+         throwParseException(token, "A class cannot extend more than one other class");
+     {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List ImplementsList(boolean isInterface) throws ParseException {
+   List ret = new LinkedList();
+   ClassOrInterfaceType cit;
+    jj_consume_token(IMPLEMENTS);
+    cit = ClassOrInterfaceType();
+                                               ret.add(cit);
+    label_6:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[14] = jj_gen;
+        break label_6;
+      }
+      jj_consume_token(COMMA);
+      cit = ClassOrInterfaceType();
+                                        ret.add(cit);
+    }
+      if (isInterface)
+         throwParseException(token, "An interface cannot implement other interfaces");
+     {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public EnumDeclaration EnumDeclaration(Modifier modifier) throws ParseException {
+        String name;
+        List impList = null;
+        EnumConstantDeclaration entry;
+        List entries = null;
+        BodyDeclaration member;
+        List members = null;
+        int line = modifier.beginLine;
+        int column = modifier.beginColumn;
+    jj_consume_token(ENUM);
+           if (line == -1) {line=token.beginLine; column=token.beginColumn;}
+    jj_consume_token(IDENTIFIER);
+                 name = token.image;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IMPLEMENTS:
+      impList = ImplementsList(false);
+      break;
+    default:
+      jj_la1[15] = jj_gen;
+      ;
+    }
+    jj_consume_token(LBRACE);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IDENTIFIER:
+    case AT:
+          entries = new LinkedList();
+      entry = EnumConstantDeclaration();
+                                            entries.add(entry);
+      label_7:
+      while (true) {
+        if (jj_2_3(2)) {
+          ;
+        } else {
+          break label_7;
+        }
+        jj_consume_token(COMMA);
+        entry = EnumConstantDeclaration();
+                                                                                                                         entries.add(entry);
+      }
+      break;
+    default:
+      jj_la1[16] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case COMMA:
+      jj_consume_token(COMMA);
+      break;
+    default:
+      jj_la1[17] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case SEMICOLON:
+      jj_consume_token(SEMICOLON);
+      label_8:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case ABSTRACT:
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case CLASS:
+        case DOUBLE:
+        case ENUM:
+        case FINAL:
+        case FLOAT:
+        case INT:
+        case INTERFACE:
+        case LONG:
+        case NATIVE:
+        case PRIVATE:
+        case PROTECTED:
+        case PUBLIC:
+        case SHORT:
+        case STATIC:
+        case STRICTFP:
+        case SYNCHRONIZED:
+        case TRANSIENT:
+        case VOID:
+        case VOLATILE:
+        case IDENTIFIER:
+        case LBRACE:
+        case SEMICOLON:
+        case AT:
+        case LT:
+          ;
+          break;
+        default:
+          jj_la1[18] = jj_gen;
+          break label_8;
+        }
+        member = ClassOrInterfaceBodyDeclaration(false);
+                                                                          members = add(members, member);
+      }
+      break;
+    default:
+      jj_la1[19] = jj_gen;
+      ;
+    }
+    jj_consume_token(RBRACE);
+    {if (true) return new EnumDeclaration(line, column, token.endLine, token.endColumn,popJavadoc(), modifier.modifiers, modifier.annotations, name, impList, entries, members);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public EnumConstantDeclaration EnumConstantDeclaration() throws ParseException {
+        List annotations = null;
+        AnnotationExpr ann;
+        String name;
+        List args = null;
+        List classBody = null;
+        int line = -1;
+        int column = -1;
+    pushJavadoc();
+    label_9:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case AT:
+        ;
+        break;
+      default:
+        jj_la1[20] = jj_gen;
+        break label_9;
+      }
+      ann = Annotation();
+                         annotations = add(annotations, ann); if(line==-1){line=ann.getBeginLine(); column=ann.getBeginColumn();}
+    }
+    jj_consume_token(IDENTIFIER);
+                 name = token.image; if(line==-1){line=token.beginLine; column=token.beginColumn;}
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LPAREN:
+      args = Arguments();
+      break;
+    default:
+      jj_la1[21] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LBRACE:
+      classBody = ClassOrInterfaceBody(false);
+      break;
+    default:
+      jj_la1[22] = jj_gen;
+      ;
+    }
+    {if (true) return new EnumConstantDeclaration(line, column, token.endLine, token.endColumn,popJavadoc(), annotations, name, args, classBody);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List TypeParameters() throws ParseException {
+        List ret = new LinkedList();
+        TypeParameter tp;
+    jj_consume_token(LT);
+         ret.add(new int[]{token.beginLine, token.beginColumn});
+    tp = TypeParameter();
+                          ret.add(tp);
+    label_10:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[23] = jj_gen;
+        break label_10;
+      }
+      jj_consume_token(COMMA);
+      tp = TypeParameter();
+                                ret.add(tp);
+    }
+    jj_consume_token(GT);
+     {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public TypeParameter TypeParameter() throws ParseException {
+        String name;
+        List typeBound = null;
+        int line;
+        int column;
+    jj_consume_token(IDENTIFIER);
+                  name = token.image; line=token.beginLine; column=token.beginColumn;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case EXTENDS:
+      typeBound = TypeBound();
+      break;
+    default:
+      jj_la1[24] = jj_gen;
+      ;
+    }
+     {if (true) return new TypeParameter(line, column, token.endLine, token.endColumn,name, typeBound);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List TypeBound() throws ParseException {
+        List ret = new LinkedList();
+        ClassOrInterfaceType cit;
+    jj_consume_token(EXTENDS);
+    cit = ClassOrInterfaceType();
+                                            ret.add(cit);
+    label_11:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BIT_AND:
+        ;
+        break;
+      default:
+        jj_la1[25] = jj_gen;
+        break label_11;
+      }
+      jj_consume_token(BIT_AND);
+      cit = ClassOrInterfaceType();
+                                            ret.add(cit);
+    }
+     {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List ClassOrInterfaceBody(boolean isInterface) throws ParseException {
+        List ret = new LinkedList();
+        BodyDeclaration member;
+    jj_consume_token(LBRACE);
+    label_12:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ABSTRACT:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CLASS:
+      case DOUBLE:
+      case ENUM:
+      case FINAL:
+      case FLOAT:
+      case INT:
+      case INTERFACE:
+      case LONG:
+      case NATIVE:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case SHORT:
+      case STATIC:
+      case STRICTFP:
+      case SYNCHRONIZED:
+      case TRANSIENT:
+      case VOID:
+      case VOLATILE:
+      case IDENTIFIER:
+      case LBRACE:
+      case SEMICOLON:
+      case AT:
+      case LT:
+        ;
+        break;
+      default:
+        jj_la1[26] = jj_gen;
+        break label_12;
+      }
+      member = ClassOrInterfaceBodyDeclaration(isInterface);
+                                                                ret.add(member);
+    }
+    jj_consume_token(RBRACE);
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public BodyDeclaration ClassOrInterfaceBodyDeclaration(boolean isInterface) throws ParseException {
+   boolean isNestedInterface = false;
+   Modifier modifier;
+   BodyDeclaration ret;
+    pushJavadoc();
+    if (jj_2_6(2)) {
+      ret = InitializerDeclaration();
+             if (isInterface)
+                throwParseException(token, "An interface cannot have initializers");
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ABSTRACT:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CLASS:
+      case DOUBLE:
+      case ENUM:
+      case FINAL:
+      case FLOAT:
+      case INT:
+      case INTERFACE:
+      case LONG:
+      case NATIVE:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case SHORT:
+      case STATIC:
+      case STRICTFP:
+      case SYNCHRONIZED:
+      case TRANSIENT:
+      case VOID:
+      case VOLATILE:
+      case IDENTIFIER:
+      case AT:
+      case LT:
+        modifier = Modifiers();
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case CLASS:
+        case INTERFACE:
+          ret = ClassOrInterfaceDeclaration(modifier);
+          break;
+        case ENUM:
+          ret = EnumDeclaration(modifier);
+          break;
+        case AT:
+          ret = AnnotationTypeDeclaration(modifier);
+          break;
+        default:
+          jj_la1[27] = jj_gen;
+          if (jj_2_4(2147483647)) {
+            ret = ConstructorDeclaration(modifier);
+          } else if (jj_2_5(2147483647)) {
+            ret = FieldDeclaration(modifier);
+          } else {
+            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+            case BOOLEAN:
+            case BYTE:
+            case CHAR:
+            case DOUBLE:
+            case FLOAT:
+            case INT:
+            case LONG:
+            case SHORT:
+            case VOID:
+            case IDENTIFIER:
+            case LT:
+              ret = MethodDeclaration(modifier);
+              break;
+            default:
+              jj_la1[28] = jj_gen;
+              jj_consume_token(-1);
+              throw new ParseException();
+            }
+          }
+        }
+        break;
+      case SEMICOLON:
+        jj_consume_token(SEMICOLON);
+                ret = new EmptyMemberDeclaration(token.beginLine, token.beginColumn, token.endLine, token.endColumn, popJavadoc());
+        break;
+      default:
+        jj_la1[29] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public FieldDeclaration FieldDeclaration(Modifier modifier) throws ParseException {
+        Type type;
+        List variables = new LinkedList();
+        VariableDeclarator val;
+    // Modifiers are already matched in the caller
+      type = Type();
+    val = VariableDeclarator();
+                                     variables.add(val);
+    label_13:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[30] = jj_gen;
+        break label_13;
+      }
+      jj_consume_token(COMMA);
+      val = VariableDeclarator();
+                                     variables.add(val);
+    }
+    jj_consume_token(SEMICOLON);
+        int line = modifier.beginLine;
+        int column = modifier.beginColumn;
+        if (line == -1) { line=type.getBeginLine(); column=type.getBeginColumn(); }
+        {if (true) return new FieldDeclaration(line, column, token.endLine, token.endColumn, popJavadoc(), modifier.modifiers, modifier.annotations, type, variables);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public VariableDeclarator VariableDeclarator() throws ParseException {
+        VariableDeclaratorId id;
+        Expression init = null;
+    id = VariableDeclaratorId();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case ASSIGN:
+      jj_consume_token(ASSIGN);
+      init = VariableInitializer();
+      break;
+    default:
+      jj_la1[31] = jj_gen;
+      ;
+    }
+    {if (true) return new  VariableDeclarator(id.getBeginLine(), id.getBeginColumn(), token.endLine, token.endColumn, id, init);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public VariableDeclaratorId VariableDeclaratorId() throws ParseException {
+        String name;
+        int arrayCount = 0;
+        int line;
+        int column;
+    jj_consume_token(IDENTIFIER);
+                 name = token.image; line=token.beginLine; column=token.beginColumn;
+    label_14:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACKET:
+        ;
+        break;
+      default:
+        jj_la1[32] = jj_gen;
+        break label_14;
+      }
+      jj_consume_token(LBRACKET);
+      jj_consume_token(RBRACKET);
+                                                                                                   arrayCount++;
+    }
+    {if (true) return new VariableDeclaratorId(line, column, token.endLine, token.endColumn,name, arrayCount);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression VariableInitializer() throws ParseException {
+        Expression ret;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LBRACE:
+      ret = ArrayInitializer();
+      break;
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case LONG_LITERAL:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case IDENTIFIER:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+      ret = Expression();
+      break;
+    default:
+      jj_la1[33] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public ArrayInitializerExpr ArrayInitializer() throws ParseException {
+        List values = null;
+        Expression val;
+        int line;
+        int column;
+    jj_consume_token(LBRACE);
+       line=token.beginLine; column=token.beginColumn;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case LONG_LITERAL:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case IDENTIFIER:
+    case LPAREN:
+    case LBRACE:
+    case BANG:
+    case TILDE:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+      val = VariableInitializer();
+                                                                                        values = add(values, val);
+      label_15:
+      while (true) {
+        if (jj_2_7(2)) {
+          ;
+        } else {
+          break label_15;
+        }
+        jj_consume_token(COMMA);
+        val = VariableInitializer();
+                                                                                                                                                                      values = add(values, val);
+      }
+      break;
+    default:
+      jj_la1[34] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case COMMA:
+      jj_consume_token(COMMA);
+      break;
+    default:
+      jj_la1[35] = jj_gen;
+      ;
+    }
+    jj_consume_token(RBRACE);
+    {if (true) return new ArrayInitializerExpr(line, column, token.endLine, token.endColumn,values);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public MethodDeclaration MethodDeclaration(Modifier modifier) throws ParseException {
+        List typeParameters = null;
+        Type type;
+        String name;
+        List parameters;
+        int arrayCount = 0;
+        List throws_ = null;
+        BlockStmt block = null;
+        int line = modifier.beginLine;
+        int column = modifier.beginColumn;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LT:
+      typeParameters = TypeParameters();
+                                        int[] lineCol=(int[])typeParameters.remove(0); if(line==-1){ line=lineCol[0]; column=lineCol[1];}
+      break;
+    default:
+      jj_la1[36] = jj_gen;
+      ;
+    }
+    type = ResultType();
+                        if(line==-1){line=type.getBeginLine(); column=type.getBeginColumn();}
+    jj_consume_token(IDENTIFIER);
+                 name = token.image;
+    parameters = FormalParameters();
+    label_16:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACKET:
+        ;
+        break;
+      default:
+        jj_la1[37] = jj_gen;
+        break label_16;
+      }
+      jj_consume_token(LBRACKET);
+      jj_consume_token(RBRACKET);
+                                                                                   arrayCount++;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case THROWS:
+      jj_consume_token(THROWS);
+      throws_ = NameList();
+      break;
+    default:
+      jj_la1[38] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LBRACE:
+      block = Block();
+      break;
+    case SEMICOLON:
+      jj_consume_token(SEMICOLON);
+      break;
+    default:
+      jj_la1[39] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    {if (true) return new MethodDeclaration(line, column, token.endLine, token.endColumn,popJavadoc(), modifier.modifiers, modifier.annotations, typeParameters, type, name, parameters, arrayCount, throws_, block);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List FormalParameters() throws ParseException {
+        List ret = null;
+        Parameter par;
+    jj_consume_token(LPAREN);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case ABSTRACT:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FINAL:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NATIVE:
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+    case SHORT:
+    case STATIC:
+    case STRICTFP:
+    case SYNCHRONIZED:
+    case TRANSIENT:
+    case VOLATILE:
+    case IDENTIFIER:
+    case AT:
+      par = FormalParameter();
+                                  ret = add(ret, par);
+      label_17:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case COMMA:
+          ;
+          break;
+        default:
+          jj_la1[40] = jj_gen;
+          break label_17;
+        }
+        jj_consume_token(COMMA);
+        par = FormalParameter();
+                                                                                         ret = add(ret, par);
+      }
+      break;
+    default:
+      jj_la1[41] = jj_gen;
+      ;
+    }
+    jj_consume_token(RPAREN);
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Parameter FormalParameter() throws ParseException {
+        Modifier modifier;
+        Type type;
+        boolean isVarArg = false;
+        VariableDeclaratorId id;
+    modifier = Modifiers();
+    type = Type();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case ELLIPSIS:
+      jj_consume_token(ELLIPSIS);
+                                                 isVarArg = true;
+      break;
+    default:
+      jj_la1[42] = jj_gen;
+      ;
+    }
+    id = VariableDeclaratorId();
+    int line = modifier.beginLine;
+    int column = modifier.beginColumn;
+    if(line==-1){ line=type.getBeginLine(); column=type.getBeginColumn(); }
+    {if (true) return new Parameter(line, column, token.endLine, token.endColumn, modifier.modifiers, modifier.annotations, type, isVarArg, id);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public ConstructorDeclaration ConstructorDeclaration(Modifier modifier) throws ParseException {
+        List typeParameters = null;
+        String name;
+        List parameters;
+        List throws_ = null;
+        ExplicitConstructorInvocationStmt exConsInv = null;
+        List stmts;
+        int line = modifier.beginLine;
+        int column = modifier.beginColumn;
+        int bbLine = 0;
+        int bbColumn = 0;
+        int beLine = 0;
+        int beColumn = 0;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LT:
+      typeParameters = TypeParameters();
+                                        int[] lineCol=(int[])typeParameters.remove(0); if(line==-1){ line=lineCol[0]; column=lineCol[1];}
+      break;
+    default:
+      jj_la1[43] = jj_gen;
+      ;
+    }
+    jj_consume_token(IDENTIFIER);
+                 name = token.image; if(line==-1){line=token.beginLine; column=token.beginColumn;}
+    parameters = FormalParameters();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case THROWS:
+      jj_consume_token(THROWS);
+      throws_ = NameList();
+      break;
+    default:
+      jj_la1[44] = jj_gen;
+      ;
+    }
+    jj_consume_token(LBRACE);
+        bbLine=token.beginLine; bbColumn=token.beginColumn;
+    if (jj_2_8(2147483647)) {
+      exConsInv = ExplicitConstructorInvocation();
+    } else {
+      ;
+    }
+    stmts = Statements();
+    jj_consume_token(RBRACE);
+        if (exConsInv != null) {
+                stmts = add(0, stmts, exConsInv);
+        }
+        {if (true) return new ConstructorDeclaration(line, column, token.endLine, token.endColumn,popJavadoc(), modifier.modifiers, modifier.annotations, typeParameters, name, parameters, throws_, new BlockStmt(bbLine, bbColumn, token.endLine, token.endColumn, stmts));}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public ExplicitConstructorInvocationStmt ExplicitConstructorInvocation() throws ParseException {
+        boolean isThis = false;
+        List args;
+        Expression expr = null;
+        List typeArgs = null;
+        int line = -1;
+        int column = 0;
+    if (jj_2_10(2147483647)) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LT:
+        typeArgs = TypeArguments();
+                                         int[] lineCol=(int[])typeArgs.remove(0); line=lineCol[0]; column=lineCol[1];
+        break;
+      default:
+        jj_la1[45] = jj_gen;
+        ;
+      }
+      jj_consume_token(THIS);
+                   if (line == -1) {line=token.beginLine; column=token.beginColumn;} isThis = true;
+      args = Arguments();
+      jj_consume_token(SEMICOLON);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case DOUBLE:
+      case FALSE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case NEW:
+      case NULL:
+      case SHORT:
+      case SUPER:
+      case THIS:
+      case TRUE:
+      case VOID:
+      case LONG_LITERAL:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case IDENTIFIER:
+      case LPAREN:
+      case LT:
+        if (jj_2_9(2147483647)) {
+          expr = PrimaryExpressionWithoutSuperSuffix();
+          jj_consume_token(DOT);
+                  line=expr.getBeginLine(); column=expr.getBeginColumn();
+        } else {
+          ;
+        }
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case LT:
+          typeArgs = TypeArguments();
+                                        int[] lineCol=(int[])typeArgs.remove(0); if (line == -1) {line=lineCol[0]; column=lineCol[1];}
+          break;
+        default:
+          jj_la1[46] = jj_gen;
+          ;
+        }
+        jj_consume_token(SUPER);
+                   if (line == -1) {line=token.beginLine; column=token.beginColumn;}
+        args = Arguments();
+        jj_consume_token(SEMICOLON);
+        break;
+      default:
+        jj_la1[47] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+    {if (true) return new ExplicitConstructorInvocationStmt(line, column, token.endLine, token.endColumn,typeArgs, isThis, expr, args);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List Statements() throws ParseException {
+        List ret = null;
+        Statement stmt;
+    label_18:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ABSTRACT:
+      case ASSERT:
+      case BOOLEAN:
+      case BREAK:
+      case BYTE:
+      case CHAR:
+      case CLASS:
+      case CONTINUE:
+      case DO:
+      case DOUBLE:
+      case FALSE:
+      case FINAL:
+      case FLOAT:
+      case FOR:
+      case IF:
+      case INT:
+      case INTERFACE:
+      case LONG:
+      case NATIVE:
+      case NEW:
+      case NULL:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case RETURN:
+      case SHORT:
+      case STATIC:
+      case STRICTFP:
+      case SUPER:
+      case SWITCH:
+      case SYNCHRONIZED:
+      case THIS:
+      case THROW:
+      case TRANSIENT:
+      case TRUE:
+      case TRY:
+      case VOID:
+      case VOLATILE:
+      case WHILE:
+      case LONG_LITERAL:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case IDENTIFIER:
+      case LPAREN:
+      case LBRACE:
+      case SEMICOLON:
+      case AT:
+      case INCR:
+      case DECR:
+        ;
+        break;
+      default:
+        jj_la1[48] = jj_gen;
+        break label_18;
+      }
+      stmt = BlockStatement();
+                                    ret = add(ret, stmt);
+    }
+          {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public InitializerDeclaration InitializerDeclaration() throws ParseException {
+        BlockStmt block;
+        int line = -1;
+        int column = 0;
+        boolean isStatic = false;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case STATIC:
+      jj_consume_token(STATIC);
+               isStatic = true; line=token.beginLine; column=token.beginColumn;
+      break;
+    default:
+      jj_la1[49] = jj_gen;
+      ;
+    }
+    block = Block();
+                                                                                                    if(line==-1){line=block.getBeginLine(); column=block.getBeginColumn();}
+    {if (true) return new InitializerDeclaration(line, column, token.endLine, token.endColumn,popJavadoc(), isStatic, block);}
+    throw new Error("Missing return statement in function");
+  }
+
+/*
+ * Type, name and expression syntax follows.
+ */
+  final public Type Type() throws ParseException {
+        Type ret;
+    if (jj_2_11(2)) {
+      ret = ReferenceType();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case DOUBLE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case SHORT:
+        ret = PrimitiveType();
+        break;
+      default:
+        jj_la1[50] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+   {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public ReferenceType ReferenceType() throws ParseException {
+        Type type;
+        int arrayCount = 0;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case SHORT:
+      type = PrimitiveType();
+      label_19:
+      while (true) {
+        jj_consume_token(LBRACKET);
+        jj_consume_token(RBRACKET);
+                                                   arrayCount++;
+        if (jj_2_12(2)) {
+          ;
+        } else {
+          break label_19;
+        }
+      }
+      break;
+    case IDENTIFIER:
+      type = ClassOrInterfaceType();
+      label_20:
+      while (true) {
+        if (jj_2_13(2)) {
+          ;
+        } else {
+          break label_20;
+        }
+        jj_consume_token(LBRACKET);
+        jj_consume_token(RBRACKET);
+                                                          arrayCount++;
+      }
+      break;
+    default:
+      jj_la1[51] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    {if (true) return new ReferenceType(type.getBeginLine(), type.getBeginColumn(), token.endLine, token.endColumn, type, arrayCount);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public ClassOrInterfaceType ClassOrInterfaceType() throws ParseException {
+        ClassOrInterfaceType ret;
+        String name;
+        List typeArgs = null;
+        int line;
+        int column;
+    jj_consume_token(IDENTIFIER);
+                line=token.beginLine; column=token.beginColumn;
+                                                                   name = token.image;
+    if (jj_2_14(2)) {
+      typeArgs = TypeArguments();
+                                             typeArgs.remove(0);
+    } else {
+      ;
+    }
+    ret = new ClassOrInterfaceType(line, column, token.endLine, token.endColumn,null, name, typeArgs);
+    label_21:
+    while (true) {
+      if (jj_2_15(2)) {
+        ;
+      } else {
+        break label_21;
+      }
+      jj_consume_token(DOT);
+      jj_consume_token(IDENTIFIER);
+                                          name = token.image;
+      if (jj_2_16(2)) {
+        typeArgs = TypeArguments();
+                                                     typeArgs.remove(0);
+      } else {
+        ;
+      }
+                                                                              ret = new ClassOrInterfaceType(line, column, token.endLine, token.endColumn,ret, name, typeArgs);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List TypeArguments() throws ParseException {
+        List ret = new LinkedList();
+        Type type;
+    jj_consume_token(LT);
+         ret.add(new int[]{token.beginLine, token.beginColumn});
+    type = TypeArgument();
+                           ret.add(type);
+    label_22:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[52] = jj_gen;
+        break label_22;
+      }
+      jj_consume_token(COMMA);
+      type = TypeArgument();
+                                                                          ret.add(type);
+    }
+    jj_consume_token(GT);
+     {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Type TypeArgument() throws ParseException {
+        Type ret;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case SHORT:
+    case IDENTIFIER:
+      ret = ReferenceType();
+      break;
+    case HOOK:
+      ret = Wildcard();
+      break;
+    default:
+      jj_la1[53] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+   {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public WildcardType Wildcard() throws ParseException {
+        ReferenceType ext = null;
+        ReferenceType sup = null;
+        int line;
+        int column;
+    jj_consume_token(HOOK);
+        line=token.beginLine; column=token.beginColumn;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case EXTENDS:
+    case SUPER:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case EXTENDS:
+        jj_consume_token(EXTENDS);
+        ext = ReferenceType();
+        break;
+      case SUPER:
+        jj_consume_token(SUPER);
+        sup = ReferenceType();
+        break;
+      default:
+        jj_la1[54] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[55] = jj_gen;
+      ;
+    }
+     {if (true) return new WildcardType(line, column, token.endLine, token.endColumn,ext, sup);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public PrimitiveType PrimitiveType() throws ParseException {
+        PrimitiveType ret;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BOOLEAN:
+      jj_consume_token(BOOLEAN);
+              ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Boolean);
+      break;
+    case CHAR:
+      jj_consume_token(CHAR);
+           ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Char);
+      break;
+    case BYTE:
+      jj_consume_token(BYTE);
+           ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Byte);
+      break;
+    case SHORT:
+      jj_consume_token(SHORT);
+            ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Short);
+      break;
+    case INT:
+      jj_consume_token(INT);
+          ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Int);
+      break;
+    case LONG:
+      jj_consume_token(LONG);
+           ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Long);
+      break;
+    case FLOAT:
+      jj_consume_token(FLOAT);
+            ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Float);
+      break;
+    case DOUBLE:
+      jj_consume_token(DOUBLE);
+             ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Double);
+      break;
+    default:
+      jj_la1[56] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Type ResultType() throws ParseException {
+        Type ret;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case VOID:
+      jj_consume_token(VOID);
+                   ret = new VoidType(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
+      break;
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case SHORT:
+    case IDENTIFIER:
+      ret = Type();
+      break;
+    default:
+      jj_la1[57] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public NameExpr Name() throws ParseException {
+        NameExpr ret;
+    jj_consume_token(IDENTIFIER);
+                 ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);
+    label_23:
+    while (true) {
+      if (jj_2_17(2)) {
+        ;
+      } else {
+        break label_23;
+      }
+      jj_consume_token(DOT);
+      jj_consume_token(IDENTIFIER);
+                                    ret = new QualifiedNameExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, token.image);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List NameList() throws ParseException {
+        List ret = new LinkedList();
+        NameExpr name;
+    name = Name();
+                  ret.add(name);
+    label_24:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[58] = jj_gen;
+        break label_24;
+      }
+      jj_consume_token(COMMA);
+      name = Name();
+                                                          ret.add(name);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+/*
+ * Expression syntax follows.
+ */
+  final public Expression Expression() throws ParseException {
+        Expression ret;
+        AssignExpr.Operator op;
+        Expression value;
+    ret = ConditionalExpression();
+    if (jj_2_18(2)) {
+      op = AssignmentOperator();
+      value = Expression();
+                                                     ret = new AssignExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, value, op);
+    } else {
+      ;
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public AssignExpr.Operator AssignmentOperator() throws ParseException {
+        AssignExpr.Operator ret;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case ASSIGN:
+      jj_consume_token(ASSIGN);
+               ret = AssignExpr.Operator.assign;
+      break;
+    case STARASSIGN:
+      jj_consume_token(STARASSIGN);
+               ret = AssignExpr.Operator.star;
+      break;
+    case SLASHASSIGN:
+      jj_consume_token(SLASHASSIGN);
+               ret = AssignExpr.Operator.slash;
+      break;
+    case REMASSIGN:
+      jj_consume_token(REMASSIGN);
+               ret = AssignExpr.Operator.rem;
+      break;
+    case PLUSASSIGN:
+      jj_consume_token(PLUSASSIGN);
+               ret = AssignExpr.Operator.plus;
+      break;
+    case MINUSASSIGN:
+      jj_consume_token(MINUSASSIGN);
+               ret = AssignExpr.Operator.minus;
+      break;
+    case LSHIFTASSIGN:
+      jj_consume_token(LSHIFTASSIGN);
+               ret = AssignExpr.Operator.lShift;
+      break;
+    case RSIGNEDSHIFTASSIGN:
+      jj_consume_token(RSIGNEDSHIFTASSIGN);
+               ret = AssignExpr.Operator.rSignedShift;
+      break;
+    case RUNSIGNEDSHIFTASSIGN:
+      jj_consume_token(RUNSIGNEDSHIFTASSIGN);
+               ret = AssignExpr.Operator.rUnsignedShift;
+      break;
+    case ANDASSIGN:
+      jj_consume_token(ANDASSIGN);
+               ret = AssignExpr.Operator.and;
+      break;
+    case XORASSIGN:
+      jj_consume_token(XORASSIGN);
+               ret = AssignExpr.Operator.xor;
+      break;
+    case ORASSIGN:
+      jj_consume_token(ORASSIGN);
+               ret = AssignExpr.Operator.or;
+      break;
+    default:
+      jj_la1[59] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression ConditionalExpression() throws ParseException {
+        Expression ret;
+        Expression left;
+        Expression right;
+    ret = ConditionalOrExpression();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case HOOK:
+      jj_consume_token(HOOK);
+      left = Expression();
+      jj_consume_token(COLON);
+      right = ConditionalExpression();
+                                                                  ret = new ConditionalExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, left, right);
+      break;
+    default:
+      jj_la1[60] = jj_gen;
+      ;
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression ConditionalOrExpression() throws ParseException {
+        Expression ret;
+        Expression right;
+    ret = ConditionalAndExpression();
+    label_25:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case SC_OR:
+        ;
+        break;
+      default:
+        jj_la1[61] = jj_gen;
+        break label_25;
+      }
+      jj_consume_token(SC_OR);
+      right = ConditionalAndExpression();
+                                                                               ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.or);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression ConditionalAndExpression() throws ParseException {
+        Expression ret;
+        Expression right;
+    ret = InclusiveOrExpression();
+    label_26:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case SC_AND:
+        ;
+        break;
+      default:
+        jj_la1[62] = jj_gen;
+        break label_26;
+      }
+      jj_consume_token(SC_AND);
+      right = InclusiveOrExpression();
+                                                                         ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.and);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression InclusiveOrExpression() throws ParseException {
+        Expression ret;
+        Expression right;
+    ret = ExclusiveOrExpression();
+    label_27:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BIT_OR:
+        ;
+        break;
+      default:
+        jj_la1[63] = jj_gen;
+        break label_27;
+      }
+      jj_consume_token(BIT_OR);
+      right = ExclusiveOrExpression();
+                                                                        ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.binOr);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression ExclusiveOrExpression() throws ParseException {
+        Expression ret;
+        Expression right;
+    ret = AndExpression();
+    label_28:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case XOR:
+        ;
+        break;
+      default:
+        jj_la1[64] = jj_gen;
+        break label_28;
+      }
+      jj_consume_token(XOR);
+      right = AndExpression();
+                                                        ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.xor);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression AndExpression() throws ParseException {
+        Expression ret;
+        Expression right;
+    ret = EqualityExpression();
+    label_29:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BIT_AND:
+        ;
+        break;
+      default:
+        jj_la1[65] = jj_gen;
+        break label_29;
+      }
+      jj_consume_token(BIT_AND);
+      right = EqualityExpression();
+                                                                  ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.binAnd);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression EqualityExpression() throws ParseException {
+        Expression ret;
+        Expression right;
+        BinaryExpr.Operator op;
+    ret = InstanceOfExpression();
+    label_30:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case EQ:
+      case NE:
+        ;
+        break;
+      default:
+        jj_la1[66] = jj_gen;
+        break label_30;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case EQ:
+        jj_consume_token(EQ);
+             op = BinaryExpr.Operator.equals;
+        break;
+      case NE:
+        jj_consume_token(NE);
+             op = BinaryExpr.Operator.notEquals;
+        break;
+      default:
+        jj_la1[67] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      right = InstanceOfExpression();
+                                       ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression InstanceOfExpression() throws ParseException {
+        Expression ret;
+        Type type;
+    ret = RelationalExpression();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INSTANCEOF:
+      jj_consume_token(INSTANCEOF);
+      type = Type();
+                                                              ret = new InstanceOfExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, type);
+      break;
+    default:
+      jj_la1[68] = jj_gen;
+      ;
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression RelationalExpression() throws ParseException {
+        Expression ret;
+        Expression right;
+        BinaryExpr.Operator op;
+    ret = ShiftExpression();
+    label_31:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LT:
+      case LE:
+      case GE:
+      case GT:
+        ;
+        break;
+      default:
+        jj_la1[69] = jj_gen;
+        break label_31;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LT:
+        jj_consume_token(LT);
+                 op = BinaryExpr.Operator.less;
+        break;
+      case GT:
+        jj_consume_token(GT);
+                 op = BinaryExpr.Operator.greater;
+        break;
+      case LE:
+        jj_consume_token(LE);
+                 op = BinaryExpr.Operator.lessEquals;
+        break;
+      case GE:
+        jj_consume_token(GE);
+                 op = BinaryExpr.Operator.greaterEquals;
+        break;
+      default:
+        jj_la1[70] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      right = ShiftExpression();
+                                      ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression ShiftExpression() throws ParseException {
+        Expression ret;
+        Expression right;
+        BinaryExpr.Operator op;
+    ret = AdditiveExpression();
+    label_32:
+    while (true) {
+      if (jj_2_19(1)) {
+        ;
+      } else {
+        break label_32;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LSHIFT:
+        jj_consume_token(LSHIFT);
+                             op = BinaryExpr.Operator.lShift;
+        break;
+      default:
+        jj_la1[71] = jj_gen;
+        if (jj_2_20(1)) {
+          RSIGNEDSHIFT();
+                             op = BinaryExpr.Operator.rSignedShift;
+        } else if (jj_2_21(1)) {
+          RUNSIGNEDSHIFT();
+                             op = BinaryExpr.Operator.rUnsignedShift;
+        } else {
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+      right = AdditiveExpression();
+                                         ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression AdditiveExpression() throws ParseException {
+        Expression ret;
+        Expression right;
+        BinaryExpr.Operator op;
+    ret = MultiplicativeExpression();
+    label_33:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PLUS:
+      case MINUS:
+        ;
+        break;
+      default:
+        jj_la1[72] = jj_gen;
+        break label_33;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PLUS:
+        jj_consume_token(PLUS);
+                op = BinaryExpr.Operator.plus;
+        break;
+      case MINUS:
+        jj_consume_token(MINUS);
+                op = BinaryExpr.Operator.minus;
+        break;
+      default:
+        jj_la1[73] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      right = MultiplicativeExpression();
+                                               ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression MultiplicativeExpression() throws ParseException {
+        Expression ret;
+        Expression right;
+        BinaryExpr.Operator op;
+    ret = UnaryExpression();
+    label_34:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case STAR:
+      case SLASH:
+      case REM:
+        ;
+        break;
+      default:
+        jj_la1[74] = jj_gen;
+        break label_34;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case STAR:
+        jj_consume_token(STAR);
+                op = BinaryExpr.Operator.times;
+        break;
+      case SLASH:
+        jj_consume_token(SLASH);
+                op = BinaryExpr.Operator.divide;
+        break;
+      case REM:
+        jj_consume_token(REM);
+                op = BinaryExpr.Operator.remainder;
+        break;
+      default:
+        jj_la1[75] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      right = UnaryExpression();
+                                      ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression UnaryExpression() throws ParseException {
+        Expression ret;
+        UnaryExpr.Operator op;
+        int line = 0;
+        int column = 0;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INCR:
+      ret = PreIncrementExpression();
+      break;
+    case DECR:
+      ret = PreDecrementExpression();
+      break;
+    case PLUS:
+    case MINUS:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PLUS:
+        jj_consume_token(PLUS);
+                  op = UnaryExpr.Operator.positive; line=token.beginLine; column=token.beginColumn;
+        break;
+      case MINUS:
+        jj_consume_token(MINUS);
+                  op = UnaryExpr.Operator.negative; line=token.beginLine; column=token.beginColumn;
+        break;
+      default:
+        jj_la1[76] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      ret = UnaryExpression();
+                 if(op == UnaryExpr.Operator.negative) {
+                        if (ret instanceof IntegerLiteralExpr && ((IntegerLiteralExpr)ret).isMinValue()) {
+                                ret = new IntegerLiteralMinValueExpr(line, column, token.endLine, token.endColumn);
+                        } else if (ret instanceof LongLiteralExpr && ((LongLiteralExpr)ret).isMinValue()) {
+                                ret = new LongLiteralMinValueExpr(line, column, token.endLine, token.endColumn);
+                        } else {
+                                ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, op);
+                        }
+                 } else {
+                        ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, op);
+                 }
+      break;
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case LONG_LITERAL:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case IDENTIFIER:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+      ret = UnaryExpressionNotPlusMinus();
+      break;
+    default:
+      jj_la1[77] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression PreIncrementExpression() throws ParseException {
+        Expression ret;
+        int line;
+        int column;
+    jj_consume_token(INCR);
+        line=token.beginLine; column=token.beginColumn;
+    ret = UnaryExpression();
+                                                                                   ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, UnaryExpr.Operator.preIncrement);
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression PreDecrementExpression() throws ParseException {
+        Expression ret;
+        int line;
+        int column;
+    jj_consume_token(DECR);
+        line=token.beginLine; column=token.beginColumn;
+    ret = UnaryExpression();
+                                                                                   ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, UnaryExpr.Operator.preDecrement);
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression UnaryExpressionNotPlusMinus() throws ParseException {
+        Expression ret;
+        UnaryExpr.Operator op;
+        int line = 0;
+        int column = 0;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BANG:
+    case TILDE:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case TILDE:
+        jj_consume_token(TILDE);
+                  op = UnaryExpr.Operator.inverse; line=token.beginLine; column=token.beginColumn;
+        break;
+      case BANG:
+        jj_consume_token(BANG);
+                  op = UnaryExpr.Operator.not;     line=token.beginLine; column=token.beginColumn;
+        break;
+      default:
+        jj_la1[78] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      ret = UnaryExpression();
+                                      ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, op);
+      break;
+    default:
+      jj_la1[79] = jj_gen;
+      if (jj_2_22(2147483647)) {
+        ret = CastExpression();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case DOUBLE:
+        case FALSE:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case NEW:
+        case NULL:
+        case SHORT:
+        case SUPER:
+        case THIS:
+        case TRUE:
+        case VOID:
+        case LONG_LITERAL:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+        case IDENTIFIER:
+        case LPAREN:
+          ret = PostfixExpression();
+          break;
+        default:
+          jj_la1[80] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression PostfixExpression() throws ParseException {
+        Expression ret;
+        UnaryExpr.Operator op;
+    ret = PrimaryExpression();
+    if (jj_2_23(2)) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case INCR:
+        jj_consume_token(INCR);
+             op = UnaryExpr.Operator.posIncrement;
+        break;
+      case DECR:
+        jj_consume_token(DECR);
+             op = UnaryExpr.Operator.posDecrement;
+        break;
+      default:
+        jj_la1[81] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+        ret = new UnaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, op);
+    } else {
+      ;
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression CastExpression() throws ParseException {
+        Expression ret;
+        Type type;
+        int line;
+        int column;
+    jj_consume_token(LPAREN);
+       line=token.beginLine; column=token.beginColumn;
+    if (jj_2_24(2)) {
+      type = PrimitiveType();
+      jj_consume_token(RPAREN);
+      ret = UnaryExpression();
+                                                               ret = new CastExpr(line, column, token.endLine, token.endColumn,type, ret);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case DOUBLE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case SHORT:
+      case IDENTIFIER:
+        type = ReferenceType();
+        jj_consume_token(RPAREN);
+        ret = UnaryExpressionNotPlusMinus();
+                                                                           ret = new CastExpr(line, column, token.endLine, token.endColumn,type, ret);
+        break;
+      default:
+        jj_la1[82] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression PrimaryExpression() throws ParseException {
+        Expression ret;
+        Expression inner;
+    ret = PrimaryPrefix();
+    label_35:
+    while (true) {
+      if (jj_2_25(2)) {
+        ;
+      } else {
+        break label_35;
+      }
+      ret = PrimarySuffix(ret);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression PrimaryExpressionWithoutSuperSuffix() throws ParseException {
+        Expression ret;
+        Expression inner;
+    ret = PrimaryPrefix();
+    label_36:
+    while (true) {
+      if (jj_2_26(2147483647)) {
+        ;
+      } else {
+        break label_36;
+      }
+      ret = PrimarySuffixWithoutSuper(ret);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression PrimaryPrefix() throws ParseException {
+        Expression ret;
+        String name;
+        List typeArgs = null;
+        List args = null;
+        boolean hasArgs = false;
+        Type type;
+        int line;
+        int column;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case FALSE:
+    case NULL:
+    case TRUE:
+    case LONG_LITERAL:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+      ret = Literal();
+      break;
+    case THIS:
+      jj_consume_token(THIS);
+                   ret = new ThisExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, null);
+      break;
+    case SUPER:
+      jj_consume_token(SUPER);
+                    ret = new SuperExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, null);
+      jj_consume_token(DOT);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LT:
+        typeArgs = TypeArguments();
+                                        typeArgs.remove(0);
+        break;
+      default:
+        jj_la1[83] = jj_gen;
+        ;
+      }
+      jj_consume_token(IDENTIFIER);
+                         name = token.image;
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LPAREN:
+        args = Arguments();
+                                hasArgs=true;
+        break;
+      default:
+        jj_la1[84] = jj_gen;
+        ;
+      }
+                        ret = hasArgs
+                                ? new MethodCallExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, typeArgs, name, args)
+                                : new FieldAccessExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, null, name);
+      break;
+    case LPAREN:
+      jj_consume_token(LPAREN);
+               line=token.beginLine; column=token.beginColumn;
+      ret = Expression();
+      jj_consume_token(RPAREN);
+                                                                                         ret = new EnclosedExpr(line, column, token.endLine, token.endColumn,ret);
+      break;
+    case NEW:
+      ret = AllocationExpression(null);
+      break;
+    default:
+      jj_la1[86] = jj_gen;
+      if (jj_2_27(2147483647)) {
+        type = ResultType();
+        jj_consume_token(DOT);
+        jj_consume_token(CLASS);
+                                            ret = new ClassExpr(type.getBeginLine(), type.getBeginColumn(), token.endLine, token.endColumn, type);
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case IDENTIFIER:
+          jj_consume_token(IDENTIFIER);
+                               name = token.image; line=token.beginLine; column=token.beginColumn;
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case LPAREN:
+            args = Arguments();
+                                      hasArgs=true;
+            break;
+          default:
+            jj_la1[85] = jj_gen;
+            ;
+          }
+                        ret = hasArgs
+                                ? new MethodCallExpr(line, column, token.endLine, token.endColumn, null, null, name, args)
+                                : new NameExpr(line, column, token.endLine, token.endColumn, name);
+          break;
+        default:
+          jj_la1[87] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression PrimarySuffix(Expression scope) throws ParseException {
+        Expression ret;
+    if (jj_2_28(2)) {
+      ret = PrimarySuffixWithoutSuper(scope);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case DOT:
+        jj_consume_token(DOT);
+        jj_consume_token(SUPER);
+                      ret = new SuperExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope);
+        break;
+      default:
+        jj_la1[88] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression PrimarySuffixWithoutSuper(Expression scope) throws ParseException {
+        Expression ret;
+        List typeArgs = null;
+        List args = null;
+        boolean hasArgs = false;
+        String name;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case DOT:
+      jj_consume_token(DOT);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case THIS:
+        jj_consume_token(THIS);
+                         ret = new ThisExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope);
+        break;
+      case NEW:
+        ret = AllocationExpression(scope);
+        break;
+      default:
+        jj_la1[91] = jj_gen;
+        if (jj_2_29(2147483647)) {
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case LT:
+            typeArgs = TypeArguments();
+                                              typeArgs.remove(0);
+            break;
+          default:
+            jj_la1[89] = jj_gen;
+            ;
+          }
+          jj_consume_token(IDENTIFIER);
+                               name = token.image;
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case LPAREN:
+            args = Arguments();
+                                      hasArgs=true;
+            break;
+          default:
+            jj_la1[90] = jj_gen;
+            ;
+          }
+                        ret = hasArgs
+                                ? new MethodCallExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope, typeArgs, name, args)
+                                : new FieldAccessExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope, typeArgs, name);
+        } else {
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+      break;
+    case LBRACKET:
+      jj_consume_token(LBRACKET);
+      ret = Expression();
+      jj_consume_token(RBRACKET);
+                                      ret = new ArrayAccessExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope, ret);
+      break;
+    default:
+      jj_la1[92] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression Literal() throws ParseException {
+        Expression ret;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INTEGER_LITERAL:
+      jj_consume_token(INTEGER_LITERAL);
+                        ret = new IntegerLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);
+      break;
+    case LONG_LITERAL:
+      jj_consume_token(LONG_LITERAL);
+                        ret = new LongLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);
+      break;
+    case FLOATING_POINT_LITERAL:
+      jj_consume_token(FLOATING_POINT_LITERAL);
+                        ret = new DoubleLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);
+      break;
+    case CHARACTER_LITERAL:
+      jj_consume_token(CHARACTER_LITERAL);
+                ret = new CharLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image.substring(1, token.image.length()-1));
+      break;
+    case STRING_LITERAL:
+      jj_consume_token(STRING_LITERAL);
+                ret = new StringLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image.substring(1, token.image.length()-1));
+      break;
+    case FALSE:
+    case TRUE:
+      ret = BooleanLiteral();
+      break;
+    case NULL:
+      ret = NullLiteral();
+      break;
+    default:
+      jj_la1[93] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression BooleanLiteral() throws ParseException {
+        Expression ret;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case TRUE:
+      jj_consume_token(TRUE);
+                   ret = new BooleanLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, true);
+      break;
+    case FALSE:
+      jj_consume_token(FALSE);
+                    ret = new BooleanLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, false);
+      break;
+    default:
+      jj_la1[94] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression NullLiteral() throws ParseException {
+    jj_consume_token(NULL);
+    {if (true) return new NullLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List Arguments() throws ParseException {
+        List ret = null;
+    jj_consume_token(LPAREN);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case LONG_LITERAL:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case IDENTIFIER:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+      ret = ArgumentList();
+      break;
+    default:
+      jj_la1[95] = jj_gen;
+      ;
+    }
+    jj_consume_token(RPAREN);
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List ArgumentList() throws ParseException {
+        List ret = new LinkedList();
+        Expression expr;
+    expr = Expression();
+                        ret.add(expr);
+    label_37:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[96] = jj_gen;
+        break label_37;
+      }
+      jj_consume_token(COMMA);
+      expr = Expression();
+                                                                     ret.add(expr);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression AllocationExpression(Expression scope) throws ParseException {
+        Expression ret;
+        Type type;
+        Object[] arr = null;
+        List typeArgs = null;
+        List anonymousBody = null;
+        List args;
+        int line;
+        int column;
+    jj_consume_token(NEW);
+          if(scope==null) {line=token.beginLine; column=token.beginColumn;} else {line=scope.getBeginLine(); column=scope.getBeginColumn();}
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case SHORT:
+      type = PrimitiveType();
+      arr = ArrayDimsAndInits();
+                if (arr[0] instanceof Integer) {
+                        ret = new ArrayCreationExpr(line, column, token.endLine, token.endColumn, type, ((Integer)arr[0]).intValue(), (ArrayInitializerExpr)arr[1]);
+                } else {
+                        ret = new ArrayCreationExpr(line, column, token.endLine, token.endColumn, type, (List)arr[0], ((Integer)arr[1]).intValue());
+                }
+      break;
+    default:
+      jj_la1[98] = jj_gen;
+      if (jj_2_31(2147483647)) {
+        type = ClassOrInterfaceType();
+        arr = ArrayDimsAndInits();
+                if (arr[0] instanceof Integer) {
+                        ret = new ArrayCreationExpr(line, column, token.endLine, token.endColumn, type, ((Integer)arr[0]).intValue(), (ArrayInitializerExpr)arr[1]);
+                } else {
+                        ret = new ArrayCreationExpr(line, column, token.endLine, token.endColumn, type, (List)arr[0], ((Integer)arr[1]).intValue());
+                }
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case IDENTIFIER:
+        case LT:
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case LT:
+            typeArgs = TypeArguments();
+                                        typeArgs.remove(0);
+            break;
+          default:
+            jj_la1[97] = jj_gen;
+            ;
+          }
+          type = ClassOrInterfaceType();
+          args = Arguments();
+          if (jj_2_30(2)) {
+            anonymousBody = ClassOrInterfaceBody(false);
+          } else {
+            ;
+          }
+        ret = new ObjectCreationExpr(line, column, token.endLine, token.endColumn, scope, (ClassOrInterfaceType) type, typeArgs, args, anonymousBody);
+          break;
+        default:
+          jj_la1[99] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+/*
+ * The third LOOKAHEAD specification below is to parse to PrimarySuffix
+ * if there is an expression between the "[...]".
+ */
+  final public Object[] ArrayDimsAndInits() throws ParseException {
+        Object[] ret = new Object[2];
+        Expression expr;
+        List inits = null;
+        int i = 0;
+    if (jj_2_34(2)) {
+      label_38:
+      while (true) {
+        jj_consume_token(LBRACKET);
+        expr = Expression();
+                                                   inits = add(inits, expr);
+        jj_consume_token(RBRACKET);
+        if (jj_2_32(2)) {
+          ;
+        } else {
+          break label_38;
+        }
+      }
+      label_39:
+      while (true) {
+        if (jj_2_33(2)) {
+          ;
+        } else {
+          break label_39;
+        }
+        jj_consume_token(LBRACKET);
+        jj_consume_token(RBRACKET);
+                                                                                                               i++;
+      }
+                                                                                                                           ret[0] = inits; ret[1] = new Integer(i);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LBRACKET:
+        label_40:
+        while (true) {
+          jj_consume_token(LBRACKET);
+          jj_consume_token(RBRACKET);
+                      i++;
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case LBRACKET:
+            ;
+            break;
+          default:
+            jj_la1[100] = jj_gen;
+            break label_40;
+          }
+        }
+        expr = ArrayInitializer();
+                                                            ret[0] = new Integer(i); ret[1] = expr;
+        break;
+      default:
+        jj_la1[101] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+/*
+ * Statement syntax follows.
+ */
+  final public Statement Statement() throws ParseException {
+        Statement ret;
+    if (jj_2_35(2)) {
+      ret = LabeledStatement();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ASSERT:
+        ret = AssertStatement();
+        break;
+      case LBRACE:
+        ret = Block();
+        break;
+      case SEMICOLON:
+        ret = EmptyStatement();
+        break;
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case DOUBLE:
+      case FALSE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case NEW:
+      case NULL:
+      case SHORT:
+      case SUPER:
+      case THIS:
+      case TRUE:
+      case VOID:
+      case LONG_LITERAL:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case IDENTIFIER:
+      case LPAREN:
+      case INCR:
+      case DECR:
+        ret = StatementExpression();
+        break;
+      case SWITCH:
+        ret = SwitchStatement();
+        break;
+      case IF:
+        ret = IfStatement();
+        break;
+      case WHILE:
+        ret = WhileStatement();
+        break;
+      case DO:
+        ret = DoStatement();
+        break;
+      case FOR:
+        ret = ForStatement();
+        break;
+      case BREAK:
+        ret = BreakStatement();
+        break;
+      case CONTINUE:
+        ret = ContinueStatement();
+        break;
+      case RETURN:
+        ret = ReturnStatement();
+        break;
+      case THROW:
+        ret = ThrowStatement();
+        break;
+      case SYNCHRONIZED:
+        ret = SynchronizedStatement();
+        break;
+      case TRY:
+        ret = TryStatement();
+        break;
+      default:
+        jj_la1[102] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public AssertStmt AssertStatement() throws ParseException {
+        Expression check;
+        Expression msg = null;
+        int line;
+        int column;
+    jj_consume_token(ASSERT);
+            line=token.beginLine; column=token.beginColumn;
+    check = Expression();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case COLON:
+      jj_consume_token(COLON);
+      msg = Expression();
+      break;
+    default:
+      jj_la1[103] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+    {if (true) return new AssertStmt(line, column, token.endLine, token.endColumn,check, msg);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public LabeledStmt LabeledStatement() throws ParseException {
+        String label;
+        Statement stmt;
+        int line;
+        int column;
+    jj_consume_token(IDENTIFIER);
+                line=token.beginLine; column=token.beginColumn;
+                                                                   label = token.image;
+    jj_consume_token(COLON);
+    stmt = Statement();
+    {if (true) return new LabeledStmt(line, column, token.endLine, token.endColumn,label, stmt);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public BlockStmt Block() throws ParseException {
+        List stmts;
+        int beginLine;
+        int beginColumn;
+    jj_consume_token(LBRACE);
+       beginLine=token.beginLine; beginColumn=token.beginColumn;
+    stmts = Statements();
+    jj_consume_token(RBRACE);
+    {if (true) return new BlockStmt(beginLine, beginColumn, token.endLine, token.endColumn, stmts);}
+    throw new Error("Missing return statement in function");
+  }
+
+/*
+ * Classes inside block stametents can only be abstract or final. The semantic must check it.
+ */
+  final public Statement BlockStatement() throws ParseException {
+        Statement ret;
+        Expression expr;
+        ClassOrInterfaceDeclaration typeDecl;
+        Modifier modifier;
+    if (jj_2_36(2147483647)) {
+            pushJavadoc();
+      modifier = Modifiers();
+      typeDecl = ClassOrInterfaceDeclaration(modifier);
+                                                             ret = new TypeDeclarationStmt(typeDecl.getBeginLine(), typeDecl.getBeginColumn(), token.endLine, token.endColumn, typeDecl);
+    } else if (jj_2_37(2147483647)) {
+      expr = VariableDeclarationExpression();
+      jj_consume_token(SEMICOLON);
+            ret = new ExpressionStmt(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ASSERT:
+      case BOOLEAN:
+      case BREAK:
+      case BYTE:
+      case CHAR:
+      case CONTINUE:
+      case DO:
+      case DOUBLE:
+      case FALSE:
+      case FLOAT:
+      case FOR:
+      case IF:
+      case INT:
+      case LONG:
+      case NEW:
+      case NULL:
+      case RETURN:
+      case SHORT:
+      case SUPER:
+      case SWITCH:
+      case SYNCHRONIZED:
+      case THIS:
+      case THROW:
+      case TRUE:
+      case TRY:
+      case VOID:
+      case WHILE:
+      case LONG_LITERAL:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case IDENTIFIER:
+      case LPAREN:
+      case LBRACE:
+      case SEMICOLON:
+      case INCR:
+      case DECR:
+        ret = Statement();
+        break;
+      default:
+        jj_la1[104] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public VariableDeclarationExpr VariableDeclarationExpression() throws ParseException {
+        Modifier modifier;
+        Type type;
+        List vars = new LinkedList();
+        VariableDeclarator var;
+    modifier = Modifiers();
+    type = Type();
+    var = VariableDeclarator();
+                                                                    vars.add(var);
+    label_41:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[105] = jj_gen;
+        break label_41;
+      }
+      jj_consume_token(COMMA);
+      var = VariableDeclarator();
+                                                                                                                        vars.add(var);
+    }
+    int line = modifier.beginLine;
+    int column = modifier.beginColumn;
+    if(line==-1) {line=type.getBeginLine(); column=type.getBeginColumn(); }
+    {if (true) return new VariableDeclarationExpr(line, column, token.endLine, token.endColumn, modifier.modifiers, modifier.annotations, type, vars);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public EmptyStmt EmptyStatement() throws ParseException {
+    jj_consume_token(SEMICOLON);
+    {if (true) return new EmptyStmt(token.beginLine, token.beginColumn, token.endLine, token.endColumn);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public ExpressionStmt StatementExpression() throws ParseException {
+        Expression expr;
+        AssignExpr.Operator op;
+        Expression value;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case INCR:
+      expr = PreIncrementExpression();
+      break;
+    case DECR:
+      expr = PreDecrementExpression();
+      break;
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case LONG_LITERAL:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case IDENTIFIER:
+    case LPAREN:
+      expr = PrimaryExpression();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ASSIGN:
+      case INCR:
+      case DECR:
+      case PLUSASSIGN:
+      case MINUSASSIGN:
+      case STARASSIGN:
+      case SLASHASSIGN:
+      case ANDASSIGN:
+      case ORASSIGN:
+      case XORASSIGN:
+      case REMASSIGN:
+      case LSHIFTASSIGN:
+      case RSIGNEDSHIFTASSIGN:
+      case RUNSIGNEDSHIFTASSIGN:
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case INCR:
+          jj_consume_token(INCR);
+                   expr = new UnaryExpr(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr, UnaryExpr.Operator.posIncrement);
+          break;
+        case DECR:
+          jj_consume_token(DECR);
+                   expr = new UnaryExpr(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr, UnaryExpr.Operator.posDecrement);
+          break;
+        case ASSIGN:
+        case PLUSASSIGN:
+        case MINUSASSIGN:
+        case STARASSIGN:
+        case SLASHASSIGN:
+        case ANDASSIGN:
+        case ORASSIGN:
+        case XORASSIGN:
+        case REMASSIGN:
+        case LSHIFTASSIGN:
+        case RSIGNEDSHIFTASSIGN:
+        case RUNSIGNEDSHIFTASSIGN:
+          op = AssignmentOperator();
+          value = Expression();
+                                                             expr = new AssignExpr(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr, value, op);
+          break;
+        default:
+          jj_la1[106] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+      default:
+        jj_la1[107] = jj_gen;
+        ;
+      }
+      break;
+    default:
+      jj_la1[108] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    jj_consume_token(SEMICOLON);
+    {if (true) return new ExpressionStmt(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public SwitchStmt SwitchStatement() throws ParseException {
+        Expression selector;
+        SwitchEntryStmt entry;
+        List entries = null;
+        int line;
+        int column;
+    jj_consume_token(SWITCH);
+            line=token.beginLine; column=token.beginColumn;
+    jj_consume_token(LPAREN);
+    selector = Expression();
+    jj_consume_token(RPAREN);
+    jj_consume_token(LBRACE);
+    label_42:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CASE:
+      case _DEFAULT:
+        ;
+        break;
+      default:
+        jj_la1[109] = jj_gen;
+        break label_42;
+      }
+      entry = SwitchEntry();
+                              entries = add(entries, entry);
+    }
+    jj_consume_token(RBRACE);
+    {if (true) return new SwitchStmt(line, column, token.endLine, token.endColumn,selector, entries);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public SwitchEntryStmt SwitchEntry() throws ParseException {
+        Expression label = null;
+        List stmts;
+        int line;
+        int column;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case CASE:
+      jj_consume_token(CASE);
+                  line=token.beginLine; column=token.beginColumn;
+      label = Expression();
+      break;
+    case _DEFAULT:
+      jj_consume_token(_DEFAULT);
+                     line=token.beginLine; column=token.beginColumn;
+      break;
+    default:
+      jj_la1[110] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    jj_consume_token(COLON);
+    stmts = Statements();
+    {if (true) return new SwitchEntryStmt(line, column, token.endLine, token.endColumn,label, stmts);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public IfStmt IfStatement() throws ParseException {
+        Expression condition;
+        Statement thenStmt;
+        Statement elseStmt = null;
+        int line;
+        int column;
+    jj_consume_token(IF);
+        line=token.beginLine; column=token.beginColumn;
+    jj_consume_token(LPAREN);
+    condition = Expression();
+    jj_consume_token(RPAREN);
+    thenStmt = Statement();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case ELSE:
+      jj_consume_token(ELSE);
+      elseStmt = Statement();
+      break;
+    default:
+      jj_la1[111] = jj_gen;
+      ;
+    }
+    {if (true) return new IfStmt(line, column, token.endLine, token.endColumn,condition, thenStmt, elseStmt);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public WhileStmt WhileStatement() throws ParseException {
+        Expression condition;
+        Statement body;
+        int line;
+        int column;
+    jj_consume_token(WHILE);
+           line=token.beginLine; column=token.beginColumn;
+    jj_consume_token(LPAREN);
+    condition = Expression();
+    jj_consume_token(RPAREN);
+    body = Statement();
+    {if (true) return new WhileStmt(line, column, token.endLine, token.endColumn,condition, body);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public DoStmt DoStatement() throws ParseException {
+        Expression condition;
+        Statement body;
+        int line;
+        int column;
+    jj_consume_token(DO);
+        line=token.beginLine; column=token.beginColumn;
+    body = Statement();
+    jj_consume_token(WHILE);
+    jj_consume_token(LPAREN);
+    condition = Expression();
+    jj_consume_token(RPAREN);
+    jj_consume_token(SEMICOLON);
+    {if (true) return new DoStmt(line, column, token.endLine, token.endColumn,body, condition);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Statement ForStatement() throws ParseException {
+        String id = null;
+        VariableDeclarationExpr varExpr = null;
+        Expression expr = null;
+        List init = null;
+        List update = null;
+        Statement body;
+        int line;
+        int column;
+    jj_consume_token(FOR);
+         line=token.beginLine; column=token.beginColumn;
+    jj_consume_token(LPAREN);
+    if (jj_2_38(2147483647)) {
+      varExpr = VariableDeclarationExpression();
+      jj_consume_token(COLON);
+      expr = Expression();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ABSTRACT:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case DOUBLE:
+      case FALSE:
+      case FINAL:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case NATIVE:
+      case NEW:
+      case NULL:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case SHORT:
+      case STATIC:
+      case STRICTFP:
+      case SUPER:
+      case SYNCHRONIZED:
+      case THIS:
+      case TRANSIENT:
+      case TRUE:
+      case VOID:
+      case VOLATILE:
+      case LONG_LITERAL:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case IDENTIFIER:
+      case LPAREN:
+      case SEMICOLON:
+      case AT:
+      case BANG:
+      case TILDE:
+      case INCR:
+      case DECR:
+      case PLUS:
+      case MINUS:
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case ABSTRACT:
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case DOUBLE:
+        case FALSE:
+        case FINAL:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case NATIVE:
+        case NEW:
+        case NULL:
+        case PRIVATE:
+        case PROTECTED:
+        case PUBLIC:
+        case SHORT:
+        case STATIC:
+        case STRICTFP:
+        case SUPER:
+        case SYNCHRONIZED:
+        case THIS:
+        case TRANSIENT:
+        case TRUE:
+        case VOID:
+        case VOLATILE:
+        case LONG_LITERAL:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+        case IDENTIFIER:
+        case LPAREN:
+        case AT:
+        case BANG:
+        case TILDE:
+        case INCR:
+        case DECR:
+        case PLUS:
+        case MINUS:
+          init = ForInit();
+          break;
+        default:
+          jj_la1[112] = jj_gen;
+          ;
+        }
+        jj_consume_token(SEMICOLON);
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case DOUBLE:
+        case FALSE:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case NEW:
+        case NULL:
+        case SHORT:
+        case SUPER:
+        case THIS:
+        case TRUE:
+        case VOID:
+        case LONG_LITERAL:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+        case IDENTIFIER:
+        case LPAREN:
+        case BANG:
+        case TILDE:
+        case INCR:
+        case DECR:
+        case PLUS:
+        case MINUS:
+          expr = Expression();
+          break;
+        default:
+          jj_la1[113] = jj_gen;
+          ;
+        }
+        jj_consume_token(SEMICOLON);
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case DOUBLE:
+        case FALSE:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case NEW:
+        case NULL:
+        case SHORT:
+        case SUPER:
+        case THIS:
+        case TRUE:
+        case VOID:
+        case LONG_LITERAL:
+        case INTEGER_LITERAL:
+        case FLOATING_POINT_LITERAL:
+        case CHARACTER_LITERAL:
+        case STRING_LITERAL:
+        case IDENTIFIER:
+        case LPAREN:
+        case BANG:
+        case TILDE:
+        case INCR:
+        case DECR:
+        case PLUS:
+        case MINUS:
+          update = ForUpdate();
+          break;
+        default:
+          jj_la1[114] = jj_gen;
+          ;
+        }
+        break;
+      default:
+        jj_la1[115] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+    jj_consume_token(RPAREN);
+    body = Statement();
+        if (varExpr != null) {
+                {if (true) return new ForeachStmt(line, column, token.endLine, token.endColumn,varExpr, expr, body);}
+        }
+        {if (true) return new ForStmt(line, column, token.endLine, token.endColumn,init, expr, update, body);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List ForInit() throws ParseException {
+        List ret;
+        Expression expr;
+    if (jj_2_39(2147483647)) {
+      expr = VariableDeclarationExpression();
+                                                   ret = new LinkedList(); ret.add(expr);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case DOUBLE:
+      case FALSE:
+      case FLOAT:
+      case INT:
+      case LONG:
+      case NEW:
+      case NULL:
+      case SHORT:
+      case SUPER:
+      case THIS:
+      case TRUE:
+      case VOID:
+      case LONG_LITERAL:
+      case INTEGER_LITERAL:
+      case FLOATING_POINT_LITERAL:
+      case CHARACTER_LITERAL:
+      case STRING_LITERAL:
+      case IDENTIFIER:
+      case LPAREN:
+      case BANG:
+      case TILDE:
+      case INCR:
+      case DECR:
+      case PLUS:
+      case MINUS:
+        ret = ExpressionList();
+        break;
+      default:
+        jj_la1[116] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List ExpressionList() throws ParseException {
+        List ret = new LinkedList();
+        Expression expr;
+    expr = Expression();
+                        ret.add(expr);
+    label_43:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[117] = jj_gen;
+        break label_43;
+      }
+      jj_consume_token(COMMA);
+      expr = Expression();
+                                                                      ret.add(expr);
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List ForUpdate() throws ParseException {
+        List ret;
+    ret = ExpressionList();
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public BreakStmt BreakStatement() throws ParseException {
+        String id = null;
+        int line;
+        int column;
+    jj_consume_token(BREAK);
+           line=token.beginLine; column=token.beginColumn;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IDENTIFIER:
+      jj_consume_token(IDENTIFIER);
+                                                                             id = token.image;
+      break;
+    default:
+      jj_la1[118] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+    {if (true) return new BreakStmt(line, column, token.endLine, token.endColumn,id);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public ContinueStmt ContinueStatement() throws ParseException {
+        String id = null;
+        int line;
+        int column;
+    jj_consume_token(CONTINUE);
+              line=token.beginLine; column=token.beginColumn;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IDENTIFIER:
+      jj_consume_token(IDENTIFIER);
+                                                                                id = token.image;
+      break;
+    default:
+      jj_la1[119] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+    {if (true) return new ContinueStmt(line, column, token.endLine, token.endColumn,id);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public ReturnStmt ReturnStatement() throws ParseException {
+        Expression expr = null;
+        int line;
+        int column;
+    jj_consume_token(RETURN);
+            line=token.beginLine; column=token.beginColumn;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case LONG_LITERAL:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case IDENTIFIER:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+      expr = Expression();
+      break;
+    default:
+      jj_la1[120] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+    {if (true) return new ReturnStmt(line, column, token.endLine, token.endColumn,expr);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public ThrowStmt ThrowStatement() throws ParseException {
+        Expression expr;
+        int line;
+        int column;
+    jj_consume_token(THROW);
+           line=token.beginLine; column=token.beginColumn;
+    expr = Expression();
+    jj_consume_token(SEMICOLON);
+    {if (true) return new ThrowStmt(line, column, token.endLine, token.endColumn,expr);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public SynchronizedStmt SynchronizedStatement() throws ParseException {
+        Expression expr;
+        BlockStmt block;
+        int line;
+        int column;
+    jj_consume_token(SYNCHRONIZED);
+                  line=token.beginLine; column=token.beginColumn;
+    jj_consume_token(LPAREN);
+    expr = Expression();
+    jj_consume_token(RPAREN);
+    block = Block();
+    {if (true) return new SynchronizedStmt(line, column, token.endLine, token.endColumn,expr, block);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public TryStmt TryStatement() throws ParseException {
+        BlockStmt tryBlock;
+        BlockStmt finallyBlock = null;
+        List catchs = null;
+        Parameter except;
+        BlockStmt catchBlock;
+        int line;
+        int column;
+        int cLine;
+        int cColumn;
+    jj_consume_token(TRY);
+         line=token.beginLine; column=token.beginColumn;
+    tryBlock = Block();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case CATCH:
+      label_44:
+      while (true) {
+        jj_consume_token(CATCH);
+                                 cLine=token.beginLine; cColumn=token.beginColumn;
+        jj_consume_token(LPAREN);
+        except = FormalParameter();
+        jj_consume_token(RPAREN);
+        catchBlock = Block();
+                          catchs = add(catchs, new CatchClause(cLine, cColumn, token.endLine, token.endColumn, except, catchBlock));
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case CATCH:
+          ;
+          break;
+        default:
+          jj_la1[121] = jj_gen;
+          break label_44;
+        }
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case FINALLY:
+        jj_consume_token(FINALLY);
+        finallyBlock = Block();
+        break;
+      default:
+        jj_la1[122] = jj_gen;
+        ;
+      }
+      break;
+    case FINALLY:
+      jj_consume_token(FINALLY);
+      finallyBlock = Block();
+      break;
+    default:
+      jj_la1[123] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    {if (true) return new TryStmt(line, column, token.endLine, token.endColumn,tryBlock, catchs, finallyBlock);}
+    throw new Error("Missing return statement in function");
+  }
+
+/* We use productions to match >>>, >> and > so that we can keep the
+ * type declaration syntax with generics clean
+ */
+  final public void RUNSIGNEDSHIFT() throws ParseException {
+    if (getToken(1).kind == GT &&
+                    ((GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT) {
+
+    } else {
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    jj_consume_token(GT);
+    jj_consume_token(GT);
+    jj_consume_token(GT);
+  }
+
+  final public void RSIGNEDSHIFT() throws ParseException {
+    if (getToken(1).kind == GT &&
+                    ((GTToken)getToken(1)).realKind == RSIGNEDSHIFT) {
+
+    } else {
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    jj_consume_token(GT);
+    jj_consume_token(GT);
+  }
+
+/* Annotation syntax follows. */
+  final public AnnotationExpr Annotation() throws ParseException {
+        AnnotationExpr ret;
+    if (jj_2_40(2147483647)) {
+      ret = NormalAnnotation();
+    } else if (jj_2_41(2147483647)) {
+      ret = SingleMemberAnnotation();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case AT:
+        ret = MarkerAnnotation();
+        break;
+      default:
+        jj_la1[124] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public NormalAnnotationExpr NormalAnnotation() throws ParseException {
+        NameExpr name;
+        List pairs = null;
+        int line;
+        int column;
+    jj_consume_token(AT);
+        line=token.beginLine; column=token.beginColumn;
+    name = Name();
+    jj_consume_token(LPAREN);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IDENTIFIER:
+      pairs = MemberValuePairs();
+      break;
+    default:
+      jj_la1[125] = jj_gen;
+      ;
+    }
+    jj_consume_token(RPAREN);
+     {if (true) return new NormalAnnotationExpr(line, column, token.endLine, token.endColumn,name, pairs);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public MarkerAnnotationExpr MarkerAnnotation() throws ParseException {
+        NameExpr name;
+        int line;
+        int column;
+    jj_consume_token(AT);
+       line=token.beginLine; column=token.beginColumn;
+    name = Name();
+    {if (true) return new MarkerAnnotationExpr(line, column, token.endLine, token.endColumn,name);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public SingleMemberAnnotationExpr SingleMemberAnnotation() throws ParseException {
+        NameExpr name;
+        Expression memberVal;
+        int line;
+        int column;
+    jj_consume_token(AT);
+       line=token.beginLine; column=token.beginColumn;
+    name = Name();
+    jj_consume_token(LPAREN);
+    memberVal = MemberValue();
+    jj_consume_token(RPAREN);
+    {if (true) return new SingleMemberAnnotationExpr(line, column, token.endLine, token.endColumn,name, memberVal);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List MemberValuePairs() throws ParseException {
+        List ret = new LinkedList();
+        MemberValuePair pair;
+    pair = MemberValuePair();
+                              ret.add(pair);
+    label_45:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[126] = jj_gen;
+        break label_45;
+      }
+      jj_consume_token(COMMA);
+      pair = MemberValuePair();
+                                                                                ret.add(pair);
+    }
+     {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public MemberValuePair MemberValuePair() throws ParseException {
+        String name;
+        Expression value;
+        int line;
+        int column;
+    jj_consume_token(IDENTIFIER);
+                   name = token.image; line=token.beginLine; column=token.beginColumn;
+    jj_consume_token(ASSIGN);
+    value = MemberValue();
+      {if (true) return new MemberValuePair(line, column, token.endLine, token.endColumn,name, value);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression MemberValue() throws ParseException {
+        Expression ret;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case AT:
+      ret = Annotation();
+      break;
+    case LBRACE:
+      ret = MemberValueArrayInitializer();
+      break;
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case LONG_LITERAL:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case IDENTIFIER:
+    case LPAREN:
+    case BANG:
+    case TILDE:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+      ret = ConditionalExpression();
+      break;
+    default:
+      jj_la1[127] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression MemberValueArrayInitializer() throws ParseException {
+        List ret = new LinkedList();
+        Expression member;
+        int line;
+        int column;
+    jj_consume_token(LBRACE);
+       line=token.beginLine; column=token.beginColumn;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case DOUBLE:
+    case FALSE:
+    case FLOAT:
+    case INT:
+    case LONG:
+    case NEW:
+    case NULL:
+    case SHORT:
+    case SUPER:
+    case THIS:
+    case TRUE:
+    case VOID:
+    case LONG_LITERAL:
+    case INTEGER_LITERAL:
+    case FLOATING_POINT_LITERAL:
+    case CHARACTER_LITERAL:
+    case STRING_LITERAL:
+    case IDENTIFIER:
+    case LPAREN:
+    case LBRACE:
+    case AT:
+    case BANG:
+    case TILDE:
+    case INCR:
+    case DECR:
+    case PLUS:
+    case MINUS:
+      member = MemberValue();
+                                 ret.add(member);
+      label_46:
+      while (true) {
+        if (jj_2_42(2)) {
+          ;
+        } else {
+          break label_46;
+        }
+        jj_consume_token(COMMA);
+        member = MemberValue();
+                                                                                                ret.add(member);
+      }
+      break;
+    default:
+      jj_la1[128] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case COMMA:
+      jj_consume_token(COMMA);
+      break;
+    default:
+      jj_la1[129] = jj_gen;
+      ;
+    }
+    jj_consume_token(RBRACE);
+    {if (true) return new ArrayInitializerExpr(line, column, token.endLine, token.endColumn,ret);}
+    throw new Error("Missing return statement in function");
+  }
+
+/* Annotation Types. */
+  final public AnnotationDeclaration AnnotationTypeDeclaration(Modifier modifier) throws ParseException {
+        String name;
+        List members;
+        int line = modifier.beginLine;
+        int column = modifier.beginColumn;
+    jj_consume_token(AT);
+        if (line == -1) {line=token.beginLine; column=token.beginColumn;}
+    jj_consume_token(INTERFACE);
+    jj_consume_token(IDENTIFIER);
+                             name = token.image;
+    members = AnnotationTypeBody();
+    {if (true) return new AnnotationDeclaration(line, column, token.endLine, token.endColumn,popJavadoc(), modifier.modifiers, modifier.annotations, name, members);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List AnnotationTypeBody() throws ParseException {
+        List ret = null;
+        BodyDeclaration member;
+    jj_consume_token(LBRACE);
+    label_47:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case ABSTRACT:
+      case BOOLEAN:
+      case BYTE:
+      case CHAR:
+      case CLASS:
+      case DOUBLE:
+      case ENUM:
+      case FINAL:
+      case FLOAT:
+      case INT:
+      case INTERFACE:
+      case LONG:
+      case NATIVE:
+      case PRIVATE:
+      case PROTECTED:
+      case PUBLIC:
+      case SHORT:
+      case STATIC:
+      case STRICTFP:
+      case SYNCHRONIZED:
+      case TRANSIENT:
+      case VOLATILE:
+      case IDENTIFIER:
+      case SEMICOLON:
+      case AT:
+        ;
+        break;
+      default:
+        jj_la1[130] = jj_gen;
+        break label_47;
+      }
+      member = AnnotationBodyDeclaration();
+                                               ret = add(ret, member);
+    }
+    jj_consume_token(RBRACE);
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public BodyDeclaration AnnotationBodyDeclaration() throws ParseException {
+   Modifier modifier;
+   BodyDeclaration ret;
+    pushJavadoc();
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case SEMICOLON:
+      jj_consume_token(SEMICOLON);
+              ret = new EmptyTypeDeclaration(token.beginLine, token.beginColumn, token.endLine, token.endColumn, popJavadoc());
+      break;
+    case ABSTRACT:
+    case BOOLEAN:
+    case BYTE:
+    case CHAR:
+    case CLASS:
+    case DOUBLE:
+    case ENUM:
+    case FINAL:
+    case FLOAT:
+    case INT:
+    case INTERFACE:
+    case LONG:
+    case NATIVE:
+    case PRIVATE:
+    case PROTECTED:
+    case PUBLIC:
+    case SHORT:
+    case STATIC:
+    case STRICTFP:
+    case SYNCHRONIZED:
+    case TRANSIENT:
+    case VOLATILE:
+    case IDENTIFIER:
+    case AT:
+      modifier = Modifiers();
+      if (jj_2_43(2147483647)) {
+        ret = AnnotationTypeMemberDeclaration(modifier);
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case CLASS:
+        case INTERFACE:
+          ret = ClassOrInterfaceDeclaration(modifier);
+          break;
+        case ENUM:
+          ret = EnumDeclaration(modifier);
+          break;
+        case AT:
+          ret = AnnotationTypeDeclaration(modifier);
+          break;
+        case BOOLEAN:
+        case BYTE:
+        case CHAR:
+        case DOUBLE:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case SHORT:
+        case IDENTIFIER:
+          ret = FieldDeclaration(modifier);
+          break;
+        default:
+          jj_la1[131] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+      break;
+    default:
+      jj_la1[132] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public AnnotationMemberDeclaration AnnotationTypeMemberDeclaration(Modifier modifier) throws ParseException {
+        Type type;
+        String name;
+        Expression defaultVal = null;
+    type = Type();
+    jj_consume_token(IDENTIFIER);
+                               name = token.image;
+    jj_consume_token(LPAREN);
+    jj_consume_token(RPAREN);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case _DEFAULT:
+      defaultVal = DefaultValue();
+      break;
+    default:
+      jj_la1[133] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+    int line = modifier.beginLine;
+    int column = modifier.beginColumn;
+    { if (line == -1) {line=type.getBeginLine(); column=type.getBeginColumn();} }
+    {if (true) return new AnnotationMemberDeclaration(line, column, token.endLine, token.endColumn, popJavadoc(), modifier.modifiers, modifier.annotations, type, name, defaultVal);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression DefaultValue() throws ParseException {
+        Expression ret;
+    jj_consume_token(_DEFAULT);
+    ret = MemberValue();
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  private boolean jj_2_1(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_1(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(0, xla); }
+  }
+
+  private boolean jj_2_2(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_2(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(1, xla); }
+  }
+
+  private boolean jj_2_3(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_3(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(2, xla); }
+  }
+
+  private boolean jj_2_4(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_4(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(3, xla); }
+  }
+
+  private boolean jj_2_5(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_5(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(4, xla); }
+  }
+
+  private boolean jj_2_6(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_6(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(5, xla); }
+  }
+
+  private boolean jj_2_7(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_7(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(6, xla); }
+  }
+
+  private boolean jj_2_8(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_8(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(7, xla); }
+  }
+
+  private boolean jj_2_9(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_9(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(8, xla); }
+  }
+
+  private boolean jj_2_10(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_10(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(9, xla); }
+  }
+
+  private boolean jj_2_11(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_11(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(10, xla); }
+  }
+
+  private boolean jj_2_12(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_12(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(11, xla); }
+  }
+
+  private boolean jj_2_13(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_13(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(12, xla); }
+  }
+
+  private boolean jj_2_14(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_14(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(13, xla); }
+  }
+
+  private boolean jj_2_15(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_15(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(14, xla); }
+  }
+
+  private boolean jj_2_16(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_16(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(15, xla); }
+  }
+
+  private boolean jj_2_17(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_17(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(16, xla); }
+  }
+
+  private boolean jj_2_18(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_18(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(17, xla); }
+  }
+
+  private boolean jj_2_19(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_19(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(18, xla); }
+  }
+
+  private boolean jj_2_20(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_20(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(19, xla); }
+  }
+
+  private boolean jj_2_21(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_21(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(20, xla); }
+  }
+
+  private boolean jj_2_22(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_22(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(21, xla); }
+  }
+
+  private boolean jj_2_23(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_23(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(22, xla); }
+  }
+
+  private boolean jj_2_24(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_24(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(23, xla); }
+  }
+
+  private boolean jj_2_25(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_25(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(24, xla); }
+  }
+
+  private boolean jj_2_26(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_26(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(25, xla); }
+  }
+
+  private boolean jj_2_27(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_27(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(26, xla); }
+  }
+
+  private boolean jj_2_28(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_28(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(27, xla); }
+  }
+
+  private boolean jj_2_29(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_29(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(28, xla); }
+  }
+
+  private boolean jj_2_30(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_30(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(29, xla); }
+  }
+
+  private boolean jj_2_31(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_31(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(30, xla); }
+  }
+
+  private boolean jj_2_32(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_32(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(31, xla); }
+  }
+
+  private boolean jj_2_33(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_33(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(32, xla); }
+  }
+
+  private boolean jj_2_34(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_34(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(33, xla); }
+  }
+
+  private boolean jj_2_35(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_35(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(34, xla); }
+  }
+
+  private boolean jj_2_36(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_36(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(35, xla); }
+  }
+
+  private boolean jj_2_37(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_37(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(36, xla); }
+  }
+
+  private boolean jj_2_38(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_38(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(37, xla); }
+  }
+
+  private boolean jj_2_39(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_39(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(38, xla); }
+  }
+
+  private boolean jj_2_40(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_40(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(39, xla); }
+  }
+
+  private boolean jj_2_41(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_41(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(40, xla); }
+  }
+
+  private boolean jj_2_42(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_42(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(41, xla); }
+  }
+
+  private boolean jj_2_43(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_43(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(42, xla); }
+  }
+
+  private boolean jj_3R_101() {
+    if (jj_3R_152()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_176() {
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_66()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_212() {
+    if (jj_3R_238()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_211() {
+    if (jj_scan_token(STRING_LITERAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_210() {
+    if (jj_scan_token(CHARACTER_LITERAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_66() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_101()) {
+    jj_scanpos = xsp;
+    if (jj_3R_102()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_209() {
+    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_208() {
+    if (jj_scan_token(LONG_LITERAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_175() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_203()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_359() {
+    if (jj_3R_370()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_207() {
+    if (jj_scan_token(INTEGER_LITERAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_64() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_84() {
+    if (jj_3R_71()) return true;
+    return false;
+  }
+
+  private boolean jj_3_29() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_84()) jj_scanpos = xsp;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_184() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_207()) {
+    jj_scanpos = xsp;
+    if (jj_3R_208()) {
+    jj_scanpos = xsp;
+    if (jj_3R_209()) {
+    jj_scanpos = xsp;
+    if (jj_3R_210()) {
+    jj_scanpos = xsp;
+    if (jj_3R_211()) {
+    jj_scanpos = xsp;
+    if (jj_3R_212()) {
+    jj_scanpos = xsp;
+    if (jj_3R_213()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_141() {
+    if (jj_3R_175()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_176()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_136() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_3R_73()) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_199() {
+    if (jj_3R_154()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_181() {
+    if (jj_3R_204()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_198() {
+    if (jj_3R_71()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_172() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_198()) jj_scanpos = xsp;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_199()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_171() {
+    if (jj_3R_187()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_170() {
+    if (jj_scan_token(THIS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_319() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_141()) return true;
+    return false;
+  }
+
+  private boolean jj_3_5() {
+    if (jj_3R_63()) return true;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_64()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_scan_token(87)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(90)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(86)) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_62() {
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3_4() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_62()) jj_scanpos = xsp;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_249() {
+    if (jj_3R_63()) return true;
+    if (jj_3R_141()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_319()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_135() {
+    if (jj_scan_token(DOT)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_170()) {
+    jj_scanpos = xsp;
+    if (jj_3R_171()) {
+    jj_scanpos = xsp;
+    if (jj_3R_172()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_231() {
+    if (jj_3R_250()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_201() {
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_230() {
+    if (jj_3R_249()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_229() {
+    if (jj_3R_248()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_82() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_135()) {
+    jj_scanpos = xsp;
+    if (jj_3R_136()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_228() {
+    if (jj_3R_247()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_227() {
+    if (jj_3R_246()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_226() {
+    if (jj_3R_245()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_370() {
+    if (jj_scan_token(_DEFAULT)) return true;
+    if (jj_3R_93()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_134() {
+    if (jj_scan_token(DOT)) return true;
+    if (jj_scan_token(SUPER)) return true;
+    return false;
+  }
+
+  private boolean jj_3_28() {
+    if (jj_3R_82()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_200() {
+    if (jj_3R_89()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_226()) {
+    jj_scanpos = xsp;
+    if (jj_3R_227()) {
+    jj_scanpos = xsp;
+    if (jj_3R_228()) {
+    jj_scanpos = xsp;
+    if (jj_3R_229()) {
+    jj_scanpos = xsp;
+    if (jj_3R_230()) {
+    jj_scanpos = xsp;
+    if (jj_3R_231()) return true;
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_188() {
+    if (jj_3R_154()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_81() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_28()) {
+    jj_scanpos = xsp;
+    if (jj_3R_134()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_27() {
+    if (jj_3R_83()) return true;
+    if (jj_scan_token(DOT)) return true;
+    if (jj_scan_token(CLASS)) return true;
+    return false;
+  }
+
+  private boolean jj_3_6() {
+    if (jj_3R_65()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_163() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_188()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_358() {
+    if (jj_3R_63()) return true;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_359()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_43() {
+    if (jj_3R_63()) return true;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_354() {
+    if (jj_3R_249()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_353() {
+    if (jj_3R_247()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_162() {
+    if (jj_3R_83()) return true;
+    if (jj_scan_token(DOT)) return true;
+    if (jj_scan_token(CLASS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_352() {
+    if (jj_3R_246()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_173() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_6()) {
+    jj_scanpos = xsp;
+    if (jj_3R_200()) {
+    jj_scanpos = xsp;
+    if (jj_3R_201()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_161() {
+    if (jj_3R_187()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_351() {
+    if (jj_3R_245()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_160() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_73()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_350() {
+    if (jj_3R_358()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_139() {
+    if (jj_3R_173()) return true;
+    return false;
+  }
+
+  private boolean jj_3_42() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_93()) return true;
+    return false;
+  }
+
+  private boolean jj_3_26() {
+    if (jj_3R_82()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_186() {
+    if (jj_3R_154()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_185() {
+    if (jj_3R_71()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_85() {
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_139()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_344() {
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_345() {
+    if (jj_3R_89()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_350()) {
+    jj_scanpos = xsp;
+    if (jj_3R_351()) {
+    jj_scanpos = xsp;
+    if (jj_3R_352()) {
+    jj_scanpos = xsp;
+    if (jj_3R_353()) {
+    jj_scanpos = xsp;
+    if (jj_3R_354()) return true;
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_159() {
+    if (jj_scan_token(SUPER)) return true;
+    if (jj_scan_token(DOT)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_185()) jj_scanpos = xsp;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_186()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_158() {
+    if (jj_scan_token(THIS)) return true;
+    return false;
+  }
+
+  private boolean jj_3_3() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_233() {
+    if (jj_scan_token(BIT_AND)) return true;
+    if (jj_3R_86()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_157() {
+    if (jj_3R_184()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_106() {
+    if (jj_3R_82()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_339() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_344()) {
+    jj_scanpos = xsp;
+    if (jj_3R_345()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_204() {
+    if (jj_scan_token(EXTENDS)) return true;
+    if (jj_3R_86()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_233()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_328() {
+    if (jj_3R_339()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_105() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_157()) {
+    jj_scanpos = xsp;
+    if (jj_3R_158()) {
+    jj_scanpos = xsp;
+    if (jj_3R_159()) {
+    jj_scanpos = xsp;
+    if (jj_3R_160()) {
+    jj_scanpos = xsp;
+    if (jj_3R_161()) {
+    jj_scanpos = xsp;
+    if (jj_3R_162()) {
+    jj_scanpos = xsp;
+    if (jj_3R_163()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_25() {
+    if (jj_3R_81()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_315() {
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_328()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_149() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_181()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_338() {
+    if (jj_3R_85()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_150() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_149()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_68() {
+    if (jj_3R_105()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_106()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_247() {
+    if (jj_scan_token(AT)) return true;
+    if (jj_scan_token(INTERFACE)) return true;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_3R_315()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_97() {
+    if (jj_scan_token(LT)) return true;
+    if (jj_3R_149()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_150()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(GT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_263() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_262()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_243() {
+    if (jj_3R_105()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_25()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_281() {
+    if (jj_3R_93()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_42()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_337() {
+    if (jj_3R_154()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_125() {
+    if (jj_3R_70()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_169()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_327() {
+    if (jj_3R_173()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_96() {
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_232() {
+    if (jj_3R_251()) return true;
+    return false;
+  }
+
+  private boolean jj_3_24() {
+    if (jj_3R_80()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_168()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_61() {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_96()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(IDENTIFIER)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_337()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_338()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_177() {
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_281()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(87)) jj_scanpos = xsp;
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_145() {
+    if (jj_3R_122()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_314() {
+    if (jj_scan_token(SEMICOLON)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_327()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_144() {
+    if (jj_3R_177()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_143() {
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_77() {
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_24()) {
+    jj_scanpos = xsp;
+    if (jj_3R_125()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_313() {
+    if (jj_3R_61()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_3()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_93() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_143()) {
+    jj_scanpos = xsp;
+    if (jj_3R_144()) {
+    jj_scanpos = xsp;
+    if (jj_3R_145()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_79() {
+    if (jj_scan_token(DECR)) return true;
+    return false;
+  }
+
+  private boolean jj_3_23() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_78()) {
+    jj_scanpos = xsp;
+    if (jj_3R_79()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_78() {
+    if (jj_scan_token(INCR)) return true;
+    return false;
+  }
+
+  private boolean jj_3_22() {
+    if (jj_3R_77()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_312() {
+    if (jj_3R_326()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_262() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_93()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_224() {
+    if (jj_3R_243()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_23()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_246() {
+    if (jj_scan_token(ENUM)) return true;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_312()) jj_scanpos = xsp;
+    if (jj_scan_token(LBRACE)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_313()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(87)) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_314()) jj_scanpos = xsp;
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_196() {
+    if (jj_3R_77()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_197() {
+    if (jj_3R_224()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_223() {
+    if (jj_scan_token(BANG)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_222() {
+    if (jj_scan_token(TILDE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_195() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_222()) {
+    jj_scanpos = xsp;
+    if (jj_3R_223()) return true;
+    }
+    if (jj_3R_168()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_251() {
+    if (jj_3R_262()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_263()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_336() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_86()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_169() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_195()) {
+    jj_scanpos = xsp;
+    if (jj_3R_196()) {
+    jj_scanpos = xsp;
+    if (jj_3R_197()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_326() {
+    if (jj_scan_token(IMPLEMENTS)) return true;
+    if (jj_3R_86()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_336()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_179() {
+    if (jj_scan_token(AT)) return true;
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_93()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_92() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_scan_token(ASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_219() {
+    if (jj_scan_token(DECR)) return true;
+    if (jj_3R_168()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_335() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_86()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_180() {
+    if (jj_scan_token(AT)) return true;
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_325() {
+    if (jj_scan_token(EXTENDS)) return true;
+    if (jj_3R_86()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_335()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3_41() {
+    if (jj_scan_token(AT)) return true;
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_218() {
+    if (jj_scan_token(INCR)) return true;
+    if (jj_3R_168()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_259() {
+    if (jj_scan_token(INTERFACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3_40() {
+    if (jj_scan_token(AT)) return true;
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_92()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(81)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_178() {
+    if (jj_scan_token(AT)) return true;
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_232()) jj_scanpos = xsp;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_194() {
+    if (jj_3R_169()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_311() {
+    if (jj_3R_326()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_148() {
+    if (jj_3R_180()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_310() {
+    if (jj_3R_325()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_309() {
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_147() {
+    if (jj_3R_179()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_245() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(20)) {
+    jj_scanpos = xsp;
+    if (jj_3R_259()) return true;
+    }
+    if (jj_scan_token(IDENTIFIER)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_309()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_310()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_311()) jj_scanpos = xsp;
+    if (jj_3R_85()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_146() {
+    if (jj_3R_178()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_221() {
+    if (jj_scan_token(MINUS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_220() {
+    if (jj_scan_token(PLUS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_193() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_220()) {
+    jj_scanpos = xsp;
+    if (jj_3R_221()) return true;
+    }
+    if (jj_3R_168()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_192() {
+    if (jj_3R_219()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_95() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_146()) {
+    jj_scanpos = xsp;
+    if (jj_3R_147()) {
+    jj_scanpos = xsp;
+    if (jj_3R_148()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_123() {
+    return false;
+  }
+
+  private boolean jj_3R_191() {
+    if (jj_3R_218()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_124() {
+    return false;
+  }
+
+  private boolean jj_3R_168() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_191()) {
+    jj_scanpos = xsp;
+    if (jj_3R_192()) {
+    jj_scanpos = xsp;
+    if (jj_3R_193()) {
+    jj_scanpos = xsp;
+    if (jj_3R_194()) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_75() {
+    jj_lookingAhead = true;
+    jj_semLA = getToken(1).kind == GT &&
+                ((GTToken)getToken(1)).realKind == RSIGNEDSHIFT;
+    jj_lookingAhead = false;
+    if (!jj_semLA || jj_3R_123()) return true;
+    if (jj_scan_token(GT)) return true;
+    if (jj_scan_token(GT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_357() {
+    if (jj_scan_token(REM)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_356() {
+    if (jj_scan_token(SLASH)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_355() {
+    if (jj_scan_token(STAR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_376() {
+    if (jj_scan_token(CATCH)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_340()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_100()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_347() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_355()) {
+    jj_scanpos = xsp;
+    if (jj_3R_356()) {
+    jj_scanpos = xsp;
+    if (jj_3R_357()) return true;
+    }
+    }
+    if (jj_3R_168()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_377() {
+    if (jj_scan_token(FINALLY)) return true;
+    if (jj_3R_100()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_369() {
+    if (jj_scan_token(FINALLY)) return true;
+    if (jj_3R_100()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_76() {
+    jj_lookingAhead = true;
+    jj_semLA = getToken(1).kind == GT &&
+                ((GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT;
+    jj_lookingAhead = false;
+    if (!jj_semLA || jj_3R_124()) return true;
+    if (jj_scan_token(GT)) return true;
+    if (jj_scan_token(GT)) return true;
+    if (jj_scan_token(GT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_367() {
+    if (jj_3R_73()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_368() {
+    Token xsp;
+    if (jj_3R_376()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_376()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_3R_377()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_323() {
+    if (jj_3R_168()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_347()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_349() {
+    if (jj_scan_token(MINUS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_348() {
+    if (jj_scan_token(PLUS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_60() {
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_366() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_343() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_348()) {
+    jj_scanpos = xsp;
+    if (jj_3R_349()) return true;
+    }
+    if (jj_3R_323()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_59() {
+    if (jj_scan_token(STRICTFP)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_58() {
+    if (jj_scan_token(VOLATILE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_57() {
+    if (jj_scan_token(TRANSIENT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_56() {
+    if (jj_scan_token(NATIVE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_305() {
+    if (jj_3R_323()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_343()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_295() {
+    if (jj_scan_token(TRY)) return true;
+    if (jj_3R_100()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_368()) {
+    jj_scanpos = xsp;
+    if (jj_3R_369()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_55() {
+    if (jj_scan_token(SYNCHRONIZED)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_54() {
+    if (jj_scan_token(ABSTRACT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_53() {
+    if (jj_scan_token(FINAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3_21() {
+    if (jj_3R_76()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_365() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    return false;
+  }
+
+  private boolean jj_3_20() {
+    if (jj_3R_75()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_52() {
+    if (jj_scan_token(PRIVATE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_74() {
+    if (jj_scan_token(LSHIFT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_51() {
+    if (jj_scan_token(PROTECTED)) return true;
+    return false;
+  }
+
+  private boolean jj_3_19() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_74()) {
+    jj_scanpos = xsp;
+    if (jj_3_20()) {
+    jj_scanpos = xsp;
+    if (jj_3_21()) return true;
+    }
+    }
+    if (jj_3R_305()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_50() {
+    if (jj_scan_token(STATIC)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_49() {
+    if (jj_scan_token(PUBLIC)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_306() {
+    if (jj_scan_token(INSTANCEOF)) return true;
+    if (jj_3R_63()) return true;
+    return false;
+  }
+
+  private boolean jj_3_2() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_49()) {
+    jj_scanpos = xsp;
+    if (jj_3R_50()) {
+    jj_scanpos = xsp;
+    if (jj_3R_51()) {
+    jj_scanpos = xsp;
+    if (jj_3R_52()) {
+    jj_scanpos = xsp;
+    if (jj_3R_53()) {
+    jj_scanpos = xsp;
+    if (jj_3R_54()) {
+    jj_scanpos = xsp;
+    if (jj_3R_55()) {
+    jj_scanpos = xsp;
+    if (jj_3R_56()) {
+    jj_scanpos = xsp;
+    if (jj_3R_57()) {
+    jj_scanpos = xsp;
+    if (jj_3R_58()) {
+    jj_scanpos = xsp;
+    if (jj_3R_59()) {
+    jj_scanpos = xsp;
+    if (jj_3R_60()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_303() {
+    if (jj_3R_305()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_19()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_89() {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_2()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_294() {
+    if (jj_scan_token(SYNCHRONIZED)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_73()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_100()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_334() {
+    if (jj_scan_token(GE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_333() {
+    if (jj_scan_token(LE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_332() {
+    if (jj_scan_token(GT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_331() {
+    if (jj_scan_token(LT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_324() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_331()) {
+    jj_scanpos = xsp;
+    if (jj_3R_332()) {
+    jj_scanpos = xsp;
+    if (jj_3R_333()) {
+    jj_scanpos = xsp;
+    if (jj_3R_334()) return true;
+    }
+    }
+    }
+    if (jj_3R_303()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_293() {
+    if (jj_scan_token(THROW)) return true;
+    if (jj_3R_73()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_301() {
+    if (jj_3R_303()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_324()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_302() {
+    if (jj_scan_token(BIT_AND)) return true;
+    if (jj_3R_279()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_292() {
+    if (jj_scan_token(RETURN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_367()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_296() {
+    if (jj_3R_301()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_306()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_388() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_73()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_94() {
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_48() {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_94()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(PACKAGE)) return true;
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_308() {
+    if (jj_scan_token(NE)) return true;
+    return false;
+  }
+
+  private boolean jj_3_1() {
+    if (jj_3R_48()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_362() {
+    if (jj_scan_token(ELSE)) return true;
+    if (jj_3R_252()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_307() {
+    if (jj_scan_token(EQ)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_291() {
+    if (jj_scan_token(CONTINUE)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_366()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_304() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_307()) {
+    jj_scanpos = xsp;
+    if (jj_3R_308()) return true;
+    }
+    if (jj_3R_296()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_297() {
+    if (jj_scan_token(XOR)) return true;
+    if (jj_3R_257()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_280() {
+    if (jj_scan_token(BIT_OR)) return true;
+    if (jj_3R_242()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_279() {
+    if (jj_3R_296()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_304()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_375() {
+    if (jj_3R_384()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_290() {
+    if (jj_scan_token(BREAK)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_365()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_258() {
+    if (jj_scan_token(SC_AND)) return true;
+    if (jj_3R_217()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_257() {
+    if (jj_3R_279()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_302()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_244() {
+    if (jj_scan_token(SC_OR)) return true;
+    if (jj_3R_190()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_384() {
+    if (jj_3R_387()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_242() {
+    if (jj_3R_257()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_297()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3_39() {
+    if (jj_3R_89()) return true;
+    if (jj_3R_63()) return true;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_387() {
+    if (jj_3R_73()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_388()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_386() {
+    if (jj_3R_387()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_374() {
+    if (jj_3R_73()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_217() {
+    if (jj_3R_242()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_280()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_385() {
+    if (jj_3R_90()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_190() {
+    if (jj_3R_217()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_258()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_383() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_385()) {
+    jj_scanpos = xsp;
+    if (jj_3R_386()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_38() {
+    if (jj_3R_90()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_167() {
+    if (jj_3R_190()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_244()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_373() {
+    if (jj_3R_383()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_364() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_373()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_374()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_375()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_225() {
+    if (jj_scan_token(HOOK)) return true;
+    if (jj_3R_73()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_122()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_363() {
+    if (jj_3R_90()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_73()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_122() {
+    if (jj_3R_167()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_225()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_289() {
+    if (jj_scan_token(FOR)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_363()) {
+    jj_scanpos = xsp;
+    if (jj_3R_364()) return true;
+    }
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_252()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_121() {
+    if (jj_scan_token(ORASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_120() {
+    if (jj_scan_token(XORASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_119() {
+    if (jj_scan_token(ANDASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_118() {
+    if (jj_scan_token(RUNSIGNEDSHIFTASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_117() {
+    if (jj_scan_token(RSIGNEDSHIFTASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_116() {
+    if (jj_scan_token(LSHIFTASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_115() {
+    if (jj_scan_token(MINUSASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_114() {
+    if (jj_scan_token(PLUSASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_113() {
+    if (jj_scan_token(REMASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_112() {
+    if (jj_scan_token(SLASHASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_111() {
+    if (jj_scan_token(STARASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_110() {
+    if (jj_scan_token(ASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_288() {
+    if (jj_scan_token(DO)) return true;
+    if (jj_3R_252()) return true;
+    if (jj_scan_token(WHILE)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_73()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_72() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_110()) {
+    jj_scanpos = xsp;
+    if (jj_3R_111()) {
+    jj_scanpos = xsp;
+    if (jj_3R_112()) {
+    jj_scanpos = xsp;
+    if (jj_3R_113()) {
+    jj_scanpos = xsp;
+    if (jj_3R_114()) {
+    jj_scanpos = xsp;
+    if (jj_3R_115()) {
+    jj_scanpos = xsp;
+    if (jj_3R_116()) {
+    jj_scanpos = xsp;
+    if (jj_3R_117()) {
+    jj_scanpos = xsp;
+    if (jj_3R_118()) {
+    jj_scanpos = xsp;
+    if (jj_3R_119()) {
+    jj_scanpos = xsp;
+    if (jj_3R_120()) {
+    jj_scanpos = xsp;
+    if (jj_3R_121()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_342() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3_18() {
+    if (jj_3R_72()) return true;
+    if (jj_3R_73()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_287() {
+    if (jj_scan_token(WHILE)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_73()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_252()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_73() {
+    if (jj_3R_122()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_18()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_286() {
+    if (jj_scan_token(IF)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_73()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_3R_252()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_362()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_142() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_141()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_382() {
+    if (jj_scan_token(_DEFAULT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_381() {
+    if (jj_scan_token(CASE)) return true;
+    if (jj_3R_73()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_330() {
+    if (jj_3R_91()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_342()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_372() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_381()) {
+    jj_scanpos = xsp;
+    if (jj_3R_382()) return true;
+    }
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_151()) return true;
+    return false;
+  }
+
+  private boolean jj_3_17() {
+    if (jj_scan_token(DOT)) return true;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_91() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_17()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_361() {
+    if (jj_3R_372()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_138() {
+    if (jj_3R_63()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_137() {
+    if (jj_scan_token(VOID)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_285() {
+    if (jj_scan_token(SWITCH)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_73()) return true;
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_361()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_380() {
+    if (jj_3R_72()) return true;
+    if (jj_3R_73()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_83() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_137()) {
+    jj_scanpos = xsp;
+    if (jj_3R_138()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_379() {
+    if (jj_scan_token(DECR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_378() {
+    if (jj_scan_token(INCR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_371() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_378()) {
+    jj_scanpos = xsp;
+    if (jj_3R_379()) {
+    jj_scanpos = xsp;
+    if (jj_3R_380()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_300() {
+    if (jj_3R_243()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_371()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_299() {
+    if (jj_3R_219()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_133() {
+    if (jj_scan_token(DOUBLE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_298() {
+    if (jj_3R_218()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_132() {
+    if (jj_scan_token(FLOAT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_131() {
+    if (jj_scan_token(LONG)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_130() {
+    if (jj_scan_token(INT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_129() {
+    if (jj_scan_token(SHORT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_128() {
+    if (jj_scan_token(BYTE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_284() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_298()) {
+    jj_scanpos = xsp;
+    if (jj_3R_299()) {
+    jj_scanpos = xsp;
+    if (jj_3R_300()) return true;
+    }
+    }
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_164() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_109()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_256() {
+    if (jj_scan_token(SUPER)) return true;
+    if (jj_3R_70()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_127() {
+    if (jj_scan_token(CHAR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_241() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_255()) {
+    jj_scanpos = xsp;
+    if (jj_3R_256()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_255() {
+    if (jj_scan_token(EXTENDS)) return true;
+    if (jj_3R_70()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_126() {
+    if (jj_scan_token(BOOLEAN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_80() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_126()) {
+    jj_scanpos = xsp;
+    if (jj_3R_127()) {
+    jj_scanpos = xsp;
+    if (jj_3R_128()) {
+    jj_scanpos = xsp;
+    if (jj_3R_129()) {
+    jj_scanpos = xsp;
+    if (jj_3R_130()) {
+    jj_scanpos = xsp;
+    if (jj_3R_131()) {
+    jj_scanpos = xsp;
+    if (jj_3R_132()) {
+    jj_scanpos = xsp;
+    if (jj_3R_133()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_360() {
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_73()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_283() {
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_189() {
+    if (jj_scan_token(HOOK)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_241()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_37() {
+    if (jj_3R_90()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_90() {
+    if (jj_3R_89()) return true;
+    if (jj_3R_63()) return true;
+    if (jj_3R_141()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_142()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_166() {
+    if (jj_3R_189()) return true;
+    return false;
+  }
+
+  private boolean jj_3_36() {
+    if (jj_3R_89()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(20)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(40)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_165() {
+    if (jj_3R_70()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_236() {
+    if (jj_3R_252()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_317() {
+    if (jj_scan_token(THROWS)) return true;
+    if (jj_3R_330()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_109() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_165()) {
+    jj_scanpos = xsp;
+    if (jj_3R_166()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_235() {
+    if (jj_3R_90()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_234() {
+    if (jj_3R_89()) return true;
+    if (jj_3R_245()) return true;
+    return false;
+  }
+
+  private boolean jj_3_13() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_71() {
+    if (jj_scan_token(LT)) return true;
+    if (jj_3R_109()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_164()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(GT)) return true;
+    return false;
+  }
+
+  private boolean jj_3_16() {
+    if (jj_3R_71()) return true;
+    return false;
+  }
+
+  private boolean jj_3_15() {
+    if (jj_scan_token(DOT)) return true;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_16()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_205() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_234()) {
+    jj_scanpos = xsp;
+    if (jj_3R_235()) {
+    jj_scanpos = xsp;
+    if (jj_3R_236()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_12() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3_14() {
+    if (jj_3R_71()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_86() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_14()) jj_scanpos = xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_15()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3_33() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_100() {
+    if (jj_scan_token(LBRACE)) return true;
+    if (jj_3R_151()) return true;
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_108() {
+    if (jj_3R_86()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_13()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_107() {
+    if (jj_3R_80()) return true;
+    Token xsp;
+    if (jj_3_12()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_12()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_70() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_107()) {
+    jj_scanpos = xsp;
+    if (jj_3R_108()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_88() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_252()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_98() {
+    if (jj_3R_80()) return true;
+    return false;
+  }
+
+  private boolean jj_3_11() {
+    if (jj_3R_70()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_282() {
+    if (jj_scan_token(ASSERT)) return true;
+    if (jj_3R_73()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_360()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_63() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_11()) {
+    jj_scanpos = xsp;
+    if (jj_3R_98()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_278() {
+    if (jj_3R_295()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_277() {
+    if (jj_3R_294()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_276() {
+    if (jj_3R_293()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_275() {
+    if (jj_3R_292()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_274() {
+    if (jj_3R_291()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_99() {
+    if (jj_scan_token(STATIC)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_273() {
+    if (jj_3R_290()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_65() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_99()) jj_scanpos = xsp;
+    if (jj_3R_100()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_272() {
+    if (jj_3R_289()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_271() {
+    if (jj_3R_288()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_182() {
+    if (jj_3R_205()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_270() {
+    if (jj_3R_287()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_151() {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_182()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_269() {
+    if (jj_3R_286()) return true;
+    return false;
+  }
+
+  private boolean jj_3_9() {
+    if (jj_3R_68()) return true;
+    if (jj_scan_token(DOT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_268() {
+    if (jj_3R_285()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_267() {
+    if (jj_3R_284()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_266() {
+    if (jj_3R_283()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_69() {
+    if (jj_3R_71()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_156() {
+    if (jj_3R_71()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_265() {
+    if (jj_3R_100()) return true;
+    return false;
+  }
+
+  private boolean jj_3_7() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_66()) return true;
+    return false;
+  }
+
+  private boolean jj_3_10() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_69()) jj_scanpos = xsp;
+    if (jj_scan_token(THIS)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_264() {
+    if (jj_3R_282()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_155() {
+    if (jj_3R_68()) return true;
+    if (jj_scan_token(DOT)) return true;
+    return false;
+  }
+
+  private boolean jj_3_35() {
+    if (jj_3R_88()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_104() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_155()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_156()) jj_scanpos = xsp;
+    if (jj_scan_token(SUPER)) return true;
+    if (jj_3R_154()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_153() {
+    if (jj_3R_71()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_103() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_153()) jj_scanpos = xsp;
+    if (jj_scan_token(THIS)) return true;
+    if (jj_3R_154()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_252() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_35()) {
+    jj_scanpos = xsp;
+    if (jj_3R_264()) {
+    jj_scanpos = xsp;
+    if (jj_3R_265()) {
+    jj_scanpos = xsp;
+    if (jj_3R_266()) {
+    jj_scanpos = xsp;
+    if (jj_3R_267()) {
+    jj_scanpos = xsp;
+    if (jj_3R_268()) {
+    jj_scanpos = xsp;
+    if (jj_3R_269()) {
+    jj_scanpos = xsp;
+    if (jj_3R_270()) {
+    jj_scanpos = xsp;
+    if (jj_3R_271()) {
+    jj_scanpos = xsp;
+    if (jj_3R_272()) {
+    jj_scanpos = xsp;
+    if (jj_3R_273()) {
+    jj_scanpos = xsp;
+    if (jj_3R_274()) {
+    jj_scanpos = xsp;
+    if (jj_3R_275()) {
+    jj_scanpos = xsp;
+    if (jj_3R_276()) {
+    jj_scanpos = xsp;
+    if (jj_3R_277()) {
+    jj_scanpos = xsp;
+    if (jj_3R_278()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_174() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_67() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_103()) {
+    jj_scanpos = xsp;
+    if (jj_3R_104()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_140() {
+    Token xsp;
+    if (jj_3R_174()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_174()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_3R_152()) return true;
+    return false;
+  }
+
+  private boolean jj_3_32() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_3R_73()) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3_34() {
+    Token xsp;
+    if (jj_3_32()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_32()) { jj_scanpos = xsp; break; }
+    }
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_33()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3_30() {
+    if (jj_3R_85()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_320() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_341() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_340()) return true;
+    return false;
+  }
+
+  private boolean jj_3_8() {
+    if (jj_3R_67()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_87() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_34()) {
+    jj_scanpos = xsp;
+    if (jj_3R_140()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_346() {
+    if (jj_scan_token(ELLIPSIS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_318() {
+    if (jj_3R_67()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_240() {
+    if (jj_3R_71()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_260() {
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_216() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_240()) jj_scanpos = xsp;
+    if (jj_3R_86()) return true;
+    if (jj_3R_154()) return true;
+    xsp = jj_scanpos;
+    if (jj_3_30()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_31() {
+    if (jj_3R_86()) return true;
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_248() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_260()) jj_scanpos = xsp;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_3R_316()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_317()) jj_scanpos = xsp;
+    if (jj_scan_token(LBRACE)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_318()) jj_scanpos = xsp;
+    if (jj_3R_151()) return true;
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_237() {
+    if (jj_scan_token(COMMA)) return true;
+    if (jj_3R_73()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_215() {
+    if (jj_3R_86()) return true;
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_203() {
+    if (jj_scan_token(LBRACKET)) return true;
+    if (jj_scan_token(RBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_202() {
+    if (jj_3R_66()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_7()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_214() {
+    if (jj_3R_80()) return true;
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_340() {
+    if (jj_3R_89()) return true;
+    if (jj_3R_63()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_346()) jj_scanpos = xsp;
+    if (jj_3R_175()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_187() {
+    if (jj_scan_token(NEW)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_214()) {
+    jj_scanpos = xsp;
+    if (jj_3R_215()) {
+    jj_scanpos = xsp;
+    if (jj_3R_216()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_329() {
+    if (jj_3R_340()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_341()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_316() {
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_329()) jj_scanpos = xsp;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_206() {
+    if (jj_3R_73()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_237()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_322() {
+    if (jj_3R_100()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_321() {
+    if (jj_scan_token(THROWS)) return true;
+    if (jj_3R_330()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_183() {
+    if (jj_3R_206()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_261() {
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_250() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_261()) jj_scanpos = xsp;
+    if (jj_3R_83()) return true;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_3R_316()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_320()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_3R_321()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_322()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(86)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_154() {
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_183()) jj_scanpos = xsp;
+    if (jj_scan_token(RPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_239() {
+    if (jj_scan_token(NULL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_254() {
+    if (jj_scan_token(FALSE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_253() {
+    if (jj_scan_token(TRUE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_152() {
+    if (jj_scan_token(LBRACE)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_202()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(87)) jj_scanpos = xsp;
+    if (jj_scan_token(RBRACE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_238() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_253()) {
+    jj_scanpos = xsp;
+    if (jj_3R_254()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_102() {
+    if (jj_3R_73()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_213() {
+    if (jj_3R_239()) return true;
+    return false;
+  }
+
+  /** Generated Token Manager. */
+  public ASTParserTokenManager token_source;
+  JavaCharStream jj_input_stream;
+  /** Current token. */
+  public Token token;
+  /** Next token. */
+  public Token jj_nt;
+  private int jj_ntk;
+  private Token jj_scanpos, jj_lastpos;
+  private int jj_la;
+  /** Whether we are looking ahead. */
+  private boolean jj_lookingAhead = false;
+  private boolean jj_semLA;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[134];
+  static private int[] jj_la1_0;
+  static private int[] jj_la1_1;
+  static private int[] jj_la1_2;
+  static private int[] jj_la1_3;
+  static private int[] jj_la1_4;
+  static {
+      jj_la1_init_0();
+      jj_la1_init_1();
+      jj_la1_init_2();
+      jj_la1_init_3();
+      jj_la1_init_4();
+   }
+   private static void jj_la1_init_0() {
+      jj_la1_0 = new int[] {0x0,0x48101000,0x1,0x0,0x0,0x0,0x40001000,0x8100000,0x48101000,0x100000,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x4a195000,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x4a195000,0x8100000,0x2094000,0x4a195000,0x0,0x0,0x0,0x22094000,0x22094000,0x0,0x0,0x0,0x0,0x0,0x0,0x42095000,0x0,0x0,0x0,0x0,0x0,0x22094000,0x6359f000,0x0,0x2094000,0x2094000,0x0,0x2094000,0x10000000,0x10000000,0x2094000,0x2094000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x22094000,0x0,0x0,0x22094000,0x0,0x2094000,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x20000000,0x22094000,0x0,0x0,0x2094000,0x0,0x0,0x0,0x2349e000,0x0,0x2349e000,0x0,0x0,0x0,0x22094000,0x820000,0x820000,0x4000000,0x62095000,0x22094000,0x22094000,0x62095000,0x22094000,0x0,0x0,0x0,0x22094000,0x40000,0x80000000,0x80040000,0x0,0x0,0x0,0x22094000,0x22094000,0x0,0x4a195000,0xa194000,0x4a195000,0x800000,};
+   }
+   private static void jj_la1_init_1() {
+      jj_la1_1 = new int[] {0x20,0x8899c500,0x0,0x0,0x80000,0x0,0x8899c400,0x100,0x8899c500,0x100,0x0,0x0,0x10,0x0,0x0,0x10,0x0,0x0,0xc89dc781,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc89dc781,0x100,0x40040281,0xc89dc781,0x0,0x0,0x0,0x51241a81,0x51241a81,0x0,0x0,0x0,0x4000000,0x0,0x0,0x889dc681,0x0,0x0,0x4000000,0x0,0x0,0x51241a81,0xfbffdf8b,0x80000,0x40281,0x40281,0x0,0x40281,0x200000,0x200000,0x40281,0x40040281,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x51241a81,0x0,0x0,0x51241a81,0x0,0x40281,0x0,0x0,0x0,0x11201800,0x0,0x0,0x0,0x0,0x1000800,0x0,0x10001000,0x10000000,0x51241a81,0x0,0x0,0x40281,0x0,0x0,0x0,0x73e61a8b,0x0,0x73e61a8b,0x0,0x0,0x0,0x51241a81,0x0,0x0,0x0,0xd9bdde81,0x51241a81,0x51241a81,0xd9bdde81,0x51241a81,0x0,0x0,0x0,0x51241a81,0x0,0x0,0x0,0x0,0x0,0x0,0x51241a81,0x51241a81,0x0,0x889dc781,0x40381,0x889dc781,0x0,};
+   }
+   private static void jj_la1_init_2() {
+      jj_la1_2 = new int[] {0x0,0x2400000,0x0,0x2000000,0x0,0x1000000,0x2000000,0x2000000,0x2400000,0x0,0x8000000,0x0,0x0,0x800000,0x800000,0x0,0x2002000,0x800000,0xa442000,0x400000,0x2000000,0x10000,0x40000,0x800000,0x0,0x0,0xa442000,0x2000000,0x8002000,0xa402000,0x800000,0x4000000,0x100000,0x30053846,0x30053846,0x800000,0x8000000,0x100000,0x0,0x440000,0x800000,0x2002000,0x0,0x8000000,0x0,0x8000000,0x8000000,0x8013846,0x2453847,0x0,0x0,0x2000,0x800000,0x40002000,0x0,0x0,0x0,0x2000,0x800000,0x4000000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x30013846,0x30000000,0x30000000,0x13846,0x0,0x2000,0x8000000,0x10000,0x10000,0x11846,0x2000,0x1000000,0x8000000,0x10000,0x0,0x1100000,0x1846,0x0,0x30013846,0x800000,0x8000000,0x0,0x8002000,0x100000,0x100000,0x453847,0x80000000,0x453847,0x800000,0x4000000,0x4000000,0x13846,0x0,0x0,0x0,0x32013846,0x30013846,0x30013846,0x32413846,0x30013846,0x800000,0x2000,0x2000,0x30013846,0x0,0x0,0x0,0x2000000,0x2000,0x800000,0x32053846,0x32053846,0x800000,0x2402000,0x2002000,0x2402000,0x0,};
+   }
+   private static void jj_la1_init_3() {
+      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c0,0x3c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffe0000,0x0,0x10,0x20,0x2000,0x4000,0x1000,0x9,0x9,0x0,0x80000006,0x80000006,0x10000,0x300,0x300,0x8c00,0x8c00,0x300,0x3c0,0x0,0x0,0x0,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0,0x0,0xc0,0x0,0xffe00c0,0xffe00c0,0xc0,0x0,0x0,0x0,0x3c0,0x3c0,0x3c0,0x3c0,0x3c0,0x0,0x0,0x0,0x3c0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c0,0x3c0,0x0,0x0,0x0,0x0,0x0,};
+   }
+   private static void jj_la1_init_4() {
+      jj_la1_4 = new int[] {0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
+   }
+  final private JJCalls[] jj_2_rtns = new JJCalls[43];
+  private boolean jj_rescan = false;
+  private int jj_gc = 0;
+
+  /** Constructor with InputStream. */
+  public ASTParser(java.io.InputStream stream) {
+     this(stream, null);
+  }
+  /** Constructor with InputStream and supplied encoding */
+  public ASTParser(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source = new ASTParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 134; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream) {
+     ReInit(stream, null);
+  }
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 134; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor. */
+  public ASTParser(java.io.Reader stream) {
+    jj_input_stream = new JavaCharStream(stream, 1, 1);
+    token_source = new ASTParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 134; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader stream) {
+    jj_input_stream.ReInit(stream, 1, 1);
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 134; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor with generated Token Manager. */
+  public ASTParser(ASTParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 134; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(ASTParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 134; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  private Token jj_consume_token(int kind) throws ParseException {
+    Token oldToken;
+    if ((oldToken = token).next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    if (token.kind == kind) {
+      jj_gen++;
+      if (++jj_gc > 100) {
+        jj_gc = 0;
+        for (int i = 0; i < jj_2_rtns.length; i++) {
+          JJCalls c = jj_2_rtns[i];
+          while (c != null) {
+            if (c.gen < jj_gen) c.first = null;
+            c = c.next;
+          }
+        }
+      }
+      return token;
+    }
+    token = oldToken;
+    jj_kind = kind;
+    throw generateParseException();
+  }
+
+  static private final class LookaheadSuccess extends java.lang.Error { }
+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
+  private boolean jj_scan_token(int kind) {
+    if (jj_scanpos == jj_lastpos) {
+      jj_la--;
+      if (jj_scanpos.next == null) {
+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
+      } else {
+        jj_lastpos = jj_scanpos = jj_scanpos.next;
+      }
+    } else {
+      jj_scanpos = jj_scanpos.next;
+    }
+    if (jj_rescan) {
+      int i = 0; Token tok = token;
+      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
+      if (tok != null) jj_add_error_token(kind, i);
+    }
+    if (jj_scanpos.kind != kind) return true;
+    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
+    return false;
+  }
+
+
+/** Get the next Token. */
+  final public Token getNextToken() {
+    if (token.next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    jj_gen++;
+    return token;
+  }
+
+/** Get the specific Token. */
+  final public Token getToken(int index) {
+    Token t = jj_lookingAhead ? jj_scanpos : token;
+    for (int i = 0; i < index; i++) {
+      if (t.next != null) t = t.next;
+      else t = t.next = token_source.getNextToken();
+    }
+    return t;
+  }
+
+  private int jj_ntk() {
+    if ((jj_nt=token.next) == null)
+      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
+    else
+      return (jj_ntk = jj_nt.kind);
+  }
+
+  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
+  private int[] jj_expentry;
+  private int jj_kind = -1;
+  private int[] jj_lasttokens = new int[100];
+  private int jj_endpos;
+
+  private void jj_add_error_token(int kind, int pos) {
+    if (pos >= 100) return;
+    if (pos == jj_endpos + 1) {
+      jj_lasttokens[jj_endpos++] = kind;
+    } else if (jj_endpos != 0) {
+      jj_expentry = new int[jj_endpos];
+      for (int i = 0; i < jj_endpos; i++) {
+        jj_expentry[i] = jj_lasttokens[i];
+      }
+      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
+        int[] oldentry = (int[])(it.next());
+        if (oldentry.length == jj_expentry.length) {
+          for (int i = 0; i < jj_expentry.length; i++) {
+            if (oldentry[i] != jj_expentry[i]) {
+              continue jj_entries_loop;
+            }
+          }
+          jj_expentries.add(jj_expentry);
+          break jj_entries_loop;
+        }
+      }
+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
+    }
+  }
+
+  /** Generate ParseException. */
+  public ParseException generateParseException() {
+    jj_expentries.clear();
+    boolean[] la1tokens = new boolean[129];
+    if (jj_kind >= 0) {
+      la1tokens[jj_kind] = true;
+      jj_kind = -1;
+    }
+    for (int i = 0; i < 134; i++) {
+      if (jj_la1[i] == jj_gen) {
+        for (int j = 0; j < 32; j++) {
+          if ((jj_la1_0[i] & (1<<j)) != 0) {
+            la1tokens[j] = true;
+          }
+          if ((jj_la1_1[i] & (1<<j)) != 0) {
+            la1tokens[32+j] = true;
+          }
+          if ((jj_la1_2[i] & (1<<j)) != 0) {
+            la1tokens[64+j] = true;
+          }
+          if ((jj_la1_3[i] & (1<<j)) != 0) {
+            la1tokens[96+j] = true;
+          }
+          if ((jj_la1_4[i] & (1<<j)) != 0) {
+            la1tokens[128+j] = true;
+          }
+        }
+      }
+    }
+    for (int i = 0; i < 129; i++) {
+      if (la1tokens[i]) {
+        jj_expentry = new int[1];
+        jj_expentry[0] = i;
+        jj_expentries.add(jj_expentry);
+      }
+    }
+    jj_endpos = 0;
+    jj_rescan_token();
+    jj_add_error_token(0, 0);
+    int[][] exptokseq = new int[jj_expentries.size()][];
+    for (int i = 0; i < jj_expentries.size(); i++) {
+      exptokseq[i] = jj_expentries.get(i);
+    }
+    return new ParseException(token, exptokseq, tokenImage);
+  }
+
+  /** Enable tracing. */
+  final public void enable_tracing() {
+  }
+
+  /** Disable tracing. */
+  final public void disable_tracing() {
+  }
+
+  private void jj_rescan_token() {
+    jj_rescan = true;
+    for (int i = 0; i < 43; i++) {
+    try {
+      JJCalls p = jj_2_rtns[i];
+      do {
+        if (p.gen > jj_gen) {
+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
+          switch (i) {
+            case 0: jj_3_1(); break;
+            case 1: jj_3_2(); break;
+            case 2: jj_3_3(); break;
+            case 3: jj_3_4(); break;
+            case 4: jj_3_5(); break;
+            case 5: jj_3_6(); break;
+            case 6: jj_3_7(); break;
+            case 7: jj_3_8(); break;
+            case 8: jj_3_9(); break;
+            case 9: jj_3_10(); break;
+            case 10: jj_3_11(); break;
+            case 11: jj_3_12(); break;
+            case 12: jj_3_13(); break;
+            case 13: jj_3_14(); break;
+            case 14: jj_3_15(); break;
+            case 15: jj_3_16(); break;
+            case 16: jj_3_17(); break;
+            case 17: jj_3_18(); break;
+            case 18: jj_3_19(); break;
+            case 19: jj_3_20(); break;
+            case 20: jj_3_21(); break;
+            case 21: jj_3_22(); break;
+            case 22: jj_3_23(); break;
+            case 23: jj_3_24(); break;
+            case 24: jj_3_25(); break;
+            case 25: jj_3_26(); break;
+            case 26: jj_3_27(); break;
+            case 27: jj_3_28(); break;
+            case 28: jj_3_29(); break;
+            case 29: jj_3_30(); break;
+            case 30: jj_3_31(); break;
+            case 31: jj_3_32(); break;
+            case 32: jj_3_33(); break;
+            case 33: jj_3_34(); break;
+            case 34: jj_3_35(); break;
+            case 35: jj_3_36(); break;
+            case 36: jj_3_37(); break;
+            case 37: jj_3_38(); break;
+            case 38: jj_3_39(); break;
+            case 39: jj_3_40(); break;
+            case 40: jj_3_41(); break;
+            case 41: jj_3_42(); break;
+            case 42: jj_3_43(); break;
+          }
+        }
+        p = p.next;
+      } while (p != null);
+      } catch(LookaheadSuccess ls) { }
+    }
+    jj_rescan = false;
+  }
+
+  private void jj_save(int index, int xla) {
+    JJCalls p = jj_2_rtns[index];
+    while (p.gen > jj_gen) {
+      if (p.next == null) { p = p.next = new JJCalls(); break; }
+      p = p.next;
+    }
+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
+  }
+
+  static final class JJCalls {
+    int gen;
+    Token first;
+    int arg;
+    JJCalls next;
+  }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ASTParserConstants.java b/parser/html/java/javaparser/src/japa/parser/ASTParserConstants.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ASTParserConstants.java
@@ -0,0 +1,410 @@
+/* Generated By:JavaCC: Do not edit this line. ASTParserConstants.java */
+/*
+ * Copyright (C) 2008 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package japa.parser;
+
+
+/** 
+ * Token literal values and constants.
+ * Generated by org.javacc.parser.OtherFilesGen#start()
+ */
+public interface ASTParserConstants {
+
+  /** End of File. */
+  int EOF = 0;
+  /** RegularExpression Id. */
+  int SINGLE_LINE_COMMENT = 6;
+  /** RegularExpression Id. */
+  int JAVA_DOC_COMMENT = 9;
+  /** RegularExpression Id. */
+  int MULTI_LINE_COMMENT = 10;
+  /** RegularExpression Id. */
+  int ABSTRACT = 12;
+  /** RegularExpression Id. */
+  int ASSERT = 13;
+  /** RegularExpression Id. */
+  int BOOLEAN = 14;
+  /** RegularExpression Id. */
+  int BREAK = 15;
+  /** RegularExpression Id. */
+  int BYTE = 16;
+  /** RegularExpression Id. */
+  int CASE = 17;
+  /** RegularExpression Id. */
+  int CATCH = 18;
+  /** RegularExpression Id. */
+  int CHAR = 19;
+  /** RegularExpression Id. */
+  int CLASS = 20;
+  /** RegularExpression Id. */
+  int CONST = 21;
+  /** RegularExpression Id. */
+  int CONTINUE = 22;
+  /** RegularExpression Id. */
+  int _DEFAULT = 23;
+  /** RegularExpression Id. */
+  int DO = 24;
+  /** RegularExpression Id. */
+  int DOUBLE = 25;
+  /** RegularExpression Id. */
+  int ELSE = 26;
+  /** RegularExpression Id. */
+  int ENUM = 27;
+  /** RegularExpression Id. */
+  int EXTENDS = 28;
+  /** RegularExpression Id. */
+  int FALSE = 29;
+  /** RegularExpression Id. */
+  int FINAL = 30;
+  /** RegularExpression Id. */
+  int FINALLY = 31;
+  /** RegularExpression Id. */
+  int FLOAT = 32;
+  /** RegularExpression Id. */
+  int FOR = 33;
+  /** RegularExpression Id. */
+  int GOTO = 34;
+  /** RegularExpression Id. */
+  int IF = 35;
+  /** RegularExpression Id. */
+  int IMPLEMENTS = 36;
+  /** RegularExpression Id. */
+  int IMPORT = 37;
+  /** RegularExpression Id. */
+  int INSTANCEOF = 38;
+  /** RegularExpression Id. */
+  int INT = 39;
+  /** RegularExpression Id. */
+  int INTERFACE = 40;
+  /** RegularExpression Id. */
+  int LONG = 41;
+  /** RegularExpression Id. */
+  int NATIVE = 42;
+  /** RegularExpression Id. */
+  int NEW = 43;
+  /** RegularExpression Id. */
+  int NULL = 44;
+  /** RegularExpression Id. */
+  int PACKAGE = 45;
+  /** RegularExpression Id. */
+  int PRIVATE = 46;
+  /** RegularExpression Id. */
+  int PROTECTED = 47;
+  /** RegularExpression Id. */
+  int PUBLIC = 48;
+  /** RegularExpression Id. */
+  int RETURN = 49;
+  /** RegularExpression Id. */
+  int SHORT = 50;
+  /** RegularExpression Id. */
+  int STATIC = 51;
+  /** RegularExpression Id. */
+  int STRICTFP = 52;
+  /** RegularExpression Id. */
+  int SUPER = 53;
+  /** RegularExpression Id. */
+  int SWITCH = 54;
+  /** RegularExpression Id. */
+  int SYNCHRONIZED = 55;
+  /** RegularExpression Id. */
+  int THIS = 56;
+  /** RegularExpression Id. */
+  int THROW = 57;
+  /** RegularExpression Id. */
+  int THROWS = 58;
+  /** RegularExpression Id. */
+  int TRANSIENT = 59;
+  /** RegularExpression Id. */
+  int TRUE = 60;
+  /** RegularExpression Id. */
+  int TRY = 61;
+  /** RegularExpression Id. */
+  int VOID = 62;
+  /** RegularExpression Id. */
+  int VOLATILE = 63;
+  /** RegularExpression Id. */
+  int WHILE = 64;
+  /** RegularExpression Id. */
+  int LONG_LITERAL = 65;
+  /** RegularExpression Id. */
+  int INTEGER_LITERAL = 66;
+  /** RegularExpression Id. */
+  int DECIMAL_LITERAL = 67;
+  /** RegularExpression Id. */
+  int HEX_LITERAL = 68;
+  /** RegularExpression Id. */
+  int OCTAL_LITERAL = 69;
+  /** RegularExpression Id. */
+  int FLOATING_POINT_LITERAL = 70;
+  /** RegularExpression Id. */
+  int DECIMAL_FLOATING_POINT_LITERAL = 71;
+  /** RegularExpression Id. */
+  int DECIMAL_EXPONENT = 72;
+  /** RegularExpression Id. */
+  int HEXADECIMAL_FLOATING_POINT_LITERAL = 73;
+  /** RegularExpression Id. */
+  int HEXADECIMAL_EXPONENT = 74;
+  /** RegularExpression Id. */
+  int CHARACTER_LITERAL = 75;
+  /** RegularExpression Id. */
+  int STRING_LITERAL = 76;
+  /** RegularExpression Id. */
+  int IDENTIFIER = 77;
+  /** RegularExpression Id. */
+  int LETTER = 78;
+  /** RegularExpression Id. */
+  int PART_LETTER = 79;
+  /** RegularExpression Id. */
+  int LPAREN = 80;
+  /** RegularExpression Id. */
+  int RPAREN = 81;
+  /** RegularExpression Id. */
+  int LBRACE = 82;
+  /** RegularExpression Id. */
+  int RBRACE = 83;
+  /** RegularExpression Id. */
+  int LBRACKET = 84;
+  /** RegularExpression Id. */
+  int RBRACKET = 85;
+  /** RegularExpression Id. */
+  int SEMICOLON = 86;
+  /** RegularExpression Id. */
+  int COMMA = 87;
+  /** RegularExpression Id. */
+  int DOT = 88;
+  /** RegularExpression Id. */
+  int AT = 89;
+  /** RegularExpression Id. */
+  int ASSIGN = 90;
+  /** RegularExpression Id. */
+  int LT = 91;
+  /** RegularExpression Id. */
+  int BANG = 92;
+  /** RegularExpression Id. */
+  int TILDE = 93;
+  /** RegularExpression Id. */
+  int HOOK = 94;
+  /** RegularExpression Id. */
+  int COLON = 95;
+  /** RegularExpression Id. */
+  int EQ = 96;
+  /** RegularExpression Id. */
+  int LE = 97;
+  /** RegularExpression Id. */
+  int GE = 98;
+  /** RegularExpression Id. */
+  int NE = 99;
+  /** RegularExpression Id. */
+  int SC_OR = 100;
+  /** RegularExpression Id. */
+  int SC_AND = 101;
+  /** RegularExpression Id. */
+  int INCR = 102;
+  /** RegularExpression Id. */
+  int DECR = 103;
+  /** RegularExpression Id. */
+  int PLUS = 104;
+  /** RegularExpression Id. */
+  int MINUS = 105;
+  /** RegularExpression Id. */
+  int STAR = 106;
+  /** RegularExpression Id. */
+  int SLASH = 107;
+  /** RegularExpression Id. */
+  int BIT_AND = 108;
+  /** RegularExpression Id. */
+  int BIT_OR = 109;
+  /** RegularExpression Id. */
+  int XOR = 110;
+  /** RegularExpression Id. */
+  int REM = 111;
+  /** RegularExpression Id. */
+  int LSHIFT = 112;
+  /** RegularExpression Id. */
+  int PLUSASSIGN = 113;
+  /** RegularExpression Id. */
+  int MINUSASSIGN = 114;
+  /** RegularExpression Id. */
+  int STARASSIGN = 115;
+  /** RegularExpression Id. */
+  int SLASHASSIGN = 116;
+  /** RegularExpression Id. */
+  int ANDASSIGN = 117;
+  /** RegularExpression Id. */
+  int ORASSIGN = 118;
+  /** RegularExpression Id. */
+  int XORASSIGN = 119;
+  /** RegularExpression Id. */
+  int REMASSIGN = 120;
+  /** RegularExpression Id. */
+  int LSHIFTASSIGN = 121;
+  /** RegularExpression Id. */
+  int RSIGNEDSHIFTASSIGN = 122;
+  /** RegularExpression Id. */
+  int RUNSIGNEDSHIFTASSIGN = 123;
+  /** RegularExpression Id. */
+  int ELLIPSIS = 124;
+  /** RegularExpression Id. */
+  int RUNSIGNEDSHIFT = 125;
+  /** RegularExpression Id. */
+  int RSIGNEDSHIFT = 126;
+  /** RegularExpression Id. */
+  int GT = 127;
+
+  /** Lexical state. */
+  int DEFAULT = 0;
+  /** Lexical state. */
+  int IN_JAVA_DOC_COMMENT = 1;
+  /** Lexical state. */
+  int IN_MULTI_LINE_COMMENT = 2;
+
+  /** Literal token values. */
+  String[] tokenImage = {
+    "<EOF>",
+    "\" \"",
+    "\"\\t\"",
+    "\"\\n\"",
+    "\"\\r\"",
+    "\"\\f\"",
+    "<SINGLE_LINE_COMMENT>",
+    "<token of kind 7>",
+    "\"/*\"",
+    "\"*/\"",
+    "\"*/\"",
+    "<token of kind 11>",
+    "\"abstract\"",
+    "\"assert\"",
+    "\"boolean\"",
+    "\"break\"",
+    "\"byte\"",
+    "\"case\"",
+    "\"catch\"",
+    "\"char\"",
+    "\"class\"",
+    "\"const\"",
+    "\"continue\"",
+    "\"default\"",
+    "\"do\"",
+    "\"double\"",
+    "\"else\"",
+    "\"enum\"",
+    "\"extends\"",
+    "\"false\"",
+    "\"final\"",
+    "\"finally\"",
+    "\"float\"",
+    "\"for\"",
+    "\"goto\"",
+    "\"if\"",
+    "\"implements\"",
+    "\"import\"",
+    "\"instanceof\"",
+    "\"int\"",
+    "\"interface\"",
+    "\"long\"",
+    "\"native\"",
+    "\"new\"",
+    "\"null\"",
+    "\"package\"",
+    "\"private\"",
+    "\"protected\"",
+    "\"public\"",
+    "\"return\"",
+    "\"short\"",
+    "\"static\"",
+    "\"strictfp\"",
+    "\"super\"",
+    "\"switch\"",
+    "\"synchronized\"",
+    "\"this\"",
+    "\"throw\"",
+    "\"throws\"",
+    "\"transient\"",
+    "\"true\"",
+    "\"try\"",
+    "\"void\"",
+    "\"volatile\"",
+    "\"while\"",
+    "<LONG_LITERAL>",
+    "<INTEGER_LITERAL>",
+    "<DECIMAL_LITERAL>",
+    "<HEX_LITERAL>",
+    "<OCTAL_LITERAL>",
+    "<FLOATING_POINT_LITERAL>",
+    "<DECIMAL_FLOATING_POINT_LITERAL>",
+    "<DECIMAL_EXPONENT>",
+    "<HEXADECIMAL_FLOATING_POINT_LITERAL>",
+    "<HEXADECIMAL_EXPONENT>",
+    "<CHARACTER_LITERAL>",
+    "<STRING_LITERAL>",
+    "<IDENTIFIER>",
+    "<LETTER>",
+    "<PART_LETTER>",
+    "\"(\"",
+    "\")\"",
+    "\"{\"",
+    "\"}\"",
+    "\"[\"",
+    "\"]\"",
+    "\";\"",
+    "\",\"",
+    "\".\"",
+    "\"@\"",
+    "\"=\"",
+    "\"<\"",
+    "\"!\"",
+    "\"~\"",
+    "\"?\"",
+    "\":\"",
+    "\"==\"",
+    "\"<=\"",
+    "\">=\"",
+    "\"!=\"",
+    "\"||\"",
+    "\"&&\"",
+    "\"++\"",
+    "\"--\"",
+    "\"+\"",
+    "\"-\"",
+    "\"*\"",
+    "\"/\"",
+    "\"&\"",
+    "\"|\"",
+    "\"^\"",
+    "\"%\"",
+    "\"<<\"",
+    "\"+=\"",
+    "\"-=\"",
+    "\"*=\"",
+    "\"/=\"",
+    "\"&=\"",
+    "\"|=\"",
+    "\"^=\"",
+    "\"%=\"",
+    "\"<<=\"",
+    "\">>=\"",
+    "\">>>=\"",
+    "\"...\"",
+    "\">>>\"",
+    "\">>\"",
+    "\">\"",
+    "\"\\u001a\"",
+  };
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ASTParserTokenManager.java b/parser/html/java/javaparser/src/japa/parser/ASTParserTokenManager.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ASTParserTokenManager.java
@@ -0,0 +1,2323 @@
+/* Generated By:JavaCC: Do not edit this line. ASTParserTokenManager.java */
+/*
+ * Copyright (C) 2008 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package japa.parser;
+import java.io.*;
+import java.util.*;
+import japa.parser.ast.*;
+import japa.parser.ast.body.*;
+import japa.parser.ast.expr.*;
+import japa.parser.ast.stmt.*;
+import japa.parser.ast.type.*;
+
+/** Token Manager. */
+public class ASTParserTokenManager implements ASTParserConstants
+{
+    private List<Comment> comments;
+    private final Stack<JavadocComment> javadocStack = new Stack<JavadocComment>();
+    private JavadocComment lastJavadoc;
+
+    void pushJavadoc() {
+        javadocStack.push(lastJavadoc);
+    }
+
+    JavadocComment popJavadoc() {
+        return javadocStack.pop();
+    }
+
+    List<Comment> getComments() {
+        return comments;
+    }
+
+    void clearComments() {
+        comments = null;
+        javadocStack.clear();
+        lastJavadoc = null;
+    }
+
+    private void CommonTokenAction(Token token) {
+        lastJavadoc = null;
+        if (token.specialToken != null) {
+                if(comments == null) {
+                    comments = new LinkedList<Comment>();
+                }
+            Token special = token.specialToken;
+            if(special.kind == JAVA_DOC_COMMENT) {
+                lastJavadoc = new JavadocComment(special.beginLine, special.beginColumn, special.endLine, special.endColumn, special.image.substring(3, special.image.length()-2));
+                comments.add(lastJavadoc);
+            } else if(special.kind == SINGLE_LINE_COMMENT) {
+                LineComment comment = new LineComment(special.beginLine, special.beginColumn, special.endLine, special.endColumn, special.image.substring(2));
+                comments.add(comment);
+            } else if(special.kind == MULTI_LINE_COMMENT) {
+                BlockComment comment = new BlockComment(special.beginLine, special.beginColumn, special.endLine, special.endColumn, special.image.substring(2, special.image.length()-2));
+                comments.add(comment);
+            }
+        }
+    }
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1, long active2)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0xfffffffffffff000L) != 0L || (active1 & 0x1L) != 0L)
+         {
+            jjmatchedKind = 77;
+            return 37;
+         }
+         if ((active1 & 0x1000000001000000L) != 0L)
+            return 1;
+         if ((active0 & 0x100L) != 0L || (active1 & 0x10080000000000L) != 0L)
+            return 54;
+         return -1;
+      case 1:
+         if ((active0 & 0x100L) != 0L)
+            return 59;
+         if ((active0 & 0x803000000L) != 0L)
+            return 37;
+         if ((active0 & 0xfffffff7fcfff000L) != 0L || (active1 & 0x1L) != 0L)
+         {
+            if (jjmatchedPos != 1)
+            {
+               jjmatchedKind = 77;
+               jjmatchedPos = 1;
+            }
+            return 37;
+         }
+         return -1;
+      case 2:
+         if ((active0 & 0xdffff675fefff000L) != 0L || (active1 & 0x1L) != 0L)
+         {
+            if (jjmatchedPos != 2)
+            {
+               jjmatchedKind = 77;
+               jjmatchedPos = 2;
+            }
+            return 37;
+         }
+         if ((active0 & 0x2000098200000000L) != 0L)
+            return 37;
+         return -1;
+      case 3:
+         if ((active0 & 0x8effe571f2f4f000L) != 0L || (active1 & 0x1L) != 0L)
+         {
+            jjmatchedKind = 77;
+            jjmatchedPos = 3;
+            return 37;
+         }
+         if ((active0 & 0x510012040c0b0000L) != 0L)
+            return 37;
+         return -1;
+      case 4:
+         if ((active0 & 0x88dbe57012c07000L) != 0L)
+         {
+            if (jjmatchedPos != 4)
+            {
+               jjmatchedKind = 77;
+               jjmatchedPos = 4;
+            }
+            return 37;
+         }
+         if ((active0 & 0x6240001e0348000L) != 0L || (active1 & 0x1L) != 0L)
+            return 37;
+         return -1;
+      case 5:
+         if ((active0 & 0x8890e15090c05000L) != 0L)
+         {
+            jjmatchedKind = 77;
+            jjmatchedPos = 5;
+            return 37;
+         }
+         if ((active0 & 0x44b042002002000L) != 0L)
+            return 37;
+         return -1;
+      case 6:
+         if ((active0 & 0x8890815000401000L) != 0L)
+         {
+            jjmatchedKind = 77;
+            jjmatchedPos = 6;
+            return 37;
+         }
+         if ((active0 & 0x600090804000L) != 0L)
+            return 37;
+         return -1;
+      case 7:
+         if ((active0 & 0x880815000000000L) != 0L)
+         {
+            jjmatchedKind = 77;
+            jjmatchedPos = 7;
+            return 37;
+         }
+         if ((active0 & 0x8010000000401000L) != 0L)
+            return 37;
+         return -1;
+      case 8:
+         if ((active0 & 0x800810000000000L) != 0L)
+            return 37;
+         if ((active0 & 0x80005000000000L) != 0L)
+         {
+            jjmatchedKind = 77;
+            jjmatchedPos = 8;
+            return 37;
+         }
+         return -1;
+      case 9:
+         if ((active0 & 0x80000000000000L) != 0L)
+         {
+            jjmatchedKind = 77;
+            jjmatchedPos = 9;
+            return 37;
+         }
+         if ((active0 & 0x5000000000L) != 0L)
+            return 37;
+         return -1;
+      case 10:
+         if ((active0 & 0x80000000000000L) != 0L)
+         {
+            jjmatchedKind = 77;
+            jjmatchedPos = 10;
+            return 37;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_0(int pos, long active0, long active1, long active2)
+{
+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1, active2), pos + 1);
+}
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private int jjMoveStringLiteralDfa0_0()
+{
+   switch(curChar)
+   {
+      case 26:
+         return jjStopAtPos(0, 128);
+      case 33:
+         jjmatchedKind = 92;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x800000000L);
+      case 37:
+         jjmatchedKind = 111;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x100000000000000L);
+      case 38:
+         jjmatchedKind = 108;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x20002000000000L);
+      case 40:
+         return jjStopAtPos(0, 80);
+      case 41:
+         return jjStopAtPos(0, 81);
+      case 42:
+         jjmatchedKind = 106;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x8000000000000L);
+      case 43:
+         jjmatchedKind = 104;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x2004000000000L);
+      case 44:
+         return jjStopAtPos(0, 87);
+      case 45:
+         jjmatchedKind = 105;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x4008000000000L);
+      case 46:
+         jjmatchedKind = 88;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x1000000000000000L);
+      case 47:
+         jjmatchedKind = 107;
+         return jjMoveStringLiteralDfa1_0(0x100L, 0x10000000000000L);
+      case 58:
+         return jjStopAtPos(0, 95);
+      case 59:
+         return jjStopAtPos(0, 86);
+      case 60:
+         jjmatchedKind = 91;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x201000200000000L);
+      case 61:
+         jjmatchedKind = 90;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x100000000L);
+      case 62:
+         jjmatchedKind = 127;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x6c00000400000000L);
+      case 63:
+         return jjStopAtPos(0, 94);
+      case 64:
+         return jjStopAtPos(0, 89);
+      case 91:
+         return jjStopAtPos(0, 84);
+      case 93:
+         return jjStopAtPos(0, 85);
+      case 94:
+         jjmatchedKind = 110;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x80000000000000L);
+      case 97:
+         return jjMoveStringLiteralDfa1_0(0x3000L, 0x0L);
+      case 98:
+         return jjMoveStringLiteralDfa1_0(0x1c000L, 0x0L);
+      case 99:
+         return jjMoveStringLiteralDfa1_0(0x7e0000L, 0x0L);
+      case 100:
+         return jjMoveStringLiteralDfa1_0(0x3800000L, 0x0L);
+      case 101:
+         return jjMoveStringLiteralDfa1_0(0x1c000000L, 0x0L);
+      case 102:
+         return jjMoveStringLiteralDfa1_0(0x3e0000000L, 0x0L);
+      case 103:
+         return jjMoveStringLiteralDfa1_0(0x400000000L, 0x0L);
+      case 105:
+         return jjMoveStringLiteralDfa1_0(0x1f800000000L, 0x0L);
+      case 108:
+         return jjMoveStringLiteralDfa1_0(0x20000000000L, 0x0L);
+      case 110:
+         return jjMoveStringLiteralDfa1_0(0x1c0000000000L, 0x0L);
+      case 112:
+         return jjMoveStringLiteralDfa1_0(0x1e00000000000L, 0x0L);
+      case 114:
+         return jjMoveStringLiteralDfa1_0(0x2000000000000L, 0x0L);
+      case 115:
+         return jjMoveStringLiteralDfa1_0(0xfc000000000000L, 0x0L);
+      case 116:
+         return jjMoveStringLiteralDfa1_0(0x3f00000000000000L, 0x0L);
+      case 118:
+         return jjMoveStringLiteralDfa1_0(0xc000000000000000L, 0x0L);
+      case 119:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x1L);
+      case 123:
+         return jjStopAtPos(0, 82);
+      case 124:
+         jjmatchedKind = 109;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x40001000000000L);
+      case 125:
+         return jjStopAtPos(0, 83);
+      case 126:
+         return jjStopAtPos(0, 93);
+      default :
+         return jjMoveNfa_0(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_0(long active0, long active1)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(0, active0, active1, 0L);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 38:
+         if ((active1 & 0x2000000000L) != 0L)
+            return jjStopAtPos(1, 101);
+         break;
+      case 42:
+         if ((active0 & 0x100L) != 0L)
+            return jjStartNfaWithStates_0(1, 8, 59);
+         break;
+      case 43:
+         if ((active1 & 0x4000000000L) != 0L)
+            return jjStopAtPos(1, 102);
+         break;
+      case 45:
+         if ((active1 & 0x8000000000L) != 0L)
+            return jjStopAtPos(1, 103);
+         break;
+      case 46:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x1000000000000000L);
+      case 60:
+         if ((active1 & 0x1000000000000L) != 0L)
+         {
+            jjmatchedKind = 112;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x200000000000000L);
+      case 61:
+         if ((active1 & 0x100000000L) != 0L)
+            return jjStopAtPos(1, 96);
+         else if ((active1 & 0x200000000L) != 0L)
+            return jjStopAtPos(1, 97);
+         else if ((active1 & 0x400000000L) != 0L)
+            return jjStopAtPos(1, 98);
+         else if ((active1 & 0x800000000L) != 0L)
+            return jjStopAtPos(1, 99);
+         else if ((active1 & 0x2000000000000L) != 0L)
+            return jjStopAtPos(1, 113);
+         else if ((active1 & 0x4000000000000L) != 0L)
+            return jjStopAtPos(1, 114);
+         else if ((active1 & 0x8000000000000L) != 0L)
+            return jjStopAtPos(1, 115);
+         else if ((active1 & 0x10000000000000L) != 0L)
+            return jjStopAtPos(1, 116);
+         else if ((active1 & 0x20000000000000L) != 0L)
+            return jjStopAtPos(1, 117);
+         else if ((active1 & 0x40000000000000L) != 0L)
+            return jjStopAtPos(1, 118);
+         else if ((active1 & 0x80000000000000L) != 0L)
+            return jjStopAtPos(1, 119);
+         else if ((active1 & 0x100000000000000L) != 0L)
+            return jjStopAtPos(1, 120);
+         break;
+      case 62:
+         if ((active1 & 0x4000000000000000L) != 0L)
+         {
+            jjmatchedKind = 126;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x2c00000000000000L);
+      case 97:
+         return jjMoveStringLiteralDfa2_0(active0, 0x240020060000L, active1, 0L);
+      case 98:
+         return jjMoveStringLiteralDfa2_0(active0, 0x1000L, active1, 0L);
+      case 101:
+         return jjMoveStringLiteralDfa2_0(active0, 0x2080000800000L, active1, 0L);
+      case 102:
+         if ((active0 & 0x800000000L) != 0L)
+            return jjStartNfaWithStates_0(1, 35, 37);
+         break;
+      case 104:
+         return jjMoveStringLiteralDfa2_0(active0, 0x704000000080000L, active1, 0x1L);
+      case 105:
+         return jjMoveStringLiteralDfa2_0(active0, 0xc0000000L, active1, 0L);
+      case 108:
+         return jjMoveStringLiteralDfa2_0(active0, 0x104100000L, active1, 0L);
+      case 109:
+         return jjMoveStringLiteralDfa2_0(active0, 0x3000000000L, active1, 0L);
+      case 110:
+         return jjMoveStringLiteralDfa2_0(active0, 0x1c008000000L, active1, 0L);
+      case 111:
+         if ((active0 & 0x1000000L) != 0L)
+         {
+            jjmatchedKind = 24;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0xc000020602604000L, active1, 0L);
+      case 114:
+         return jjMoveStringLiteralDfa2_0(active0, 0x3800c00000008000L, active1, 0L);
+      case 115:
+         return jjMoveStringLiteralDfa2_0(active0, 0x2000L, active1, 0L);
+      case 116:
+         return jjMoveStringLiteralDfa2_0(active0, 0x18000000000000L, active1, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa2_0(active0, 0x21100000000000L, active1, 0L);
+      case 119:
+         return jjMoveStringLiteralDfa2_0(active0, 0x40000000000000L, active1, 0L);
+      case 120:
+         return jjMoveStringLiteralDfa2_0(active0, 0x10000000L, active1, 0L);
+      case 121:
+         return jjMoveStringLiteralDfa2_0(active0, 0x80000000010000L, active1, 0L);
+      case 124:
+         if ((active1 & 0x1000000000L) != 0L)
+            return jjStopAtPos(1, 100);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(0, active0, active1, 0L);
+}
+private int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1)
+{
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjStartNfa_0(0, old0, old1, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(1, active0, active1, 0L);
+      return 2;
+   }
+   switch(curChar)
+   {
+      case 46:
+         if ((active1 & 0x1000000000000000L) != 0L)
+            return jjStopAtPos(2, 124);
+         break;
+      case 61:
+         if ((active1 & 0x200000000000000L) != 0L)
+            return jjStopAtPos(2, 121);
+         else if ((active1 & 0x400000000000000L) != 0L)
+            return jjStopAtPos(2, 122);
+         break;
+      case 62:
+         if ((active1 & 0x2000000000000000L) != 0L)
+         {
+            jjmatchedKind = 125;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x800000000000000L);
+      case 97:
+         return jjMoveStringLiteralDfa3_0(active0, 0x808000000180000L, active1, 0L);
+      case 98:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000000000000L, active1, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa3_0(active0, 0x200000000000L, active1, 0L);
+      case 101:
+         return jjMoveStringLiteralDfa3_0(active0, 0x8000L, active1, 0L);
+      case 102:
+         return jjMoveStringLiteralDfa3_0(active0, 0x800000L, active1, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4140400000000000L, active1, 0x1L);
+      case 108:
+         return jjMoveStringLiteralDfa3_0(active0, 0x8000100020000000L, active1, 0L);
+      case 110:
+         return jjMoveStringLiteralDfa3_0(active0, 0x800200c0600000L, active1, 0L);
+      case 111:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4800100004000L, active1, 0L);
+      case 112:
+         return jjMoveStringLiteralDfa3_0(active0, 0x20003000000000L, active1, 0L);
+      case 114:
+         if ((active0 & 0x200000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 33, 37);
+         return jjMoveStringLiteralDfa3_0(active0, 0x610000000000000L, active1, 0L);
+      case 115:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4004023000L, active1, 0L);
+      case 116:
+         if ((active0 & 0x8000000000L) != 0L)
+         {
+            jjmatchedKind = 39;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x2050410050000L, active1, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa3_0(active0, 0x100000000a000000L, active1, 0L);
+      case 119:
+         if ((active0 & 0x80000000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 43, 37);
+         break;
+      case 121:
+         if ((active0 & 0x2000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 61, 37);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(1, active0, active1, 0L);
+}
+private int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1)
+{
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjStartNfa_0(1, old0, old1, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(2, active0, active1, 0L);
+      return 3;
+   }
+   switch(curChar)
+   {
+      case 61:
+         if ((active1 & 0x800000000000000L) != 0L)
+            return jjStopAtPos(3, 123);
+         break;
+      case 97:
+         return jjMoveStringLiteralDfa4_0(active0, 0x80000001c0808000L, active1, 0L);
+      case 98:
+         return jjMoveStringLiteralDfa4_0(active0, 0x2000000L, active1, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa4_0(active0, 0x80000000040000L, active1, 0L);
+      case 100:
+         if ((active0 & 0x4000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 62, 37);
+         break;
+      case 101:
+         if ((active0 & 0x10000L) != 0L)
+            return jjStartNfaWithStates_0(3, 16, 37);
+         else if ((active0 & 0x20000L) != 0L)
+            return jjStartNfaWithStates_0(3, 17, 37);
+         else if ((active0 & 0x4000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 26, 37);
+         else if ((active0 & 0x1000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 60, 37);
+         return jjMoveStringLiteralDfa4_0(active0, 0x20010010002000L, active1, 0L);
+      case 103:
+         if ((active0 & 0x20000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 41, 37);
+         break;
+      case 105:
+         return jjMoveStringLiteralDfa4_0(active0, 0x10040000000000L, active1, 0L);
+      case 107:
+         return jjMoveStringLiteralDfa4_0(active0, 0x200000000000L, active1, 0L);
+      case 108:
+         if ((active0 & 0x100000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 44, 37);
+         return jjMoveStringLiteralDfa4_0(active0, 0x1001000004000L, active1, 0x1L);
+      case 109:
+         if ((active0 & 0x8000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 27, 37);
+         break;
+      case 110:
+         return jjMoveStringLiteralDfa4_0(active0, 0x800000000000000L, active1, 0L);
+      case 111:
+         if ((active0 & 0x400000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 34, 37);
+         return jjMoveStringLiteralDfa4_0(active0, 0x600002000000000L, active1, 0L);
+      case 114:
+         if ((active0 & 0x80000L) != 0L)
+            return jjStartNfaWithStates_0(3, 19, 37);
+         return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000L, active1, 0L);
+      case 115:
+         if ((active0 & 0x100000000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 56, 37);
+         return jjMoveStringLiteralDfa4_0(active0, 0x20300000L, active1, 0L);
+      case 116:
+         return jjMoveStringLiteralDfa4_0(active0, 0x48804000401000L, active1, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa4_0(active0, 0x2000000000000L, active1, 0L);
+      case 118:
+         return jjMoveStringLiteralDfa4_0(active0, 0x400000000000L, active1, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(2, active0, active1, 0L);
+}
+private int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1)
+{
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjStartNfa_0(2, old0, old1, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(3, active0, active1, 0L);
+      return 4;
+   }
+   switch(curChar)
+   {
+      case 97:
+         return jjMoveStringLiteralDfa5_0(active0, 0x604000000000L, active1, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa5_0(active0, 0x50000000000000L, active1, 0L);
+      case 101:
+         if ((active0 & 0x20000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 29, 37);
+         else if ((active1 & 0x1L) != 0L)
+            return jjStartNfaWithStates_0(4, 64, 37);
+         return jjMoveStringLiteralDfa5_0(active0, 0x801000004000L, active1, 0L);
+      case 104:
+         if ((active0 & 0x40000L) != 0L)
+            return jjStartNfaWithStates_0(4, 18, 37);
+         return jjMoveStringLiteralDfa5_0(active0, 0x80000000000000L, active1, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa5_0(active0, 0x9000000400000L, active1, 0L);
+      case 107:
+         if ((active0 & 0x8000L) != 0L)
+            return jjStartNfaWithStates_0(4, 15, 37);
+         break;
+      case 108:
+         if ((active0 & 0x40000000L) != 0L)
+         {
+            jjmatchedKind = 30;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0x82000000L, active1, 0L);
+      case 110:
+         return jjMoveStringLiteralDfa5_0(active0, 0x10000000L, active1, 0L);
+      case 114:
+         if ((active0 & 0x20000000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 53, 37);
+         return jjMoveStringLiteralDfa5_0(active0, 0x2012000003000L, active1, 0L);
+      case 115:
+         if ((active0 & 0x100000L) != 0L)
+            return jjStartNfaWithStates_0(4, 20, 37);
+         return jjMoveStringLiteralDfa5_0(active0, 0x800000000000000L, active1, 0L);
+      case 116:
+         if ((active0 & 0x200000L) != 0L)
+            return jjStartNfaWithStates_0(4, 21, 37);
+         else if ((active0 & 0x100000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 32, 37);
+         else if ((active0 & 0x4000000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 50, 37);
+         return jjMoveStringLiteralDfa5_0(active0, 0x8000000000000000L, active1, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa5_0(active0, 0x800000L, active1, 0L);
+      case 118:
+         return jjMoveStringLiteralDfa5_0(active0, 0x40000000000L, active1, 0L);
+      case 119:
+         if ((active0 & 0x200000000000000L) != 0L)
+         {
+            jjmatchedKind = 57;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0x400000000000000L, active1, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(3, active0, active1, 0L);
+}
+private int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1)
+{
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjStartNfa_0(3, old0, old1, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(4, active0, 0L, 0L);
+      return 5;
+   }
+   switch(curChar)
+   {
+      case 97:
+         return jjMoveStringLiteralDfa6_0(active0, 0x5000L);
+      case 99:
+         if ((active0 & 0x1000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 48, 37);
+         else if ((active0 & 0x8000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 51, 37);
+         return jjMoveStringLiteralDfa6_0(active0, 0x800000000000L);
+      case 100:
+         return jjMoveStringLiteralDfa6_0(active0, 0x10000000L);
+      case 101:
+         if ((active0 & 0x2000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 25, 37);
+         else if ((active0 & 0x40000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 42, 37);
+         break;
+      case 102:
+         return jjMoveStringLiteralDfa6_0(active0, 0x10000000000L);
+      case 103:
+         return jjMoveStringLiteralDfa6_0(active0, 0x200000000000L);
+      case 104:
+         if ((active0 & 0x40000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 54, 37);
+         break;
+      case 105:
+         return jjMoveStringLiteralDfa6_0(active0, 0x8800000000000000L);
+      case 108:
+         return jjMoveStringLiteralDfa6_0(active0, 0x80800000L);
+      case 109:
+         return jjMoveStringLiteralDfa6_0(active0, 0x1000000000L);
+      case 110:
+         if ((active0 & 0x2000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 49, 37);
+         return jjMoveStringLiteralDfa6_0(active0, 0x4000400000L);
+      case 114:
+         return jjMoveStringLiteralDfa6_0(active0, 0x80000000000000L);
+      case 115:
+         if ((active0 & 0x400000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 58, 37);
+         break;
+      case 116:
+         if ((active0 & 0x2000L) != 0L)
+            return jjStartNfaWithStates_0(5, 13, 37);
+         else if ((active0 & 0x2000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 37, 37);
+         return jjMoveStringLiteralDfa6_0(active0, 0x10400000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(4, active0, 0L, 0L);
+}
+private int jjMoveStringLiteralDfa6_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(4, old0, 0L, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(5, active0, 0L, 0L);
+      return 6;
+   }
+   switch(curChar)
+   {
+      case 97:
+         return jjMoveStringLiteralDfa7_0(active0, 0x10000000000L);
+      case 99:
+         return jjMoveStringLiteralDfa7_0(active0, 0x4000001000L);
+      case 101:
+         if ((active0 & 0x200000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 45, 37);
+         else if ((active0 & 0x400000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 46, 37);
+         return jjMoveStringLiteralDfa7_0(active0, 0x800001000000000L);
+      case 102:
+         return jjMoveStringLiteralDfa7_0(active0, 0x10000000000000L);
+      case 108:
+         return jjMoveStringLiteralDfa7_0(active0, 0x8000000000000000L);
+      case 110:
+         if ((active0 & 0x4000L) != 0L)
+            return jjStartNfaWithStates_0(6, 14, 37);
+         break;
+      case 111:
+         return jjMoveStringLiteralDfa7_0(active0, 0x80000000000000L);
+      case 115:
+         if ((active0 & 0x10000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 28, 37);
+         break;
+      case 116:
+         if ((active0 & 0x800000L) != 0L)
+            return jjStartNfaWithStates_0(6, 23, 37);
+         return jjMoveStringLiteralDfa7_0(active0, 0x800000000000L);
+      case 117:
+         return jjMoveStringLiteralDfa7_0(active0, 0x400000L);
+      case 121:
+         if ((active0 & 0x80000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 31, 37);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(5, active0, 0L, 0L);
+}
+private int jjMoveStringLiteralDfa7_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(5, old0, 0L, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(6, active0, 0L, 0L);
+      return 7;
+   }
+   switch(curChar)
+   {
+      case 99:
+         return jjMoveStringLiteralDfa8_0(active0, 0x10000000000L);
+      case 101:
+         if ((active0 & 0x400000L) != 0L)
+            return jjStartNfaWithStates_0(7, 22, 37);
+         else if ((active0 & 0x8000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 63, 37);
+         return jjMoveStringLiteralDfa8_0(active0, 0x804000000000L);
+      case 110:
+         return jjMoveStringLiteralDfa8_0(active0, 0x880001000000000L);
+      case 112:
+         if ((active0 & 0x10000000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 52, 37);
+         break;
+      case 116:
+         if ((active0 & 0x1000L) != 0L)
+            return jjStartNfaWithStates_0(7, 12, 37);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(6, active0, 0L, 0L);
+}
+private int jjMoveStringLiteralDfa8_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(6, old0, 0L, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(7, active0, 0L, 0L);
+      return 8;
+   }
+   switch(curChar)
+   {
+      case 100:
+         if ((active0 & 0x800000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 47, 37);
+         break;
+      case 101:
+         if ((active0 & 0x10000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 40, 37);
+         break;
+      case 105:
+         return jjMoveStringLiteralDfa9_0(active0, 0x80000000000000L);
+      case 111:
+         return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L);
+      case 116:
+         if ((active0 & 0x800000000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 59, 37);
+         return jjMoveStringLiteralDfa9_0(active0, 0x1000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(7, active0, 0L, 0L);
+}
+private int jjMoveStringLiteralDfa9_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(7, old0, 0L, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(8, active0, 0L, 0L);
+      return 9;
+   }
+   switch(curChar)
+   {
+      case 102:
+         if ((active0 & 0x4000000000L) != 0L)
+            return jjStartNfaWithStates_0(9, 38, 37);
+         break;
+      case 115:
+         if ((active0 & 0x1000000000L) != 0L)
+            return jjStartNfaWithStates_0(9, 36, 37);
+         break;
+      case 122:
+         return jjMoveStringLiteralDfa10_0(active0, 0x80000000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(8, active0, 0L, 0L);
+}
+private int jjMoveStringLiteralDfa10_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(8, old0, 0L, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(9, active0, 0L, 0L);
+      return 10;
+   }
+   switch(curChar)
+   {
+      case 101:
+         return jjMoveStringLiteralDfa11_0(active0, 0x80000000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(9, active0, 0L, 0L);
+}
+private int jjMoveStringLiteralDfa11_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(9, old0, 0L, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(10, active0, 0L, 0L);
+      return 11;
+   }
+   switch(curChar)
+   {
+      case 100:
+         if ((active0 & 0x80000000000000L) != 0L)
+            return jjStartNfaWithStates_0(11, 55, 37);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(10, active0, 0L, 0L);
+}
+private int jjStartNfaWithStates_0(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_0(state, pos + 1);
+}
+static final long[] jjbitVec0 = {
+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec2 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec3 = {
+   0xfff0000000200002L, 0xffffffffffffdfffL, 0xfffff00f7fffffffL, 0x12000000007fffffL
+};
+static final long[] jjbitVec4 = {
+   0x0L, 0x0L, 0x420043c00000000L, 0xff7fffffff7fffffL
+};
+static final long[] jjbitVec5 = {
+   0x7fffffffffffffL, 0xffffffffffff0000L, 0xffffffffffffffffL, 0x401f0003ffc3L
+};
+static final long[] jjbitVec6 = {
+   0x0L, 0x400000000000000L, 0xfffffffbffffd740L, 0xfbfffffffff7fffL
+};
+static final long[] jjbitVec7 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffffffc03L, 0x33fffffffff7fffL
+};
+static final long[] jjbitVec8 = {
+   0xfffe00000000ffffL, 0xfffffffe027fffffL, 0xffL, 0x707ffffff0000L
+};
+static final long[] jjbitVec9 = {
+   0x7fffffe00000000L, 0xfffec000000007ffL, 0xffffffffffffffffL, 0x9c00c060002fffffL
+};
+static final long[] jjbitVec10 = {
+   0xfffffffd0000L, 0xe000L, 0x2003fffffffffL, 0x0L
+};
+static final long[] jjbitVec11 = {
+   0x23fffffffffffff0L, 0x3ff010000L, 0x23c5fdfffff99fe0L, 0xf0003b0000000L
+};
+static final long[] jjbitVec12 = {
+   0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbbfe0L, 0x2000300010000L
+};
+static final long[] jjbitVec13 = {
+   0x23edfdfffff99fe0L, 0x20003b0000000L, 0x3bfc718d63dc7e8L, 0x200000000000000L
+};
+static final long[] jjbitVec14 = {
+   0x3effdfffffddfe0L, 0x300000000L, 0x23effdfffffddfe0L, 0x340000000L
+};
+static final long[] jjbitVec15 = {
+   0x3fffdfffffddfe0L, 0x300000000L, 0x2ffbfffffc7fffe0L, 0x7fL
+};
+static final long[] jjbitVec16 = {
+   0x800dfffffffffffeL, 0x7fL, 0x200decaefef02596L, 0x3000005fL
+};
+static final long[] jjbitVec17 = {
+   0x1L, 0x7fffffffeffL, 0xf00L, 0x0L
+};
+static final long[] jjbitVec18 = {
+   0x6fbffffffffL, 0x3f0000L, 0xffffffff00000000L, 0x1ffffffffff003fL
+};
+static final long[] jjbitVec19 = {
+   0xffffffffffffffffL, 0xffffffff83ffffffL, 0xffffff07ffffffffL, 0x3ffffffffffffffL
+};
+static final long[] jjbitVec20 = {
+   0xffffffffffffff7fL, 0xffffffff3d7f3d7fL, 0x7f3d7fffffff3d7fL, 0xffff7fffff7f7f3dL
+};
+static final long[] jjbitVec21 = {
+   0xffffffff7f3d7fffL, 0x7ffff7fL, 0xffffffff00000000L, 0x1fffffffffffffL
+};
+static final long[] jjbitVec22 = {
+   0xffffffffffffffffL, 0x7f9fffffffffffL, 0xffffffff07fffffeL, 0x1c7ffffffffffL
+};
+static final long[] jjbitVec23 = {
+   0x3ffff0003dfffL, 0x1dfff0003ffffL, 0xfffffffffffffL, 0x18800000L
+};
+static final long[] jjbitVec24 = {
+   0xffffffff00000000L, 0xffffffffffffffL, 0x1ffffffffffL, 0x0L
+};
+static final long[] jjbitVec25 = {
+   0x1fffffffL, 0x1f3fffffff0000L, 0x0L, 0x0L
+};
+static final long[] jjbitVec26 = {
+   0xffffffffffffffffL, 0xfffffffffffL, 0x0L, 0x0L
+};
+static final long[] jjbitVec27 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL
+};
+static final long[] jjbitVec28 = {
+   0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL
+};
+static final long[] jjbitVec29 = {
+   0x8000000000000000L, 0x8002000000100001L, 0x3ffff00000000L, 0x0L
+};
+static final long[] jjbitVec30 = {
+   0xe3fbbd503e2ffc84L, 0xffffffff000003e0L, 0xfL, 0x0L
+};
+static final long[] jjbitVec31 = {
+   0x1f3e03fe000000e0L, 0xfffffffffffffffeL, 0xfffffffee07fffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec32 = {
+   0xfffe1fffffffffe0L, 0xffffffffffffffffL, 0xffffff00007fffL, 0xffff000000000000L
+};
+static final long[] jjbitVec33 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffffffL, 0x0L
+};
+static final long[] jjbitVec34 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L
+};
+static final long[] jjbitVec35 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0x1fffL, 0x0L
+};
+static final long[] jjbitVec36 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L
+};
+static final long[] jjbitVec37 = {
+   0x6L, 0x0L, 0x0L, 0x0L
+};
+static final long[] jjbitVec38 = {
+   0xffff3fffffffffffL, 0x7ffffffffffL, 0x0L, 0x0L
+};
+static final long[] jjbitVec39 = {
+   0x5f7ffdffa0f8007fL, 0xffffffffffffffdbL, 0x3ffffffffffffL, 0xfffffffffff80000L
+};
+static final long[] jjbitVec40 = {
+   0x3fffffffffffffffL, 0xffffffffffff0000L, 0xfffffffffffcffffL, 0x1fff0000000000ffL
+};
+static final long[] jjbitVec41 = {
+   0x18000000000000L, 0xffdf02000000e000L, 0xffffffffffffffffL, 0x1fffffffffffffffL
+};
+static final long[] jjbitVec42 = {
+   0x87fffffe00000010L, 0xffffffe007fffffeL, 0x7fffffffffffffffL, 0x631cfcfcfcL
+};
+static final long[] jjbitVec43 = {
+   0x0L, 0x0L, 0x420243cffffffffL, 0xff7fffffff7fffffL
+};
+static final long[] jjbitVec44 = {
+   0xffffffffffffffffL, 0x400ffffe0ffffffL, 0xfffffffbffffd740L, 0xfbfffffffff7fffL
+};
+static final long[] jjbitVec45 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffffffc7bL, 0x33fffffffff7fffL
+};
+static final long[] jjbitVec46 = {
+   0xfffe00000000ffffL, 0xfffffffe027fffffL, 0xbbfffffbfffe00ffL, 0x707ffffff0016L
+};
+static final long[] jjbitVec47 = {
+   0x7fffffe003f000fL, 0xffffc3ff01ffffffL, 0xffffffffffffffffL, 0x9ffffdffbfefffffL
+};
+static final long[] jjbitVec48 = {
+   0xffffffffffff8000L, 0xe7ffL, 0x3ffffffffffffL, 0x0L
+};
+static final long[] jjbitVec49 = {
+   0xf3fffffffffffffeL, 0xffcfff1f3fffL, 0xf3c5fdfffff99feeL, 0xfffcfb080399fL
+};
+static final long[] jjbitVec50 = {
+   0xd36dfdfffff987eeL, 0x1fffc05e003987L, 0xf3edfdfffffbbfeeL, 0x2ffcf00013bbfL
+};
+static final long[] jjbitVec51 = {
+   0xf3edfdfffff99feeL, 0x2ffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0x200ff8000803dc7L
+};
+static final long[] jjbitVec52 = {
+   0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xf3effdfffffddfecL, 0xffc340603ddfL
+};
+static final long[] jjbitVec53 = {
+   0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x2ffbfffffc7fffecL, 0xc0000ff5f847fL
+};
+static final long[] jjbitVec54 = {
+   0x87fffffffffffffeL, 0x3ff7fffL, 0x3bffecaefef02596L, 0x33ff3f5fL
+};
+static final long[] jjbitVec55 = {
+   0xc2a003ff03000001L, 0xfffe07fffffffeffL, 0x1ffffffffeff0fdfL, 0x40L
+};
+static final long[] jjbitVec56 = {
+   0x3c7f6fbffffffffL, 0x3ff03ffL, 0xffffffff00000000L, 0x1ffffffffff003fL
+};
+static final long[] jjbitVec57 = {
+   0xffffffff7f3d7fffL, 0x3fe0007ffff7fL, 0xffffffff00000000L, 0x1fffffffffffffL
+};
+static final long[] jjbitVec58 = {
+   0x1fffff001fdfffL, 0xddfff000fffffL, 0xffffffffffffffffL, 0x3ff388fffffL
+};
+static final long[] jjbitVec59 = {
+   0xffffffff03ff3800L, 0xffffffffffffffL, 0x3ffffffffffL, 0x0L
+};
+static final long[] jjbitVec60 = {
+   0xfff0fff1fffffffL, 0x1f3fffffffffc0L, 0x0L, 0x0L
+};
+static final long[] jjbitVec61 = {
+   0x80007c000000f000L, 0x8002fc0f00100001L, 0x3ffff00000000L, 0x7e21fff0000L
+};
+static final long[] jjbitVec62 = {
+   0x1f3efffe000000e0L, 0xfffffffffffffffeL, 0xfffffffee67fffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec63 = {
+   0x10000000000006L, 0x0L, 0x0L, 0x0L
+};
+static final long[] jjbitVec64 = {
+   0x3L, 0x0L, 0x0L, 0x0L
+};
+static final long[] jjbitVec65 = {
+   0x0L, 0x800000000000000L, 0x0L, 0x0L
+};
+static final long[] jjbitVec66 = {
+   0x5f7ffdffe0f8007fL, 0xffffffffffffffdbL, 0x3ffffffffffffL, 0xfffffffffff80000L
+};
+static final long[] jjbitVec67 = {
+   0x18000f0000ffffL, 0xffdf02000000e000L, 0xffffffffffffffffL, 0x9fffffffffffffffL
+};
+static final long[] jjbitVec68 = {
+   0x87fffffe03ff0010L, 0xffffffe007fffffeL, 0x7fffffffffffffffL, 0xe0000631cfcfcfcL
+};
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 86;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 54:
+                  if (curChar == 42)
+                     jjstateSet[jjnewStateCnt++] = 59;
+                  else if (curChar == 47)
+                  {
+                     if (kind > 6)
+                        kind = 6;
+                     jjCheckNAddStates(0, 2);
+                  }
+                  break;
+               case 0:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(3, 9);
+                  else if (curChar == 47)
+                     jjAddStates(10, 11);
+                  else if (curChar == 36)
+                  {
+                     if (kind > 77)
+                        kind = 77;
+                     jjCheckNAdd(37);
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddStates(12, 15);
+                  else if (curChar == 39)
+                     jjAddStates(16, 18);
+                  else if (curChar == 46)
+                     jjCheckNAdd(1);
+                  if ((0x3fe000000000000L & l) != 0L)
+                  {
+                     if (kind > 66)
+                        kind = 66;
+                     jjCheckNAddStates(19, 21);
+                  }
+                  else if (curChar == 48)
+                  {
+                     if (kind > 66)
+                        kind = 66;
+                     jjCheckNAddStates(22, 28);
+                  }
+                  break;
+               case 1:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 70)
+                     kind = 70;
+                  jjCheckNAddStates(29, 31);
+                  break;
+               case 3:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(4);
+                  break;
+               case 4:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 70)
+                     kind = 70;
+                  jjCheckNAddTwoStates(4, 5);
+                  break;
+               case 6:
+                  if (curChar == 39)
+                     jjAddStates(16, 18);
+                  break;
+               case 7:
+                  if ((0xffffff7fffffdbffL & l) != 0L)
+                     jjCheckNAdd(8);
+                  break;
+               case 8:
+                  if (curChar == 39 && kind > 75)
+                     kind = 75;
+                  break;
+               case 10:
+                  if ((0x8400000000L & l) != 0L)
+                     jjCheckNAdd(8);
+                  break;
+               case 11:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(12, 8);
+                  break;
+               case 12:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAdd(8);
+                  break;
+               case 13:
+                  if ((0xf000000000000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 14;
+                  break;
+               case 14:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAdd(12);
+                  break;
+               case 16:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 17;
+                  break;
+               case 17:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 18;
+                  break;
+               case 18:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 19;
+                  break;
+               case 19:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAdd(8);
+                  break;
+               case 21:
+                  if (curChar == 34)
+                     jjCheckNAddStates(12, 15);
+                  break;
+               case 22:
+                  if ((0xfffffffbffffdbffL & l) != 0L)
+                     jjCheckNAddStates(12, 15);
+                  break;
+               case 24:
+                  if ((0x8400000000L & l) != 0L)
+                     jjCheckNAddStates(12, 15);
+                  break;
+               case 26:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 27;
+                  break;
+               case 27:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 28;
+                  break;
+               case 28:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 29;
+                  break;
+               case 29:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(12, 15);
+                  break;
+               case 31:
+                  if (curChar == 34 && kind > 76)
+                     kind = 76;
+                  break;
+               case 32:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAddStates(32, 36);
+                  break;
+               case 33:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAddStates(12, 15);
+                  break;
+               case 34:
+                  if ((0xf000000000000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 35;
+                  break;
+               case 35:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAdd(33);
+                  break;
+               case 36:
+                  if (curChar != 36)
+                     break;
+                  if (kind > 77)
+                     kind = 77;
+                  jjCheckNAdd(37);
+                  break;
+               case 37:
+                  if ((0x3ff00100fffc1ffL & l) == 0L)
+                     break;
+                  if (kind > 77)
+                     kind = 77;
+                  jjCheckNAdd(37);
+                  break;
+               case 38:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(3, 9);
+                  break;
+               case 39:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(37, 39);
+                  break;
+               case 41:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(42);
+                  break;
+               case 42:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(42, 5);
+                  break;
+               case 43:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(43, 44);
+                  break;
+               case 45:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(46);
+                  break;
+               case 46:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 70)
+                     kind = 70;
+                  jjCheckNAddTwoStates(46, 5);
+                  break;
+               case 47:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(47, 48);
+                  break;
+               case 48:
+                  if (curChar != 46)
+                     break;
+                  if (kind > 70)
+                     kind = 70;
+                  jjCheckNAddStates(40, 42);
+                  break;
+               case 49:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 70)
+                     kind = 70;
+                  jjCheckNAddStates(40, 42);
+                  break;
+               case 51:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(52);
+                  break;
+               case 52:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 70)
+                     kind = 70;
+                  jjCheckNAddTwoStates(52, 5);
+                  break;
+               case 53:
+                  if (curChar == 47)
+                     jjAddStates(10, 11);
+                  break;
+               case 55:
+                  if ((0xffffffffffffdbffL & l) == 0L)
+                     break;
+                  if (kind > 6)
+                     kind = 6;
+                  jjCheckNAddStates(0, 2);
+                  break;
+               case 56:
+                  if ((0x2400L & l) != 0L && kind > 6)
+                     kind = 6;
+                  break;
+               case 57:
+                  if (curChar == 10 && kind > 6)
+                     kind = 6;
+                  break;
+               case 58:
+                  if (curChar == 13)
+                     jjstateSet[jjnewStateCnt++] = 57;
+                  break;
+               case 59:
+                  if (curChar == 42)
+                     jjstateSet[jjnewStateCnt++] = 60;
+                  break;
+               case 60:
+                  if ((0xffff7fffffffffffL & l) != 0L && kind > 7)
+                     kind = 7;
+                  break;
+               case 61:
+                  if (curChar == 42)
+                     jjstateSet[jjnewStateCnt++] = 59;
+                  break;
+               case 62:
+                  if ((0x3fe000000000000L & l) == 0L)
+                     break;
+                  if (kind > 66)
+                     kind = 66;
+                  jjCheckNAddStates(19, 21);
+                  break;
+               case 63:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(63, 64);
+                  break;
+               case 65:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 66)
+                     kind = 66;
+                  jjCheckNAdd(65);
+                  break;
+               case 66:
+                  if (curChar != 48)
+                     break;
+                  if (kind > 66)
+                     kind = 66;
+                  jjCheckNAddStates(22, 28);
+                  break;
+               case 68:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(68, 64);
+                  break;
+               case 69:
+                  if ((0xff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(69, 64);
+                  break;
+               case 71:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 66)
+                     kind = 66;
+                  jjstateSet[jjnewStateCnt++] = 71;
+                  break;
+               case 72:
+                  if ((0xff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 66)
+                     kind = 66;
+                  jjCheckNAdd(72);
+                  break;
+               case 74:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjAddStates(43, 44);
+                  break;
+               case 75:
+                  if (curChar == 46)
+                     jjCheckNAdd(76);
+                  break;
+               case 76:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(76, 77);
+                  break;
+               case 78:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(79);
+                  break;
+               case 79:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 70)
+                     kind = 70;
+                  jjCheckNAddTwoStates(79, 5);
+                  break;
+               case 81:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddStates(45, 47);
+                  break;
+               case 82:
+                  if (curChar == 46)
+                     jjCheckNAdd(83);
+                  break;
+               case 84:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(85);
+                  break;
+               case 85:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 70)
+                     kind = 70;
+                  jjCheckNAddTwoStates(85, 5);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x7fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 77)
+                     kind = 77;
+                  jjCheckNAdd(37);
+                  break;
+               case 2:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(48, 49);
+                  break;
+               case 5:
+                  if ((0x5000000050L & l) != 0L && kind > 70)
+                     kind = 70;
+                  break;
+               case 7:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAdd(8);
+                  break;
+               case 9:
+                  if (curChar == 92)
+                     jjAddStates(50, 52);
+                  break;
+               case 10:
+                  if ((0x14404410000000L & l) != 0L)
+                     jjCheckNAdd(8);
+                  break;
+               case 15:
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 16;
+                  break;
+               case 16:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 17;
+                  break;
+               case 17:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 18;
+                  break;
+               case 18:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 19;
+                  break;
+               case 19:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjCheckNAdd(8);
+                  break;
+               case 20:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 15;
+                  break;
+               case 22:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAddStates(12, 15);
+                  break;
+               case 23:
+                  if (curChar == 92)
+                     jjAddStates(53, 55);
+                  break;
+               case 24:
+                  if ((0x14404410000000L & l) != 0L)
+                     jjCheckNAddStates(12, 15);
+                  break;
+               case 25:
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 26;
+                  break;
+               case 26:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 27;
+                  break;
+               case 27:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 28;
+                  break;
+               case 28:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 29;
+                  break;
+               case 29:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjCheckNAddStates(12, 15);
+                  break;
+               case 30:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 25;
+                  break;
+               case 37:
+                  if ((0x87fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 77)
+                     kind = 77;
+                  jjCheckNAdd(37);
+                  break;
+               case 40:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(56, 57);
+                  break;
+               case 44:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(58, 59);
+                  break;
+               case 50:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(60, 61);
+                  break;
+               case 55:
+                  if (kind > 6)
+                     kind = 6;
+                  jjAddStates(0, 2);
+                  break;
+               case 60:
+                  if (kind > 7)
+                     kind = 7;
+                  break;
+               case 64:
+                  if ((0x100000001000L & l) != 0L && kind > 65)
+                     kind = 65;
+                  break;
+               case 67:
+                  if ((0x100000001000000L & l) != 0L)
+                     jjCheckNAdd(68);
+                  break;
+               case 68:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjCheckNAddTwoStates(68, 64);
+                  break;
+               case 70:
+                  if ((0x100000001000000L & l) != 0L)
+                     jjCheckNAdd(71);
+                  break;
+               case 71:
+                  if ((0x7e0000007eL & l) == 0L)
+                     break;
+                  if (kind > 66)
+                     kind = 66;
+                  jjCheckNAdd(71);
+                  break;
+               case 73:
+                  if ((0x100000001000000L & l) != 0L)
+                     jjCheckNAddTwoStates(74, 75);
+                  break;
+               case 74:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjCheckNAddTwoStates(74, 75);
+                  break;
+               case 76:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjAddStates(62, 63);
+                  break;
+               case 77:
+                  if ((0x1000000010000L & l) != 0L)
+                     jjAddStates(64, 65);
+                  break;
+               case 80:
+                  if ((0x100000001000000L & l) != 0L)
+                     jjCheckNAdd(81);
+                  break;
+               case 81:
+                  if ((0x7e0000007eL & l) != 0L)
+                     jjCheckNAddStates(45, 47);
+                  break;
+               case 83:
+                  if ((0x1000000010000L & l) != 0L)
+                     jjAddStates(66, 67);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 77)
+                     kind = 77;
+                  jjCheckNAdd(37);
+                  break;
+               case 7:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  break;
+               case 22:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(12, 15);
+                  break;
+               case 37:
+                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 77)
+                     kind = 77;
+                  jjCheckNAdd(37);
+                  break;
+               case 55:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 6)
+                     kind = 6;
+                  jjAddStates(0, 2);
+                  break;
+               case 60:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 7)
+                     kind = 7;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 86 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_2()
+{
+   switch(curChar)
+   {
+      case 42:
+         return jjMoveStringLiteralDfa1_2(0x400L);
+      default :
+         return 1;
+   }
+}
+private int jjMoveStringLiteralDfa1_2(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 47:
+         if ((active0 & 0x400L) != 0L)
+            return jjStopAtPos(1, 10);
+         break;
+      default :
+         return 2;
+   }
+   return 2;
+}
+private int jjMoveStringLiteralDfa0_1()
+{
+   switch(curChar)
+   {
+      case 42:
+         return jjMoveStringLiteralDfa1_1(0x200L);
+      default :
+         return 1;
+   }
+}
+private int jjMoveStringLiteralDfa1_1(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 47:
+         if ((active0 & 0x200L) != 0L)
+            return jjStopAtPos(1, 9);
+         break;
+      default :
+         return 2;
+   }
+   return 2;
+}
+static final int[] jjnextStates = {
+   55, 56, 58, 39, 40, 5, 43, 44, 47, 48, 54, 61, 22, 23, 30, 31, 
+   7, 9, 20, 63, 64, 65, 67, 69, 64, 70, 72, 73, 80, 1, 2, 5, 
+   22, 23, 33, 30, 31, 39, 40, 5, 49, 50, 5, 74, 75, 81, 82, 83, 
+   3, 4, 10, 11, 13, 24, 32, 34, 41, 42, 45, 46, 51, 52, 76, 77, 
+   78, 79, 84, 85, 
+};
+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec2[i2] & l2) != 0L);
+      default : 
+         if ((jjbitVec0[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec4[i2] & l2) != 0L);
+      case 2:
+         return ((jjbitVec5[i2] & l2) != 0L);
+      case 3:
+         return ((jjbitVec6[i2] & l2) != 0L);
+      case 4:
+         return ((jjbitVec7[i2] & l2) != 0L);
+      case 5:
+         return ((jjbitVec8[i2] & l2) != 0L);
+      case 6:
+         return ((jjbitVec9[i2] & l2) != 0L);
+      case 7:
+         return ((jjbitVec10[i2] & l2) != 0L);
+      case 9:
+         return ((jjbitVec11[i2] & l2) != 0L);
+      case 10:
+         return ((jjbitVec12[i2] & l2) != 0L);
+      case 11:
+         return ((jjbitVec13[i2] & l2) != 0L);
+      case 12:
+         return ((jjbitVec14[i2] & l2) != 0L);
+      case 13:
+         return ((jjbitVec15[i2] & l2) != 0L);
+      case 14:
+         return ((jjbitVec16[i2] & l2) != 0L);
+      case 15:
+         return ((jjbitVec17[i2] & l2) != 0L);
+      case 16:
+         return ((jjbitVec18[i2] & l2) != 0L);
+      case 17:
+         return ((jjbitVec19[i2] & l2) != 0L);
+      case 18:
+         return ((jjbitVec20[i2] & l2) != 0L);
+      case 19:
+         return ((jjbitVec21[i2] & l2) != 0L);
+      case 20:
+         return ((jjbitVec0[i2] & l2) != 0L);
+      case 22:
+         return ((jjbitVec22[i2] & l2) != 0L);
+      case 23:
+         return ((jjbitVec23[i2] & l2) != 0L);
+      case 24:
+         return ((jjbitVec24[i2] & l2) != 0L);
+      case 25:
+         return ((jjbitVec25[i2] & l2) != 0L);
+      case 29:
+         return ((jjbitVec26[i2] & l2) != 0L);
+      case 30:
+         return ((jjbitVec27[i2] & l2) != 0L);
+      case 31:
+         return ((jjbitVec28[i2] & l2) != 0L);
+      case 32:
+         return ((jjbitVec29[i2] & l2) != 0L);
+      case 33:
+         return ((jjbitVec30[i2] & l2) != 0L);
+      case 48:
+         return ((jjbitVec31[i2] & l2) != 0L);
+      case 49:
+         return ((jjbitVec32[i2] & l2) != 0L);
+      case 77:
+         return ((jjbitVec33[i2] & l2) != 0L);
+      case 159:
+         return ((jjbitVec34[i2] & l2) != 0L);
+      case 164:
+         return ((jjbitVec35[i2] & l2) != 0L);
+      case 215:
+         return ((jjbitVec36[i2] & l2) != 0L);
+      case 216:
+         return ((jjbitVec37[i2] & l2) != 0L);
+      case 250:
+         return ((jjbitVec38[i2] & l2) != 0L);
+      case 251:
+         return ((jjbitVec39[i2] & l2) != 0L);
+      case 253:
+         return ((jjbitVec40[i2] & l2) != 0L);
+      case 254:
+         return ((jjbitVec41[i2] & l2) != 0L);
+      case 255:
+         return ((jjbitVec42[i2] & l2) != 0L);
+      default : 
+         if ((jjbitVec3[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec43[i2] & l2) != 0L);
+      case 2:
+         return ((jjbitVec5[i2] & l2) != 0L);
+      case 3:
+         return ((jjbitVec44[i2] & l2) != 0L);
+      case 4:
+         return ((jjbitVec45[i2] & l2) != 0L);
+      case 5:
+         return ((jjbitVec46[i2] & l2) != 0L);
+      case 6:
+         return ((jjbitVec47[i2] & l2) != 0L);
+      case 7:
+         return ((jjbitVec48[i2] & l2) != 0L);
+      case 9:
+         return ((jjbitVec49[i2] & l2) != 0L);
+      case 10:
+         return ((jjbitVec50[i2] & l2) != 0L);
+      case 11:
+         return ((jjbitVec51[i2] & l2) != 0L);
+      case 12:
+         return ((jjbitVec52[i2] & l2) != 0L);
+      case 13:
+         return ((jjbitVec53[i2] & l2) != 0L);
+      case 14:
+         return ((jjbitVec54[i2] & l2) != 0L);
+      case 15:
+         return ((jjbitVec55[i2] & l2) != 0L);
+      case 16:
+         return ((jjbitVec56[i2] & l2) != 0L);
+      case 17:
+         return ((jjbitVec19[i2] & l2) != 0L);
+      case 18:
+         return ((jjbitVec20[i2] & l2) != 0L);
+      case 19:
+         return ((jjbitVec57[i2] & l2) != 0L);
+      case 20:
+         return ((jjbitVec0[i2] & l2) != 0L);
+      case 22:
+         return ((jjbitVec22[i2] & l2) != 0L);
+      case 23:
+         return ((jjbitVec58[i2] & l2) != 0L);
+      case 24:
+         return ((jjbitVec59[i2] & l2) != 0L);
+      case 25:
+         return ((jjbitVec60[i2] & l2) != 0L);
+      case 29:
+         return ((jjbitVec26[i2] & l2) != 0L);
+      case 30:
+         return ((jjbitVec27[i2] & l2) != 0L);
+      case 31:
+         return ((jjbitVec28[i2] & l2) != 0L);
+      case 32:
+         return ((jjbitVec61[i2] & l2) != 0L);
+      case 33:
+         return ((jjbitVec30[i2] & l2) != 0L);
+      case 48:
+         return ((jjbitVec62[i2] & l2) != 0L);
+      case 49:
+         return ((jjbitVec32[i2] & l2) != 0L);
+      case 77:
+         return ((jjbitVec33[i2] & l2) != 0L);
+      case 159:
+         return ((jjbitVec34[i2] & l2) != 0L);
+      case 164:
+         return ((jjbitVec35[i2] & l2) != 0L);
+      case 215:
+         return ((jjbitVec36[i2] & l2) != 0L);
+      case 216:
+         return ((jjbitVec63[i2] & l2) != 0L);
+      case 220:
+         return ((jjbitVec64[i2] & l2) != 0L);
+      case 221:
+         return ((jjbitVec65[i2] & l2) != 0L);
+      case 250:
+         return ((jjbitVec38[i2] & l2) != 0L);
+      case 251:
+         return ((jjbitVec66[i2] & l2) != 0L);
+      case 253:
+         return ((jjbitVec40[i2] & l2) != 0L);
+      case 254:
+         return ((jjbitVec67[i2] & l2) != 0L);
+      case 255:
+         return ((jjbitVec68[i2] & l2) != 0L);
+      default : 
+         if ((jjbitVec3[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, null, null, null, null, null, null, 
+"\141\142\163\164\162\141\143\164", "\141\163\163\145\162\164", "\142\157\157\154\145\141\156", 
+"\142\162\145\141\153", "\142\171\164\145", "\143\141\163\145", "\143\141\164\143\150", 
+"\143\150\141\162", "\143\154\141\163\163", "\143\157\156\163\164", 
+"\143\157\156\164\151\156\165\145", "\144\145\146\141\165\154\164", "\144\157", "\144\157\165\142\154\145", 
+"\145\154\163\145", "\145\156\165\155", "\145\170\164\145\156\144\163", "\146\141\154\163\145", 
+"\146\151\156\141\154", "\146\151\156\141\154\154\171", "\146\154\157\141\164", "\146\157\162", 
+"\147\157\164\157", "\151\146", "\151\155\160\154\145\155\145\156\164\163", 
+"\151\155\160\157\162\164", "\151\156\163\164\141\156\143\145\157\146", "\151\156\164", 
+"\151\156\164\145\162\146\141\143\145", "\154\157\156\147", "\156\141\164\151\166\145", "\156\145\167", 
+"\156\165\154\154", "\160\141\143\153\141\147\145", "\160\162\151\166\141\164\145", 
+"\160\162\157\164\145\143\164\145\144", "\160\165\142\154\151\143", "\162\145\164\165\162\156", 
+"\163\150\157\162\164", "\163\164\141\164\151\143", "\163\164\162\151\143\164\146\160", 
+"\163\165\160\145\162", "\163\167\151\164\143\150", 
+"\163\171\156\143\150\162\157\156\151\172\145\144", "\164\150\151\163", "\164\150\162\157\167", "\164\150\162\157\167\163", 
+"\164\162\141\156\163\151\145\156\164", "\164\162\165\145", "\164\162\171", "\166\157\151\144", 
+"\166\157\154\141\164\151\154\145", "\167\150\151\154\145", null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, "\50", "\51", "\173", "\175", "\133", "\135", 
+"\73", "\54", "\56", "\100", "\75", "\74", "\41", "\176", "\77", "\72", "\75\75", 
+"\74\75", "\76\75", "\41\75", "\174\174", "\46\46", "\53\53", "\55\55", "\53", "\55", 
+"\52", "\57", "\46", "\174", "\136", "\45", "\74\74", "\53\75", "\55\75", "\52\75", 
+"\57\75", "\46\75", "\174\75", "\136\75", "\45\75", "\74\74\75", "\76\76\75", 
+"\76\76\76\75", "\56\56\56", "\76\76\76", "\76\76", "\76", "\32", };
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "DEFAULT", 
+   "IN_JAVA_DOC_COMMENT", 
+   "IN_MULTI_LINE_COMMENT", 
+};
+
+/** Lex State array. */
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, -1, 1, 2, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0xfffffffffffff001L, 0xffffffffffff3847L, 0x1L, 
+};
+static final long[] jjtoSkip = {
+   0x67eL, 0x0L, 0x0L, 
+};
+static final long[] jjtoSpecial = {
+   0x640L, 0x0L, 0x0L, 
+};
+static final long[] jjtoMore = {
+   0x980L, 0x0L, 0x0L, 
+};
+protected JavaCharStream input_stream;
+private final int[] jjrounds = new int[86];
+private final int[] jjstateSet = new int[172];
+private final StringBuilder jjimage = new StringBuilder();
+private StringBuilder image = jjimage;
+private int jjimageLen;
+private int lengthOfMatch;
+protected char curChar;
+/** Constructor. */
+public ASTParserTokenManager(JavaCharStream stream){
+   if (JavaCharStream.staticFlag)
+      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
+   input_stream = stream;
+}
+
+/** Constructor. */
+public ASTParserTokenManager(JavaCharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+
+/** Reinitialise parser. */
+public void ReInit(JavaCharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 86; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+}
+
+/** Reinitialise parser. */
+public void ReInit(JavaCharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+
+/** Switch to specified lex state. */
+public void SwitchTo(int lexState)
+{
+   if (lexState >= 3 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   final Token t;
+   final String curTokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   curTokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = ASTParser.GTToken.newToken(jjmatchedKind, curTokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+
+int curLexState = 0;
+int defaultLexState = 0;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  Token specialToken = null;
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {   
+   try   
+   {     
+      curChar = input_stream.BeginToken();
+   }     
+   catch(java.io.IOException e)
+   {        
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      matchedToken.specialToken = specialToken;
+      CommonTokenAction(matchedToken);
+      return matchedToken;
+   }
+   image = jjimage;
+   image.setLength(0);
+   jjimageLen = 0;
+
+   for (;;)
+   {
+     switch(curLexState)
+     {
+       case 0:
+         try { input_stream.backup(0);
+            while (curChar <= 32 && (0x100003600L & (1L << curChar)) != 0L)
+               curChar = input_stream.BeginToken();
+         }
+         catch (java.io.IOException e1) { continue EOFLoop; }
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_0();
+         break;
+       case 1:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_1();
+         if (jjmatchedPos == 0 && jjmatchedKind > 11)
+         {
+            jjmatchedKind = 11;
+         }
+         break;
+       case 2:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_2();
+         if (jjmatchedPos == 0 && jjmatchedKind > 11)
+         {
+            jjmatchedKind = 11;
+         }
+         break;
+     }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 < curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+           matchedToken.specialToken = specialToken;
+           TokenLexicalActions(matchedToken);
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           CommonTokenAction(matchedToken);
+           return matchedToken;
+        }
+        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+           {
+              matchedToken = jjFillToken();
+              if (specialToken == null)
+                 specialToken = matchedToken;
+              else
+              {
+                 matchedToken.specialToken = specialToken;
+                 specialToken = (specialToken.next = matchedToken);
+              }
+              SkipLexicalActions(matchedToken);
+           }
+           else 
+              SkipLexicalActions(null);
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+        MoreLexicalActions();
+      if (jjnewLexState[jjmatchedKind] != -1)
+        curLexState = jjnewLexState[jjmatchedKind];
+        curPos = 0;
+        jjmatchedKind = 0x7fffffff;
+        try {
+           curChar = input_stream.readChar();
+           continue;
+        }
+        catch (java.io.IOException e1) { }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+   }
+  }
+}
+
+void SkipLexicalActions(Token matchedToken)
+{
+   switch(jjmatchedKind)
+   {
+      default :
+         break;
+   }
+}
+void MoreLexicalActions()
+{
+   jjimageLen += (lengthOfMatch = jjmatchedPos + 1);
+   switch(jjmatchedKind)
+   {
+      case 7 :
+         image.append(input_stream.GetSuffix(jjimageLen));
+         jjimageLen = 0;
+                   input_stream.backup(1);
+         break;
+      default : 
+         break;
+   }
+}
+void TokenLexicalActions(Token matchedToken)
+{
+   switch(jjmatchedKind)
+   {
+      case 125 :
+        image.append(jjstrLiteralImages[125]);
+        lengthOfMatch = jjstrLiteralImages[125].length();
+     matchedToken.kind = GT;
+     ((ASTParser.GTToken)matchedToken).realKind = RUNSIGNEDSHIFT;
+     input_stream.backup(2);
+         break;
+      case 126 :
+        image.append(jjstrLiteralImages[126]);
+        lengthOfMatch = jjstrLiteralImages[126].length();
+     matchedToken.kind = GT;
+     ((ASTParser.GTToken)matchedToken).realKind = RSIGNEDSHIFT;
+     input_stream.backup(1);
+         break;
+      default : 
+         break;
+   }
+}
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/JavaCharStream.java b/parser/html/java/javaparser/src/japa/parser/JavaCharStream.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/JavaCharStream.java
@@ -0,0 +1,634 @@
+/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 4.1 */
+/* JavaCCOptions:STATIC=false */
+/*
+ * Copyright (C) 2008 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package japa.parser;
+
+/**
+ * An implementation of interface CharStream, where the stream is assumed to
+ * contain only ASCII characters (with java-like unicode escape processing).
+ */
+
+public class JavaCharStream
+{
+/** Whether parser is static. */
+  public static final boolean staticFlag = false;
+  static final int hexval(char c) throws java.io.IOException {
+    switch(c)
+    {
+       case '0' :
+          return 0;
+       case '1' :
+          return 1;
+       case '2' :
+          return 2;
+       case '3' :
+          return 3;
+       case '4' :
+          return 4;
+       case '5' :
+          return 5;
+       case '6' :
+          return 6;
+       case '7' :
+          return 7;
+       case '8' :
+          return 8;
+       case '9' :
+          return 9;
+
+       case 'a' :
+       case 'A' :
+          return 10;
+       case 'b' :
+       case 'B' :
+          return 11;
+       case 'c' :
+       case 'C' :
+          return 12;
+       case 'd' :
+       case 'D' :
+          return 13;
+       case 'e' :
+       case 'E' :
+          return 14;
+       case 'f' :
+       case 'F' :
+          return 15;
+    }
+
+    throw new java.io.IOException(); // Should never come here
+  }
+
+/** Position in buffer. */
+  public int bufpos = -1;
+  int bufsize;
+  int available;
+  int tokenBegin;
+  protected int bufline[];
+  protected int bufcolumn[];
+
+  protected int column = 0;
+  protected int line = 1;
+
+  protected boolean prevCharIsCR = false;
+  protected boolean prevCharIsLF = false;
+
+  protected java.io.Reader inputStream;
+
+  protected char[] nextCharBuf;
+  protected char[] buffer;
+  protected int maxNextCharInd = 0;
+  protected int nextCharInd = -1;
+  protected int inBuf = 0;
+  protected int tabSize = 8;
+
+  protected void setTabSize(int i) { tabSize = i; }
+  protected int getTabSize(int i) { return tabSize; }
+
+  protected void ExpandBuff(boolean wrapAround)
+  {
+     char[] newbuffer = new char[bufsize + 2048];
+     int newbufline[] = new int[bufsize + 2048];
+     int newbufcolumn[] = new int[bufsize + 2048];
+
+     try
+     {
+        if (wrapAround)
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           System.arraycopy(buffer, 0, newbuffer,
+                                             bufsize - tokenBegin, bufpos);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
+           bufcolumn = newbufcolumn;
+
+           bufpos += (bufsize - tokenBegin);
+        }
+        else
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           bufcolumn = newbufcolumn;
+
+           bufpos -= tokenBegin;
+        }
+     }
+     catch (Throwable t)
+     {
+        throw new Error(t.getMessage());
+     }
+
+     available = (bufsize += 2048);
+     tokenBegin = 0;
+  }
+
+  protected void FillBuff() throws java.io.IOException
+  {
+     int i;
+     if (maxNextCharInd == 4096)
+        maxNextCharInd = nextCharInd = 0;
+
+     try {
+        if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
+                                            4096 - maxNextCharInd)) == -1)
+        {
+           inputStream.close();
+           throw new java.io.IOException();
+        }
+        else
+           maxNextCharInd += i;
+        return;
+     }
+     catch(java.io.IOException e) {
+        if (bufpos != 0)
+        {
+           --bufpos;
+           backup(0);
+        }
+        else
+        {
+           bufline[bufpos] = line;
+           bufcolumn[bufpos] = column;
+        }
+        throw e;
+     }
+  }
+
+  protected char ReadByte() throws java.io.IOException
+  {
+     if (++nextCharInd >= maxNextCharInd)
+        FillBuff();
+
+     return nextCharBuf[nextCharInd];
+  }
+
+/** @return starting character for token. */
+  public char BeginToken() throws java.io.IOException
+  {     
+     if (inBuf > 0)
+     {
+        --inBuf;
+
+        if (++bufpos == bufsize)
+           bufpos = 0;
+
+        tokenBegin = bufpos;
+        return buffer[bufpos];
+     }
+
+     tokenBegin = 0;
+     bufpos = -1;
+
+     return readChar();
+  }     
+
+  protected void AdjustBuffSize()
+  {
+     if (available == bufsize)
+     {
+        if (tokenBegin > 2048)
+        {
+           bufpos = 0;
+           available = tokenBegin;
+        }
+        else
+           ExpandBuff(false);
+     }
+     else if (available > tokenBegin)
+        available = bufsize;
+     else if ((tokenBegin - available) < 2048)
+        ExpandBuff(true);
+     else
+        available = tokenBegin;
+  }
+
+  protected void UpdateLineColumn(char c)
+  {
+     column++;
+
+     if (prevCharIsLF)
+     {
+        prevCharIsLF = false;
+        line += (column = 1);
+     }
+     else if (prevCharIsCR)
+     {
+        prevCharIsCR = false;
+        if (c == '\n')
+        {
+           prevCharIsLF = true;
+        }
+        else
+           line += (column = 1);
+     }
+
+     switch (c)
+     {
+        case '\r' :
+           prevCharIsCR = true;
+           break;
+        case '\n' :
+           prevCharIsLF = true;
+           break;
+        case '\t' :
+           column--;
+           column += (tabSize - (column % tabSize));
+           break;
+        default :
+           break;
+     }
+
+     bufline[bufpos] = line;
+     bufcolumn[bufpos] = column;
+  }
+
+/** Read a character. */
+  public char readChar() throws java.io.IOException
+  {
+     if (inBuf > 0)
+     {
+        --inBuf;
+
+        if (++bufpos == bufsize)
+           bufpos = 0;
+
+        return buffer[bufpos];
+     }
+
+     char c;
+
+     if (++bufpos == available)
+        AdjustBuffSize();
+
+     if ((buffer[bufpos] = c = ReadByte()) == '\\')
+     {
+        UpdateLineColumn(c);
+
+        int backSlashCnt = 1;
+
+        for (;;) // Read all the backslashes
+        {
+           if (++bufpos == available)
+              AdjustBuffSize();
+
+           try
+           {
+              if ((buffer[bufpos] = c = ReadByte()) != '\\')
+              {
+                 UpdateLineColumn(c);
+                 // found a non-backslash char.
+                 if ((c == 'u') && ((backSlashCnt & 1) == 1))
+                 {
+                    if (--bufpos < 0)
+                       bufpos = bufsize - 1;
+
+                    break;
+                 }
+
+                 backup(backSlashCnt);
+                 return '\\';
+              }
+           }
+           catch(java.io.IOException e)
+           {
+              if (backSlashCnt > 1)
+                 backup(backSlashCnt-1);
+
+              return '\\';
+           }
+
+           UpdateLineColumn(c);
+           backSlashCnt++;
+        }
+
+        // Here, we have seen an odd number of backslash's followed by a 'u'
+        try
+        {
+           while ((c = ReadByte()) == 'u')
+              ++column;
+
+           buffer[bufpos] = c = (char)(hexval(c) << 12 |
+                                       hexval(ReadByte()) << 8 |
+                                       hexval(ReadByte()) << 4 |
+                                       hexval(ReadByte()));
+
+           column += 4;
+        }
+        catch(java.io.IOException e)
+        {
+           throw new Error("Invalid escape character at line " + line +
+                                         " column " + column + ".");
+        }
+
+        if (backSlashCnt == 1)
+           return c;
+        else
+        {
+           backup(backSlashCnt - 1);
+           return '\\';
+        }
+     }
+     else
+     {
+        UpdateLineColumn(c);
+        return c;
+     }
+  }
+
+  @Deprecated
+  /**
+   * @deprecated 
+   * @see #getEndColumn
+   */
+  public int getColumn() {
+     return bufcolumn[bufpos];
+  }
+
+  @Deprecated
+  /**
+   * @deprecated 
+   * @see #getEndLine
+   */
+  public int getLine() {
+     return bufline[bufpos];
+  }
+
+/** Get end column. */
+  public int getEndColumn() {
+     return bufcolumn[bufpos];
+  }
+
+/** Get end line. */
+  public int getEndLine() {
+     return bufline[bufpos];
+  }
+
+/** @return column of token start */
+  public int getBeginColumn() {
+     return bufcolumn[tokenBegin];
+  }
+
+/** @return line number of token start */
+  public int getBeginLine() {
+     return bufline[tokenBegin];
+  }
+
+/** Retreat. */
+  public void backup(int amount) {
+
+    inBuf += amount;
+    if ((bufpos -= amount) < 0)
+       bufpos += bufsize;
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    available = bufsize = buffersize;
+    buffer = new char[buffersize];
+    bufline = new int[buffersize];
+    bufcolumn = new int[buffersize];
+    nextCharBuf = new char[4096];
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+     this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream)
+  {
+     this(dstream, 1, 1, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    if (buffer == null || buffersize != buffer.length)
+    {
+      available = bufsize = buffersize;
+      buffer = new char[buffersize];
+      bufline = new int[buffersize];
+      bufcolumn = new int[buffersize];
+      nextCharBuf = new char[4096];
+    }
+    prevCharIsLF = prevCharIsCR = false;
+    tokenBegin = inBuf = maxNextCharInd = 0;
+    nextCharInd = bufpos = -1;
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+     ReInit(dstream, startline, startcolumn, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream)
+  {
+     ReInit(dstream, 1, 1, 4096);
+  }
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+                        int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+                        int startcolumn)
+  {
+     this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream)
+  {
+     this(dstream, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                     int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+                     int startcolumn)
+  {
+     ReInit(dstream, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream)
+  {
+     ReInit(dstream, 1, 1, 4096);
+  }
+
+  /** @return token image as String */
+  public String GetImage()
+  {
+     if (bufpos >= tokenBegin)
+        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
+     else
+        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
+                              new String(buffer, 0, bufpos + 1);
+  }
+
+  /** @return suffix */
+  public char[] GetSuffix(int len)
+  {
+     char[] ret = new char[len];
+
+     if ((bufpos + 1) >= len)
+        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
+     else
+     {
+        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
+                                                          len - bufpos - 1);
+        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
+     }
+
+     return ret;
+  }
+
+  /** Set buffers back to null when finished. */
+  public void Done()
+  {
+     nextCharBuf = null;
+     buffer = null;
+     bufline = null;
+     bufcolumn = null;
+  }
+
+  /**
+   * Method to adjust line and column numbers for the start of a token.
+   */
+  public void adjustBeginLineColumn(int newLine, int newCol)
+  {
+     int start = tokenBegin;
+     int len;
+
+     if (bufpos >= tokenBegin)
+     {
+        len = bufpos - tokenBegin + inBuf + 1;
+     }
+     else
+     {
+        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
+     }
+
+     int i = 0, j = 0, k = 0;
+     int nextColDiff = 0, columnDiff = 0;
+
+     while (i < len &&
+            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
+     {
+        bufline[j] = newLine;
+        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
+        bufcolumn[j] = newCol + columnDiff;
+        columnDiff = nextColDiff;
+        i++;
+     } 
+
+     if (i < len)
+     {
+        bufline[j] = newLine++;
+        bufcolumn[j] = newCol + columnDiff;
+
+        while (i++ < len)
+        {
+           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
+              bufline[j] = newLine++;
+           else
+              bufline[j] = newLine;
+        }
+     }
+
+     line = bufline[j];
+     column = bufcolumn[j];
+  }
+
+}
+/* JavaCC - OriginalChecksum=46aebc46574be349188fc26719761bcb (do not edit this line) */
diff --git a/parser/html/java/javaparser/src/japa/parser/JavaParser.java b/parser/html/java/javaparser/src/japa/parser/JavaParser.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/JavaParser.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2008 Jlio Vilmar Gesser.
+ *
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser;
+
+import japa.parser.ast.CompilationUnit;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * <p>This class was generated automatically by javacc, do not edit.</p>
+ * <p>Parse Java 1.5 source code and creates Abstract Syntax Tree classes.</p>
+ * <p><b>Note:</b> To use this parser asynchronously, disable de parser cache
+ * by calling the method {@link setCacheParser} with <code>false</code>
+ * as argument.</p>
+ *
+ * @author Jlio Vilmar Gesser
+ */
+public final class JavaParser {
+
+    private static ASTParser parser;
+
+    private static boolean cacheParser = true;
+
+    private JavaParser() {
+        // hide the constructor
+    }
+
+    /**
+     * Changes the way that the parser acts when starts to parse. If the 
+     * parser cache is enabled, only one insance of this object will be 
+     * used in every call to parse methods.
+     * If this parser is intend to be used asynchonously, the cache must 
+     * be disabled setting this flag to <code>false</code>.
+     * By default, the cache is enabled.
+     * @param value <code>false</code> to disable the parser instance cache. 
+     */
+    public static void setCacheParser(boolean value) {
+        cacheParser = value;
+        if (!value) {
+            parser = null;
+        }
+    }
+
+    /**
+     * Parses the Java code contained in the {@link InputStream} and returns 
+     * a {@link CompilationUnit} that represents it. 
+     * @param in {@link InputStream} containing Java source code
+     * @param encoding encoding of the source code
+     * @return CompilationUnit representing the Java source code
+     * @throws ParseException if the source code has parser errors
+     */
+    public static CompilationUnit parse(InputStream in, String encoding) throws ParseException {
+        if (cacheParser) {
+            if (parser == null) {
+                parser = new ASTParser(in, encoding);
+            } else {
+                parser.reset(in, encoding);
+            }
+            return parser.CompilationUnit();
+        }
+        return new ASTParser(in, encoding).CompilationUnit();
+    }
+
+    /**
+     * Parses the Java code contained in the {@link InputStream} and returns 
+     * a {@link CompilationUnit} that represents it. 
+     * @param in {@link InputStream} containing Java source code
+     * @return CompilationUnit representing the Java source code
+     * @throws ParseException if the source code has parser errors
+     */
+    public static CompilationUnit parse(InputStream in) throws ParseException {
+        return parse(in, null);
+    }
+
+    /**
+     * Parses the Java code contained in a {@link File} and returns 
+     * a {@link CompilationUnit} that represents it. 
+     * @param file {@link File} containing Java source code
+     * @param encoding encoding of the source code
+     * @return CompilationUnit representing the Java source code
+     * @throws ParseException if the source code has parser errors
+     * @throws IOException 
+     */
+    public static CompilationUnit parse(File file, String encoding) throws ParseException, IOException {
+        FileInputStream in = new FileInputStream(file);
+        try {
+            return parse(in, encoding);
+        } finally {
+            in.close();
+        }
+    }
+
+    /**
+     * Parses the Java code contained in a {@link File} and returns 
+     * a {@link CompilationUnit} that represents it. 
+     * @param file {@link File} containing Java source code
+     * @return CompilationUnit representing the Java source code
+     * @throws ParseException if the source code has parser errors
+     * @throws IOException 
+     */
+    public static CompilationUnit parse(File file) throws ParseException, IOException {
+        return parse(file, null);
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ParseException.java b/parser/html/java/javaparser/src/japa/parser/ParseException.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ParseException.java
@@ -0,0 +1,216 @@
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 */
+/* JavaCCOptions:KEEP_LINE_COL=null */
+/*
+ * Copyright (C) 2008 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package japa.parser;
+
+/**
+ * This exception is thrown when parse errors are encountered.
+ * You can explicitly create objects of this exception type by
+ * calling the method generateParseException in the generated
+ * parser.
+ *
+ * You can modify this class to customize your error reporting
+ * mechanisms so long as you retain the public fields.
+ */
+public class ParseException extends Exception {
+
+  /**
+   * This constructor is used by the method "generateParseException"
+   * in the generated parser.  Calling this constructor generates
+   * a new object of this type with the fields "currentToken",
+   * "expectedTokenSequences", and "tokenImage" set.  The boolean
+   * flag "specialConstructor" is also set to true to indicate that
+   * this constructor was used to create this object.
+   * This constructor calls its super class with the empty string
+   * to force the "toString" method of parent class "Throwable" to
+   * print the error message in the form:
+   *     ParseException: <result of getMessage>
+   */
+  public ParseException(Token currentTokenVal,
+                        int[][] expectedTokenSequencesVal,
+                        String[] tokenImageVal
+                       )
+  {
+    super("");
+    specialConstructor = true;
+    currentToken = currentTokenVal;
+    expectedTokenSequences = expectedTokenSequencesVal;
+    tokenImage = tokenImageVal;
+  }
+
+  /**
+   * The following constructors are for use by you for whatever
+   * purpose you can think of.  Constructing the exception in this
+   * manner makes the exception behave in the normal way - i.e., as
+   * documented in the class "Throwable".  The fields "errorToken",
+   * "expectedTokenSequences", and "tokenImage" do not contain
+   * relevant information.  The JavaCC generated code does not use
+   * these constructors.
+   */
+
+  public ParseException() {
+    super();
+    specialConstructor = false;
+  }
+
+  /** Constructor with message. */
+  public ParseException(String message) {
+    super(message);
+    specialConstructor = false;
+  }
+
+  /**
+   * This variable determines which constructor was used to create
+   * this object and thereby affects the semantics of the
+   * "getMessage" method (see below).
+   */
+  protected boolean specialConstructor;
+
+  /**
+   * This is the last token that has been consumed successfully.  If
+   * this object has been created due to a parse error, the token
+   * followng this token will (therefore) be the first error token.
+   */
+  public Token currentToken;
+
+  /**
+   * Each entry in this array is an array of integers.  Each array
+   * of integers represents a sequence of tokens (by their ordinal
+   * values) that is expected at this point of the parse.
+   */
+  public int[][] expectedTokenSequences;
+
+  /**
+   * This is a reference to the "tokenImage" array of the generated
+   * parser within which the parse error occurred.  This array is
+   * defined in the generated ...Constants interface.
+   */
+  public String[] tokenImage;
+
+  /**
+   * This method has the standard behavior when this object has been
+   * created using the standard constructors.  Otherwise, it uses
+   * "currentToken" and "expectedTokenSequences" to generate a parse
+   * error message and returns it.  If this object has been created
+   * due to a parse error, and you do not catch it (it gets thrown
+   * from the parser), then this method is called during the printing
+   * of the final stack trace, and hence the correct error message
+   * gets displayed.
+   */
+  public String getMessage() {
+    if (!specialConstructor) {
+      return super.getMessage();
+    }
+    StringBuffer expected = new StringBuffer();
+    int maxSize = 0;
+    for (int i = 0; i < expectedTokenSequences.length; i++) {
+      if (maxSize < expectedTokenSequences[i].length) {
+        maxSize = expectedTokenSequences[i].length;
+      }
+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
+      }
+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
+        expected.append("...");
+      }
+      expected.append(eol).append("    ");
+    }
+    String retval = "Encountered \"";
+    Token tok = currentToken.next;
+    for (int i = 0; i < maxSize; i++) {
+      if (i != 0) retval += " ";
+      if (tok.kind == 0) {
+        retval += tokenImage[0];
+        break;
+      }
+      retval += " " + tokenImage[tok.kind];
+      retval += " \"";
+      retval += add_escapes(tok.image);
+      retval += " \"";
+      tok = tok.next; 
+    }
+    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
+    retval += "." + eol;
+    if (expectedTokenSequences.length == 1) {
+      retval += "Was expecting:" + eol + "    ";
+    } else {
+      retval += "Was expecting one of:" + eol + "    ";
+    }
+    retval += expected.toString();
+    return retval;
+  }
+
+  /**
+   * The end of line string for this machine.
+   */
+  protected String eol = System.getProperty("line.separator", "\n");
+ 
+  /**
+   * Used to convert raw characters to their escaped version
+   * when these raw version cannot be used as part of an ASCII
+   * string literal.
+   */
+  protected String add_escapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+}
+/* JavaCC - OriginalChecksum=1164e36971d84a0433c5f702fcb960dd (do not edit this line) */
diff --git a/parser/html/java/javaparser/src/japa/parser/Token.java b/parser/html/java/javaparser/src/japa/parser/Token.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/Token.java
@@ -0,0 +1,142 @@
+/* Generated By:JavaCC: Do not edit this line. Token.java Version 4.1 */
+/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null */
+/*
+ * Copyright (C) 2008 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package japa.parser;
+
+/**
+ * Describes the input token stream.
+ */
+
+public class Token {
+
+  /**
+   * An integer that describes the kind of this token.  This numbering
+   * system is determined by JavaCCParser, and a table of these numbers is
+   * stored in the file ...Constants.java.
+   */
+  public int kind;
+
+  /** The line number of the first character of this Token. */
+  public int beginLine;
+  /** The column number of the first character of this Token. */
+  public int beginColumn;
+  /** The line number of the last character of this Token. */
+  public int endLine;
+  /** The column number of the last character of this Token. */
+  public int endColumn;
+
+  /**
+   * The string image of the token.
+   */
+  public String image;
+
+  /**
+   * A reference to the next regular (non-special) token from the input
+   * stream.  If this is the last token from the input stream, or if the
+   * token manager has not read tokens beyond this one, this field is
+   * set to null.  This is true only if this token is also a regular
+   * token.  Otherwise, see below for a description of the contents of
+   * this field.
+   */
+  public Token next;
+
+  /**
+   * This field is used to access special tokens that occur prior to this
+   * token, but after the immediately preceding regular (non-special) token.
+   * If there are no such special tokens, this field is set to null.
+   * When there are more than one such special token, this field refers
+   * to the last of these special tokens, which in turn refers to the next
+   * previous special token through its specialToken field, and so on
+   * until the first special token (whose specialToken field is null).
+   * The next fields of special tokens refer to other special tokens that
+   * immediately follow it (without an intervening regular token).  If there
+   * is no such token, this field is null.
+   */
+  public Token specialToken;
+
+  /**
+   * An optional attribute value of the Token.
+   * Tokens which are not used as syntactic sugar will often contain
+   * meaningful values that will be used later on by the compiler or
+   * interpreter. This attribute value is often different from the image.
+   * Any subclass of Token that actually wants to return a non-null value can
+   * override this method as appropriate.
+   */
+  public Object getValue() {
+    return null;
+  }
+
+  /**
+   * No-argument constructor
+   */
+  public Token() {}
+
+  /**
+   * Constructs a new token for the specified Image.
+   */
+  public Token(int kind)
+  {
+     this(kind, null);
+  }
+
+  /**
+   * Constructs a new token for the specified Image and Kind.
+   */
+  public Token(int kind, String image)
+  {
+     this.kind = kind;
+     this.image = image;
+  }
+
+  /**
+   * Returns the image.
+   */
+  public String toString()
+  {
+     return image;
+  }
+
+  /**
+   * Returns a new Token object, by default. However, if you want, you
+   * can create and return subclass objects based on the value of ofKind.
+   * Simply add the cases to the switch for all those special cases.
+   * For example, if you have a subclass of Token called IDToken that
+   * you want to create if ofKind is ID, simply add something like :
+   *
+   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
+   *
+   * to the following switch statement. Then you can cast matchedToken
+   * variable to the appropriate type and use sit in your lexical actions.
+   */
+  public static Token newToken(int ofKind, String image)
+  {
+     switch(ofKind)
+     {
+       default : return new Token(ofKind, image);
+     }
+  }
+
+  public static Token newToken(int ofKind)
+  {
+     return newToken(ofKind, null);
+  }
+
+}
+/* JavaCC - OriginalChecksum=36e116391da53a8cb5fc7d23289ae0c7 (do not edit this line) */
diff --git a/parser/html/java/javaparser/src/japa/parser/TokenMgrError.java b/parser/html/java/javaparser/src/japa/parser/TokenMgrError.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/TokenMgrError.java
@@ -0,0 +1,159 @@
+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 4.1 */
+/* JavaCCOptions: */
+/*
+ * Copyright (C) 2008 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package japa.parser;
+
+/** Token Manager Error. */
+@SuppressWarnings("serial")
+public class TokenMgrError extends Error
+{
+
+   /*
+    * Ordinals for various reasons why an Error of this type can be thrown.
+    */
+
+   /**
+    * Lexical error occurred.
+    */
+   static final int LEXICAL_ERROR = 0;
+
+   /**
+    * An attempt was made to create a second instance of a static token manager.
+    */
+   static final int STATIC_LEXER_ERROR = 1;
+
+   /**
+    * Tried to change to an invalid lexical state.
+    */
+   static final int INVALID_LEXICAL_STATE = 2;
+
+   /**
+    * Detected (and bailed out of) an infinite loop in the token manager.
+    */
+   static final int LOOP_DETECTED = 3;
+
+   /**
+    * Indicates the reason why the exception is thrown. It will have
+    * one of the above 4 values.
+    */
+   int errorCode;
+
+   /**
+    * Replaces unprintable characters by their escaped (or unicode escaped)
+    * equivalents in the given string
+    */
+   protected static final String addEscapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+   /**
+    * Returns a detailed message for the Error when it is thrown by the
+    * token manager to indicate a lexical error.
+    * Parameters : 
+    *    EOFSeen     : indicates if EOF caused the lexical error
+    *    curLexState : lexical state in which this error occurred
+    *    errorLine   : line number when the error occurred
+    *    errorColumn : column number when the error occurred
+    *    errorAfter  : prefix that was seen before this error occurred
+    *    curchar     : the offending character
+    * Note: You can customize the lexical error message by modifying this method.
+    */
+   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
+      return("Lexical error at line " +
+           errorLine + ", column " +
+           errorColumn + ".  Encountered: " +
+           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
+           "after : \"" + addEscapes(errorAfter) + "\"");
+   }
+
+   /**
+    * You can also modify the body of this method to customize your error messages.
+    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
+    * of end-users concern, so you can return something like : 
+    *
+    *     "Internal Error : Please file a bug report .... "
+    *
+    * from this method for such cases in the release version of your parser.
+    */
+   public String getMessage() {
+      return super.getMessage();
+   }
+
+   /*
+    * Constructors of various flavors follow.
+    */
+
+   /** No arg constructor. */
+   public TokenMgrError() {
+   }
+
+   /** Constructor with message and reason. */
+   public TokenMgrError(String message, int reason) {
+      super(message);
+      errorCode = reason;
+   }
+
+   /** Full Constructor. */
+   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
+      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
+   }
+}
+/* JavaCC - OriginalChecksum=c0bde2b885c772c9db66b8a6b4f07329 (do not edit this line) */
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/BlockComment.java b/parser/html/java/javaparser/src/japa/parser/ast/BlockComment.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/BlockComment.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 23/05/2008
+ */
+package japa.parser.ast;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * <p>
+ * AST node that represent block comments.
+ * </p>
+ * Block comments can has multi lines and are delimited by "/&#42;" and
+ * "&#42;/".
+ * 
+ * @author Julio Vilmar Gesser
+ */
+public final class BlockComment extends Comment {
+
+    public BlockComment() {
+    }
+
+    public BlockComment(String content) {
+        super(content);
+    }
+
+    public BlockComment(int beginLine, int beginColumn, int endLine, int endColumn, String content) {
+        super(beginLine, beginColumn, endLine, endColumn, content);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/Comment.java b/parser/html/java/javaparser/src/japa/parser/ast/Comment.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/Comment.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 23/05/2008
+ */
+package japa.parser.ast;
+
+import japa.parser.ast.body.JavadocComment;
+
+/**
+ * Abstract class for all AST nodes that represent comments.
+ * 
+ * @see BlockComment
+ * @see LineComment
+ * @see JavadocComment
+ * @author Julio Vilmar Gesser
+ */
+public abstract class Comment extends Node {
+
+    private String content;
+
+    public Comment() {
+    }
+
+    public Comment(String content) {
+        this.content = content;
+    }
+
+    public Comment(int beginLine, int beginColumn, int endLine, int endColumn, String content) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.content = content;
+    }
+
+    /**
+     * Return the text of the comment.
+     * 
+     * @return text of the comment
+     */
+    public final String getContent() {
+        return content;
+    }
+
+    /**
+     * Sets the text of the comment.
+     * 
+     * @param content
+     *            the text of the comment to set
+     */
+    public void setContent(String content) {
+        this.content = content;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/CompilationUnit.java b/parser/html/java/javaparser/src/japa/parser/ast/CompilationUnit.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/CompilationUnit.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast;
+
+import japa.parser.ast.body.AnnotationDeclaration;
+import japa.parser.ast.body.ClassOrInterfaceDeclaration;
+import japa.parser.ast.body.EmptyTypeDeclaration;
+import japa.parser.ast.body.EnumDeclaration;
+import japa.parser.ast.body.JavadocComment;
+import japa.parser.ast.body.TypeDeclaration;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * <p>
+ * This class represents the entire compilation unit. Each java file denotes a
+ * compilation unit.
+ * </p>
+ * The CompilationUnit is constructed following the syntax:<br>
+ * <code>
+ * <table>
+ * <tr valign=baseline>
+ *   <td align=right>CompilationUnit</td>
+ *   <td align=center>::=</td>
+ *   <td align=left>
+ *   ( {@link PackageDeclaration} )?<br> 
+ *   ( {@link ImportDeclaration} )*<br>
+ *   ( {@link TypeDeclaration} )*<br>
+ *   </td>
+ * </tr>
+ * </table> 
+ * </code>
+ * 
+ * @author Julio Vilmar Gesser
+ */
+public final class CompilationUnit extends Node {
+
+    private PackageDeclaration pakage;
+
+    private List<ImportDeclaration> imports;
+
+    private List<TypeDeclaration> types;
+
+    private List<Comment> comments;
+
+    public CompilationUnit() {
+    }
+
+    public CompilationUnit(PackageDeclaration pakage, List<ImportDeclaration> imports, List<TypeDeclaration> types, List<Comment> comments) {
+        this.pakage = pakage;
+        this.imports = imports;
+        this.types = types;
+        this.comments = comments;
+    }
+
+    public CompilationUnit(int beginLine, int beginColumn, int endLine, int endColumn, PackageDeclaration pakage, List<ImportDeclaration> imports, List<TypeDeclaration> types, List<Comment> comments) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.pakage = pakage;
+        this.imports = imports;
+        this.types = types;
+        this.comments = comments;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    /**
+     * Return a list containing all comments declared in this compilation unit.
+     * Including javadocs, line comments and block comments of all types,
+     * inner-classes and other members.<br>
+     * If there is no comment, <code>null</code> is returned.
+     * 
+     * @return list with all comments of this compilation unit or
+     *         <code>null</code>
+     * @see JavadocComment
+     * @see LineComment
+     * @see BlockComment
+     */
+    public List<Comment> getComments() {
+        return comments;
+    }
+
+    /**
+     * Retrieves the list of imports declared in this compilation unit or
+     * <code>null</code> if there is no import.
+     * 
+     * @return the list of imports or <code>null</code> if there is no import
+     */
+    public List<ImportDeclaration> getImports() {
+        return imports;
+    }
+
+    /**
+     * Retrieves the package declaration of this compilation unit.<br>
+     * If this compilation unit has no package declaration (default package),
+     * <code>null</code> is returned.
+     * 
+     * @return the package declaration or <code>null</code>
+     */
+    public PackageDeclaration getPackage() {
+        return pakage;
+    }
+
+    /**
+     * Return the list of types declared in this compilation unit.<br>
+     * If there is no types declared, <code>null</code> is returned.
+     * 
+     * @return the list of types or <code>null</code> null if there is no type
+     * @see AnnotationDeclaration
+     * @see ClassOrInterfaceDeclaration
+     * @see EmptyTypeDeclaration
+     * @see EnumDeclaration
+     */
+    public List<TypeDeclaration> getTypes() {
+        return types;
+    }
+
+    /**
+     * Sets the list of comments of this compilation unit.
+     * 
+     * @param comments
+     *            the list of comments
+     */
+    public void setComments(List<Comment> comments) {
+        this.comments = comments;
+    }
+
+    /**
+     * Sets the list of imports of this compilation unit. The list is initially
+     * <code>null</code>.
+     * 
+     * @param imports
+     *            the list of imports
+     */
+    public void setImports(List<ImportDeclaration> imports) {
+        this.imports = imports;
+    }
+
+    /**
+     * Sets or clear the package declarations of this compilation unit.
+     * 
+     * @param pakage
+     *            the pakage declaration to set or <code>null</code> to default
+     *            package
+     */
+    public void setPackage(PackageDeclaration pakage) {
+        this.pakage = pakage;
+    }
+
+    /**
+     * Sets the list of types declared in this compilation unit.
+     * 
+     * @param types
+     *            the lis of types
+     */
+    public void setTypes(List<TypeDeclaration> types) {
+        this.types = types;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/ImportDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/ImportDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/ImportDeclaration.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast;
+
+import japa.parser.ast.expr.NameExpr;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * <p>
+ * This class represents a import declaration. Imports are optional for the
+ * {@link CompilationUnit}.
+ * </p>
+ * The ImportDeclaration is constructed following the syntax:<br>
+ * <code>
+ * <table>
+ * <tr valign=baseline>
+ *   <td align=right>ImportDeclaration</td>
+ *   <td align=center>::=</td>
+ *   <td align=left>
+ *       "import" ( "static" )? {@link NameExpr} ( "." "*" )? ";"
+ *   </td>
+ * </tr>
+ * </table> 
+ * </code>
+ * 
+ * @author Julio Vilmar Gesser
+ */
+public final class ImportDeclaration extends Node {
+
+    private NameExpr name;
+
+    private boolean static_;
+
+    private boolean asterisk;
+
+    public ImportDeclaration() {
+    }
+
+    public ImportDeclaration(NameExpr name, boolean isStatic, boolean isAsterisk) {
+        this.name = name;
+        this.static_ = isStatic;
+        this.asterisk = isAsterisk;
+    }
+
+    public ImportDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, NameExpr name, boolean isStatic, boolean isAsterisk) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.name = name;
+        this.static_ = isStatic;
+        this.asterisk = isAsterisk;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    /**
+     * Retrieves the name of the import.
+     * 
+     * @return the name of the import
+     */
+    public NameExpr getName() {
+        return name;
+    }
+
+    /**
+     * Return if the import ends with "*".
+     * 
+     * @return <code>true</code> if the import ends with "*", <code>false</code>
+     *         otherwise
+     */
+    public boolean isAsterisk() {
+        return asterisk;
+    }
+
+    /**
+     * Return if the import is static.
+     * 
+     * @return <code>true</code> if the import is static, <code>false</code>
+     *         otherwise
+     */
+    public boolean isStatic() {
+        return static_;
+    }
+
+    /**
+     * Sets if this import is asterisk.
+     * 
+     * @param asterisk
+     *            <code>true</code> if this import is asterisk
+     */
+    public void setAsterisk(boolean asterisk) {
+        this.asterisk = asterisk;
+    }
+
+    /**
+     * Sets the name this import.
+     * 
+     * @param name
+     *            the name to set
+     */
+    public void setName(NameExpr name) {
+        this.name = name;
+    }
+
+    /**
+     * Sets if this import is static.
+     * 
+     * @param static_
+     *            <code>true</code> if this import is static
+     */
+    public void setStatic(boolean static_) {
+        this.static_ = static_;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/LineComment.java b/parser/html/java/javaparser/src/japa/parser/ast/LineComment.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/LineComment.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 23/05/2008
+ */
+package japa.parser.ast;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * <p>
+ * AST node that represent line comments.
+ * </p>
+ * Line comments are started with "//" and finish at the end of the line ("\n").
+ * 
+ * @author Julio Vilmar Gesser
+ */
+public final class LineComment extends Comment {
+
+    public LineComment() {
+    }
+
+    public LineComment(String content) {
+        super(content);
+    }
+
+    public LineComment(int beginLine, int beginColumn, int endLine, int endColumn, String content) {
+        super(beginLine, beginColumn, endLine, endColumn, content);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/Node.java b/parser/html/java/javaparser/src/japa/parser/ast/Node.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/Node.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ *
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast;
+
+import japa.parser.ast.visitor.DumpVisitor;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * Abstract class for all nodes of the AST.
+ * 
+ * @author Julio Vilmar Gesser
+ */
+public abstract class Node {
+
+    private int beginLine;
+
+    private int beginColumn;
+
+    private int endLine;
+
+    private int endColumn;
+
+    /**
+     * This attribute can store additional information from semantic analysis.
+     */
+    private Object data;
+
+    public Node() {
+    }
+
+    public Node(int beginLine, int beginColumn, int endLine, int endColumn) {
+        this.beginLine = beginLine;
+        this.beginColumn = beginColumn;
+        this.endLine = endLine;
+        this.endColumn = endColumn;
+    }
+
+    /**
+     * Accept method for visitor support.
+     * 
+     * @param <R>
+     *            the type the return value of the visitor
+     * @param <A>
+     *            the type the argument passed for the visitor
+     * @param v
+     *            the visitor implementation
+     * @param arg
+     *            any value relevant for the visitor
+     * @return the result of the visit
+     */
+    public abstract <R, A> R accept(GenericVisitor<R, A> v, A arg);
+
+    /**
+     * Accept method for visitor support.
+     * 
+     * @param <A>
+     *            the type the argument passed for the visitor
+     * @param v
+     *            the visitor implementation
+     * @param arg
+     *            any value relevant for the visitor
+     */
+    public abstract <A> void accept(VoidVisitor<A> v, A arg);
+
+    /**
+     * Return the begin column of this node.
+     * 
+     * @return the begin column of this node
+     */
+    public final int getBeginColumn() {
+        return beginColumn;
+    }
+
+    /**
+     * Return the begin line of this node.
+     * 
+     * @return the begin line of this node
+     */
+    public final int getBeginLine() {
+        return beginLine;
+    }
+
+    /**
+     * Use this to retrieve additional information associated to this node.
+     */
+    public final Object getData() {
+        return data;
+    }
+
+    /**
+     * Return the end column of this node.
+     * 
+     * @return the end column of this node
+     */
+    public final int getEndColumn() {
+        return endColumn;
+    }
+
+    /**
+     * Return the end line of this node.
+     * 
+     * @return the end line of this node
+     */
+    public final int getEndLine() {
+        return endLine;
+    }
+
+    /**
+     * Sets the begin column of this node.
+     * 
+     * @param beginColumn
+     *            the begin column of this node
+     */
+    public final void setBeginColumn(int beginColumn) {
+        this.beginColumn = beginColumn;
+    }
+
+    /**
+     * Sets the begin line of this node.
+     * 
+     * @param beginLine
+     *            the begin line of this node
+     */
+    public final void setBeginLine(int beginLine) {
+        this.beginLine = beginLine;
+    }
+
+    /**
+     * Use this to store additional information to this node.
+     */
+    public final void setData(Object data) {
+        this.data = data;
+    }
+
+    /**
+     * Sets the end column of this node.
+     * 
+     * @param endColumn
+     *            the end column of this node
+     */
+    public final void setEndColumn(int endColumn) {
+        this.endColumn = endColumn;
+    }
+
+    /**
+     * Sets the end line of this node.
+     * 
+     * @param endLine
+     *            the end line of this node
+     */
+    public final void setEndLine(int endLine) {
+        this.endLine = endLine;
+    }
+
+    /**
+     * Return the String representation of this node.
+     * 
+     * @return the String representation of this node
+     */
+    @Override
+    public final String toString() {
+        DumpVisitor visitor = new DumpVisitor();
+        accept(visitor, null);
+        return visitor.getSource();
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/PackageDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/PackageDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/PackageDeclaration.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 17/10/2007
+ */
+package japa.parser.ast;
+
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.expr.NameExpr;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * <p>
+ * This class represents the package declaration. The package declaration is
+ * optional for the {@link CompilationUnit}.
+ * </p>
+ * The PackageDeclaration is constructed following the syntax:<br>
+ * <code>
+ * <table>
+ * <tr valign=baseline>
+ *   <td align=right>PackageDeclaration</td>
+ *   <td align=center>::=</td>
+ *   <td align=left>
+ *       ( {@link AnnotationExpr} )* "package" {@link NameExpr} ) ";"
+ *   </td>
+ * </tr>
+ * </table> 
+ * </code>
+ * 
+ * @author Julio Vilmar Gesser
+ */
+public final class PackageDeclaration extends Node {
+
+    private List<AnnotationExpr> annotations;
+
+    private NameExpr name;
+
+    public PackageDeclaration() {
+    }
+
+    public PackageDeclaration(NameExpr name) {
+        this.name = name;
+    }
+
+    public PackageDeclaration(List<AnnotationExpr> annotations, NameExpr name) {
+        this.annotations = annotations;
+        this.name = name;
+    }
+
+    public PackageDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, List<AnnotationExpr> annotations, NameExpr name) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.annotations = annotations;
+        this.name = name;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    /**
+     * Retrieves the list of annotations declared before the package
+     * declaration. Return <code>null</code> if there are no annotations.
+     * 
+     * @return list of annotations or <code>null</code>
+     */
+    public List<AnnotationExpr> getAnnotations() {
+        return annotations;
+    }
+
+    /**
+     * Return the name of the package.
+     * 
+     * @return the name of the package
+     */
+    public NameExpr getName() {
+        return name;
+    }
+
+    /**
+     * @param annotations
+     *            the annotations to set
+     */
+    public void setAnnotations(List<AnnotationExpr> annotations) {
+        this.annotations = annotations;
+    }
+
+    /**
+     * Sets the name of this package declaration.
+     * 
+     * @param name
+     *            the name to set
+     */
+    public void setName(NameExpr name) {
+        this.name = name;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/TypeParameter.java b/parser/html/java/javaparser/src/japa/parser/ast/TypeParameter.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/TypeParameter.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast;
+
+import japa.parser.ast.type.ClassOrInterfaceType;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * <p>
+ * This class represents the declaration of a genetics argument.
+ * </p>
+ * The TypeParameter is constructed following the syntax:<br>
+ * <code>
+ * <table>
+ * <tr valign=baseline>
+ *   <td align=right>TypeParameter</td>
+ *   <td align=center>::=</td>
+ *   <td align=left>
+ *       &lt;IDENTIFIER&gt; ( "extends" {@link ClassOrInterfaceType} ( "&" {@link ClassOrInterfaceType} )* )?
+ *   </td>
+ * </tr>
+ * </table> 
+ * </code>
+ * 
+ * @author Julio Vilmar Gesser
+ */
+public final class TypeParameter extends Node {
+
+    private String name;
+
+    private List<ClassOrInterfaceType> typeBound;
+
+    public TypeParameter() {
+    }
+
+    public TypeParameter(String name, List<ClassOrInterfaceType> typeBound) {
+        this.name = name;
+        this.typeBound = typeBound;
+    }
+
+    public TypeParameter(int beginLine, int beginColumn, int endLine, int endColumn, String name, List<ClassOrInterfaceType> typeBound) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.name = name;
+        this.typeBound = typeBound;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    /**
+     * Return the name of the paramenter.
+     * 
+     * @return the name of the paramenter
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Return the list of {@link ClassOrInterfaceType} that this parameter
+     * extends. Return <code>null</code> null if there are no type.
+     * 
+     * @return list of types that this paramente extends or <code>null</code>
+     */
+    public List<ClassOrInterfaceType> getTypeBound() {
+        return typeBound;
+    }
+
+    /**
+     * Sets the name of this type parameter.
+     * 
+     * @param name
+     *            the name to set
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /**
+     * Sets the list o types.
+     * 
+     * @param typeBound
+     *            the typeBound to set
+     */
+    public void setTypeBound(List<ClassOrInterfaceType> typeBound) {
+        this.typeBound = typeBound;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/AnnotationDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/body/AnnotationDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/AnnotationDeclaration.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 21/11/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class AnnotationDeclaration extends TypeDeclaration {
+
+    public AnnotationDeclaration() {
+    }
+
+    public AnnotationDeclaration(int modifiers, String name) {
+        super(modifiers, name);
+    }
+
+    public AnnotationDeclaration(JavadocComment javaDoc, int modifiers, List<AnnotationExpr> annotations, String name, List<BodyDeclaration> members) {
+        super(annotations, javaDoc, modifiers, name, members);
+    }
+
+    public AnnotationDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, JavadocComment javaDoc, int modifiers, List<AnnotationExpr> annotations, String name, List<BodyDeclaration> members) {
+        super(beginLine, beginColumn, endLine, endColumn, annotations, javaDoc, modifiers, name, members);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/AnnotationMemberDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/body/AnnotationMemberDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/AnnotationMemberDeclaration.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 21/11/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.type.Type;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class AnnotationMemberDeclaration extends BodyDeclaration {
+
+    private int modifiers;
+
+    private Type type;
+
+    private String name;
+
+    private Expression defaultValue;
+
+    public AnnotationMemberDeclaration() {
+    }
+
+    public AnnotationMemberDeclaration(int modifiers, Type type, String name, Expression defaultValue) {
+        this.modifiers = modifiers;
+        this.type = type;
+        this.name = name;
+        this.defaultValue = defaultValue;
+    }
+
+    public AnnotationMemberDeclaration(JavadocComment javaDoc, int modifiers, List<AnnotationExpr> annotations, Type type, String name, Expression defaultValue) {
+        super(annotations, javaDoc);
+        this.modifiers = modifiers;
+        this.type = type;
+        this.name = name;
+        this.defaultValue = defaultValue;
+    }
+
+    public AnnotationMemberDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, JavadocComment javaDoc, int modifiers, List<AnnotationExpr> annotations, Type type, String name, Expression defaultValue) {
+        super(beginLine, beginColumn, endLine, endColumn, annotations, javaDoc);
+        this.modifiers = modifiers;
+        this.type = type;
+        this.name = name;
+        this.defaultValue = defaultValue;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getDefaultValue() {
+        return defaultValue;
+    }
+
+    /**
+     * Return the modifiers of this member declaration.
+     * 
+     * @see ModifierSet
+     * @return modifiers
+     */
+    public int getModifiers() {
+        return modifiers;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    public void setDefaultValue(Expression defaultValue) {
+        this.defaultValue = defaultValue;
+    }
+
+    public void setModifiers(int modifiers) {
+        this.modifiers = modifiers;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/BodyDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/body/BodyDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/BodyDeclaration.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.Node;
+import japa.parser.ast.expr.AnnotationExpr;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public abstract class BodyDeclaration extends Node {
+
+    private JavadocComment javaDoc;
+
+    private List<AnnotationExpr> annotations;
+
+    public BodyDeclaration() {
+    }
+
+    public BodyDeclaration(List<AnnotationExpr> annotations, JavadocComment javaDoc) {
+        this.javaDoc = javaDoc;
+        this.annotations = annotations;
+    }
+
+    public BodyDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, List<AnnotationExpr> annotations, JavadocComment javaDoc) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.javaDoc = javaDoc;
+        this.annotations = annotations;
+    }
+
+    public final JavadocComment getJavaDoc() {
+        return javaDoc;
+    }
+
+    public final List<AnnotationExpr> getAnnotations() {
+        return annotations;
+    }
+
+    public final void setJavaDoc(JavadocComment javaDoc) {
+        this.javaDoc = javaDoc;
+    }
+
+    public final void setAnnotations(List<AnnotationExpr> annotations) {
+        this.annotations = annotations;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/ClassOrInterfaceDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/body/ClassOrInterfaceDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/ClassOrInterfaceDeclaration.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.TypeParameter;
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.type.ClassOrInterfaceType;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ClassOrInterfaceDeclaration extends TypeDeclaration {
+
+    private boolean interface_;
+
+    private List<TypeParameter> typeParameters;
+
+    private List<ClassOrInterfaceType> extendsList;
+
+    private List<ClassOrInterfaceType> implementsList;
+
+    public ClassOrInterfaceDeclaration() {
+    }
+
+    public ClassOrInterfaceDeclaration(int modifiers, boolean isInterface, String name) {
+        super(modifiers, name);
+        this.interface_ = isInterface;
+    }
+
+    public ClassOrInterfaceDeclaration(JavadocComment javaDoc, int modifiers, List<AnnotationExpr> annotations, boolean isInterface, String name, List<TypeParameter> typeParameters, List<ClassOrInterfaceType> extendsList, List<ClassOrInterfaceType> implementsList, List<BodyDeclaration> members) {
+        super(annotations, javaDoc, modifiers, name, members);
+        this.interface_ = isInterface;
+        this.typeParameters = typeParameters;
+        this.extendsList = extendsList;
+        this.implementsList = implementsList;
+    }
+
+    public ClassOrInterfaceDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, JavadocComment javaDoc, int modifiers, List<AnnotationExpr> annotations, boolean isInterface, String name, List<TypeParameter> typeParameters, List<ClassOrInterfaceType> extendsList, List<ClassOrInterfaceType> implementsList, List<BodyDeclaration> members) {
+        super(beginLine, beginColumn, endLine, endColumn, annotations, javaDoc, modifiers, name, members);
+        this.interface_ = isInterface;
+        this.typeParameters = typeParameters;
+        this.extendsList = extendsList;
+        this.implementsList = implementsList;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public List<ClassOrInterfaceType> getExtends() {
+        return extendsList;
+    }
+
+    public List<ClassOrInterfaceType> getImplements() {
+        return implementsList;
+    }
+
+    public List<TypeParameter> getTypeParameters() {
+        return typeParameters;
+    }
+
+    public boolean isInterface() {
+        return interface_;
+    }
+
+    public void setExtends(List<ClassOrInterfaceType> extendsList) {
+        this.extendsList = extendsList;
+    }
+
+    public void setImplements(List<ClassOrInterfaceType> implementsList) {
+        this.implementsList = implementsList;
+    }
+
+    public void setInterface(boolean interface_) {
+        this.interface_ = interface_;
+    }
+
+    public void setTypeParameters(List<TypeParameter> typeParameters) {
+        this.typeParameters = typeParameters;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/ConstructorDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/body/ConstructorDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/ConstructorDeclaration.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.TypeParameter;
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.expr.NameExpr;
+import japa.parser.ast.stmt.BlockStmt;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ConstructorDeclaration extends BodyDeclaration {
+
+    private int modifiers;
+
+    private List<TypeParameter> typeParameters;
+
+    private String name;
+
+    private List<Parameter> parameters;
+
+    private List<NameExpr> throws_;
+
+    private BlockStmt block;
+
+    public ConstructorDeclaration() {
+    }
+
+    public ConstructorDeclaration(int modifiers, String name) {
+        this.modifiers = modifiers;
+        this.name = name;
+    }
+
+    public ConstructorDeclaration(JavadocComment javaDoc, int modifiers, List<AnnotationExpr> annotations, List<TypeParameter> typeParameters, String name, List<Parameter> parameters, List<NameExpr> throws_, BlockStmt block) {
+        super(annotations, javaDoc);
+        this.modifiers = modifiers;
+        this.typeParameters = typeParameters;
+        this.name = name;
+        this.parameters = parameters;
+        this.throws_ = throws_;
+        this.block = block;
+    }
+
+    public ConstructorDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, JavadocComment javaDoc, int modifiers, List<AnnotationExpr> annotations, List<TypeParameter> typeParameters, String name, List<Parameter> parameters, List<NameExpr> throws_, BlockStmt block) {
+        super(beginLine, beginColumn, endLine, endColumn, annotations, javaDoc);
+        this.modifiers = modifiers;
+        this.typeParameters = typeParameters;
+        this.name = name;
+        this.parameters = parameters;
+        this.throws_ = throws_;
+        this.block = block;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public BlockStmt getBlock() {
+        return block;
+    }
+
+    /**
+     * Return the modifiers of this member declaration.
+     * 
+     * @see ModifierSet
+     * @return modifiers
+     */
+    public int getModifiers() {
+        return modifiers;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public List<Parameter> getParameters() {
+        return parameters;
+    }
+
+    public List<NameExpr> getThrows() {
+        return throws_;
+    }
+
+    public List<TypeParameter> getTypeParameters() {
+        return typeParameters;
+    }
+
+    public void setBlock(BlockStmt block) {
+        this.block = block;
+    }
+
+    public void setModifiers(int modifiers) {
+        this.modifiers = modifiers;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public void setParameters(List<Parameter> parameters) {
+        this.parameters = parameters;
+    }
+
+    public void setThrows(List<NameExpr> throws_) {
+        this.throws_ = throws_;
+    }
+
+    public void setTypeParameters(List<TypeParameter> typeParameters) {
+        this.typeParameters = typeParameters;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/EmptyMemberDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/body/EmptyMemberDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/EmptyMemberDeclaration.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 07/11/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class EmptyMemberDeclaration extends BodyDeclaration {
+
+    public EmptyMemberDeclaration() {
+    }
+
+    public EmptyMemberDeclaration(JavadocComment javaDoc) {
+        super(null, javaDoc);
+    }
+
+    public EmptyMemberDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, JavadocComment javaDoc) {
+        super(beginLine, beginColumn, endLine, endColumn, null, javaDoc);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/EmptyTypeDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/body/EmptyTypeDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/EmptyTypeDeclaration.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 20/01/2007
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class EmptyTypeDeclaration extends TypeDeclaration {
+
+    public EmptyTypeDeclaration() {
+    }
+
+    public EmptyTypeDeclaration(JavadocComment javaDoc) {
+        super(null, javaDoc, 0, null, null);
+    }
+
+    public EmptyTypeDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, JavadocComment javaDoc) {
+        super(beginLine, beginColumn, endLine, endColumn, null, javaDoc, 0, null, null);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/EnumConstantDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/body/EnumConstantDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/EnumConstantDeclaration.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/11/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class EnumConstantDeclaration extends BodyDeclaration {
+
+    private String name;
+
+    private List<Expression> args;
+
+    private List<BodyDeclaration> classBody;
+
+    public EnumConstantDeclaration() {
+    }
+
+    public EnumConstantDeclaration(String name) {
+        this.name = name;
+    }
+
+    public EnumConstantDeclaration(JavadocComment javaDoc, List<AnnotationExpr> annotations, String name, List<Expression> args, List<BodyDeclaration> classBody) {
+        super(annotations, javaDoc);
+        this.name = name;
+        this.args = args;
+        this.classBody = classBody;
+    }
+
+    public EnumConstantDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, JavadocComment javaDoc, List<AnnotationExpr> annotations, String name, List<Expression> args, List<BodyDeclaration> classBody) {
+        super(beginLine, beginColumn, endLine, endColumn, annotations, javaDoc);
+        this.name = name;
+        this.args = args;
+        this.classBody = classBody;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public List<Expression> getArgs() {
+        return args;
+    }
+
+    public List<BodyDeclaration> getClassBody() {
+        return classBody;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setArgs(List<Expression> args) {
+        this.args = args;
+    }
+
+    public void setClassBody(List<BodyDeclaration> classBody) {
+        this.classBody = classBody;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/EnumDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/body/EnumDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/EnumDeclaration.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.type.ClassOrInterfaceType;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class EnumDeclaration extends TypeDeclaration {
+
+    private List<ClassOrInterfaceType> implementsList;
+
+    private List<EnumConstantDeclaration> entries;
+
+    public EnumDeclaration() {
+    }
+
+    public EnumDeclaration(int modifiers, String name) {
+        super(modifiers, name);
+    }
+
+    public EnumDeclaration(JavadocComment javaDoc, int modifiers, List<AnnotationExpr> annotations, String name, List<ClassOrInterfaceType> implementsList, List<EnumConstantDeclaration> entries, List<BodyDeclaration> members) {
+        super(annotations, javaDoc, modifiers, name, members);
+        this.implementsList = implementsList;
+        this.entries = entries;
+    }
+
+    public EnumDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, JavadocComment javaDoc, int modifiers, List<AnnotationExpr> annotations, String name, List<ClassOrInterfaceType> implementsList, List<EnumConstantDeclaration> entries, List<BodyDeclaration> members) {
+        super(beginLine, beginColumn, endLine, endColumn, annotations, javaDoc, modifiers, name, members);
+        this.implementsList = implementsList;
+        this.entries = entries;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public List<EnumConstantDeclaration> getEntries() {
+        return entries;
+    }
+
+    public List<ClassOrInterfaceType> getImplements() {
+        return implementsList;
+    }
+
+    public void setEntries(List<EnumConstantDeclaration> entries) {
+        this.entries = entries;
+    }
+
+    public void setImplements(List<ClassOrInterfaceType> implementsList) {
+        this.implementsList = implementsList;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/FieldDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/body/FieldDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/FieldDeclaration.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.type.Type;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class FieldDeclaration extends BodyDeclaration {
+
+    private int modifiers;
+
+    private Type type;
+
+    private List<VariableDeclarator> variables;
+
+    public FieldDeclaration() {
+    }
+
+    public FieldDeclaration(int modifiers, Type type, VariableDeclarator variable) {
+        this.modifiers = modifiers;
+        this.type = type;
+        this.variables = new ArrayList<VariableDeclarator>();
+        this.variables.add(variable);
+    }
+
+    public FieldDeclaration(int modifiers, Type type, List<VariableDeclarator> variables) {
+        this.modifiers = modifiers;
+        this.type = type;
+        this.variables = variables;
+    }
+
+    public FieldDeclaration(JavadocComment javaDoc, int modifiers, List<AnnotationExpr> annotations, Type type, List<VariableDeclarator> variables) {
+        super(annotations, javaDoc);
+        this.modifiers = modifiers;
+        this.type = type;
+        this.variables = variables;
+    }
+
+    public FieldDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, JavadocComment javaDoc, int modifiers, List<AnnotationExpr> annotations, Type type, List<VariableDeclarator> variables) {
+        super(beginLine, beginColumn, endLine, endColumn, annotations, javaDoc);
+        this.modifiers = modifiers;
+        this.type = type;
+        this.variables = variables;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    /**
+     * Return the modifiers of this member declaration.
+     * 
+     * @see ModifierSet
+     * @return modifiers
+     */
+    public int getModifiers() {
+        return modifiers;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    public List<VariableDeclarator> getVariables() {
+        return variables;
+    }
+
+    public void setModifiers(int modifiers) {
+        this.modifiers = modifiers;
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+    }
+
+    public void setVariables(List<VariableDeclarator> variables) {
+        this.variables = variables;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/InitializerDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/body/InitializerDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/InitializerDeclaration.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 07/11/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.stmt.BlockStmt;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class InitializerDeclaration extends BodyDeclaration {
+
+    private boolean isStatic;
+
+    private BlockStmt block;
+
+    public InitializerDeclaration() {
+    }
+
+    public InitializerDeclaration(boolean isStatic, BlockStmt block) {
+        this.isStatic = isStatic;
+        this.block = block;
+    }
+
+    public InitializerDeclaration(JavadocComment javaDoc, boolean isStatic, BlockStmt block) {
+        super(null, javaDoc);
+        this.isStatic = isStatic;
+        this.block = block;
+    }
+
+    public InitializerDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, JavadocComment javaDoc, boolean isStatic, BlockStmt block) {
+        super(beginLine, beginColumn, endLine, endColumn, null, javaDoc);
+        this.isStatic = isStatic;
+        this.block = block;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public BlockStmt getBlock() {
+        return block;
+    }
+
+    public boolean isStatic() {
+        return isStatic;
+    }
+
+    public void setBlock(BlockStmt block) {
+        this.block = block;
+    }
+
+    public void setStatic(boolean isStatic) {
+        this.isStatic = isStatic;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/JavadocComment.java b/parser/html/java/javaparser/src/japa/parser/ast/body/JavadocComment.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/JavadocComment.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 23/05/2008
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.Comment;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class JavadocComment extends Comment {
+
+    public JavadocComment() {
+    }
+
+    public JavadocComment(String content) {
+        super(content);
+    }
+
+    public JavadocComment(int beginLine, int beginColumn, int endLine, int endColumn, String content) {
+        super(beginLine, beginColumn, endLine, endColumn, content);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/MethodDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/body/MethodDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/MethodDeclaration.java
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.TypeParameter;
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.expr.NameExpr;
+import japa.parser.ast.stmt.BlockStmt;
+import japa.parser.ast.type.Type;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class MethodDeclaration extends BodyDeclaration {
+
+    private int modifiers;
+
+    private List<TypeParameter> typeParameters;
+
+    private Type type;
+
+    private String name;
+
+    private List<Parameter> parameters;
+
+    private int arrayCount;
+
+    private List<NameExpr> throws_;
+
+    private BlockStmt body;
+
+    public MethodDeclaration() {
+    }
+
+    public MethodDeclaration(int modifiers, Type type, String name) {
+        this.modifiers = modifiers;
+        this.type = type;
+        this.name = name;
+    }
+
+    public MethodDeclaration(int modifiers, Type type, String name, List<Parameter> parameters) {
+        this.modifiers = modifiers;
+        this.type = type;
+        this.name = name;
+        this.parameters = parameters;
+    }
+
+    public MethodDeclaration(JavadocComment javaDoc, int modifiers, List<AnnotationExpr> annotations, List<TypeParameter> typeParameters, Type type, String name, List<Parameter> parameters, int arrayCount, List<NameExpr> throws_, BlockStmt block) {
+        super(annotations, javaDoc);
+        this.modifiers = modifiers;
+        this.typeParameters = typeParameters;
+        this.type = type;
+        this.name = name;
+        this.parameters = parameters;
+        this.arrayCount = arrayCount;
+        this.throws_ = throws_;
+        this.body = block;
+    }
+
+    public MethodDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, JavadocComment javaDoc, int modifiers, List<AnnotationExpr> annotations, List<TypeParameter> typeParameters, Type type, String name, List<Parameter> parameters, int arrayCount, List<NameExpr> throws_, BlockStmt block) {
+        super(beginLine, beginColumn, endLine, endColumn, annotations, javaDoc);
+        this.modifiers = modifiers;
+        this.typeParameters = typeParameters;
+        this.type = type;
+        this.name = name;
+        this.parameters = parameters;
+        this.arrayCount = arrayCount;
+        this.throws_ = throws_;
+        this.body = block;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public int getArrayCount() {
+        return arrayCount;
+    }
+
+    public BlockStmt getBody() {
+        return body;
+    }
+
+    /**
+     * Return the modifiers of this member declaration.
+     * 
+     * @see ModifierSet
+     * @return modifiers
+     */
+    public int getModifiers() {
+        return modifiers;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public List<Parameter> getParameters() {
+        return parameters;
+    }
+
+    public List<NameExpr> getThrows() {
+        return throws_;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    public List<TypeParameter> getTypeParameters() {
+        return typeParameters;
+    }
+
+    public void setArrayCount(int arrayCount) {
+        this.arrayCount = arrayCount;
+    }
+
+    public void setBody(BlockStmt body) {
+        this.body = body;
+    }
+
+    public void setModifiers(int modifiers) {
+        this.modifiers = modifiers;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public void setParameters(List<Parameter> parameters) {
+        this.parameters = parameters;
+    }
+
+    public void setThrows(List<NameExpr> throws_) {
+        this.throws_ = throws_;
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+    }
+
+    public void setTypeParameters(List<TypeParameter> typeParameters) {
+        this.typeParameters = typeParameters;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/ModifierSet.java b/parser/html/java/javaparser/src/japa/parser/ast/body/ModifierSet.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/ModifierSet.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package japa.parser.ast.body;
+
+/**
+ * Class to hold modifiers.
+ */
+public final class ModifierSet {
+
+    /* Definitions of the bits in the modifiers field.  */
+    public static final int PUBLIC = 0x0001;
+
+    public static final int PROTECTED = 0x0002;
+
+    public static final int PRIVATE = 0x0004;
+
+    public static final int ABSTRACT = 0x0008;
+
+    public static final int STATIC = 0x0010;
+
+    public static final int FINAL = 0x0020;
+
+    public static final int SYNCHRONIZED = 0x0040;
+
+    public static final int NATIVE = 0x0080;
+
+    public static final int TRANSIENT = 0x0100;
+
+    public static final int VOLATILE = 0x0200;
+
+    public static final int STRICTFP = 0x1000;
+
+    /**
+     * Adds the given modifier.
+     */
+    public static int addModifier(int modifiers, int mod) {
+        return modifiers |= mod;
+    }
+
+    public static boolean hasModifier(int modifiers, int modifier) {
+        return (modifiers & modifier) != 0;
+    }
+
+    public static boolean isAbstract(int modifiers) {
+        return (modifiers & ABSTRACT) != 0;
+    }
+
+    public static boolean isFinal(int modifiers) {
+        return (modifiers & FINAL) != 0;
+    }
+
+    public static boolean isNative(int modifiers) {
+        return (modifiers & NATIVE) != 0;
+    }
+
+    public static boolean isPrivate(int modifiers) {
+        return (modifiers & PRIVATE) != 0;
+    }
+
+    public static boolean isProtected(int modifiers) {
+        return (modifiers & PROTECTED) != 0;
+    }
+
+    /**
+     * A set of accessors that indicate whether the specified modifier is in the
+     * set.
+     */
+
+    public static boolean isPublic(int modifiers) {
+        return (modifiers & PUBLIC) != 0;
+    }
+
+    public static boolean isStatic(int modifiers) {
+        return (modifiers & STATIC) != 0;
+    }
+
+    public static boolean isStrictfp(int modifiers) {
+        return (modifiers & STRICTFP) != 0;
+    }
+
+    public static boolean isSynchronized(int modifiers) {
+        return (modifiers & SYNCHRONIZED) != 0;
+    }
+
+    public static boolean isTransient(int modifiers) {
+        return (modifiers & TRANSIENT) != 0;
+    }
+
+    public static boolean isVolatile(int modifiers) {
+        return (modifiers & VOLATILE) != 0;
+    }
+
+    /**
+     * Removes the given modifier.
+     */
+    public static int removeModifier(int modifiers, int mod) {
+        return modifiers &= ~mod;
+    }
+
+    private ModifierSet() {
+    }
+}
\ No newline at end of file
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/Parameter.java b/parser/html/java/javaparser/src/japa/parser/ast/body/Parameter.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/Parameter.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 03/11/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.Node;
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.type.Type;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class Parameter extends Node {
+
+    private int modifiers;
+
+    private List<AnnotationExpr> annotations;
+
+    private Type type;
+
+    private boolean isVarArgs;
+
+    private VariableDeclaratorId id;
+
+    public Parameter() {
+    }
+
+    public Parameter(Type type, VariableDeclaratorId id) {
+        this.type = type;
+        this.id = id;
+    }
+
+    public Parameter(int modifiers, Type type, VariableDeclaratorId id) {
+        this.modifiers = modifiers;
+        this.type = type;
+        this.id = id;
+    }
+
+    public Parameter(int beginLine, int beginColumn, int endLine, int endColumn, int modifiers, List<AnnotationExpr> annotations, Type type, boolean isVarArgs, VariableDeclaratorId id) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.modifiers = modifiers;
+        this.annotations = annotations;
+        this.type = type;
+        this.isVarArgs = isVarArgs;
+        this.id = id;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public List<AnnotationExpr> getAnnotations() {
+        return annotations;
+    }
+
+    public VariableDeclaratorId getId() {
+        return id;
+    }
+
+    /**
+     * Return the modifiers of this parameter declaration.
+     * 
+     * @see ModifierSet
+     * @return modifiers
+     */
+    public int getModifiers() {
+        return modifiers;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    public boolean isVarArgs() {
+        return isVarArgs;
+    }
+
+    public void setAnnotations(List<AnnotationExpr> annotations) {
+        this.annotations = annotations;
+    }
+
+    public void setId(VariableDeclaratorId id) {
+        this.id = id;
+    }
+
+    public void setModifiers(int modifiers) {
+        this.modifiers = modifiers;
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+    }
+
+    public void setVarArgs(boolean isVarArgs) {
+        this.isVarArgs = isVarArgs;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/TypeDeclaration.java b/parser/html/java/javaparser/src/japa/parser/ast/body/TypeDeclaration.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/TypeDeclaration.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.expr.AnnotationExpr;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public abstract class TypeDeclaration extends BodyDeclaration {
+
+    private String name;
+
+    private int modifiers;
+
+    private List<BodyDeclaration> members;
+
+    public TypeDeclaration() {
+    }
+
+    public TypeDeclaration(int modifiers, String name) {
+        this.name = name;
+        this.modifiers = modifiers;
+    }
+
+    public TypeDeclaration(List<AnnotationExpr> annotations, JavadocComment javaDoc, int modifiers, String name, List<BodyDeclaration> members) {
+        super(annotations, javaDoc);
+        this.name = name;
+        this.modifiers = modifiers;
+        this.members = members;
+    }
+
+    public TypeDeclaration(int beginLine, int beginColumn, int endLine, int endColumn, List<AnnotationExpr> annotations, JavadocComment javaDoc, int modifiers, String name, List<BodyDeclaration> members) {
+        super(beginLine, beginColumn, endLine, endColumn, annotations, javaDoc);
+        this.name = name;
+        this.modifiers = modifiers;
+        this.members = members;
+    }
+
+    public final List<BodyDeclaration> getMembers() {
+        return members;
+    }
+
+    /**
+     * Return the modifiers of this type declaration.
+     * 
+     * @see ModifierSet
+     * @return modifiers
+     */
+    public final int getModifiers() {
+        return modifiers;
+    }
+
+    public final String getName() {
+        return name;
+    }
+
+    public void setMembers(List<BodyDeclaration> members) {
+        this.members = members;
+    }
+
+    public final void setModifiers(int modifiers) {
+        this.modifiers = modifiers;
+    }
+
+    public final void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/VariableDeclarator.java b/parser/html/java/javaparser/src/japa/parser/ast/body/VariableDeclarator.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/VariableDeclarator.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.Node;
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class VariableDeclarator extends Node {
+
+    private VariableDeclaratorId id;
+
+    private Expression init;
+
+    public VariableDeclarator() {
+    }
+
+    public VariableDeclarator(VariableDeclaratorId id) {
+        this.id = id;
+    }
+
+    public VariableDeclarator(VariableDeclaratorId id, Expression init) {
+        this.id = id;
+        this.init = init;
+    }
+
+    public VariableDeclarator(int beginLine, int beginColumn, int endLine, int endColumn, VariableDeclaratorId id, Expression init) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.id = id;
+        this.init = init;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public VariableDeclaratorId getId() {
+        return id;
+    }
+
+    public Expression getInit() {
+        return init;
+    }
+
+    public void setId(VariableDeclaratorId id) {
+        this.id = id;
+    }
+
+    public void setInit(Expression init) {
+        this.init = init;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/body/VariableDeclaratorId.java b/parser/html/java/javaparser/src/japa/parser/ast/body/VariableDeclaratorId.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/body/VariableDeclaratorId.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.body;
+
+import japa.parser.ast.Node;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class VariableDeclaratorId extends Node {
+
+    private String name;
+
+    private int arrayCount;
+
+    public VariableDeclaratorId() {
+    }
+
+    public VariableDeclaratorId(String name) {
+        this.name = name;
+    }
+
+    public VariableDeclaratorId(int beginLine, int beginColumn, int endLine, int endColumn, String name, int arrayCount) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.name = name;
+        this.arrayCount = arrayCount;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public int getArrayCount() {
+        return arrayCount;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setArrayCount(int arrayCount) {
+        this.arrayCount = arrayCount;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/AnnotationExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/AnnotationExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/AnnotationExpr.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 21/11/2006
+ */
+package japa.parser.ast.expr;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public abstract class AnnotationExpr extends Expression {
+
+    public AnnotationExpr() {
+    }
+
+    public AnnotationExpr(int beginLine, int beginColumn, int endLine, int endColumn) {
+        super(beginLine, beginColumn, endLine, endColumn);
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/ArrayAccessExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/ArrayAccessExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/ArrayAccessExpr.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ArrayAccessExpr extends Expression {
+
+    private Expression name;
+
+    private Expression index;
+
+    public ArrayAccessExpr() {
+    }
+
+    public ArrayAccessExpr(Expression name, Expression index) {
+        this.name = name;
+        this.index = index;
+    }
+
+    public ArrayAccessExpr(int beginLine, int beginColumn, int endLine, int endColumn, Expression name, Expression index) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.name = name;
+        this.index = index;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getIndex() {
+        return index;
+    }
+
+    public Expression getName() {
+        return name;
+    }
+
+    public void setIndex(Expression index) {
+        this.index = index;
+    }
+
+    public void setName(Expression name) {
+        this.name = name;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/ArrayCreationExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/ArrayCreationExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/ArrayCreationExpr.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.type.Type;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ArrayCreationExpr extends Expression {
+
+    private Type type;
+
+    private int arrayCount;
+
+    private ArrayInitializerExpr initializer;
+
+    private List<Expression> dimensions;
+
+    public ArrayCreationExpr() {
+    }
+
+    public ArrayCreationExpr(Type type, int arrayCount, ArrayInitializerExpr initializer) {
+        this.type = type;
+        this.arrayCount = arrayCount;
+        this.initializer = initializer;
+        this.dimensions = null;
+    }
+
+    public ArrayCreationExpr(int beginLine, int beginColumn, int endLine, int endColumn, Type type, int arrayCount, ArrayInitializerExpr initializer) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.type = type;
+        this.arrayCount = arrayCount;
+        this.initializer = initializer;
+        this.dimensions = null;
+    }
+
+    public ArrayCreationExpr(Type type, List<Expression> dimensions, int arrayCount) {
+        this.type = type;
+        this.arrayCount = arrayCount;
+        this.dimensions = dimensions;
+        this.initializer = null;
+    }
+
+    public ArrayCreationExpr(int beginLine, int beginColumn, int endLine, int endColumn, Type type, List<Expression> dimensions, int arrayCount) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.type = type;
+        this.arrayCount = arrayCount;
+        this.dimensions = dimensions;
+        this.initializer = null;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public int getArrayCount() {
+        return arrayCount;
+    }
+
+    public List<Expression> getDimensions() {
+        return dimensions;
+    }
+
+    public ArrayInitializerExpr getInitializer() {
+        return initializer;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    public void setArrayCount(int arrayCount) {
+        this.arrayCount = arrayCount;
+    }
+
+    public void setDimensions(List<Expression> dimensions) {
+        this.dimensions = dimensions;
+    }
+
+    public void setInitializer(ArrayInitializerExpr initializer) {
+        this.initializer = initializer;
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/ArrayInitializerExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/ArrayInitializerExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/ArrayInitializerExpr.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ArrayInitializerExpr extends Expression {
+
+    private List<Expression> values;
+
+    public ArrayInitializerExpr() {
+    }
+
+    public ArrayInitializerExpr(List<Expression> values) {
+        this.values = values;
+    }
+
+    public ArrayInitializerExpr(int beginLine, int beginColumn, int endLine, int endColumn, List<Expression> values) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.values = values;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public List<Expression> getValues() {
+        return values;
+    }
+
+    public void setValues(List<Expression> values) {
+        this.values = values;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/AssignExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/AssignExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/AssignExpr.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class AssignExpr extends Expression {
+
+    public static enum Operator {
+        assign, // =
+        plus, // +=
+        minus, // -=
+        star, // *=
+        slash, // /=
+        and, // &=
+        or, // |=
+        xor, // ^=
+        rem, // %=
+        lShift, // <<=
+        rSignedShift, // >>=
+        rUnsignedShift, // >>>=
+    }
+
+    private Expression target;
+
+    private Expression value;
+
+    private Operator op;
+
+    public AssignExpr() {
+    }
+
+    public AssignExpr(Expression target, Expression value, Operator op) {
+        this.target = target;
+        this.value = value;
+        this.op = op;
+    }
+
+    public AssignExpr(int beginLine, int beginColumn, int endLine, int endColumn, Expression target, Expression value, Operator op) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.target = target;
+        this.value = value;
+        this.op = op;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Operator getOperator() {
+        return op;
+    }
+
+    public Expression getTarget() {
+        return target;
+    }
+
+    public Expression getValue() {
+        return value;
+    }
+
+    public void setOperator(Operator op) {
+        this.op = op;
+    }
+
+    public void setTarget(Expression target) {
+        this.target = target;
+    }
+
+    public void setValue(Expression value) {
+        this.value = value;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/BinaryExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/BinaryExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/BinaryExpr.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class BinaryExpr extends Expression {
+
+    public static enum Operator {
+        or, // ||
+        and, // &&
+        binOr, // |
+        binAnd, // &
+        xor, // ^
+        equals, // ==
+        notEquals, // !=
+        less, // <
+        greater, // >
+        lessEquals, // <=
+        greaterEquals, // >=
+        lShift, // <<
+        rSignedShift, // >>
+        rUnsignedShift, // >>>
+        plus, // +
+        minus, // -
+        times, // *
+        divide, // /
+        remainder, // %
+    }
+
+    private Expression left;
+
+    private Expression right;
+
+    private Operator op;
+
+    public BinaryExpr() {
+    }
+
+    public BinaryExpr(Expression left, Expression right, Operator op) {
+        this.left = left;
+        this.right = right;
+        this.op = op;
+    }
+
+    public BinaryExpr(int beginLine, int beginColumn, int endLine, int endColumn, Expression left, Expression right, Operator op) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.left = left;
+        this.right = right;
+        this.op = op;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getLeft() {
+        return left;
+    }
+
+    public Operator getOperator() {
+        return op;
+    }
+
+    public Expression getRight() {
+        return right;
+    }
+
+    public void setLeft(Expression left) {
+        this.left = left;
+    }
+
+    public void setOperator(Operator op) {
+        this.op = op;
+    }
+
+    public void setRight(Expression right) {
+        this.right = right;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/BooleanLiteralExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/BooleanLiteralExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/BooleanLiteralExpr.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 02/03/2007
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class BooleanLiteralExpr extends LiteralExpr {
+
+    private boolean value;
+
+    public BooleanLiteralExpr() {
+    }
+
+    public BooleanLiteralExpr(boolean value) {
+        this.value = value;
+    }
+
+    public BooleanLiteralExpr(int beginLine, int beginColumn, int endLine, int endColumn, boolean value) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.value = value;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public boolean getValue() {
+        return value;
+    }
+
+    public void setValue(boolean value) {
+        this.value = value;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/CastExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/CastExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/CastExpr.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.type.Type;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class CastExpr extends Expression {
+
+    private Type type;
+
+    private Expression expr;
+
+    public CastExpr() {
+    }
+
+    public CastExpr(Type type, Expression expr) {
+        this.type = type;
+        this.expr = expr;
+    }
+
+    public CastExpr(int beginLine, int beginColumn, int endLine, int endColumn, Type type, Expression expr) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.type = type;
+        this.expr = expr;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getExpr() {
+        return expr;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    public void setExpr(Expression expr) {
+        this.expr = expr;
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/CharLiteralExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/CharLiteralExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/CharLiteralExpr.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 02/03/2007
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class CharLiteralExpr extends StringLiteralExpr {
+
+    public CharLiteralExpr() {
+    }
+
+    public CharLiteralExpr(String value) {
+        super(value);
+    }
+
+    public CharLiteralExpr(int beginLine, int beginColumn, int endLine, int endColumn, String value) {
+        super(beginLine, beginColumn, endLine, endColumn, value);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/ClassExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/ClassExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/ClassExpr.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.type.Type;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ClassExpr extends Expression {
+
+    private Type type;
+
+    public ClassExpr() {
+    }
+
+    public ClassExpr(Type type) {
+        this.type = type;
+    }
+
+    public ClassExpr(int beginLine, int beginColumn, int endLine, int endColumn, Type type) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.type = type;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/ConditionalExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/ConditionalExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/ConditionalExpr.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ConditionalExpr extends Expression {
+
+    private Expression condition;
+
+    private Expression thenExpr;
+
+    private Expression elseExpr;
+
+    public ConditionalExpr() {
+    }
+
+    public ConditionalExpr(Expression condition, Expression thenExpr, Expression elseExpr) {
+        this.condition = condition;
+        this.thenExpr = thenExpr;
+        this.elseExpr = elseExpr;
+    }
+
+    public ConditionalExpr(int beginLine, int beginColumn, int endLine, int endColumn, Expression condition, Expression thenExpr, Expression elseExpr) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.condition = condition;
+        this.thenExpr = thenExpr;
+        this.elseExpr = elseExpr;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getCondition() {
+        return condition;
+    }
+
+    public Expression getElseExpr() {
+        return elseExpr;
+    }
+
+    public Expression getThenExpr() {
+        return thenExpr;
+    }
+
+    public void setCondition(Expression condition) {
+        this.condition = condition;
+    }
+
+    public void setElseExpr(Expression elseExpr) {
+        this.elseExpr = elseExpr;
+    }
+
+    public void setThenExpr(Expression thenExpr) {
+        this.thenExpr = thenExpr;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/DoubleLiteralExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/DoubleLiteralExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/DoubleLiteralExpr.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 02/03/2007
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class DoubleLiteralExpr extends StringLiteralExpr {
+
+    public DoubleLiteralExpr() {
+    }
+
+    public DoubleLiteralExpr(String value) {
+        super(value);
+    }
+
+    public DoubleLiteralExpr(int beginLine, int beginColumn, int endLine, int endColumn, String value) {
+        super(beginLine, beginColumn, endLine, endColumn, value);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/EnclosedExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/EnclosedExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/EnclosedExpr.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class EnclosedExpr extends Expression {
+
+    private Expression inner;
+
+    public EnclosedExpr() {
+    }
+
+    public EnclosedExpr(Expression inner) {
+        this.inner = inner;
+    }
+
+    public EnclosedExpr(int beginLine, int beginColumn, int endLine, int endColumn, Expression inner) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.inner = inner;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getInner() {
+        return inner;
+    }
+
+    public void setInner(Expression inner) {
+        this.inner = inner;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/Expression.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/Expression.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/Expression.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 10/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.Node;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public abstract class Expression extends Node {
+
+    public Expression() {
+    }
+
+    public Expression(int beginLine, int beginColumn, int endLine, int endColumn) {
+        super(beginLine, beginColumn, endLine, endColumn);
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/FieldAccessExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/FieldAccessExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/FieldAccessExpr.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.type.Type;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class FieldAccessExpr extends Expression {
+
+    private Expression scope;
+
+    private List<Type> typeArgs;
+
+    private String field;
+
+    public FieldAccessExpr() {
+    }
+
+    public FieldAccessExpr(Expression scope, String field) {
+        this.scope = scope;
+        this.field = field;
+    }
+
+    public FieldAccessExpr(int beginLine, int beginColumn, int endLine, int endColumn, Expression scope, List<Type> typeArgs, String field) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.scope = scope;
+        this.typeArgs = typeArgs;
+        this.field = field;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public String getField() {
+        return field;
+    }
+
+    public Expression getScope() {
+        return scope;
+    }
+
+    public List<Type> getTypeArgs() {
+        return typeArgs;
+    }
+
+    public void setField(String field) {
+        this.field = field;
+    }
+
+    public void setScope(Expression scope) {
+        this.scope = scope;
+    }
+
+    public void setTypeArgs(List<Type> typeArgs) {
+        this.typeArgs = typeArgs;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/InstanceOfExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/InstanceOfExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/InstanceOfExpr.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.type.Type;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class InstanceOfExpr extends Expression {
+
+    private Expression expr;
+
+    private Type type;
+
+    public InstanceOfExpr() {
+    }
+
+    public InstanceOfExpr(Expression expr, Type type) {
+        this.expr = expr;
+        this.type = type;
+    }
+
+    public InstanceOfExpr(int beginLine, int beginColumn, int endLine, int endColumn, Expression expr, Type type) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.expr = expr;
+        this.type = type;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getExpr() {
+        return expr;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    public void setExpr(Expression expr) {
+        this.expr = expr;
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/IntegerLiteralExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/IntegerLiteralExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/IntegerLiteralExpr.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 02/03/2007
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public class IntegerLiteralExpr extends StringLiteralExpr {
+
+    private static final String UNSIGNED_MIN_VALUE = "2147483648";
+
+    protected static final String MIN_VALUE = "-" + UNSIGNED_MIN_VALUE;
+
+    public IntegerLiteralExpr() {
+    }
+
+    public IntegerLiteralExpr(String value) {
+        super(value);
+    }
+
+    public IntegerLiteralExpr(int beginLine, int beginColumn, int endLine, int endColumn, String value) {
+        super(beginLine, beginColumn, endLine, endColumn, value);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public final boolean isMinValue() {
+        return value != null && //
+                value.length() == 10 && //
+                value.equals(UNSIGNED_MIN_VALUE);
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/IntegerLiteralMinValueExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/IntegerLiteralMinValueExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/IntegerLiteralMinValueExpr.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 09/03/2007
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class IntegerLiteralMinValueExpr extends IntegerLiteralExpr {
+
+    public IntegerLiteralMinValueExpr() {
+        super(MIN_VALUE);
+    }
+
+    public IntegerLiteralMinValueExpr(int beginLine, int beginColumn, int endLine, int endColumn) {
+        super(beginLine, beginColumn, endLine, endColumn, MIN_VALUE);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/LiteralExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/LiteralExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/LiteralExpr.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public abstract class LiteralExpr extends Expression {
+
+    public LiteralExpr() {
+    }
+
+    public LiteralExpr(int beginLine, int beginColumn, int endLine, int endColumn) {
+        super(beginLine, beginColumn, endLine, endColumn);
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/LongLiteralExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/LongLiteralExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/LongLiteralExpr.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 02/03/2007
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public class LongLiteralExpr extends StringLiteralExpr {
+
+    private static final String UNSIGNED_MIN_VALUE = "9223372036854775808";
+
+    protected static final String MIN_VALUE = "-" + UNSIGNED_MIN_VALUE + "L";
+
+    public LongLiteralExpr() {
+    }
+
+    public LongLiteralExpr(String value) {
+        super(value);
+    }
+
+    public LongLiteralExpr(int beginLine, int beginColumn, int endLine, int endColumn, String value) {
+        super(beginLine, beginColumn, endLine, endColumn, value);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public final boolean isMinValue() {
+        return value != null && //
+                value.length() == 20 && //
+                value.startsWith(UNSIGNED_MIN_VALUE) && //
+                (value.charAt(19) == 'L' || value.charAt(19) == 'l');
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/LongLiteralMinValueExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/LongLiteralMinValueExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/LongLiteralMinValueExpr.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 09/03/2007
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class LongLiteralMinValueExpr extends LongLiteralExpr {
+
+    public LongLiteralMinValueExpr() {
+        super(MIN_VALUE);
+    }
+
+    public LongLiteralMinValueExpr(int beginLine, int beginColumn, int endLine, int endColumn) {
+        super(beginLine, beginColumn, endLine, endColumn, MIN_VALUE);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/MarkerAnnotationExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/MarkerAnnotationExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/MarkerAnnotationExpr.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 21/11/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class MarkerAnnotationExpr extends AnnotationExpr {
+
+    private NameExpr name;
+
+    public MarkerAnnotationExpr() {
+    }
+
+    public MarkerAnnotationExpr(NameExpr name) {
+        this.name = name;
+    }
+
+    public MarkerAnnotationExpr(int beginLine, int beginColumn, int endLine, int endColumn, NameExpr name) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.name = name;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public NameExpr getName() {
+        return name;
+    }
+
+    public void setName(NameExpr name) {
+        this.name = name;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/MemberValuePair.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/MemberValuePair.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/MemberValuePair.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 21/11/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.Node;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class MemberValuePair extends Node {
+
+    private String name;
+
+    private Expression value;
+
+    public MemberValuePair() {
+    }
+
+    public MemberValuePair(String name, Expression value) {
+        this.name = name;
+        this.value = value;
+    }
+
+    public MemberValuePair(int beginLine, int beginColumn, int endLine, int endColumn, String name, Expression value) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.name = name;
+        this.value = value;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public Expression getValue() {
+        return value;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public void setValue(Expression value) {
+        this.value = value;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/MethodCallExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/MethodCallExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/MethodCallExpr.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.type.Type;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class MethodCallExpr extends Expression {
+
+    private Expression scope;
+
+    private List<Type> typeArgs;
+
+    private String name;
+
+    private List<Expression> args;
+
+    public MethodCallExpr() {
+    }
+
+    public MethodCallExpr(Expression scope, String name) {
+        this.scope = scope;
+        this.name = name;
+    }
+
+    public MethodCallExpr(Expression scope, String name, List<Expression> args) {
+        this.scope = scope;
+        this.name = name;
+        this.args = args;
+    }
+
+    public MethodCallExpr(int beginLine, int beginColumn, int endLine, int endColumn, Expression scope, List<Type> typeArgs, String name, List<Expression> args) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.scope = scope;
+        this.typeArgs = typeArgs;
+        this.name = name;
+        this.args = args;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public List<Expression> getArgs() {
+        return args;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public Expression getScope() {
+        return scope;
+    }
+
+    public List<Type> getTypeArgs() {
+        return typeArgs;
+    }
+
+    public void setArgs(List<Expression> args) {
+        this.args = args;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public void setScope(Expression scope) {
+        this.scope = scope;
+    }
+
+    public void setTypeArgs(List<Type> typeArgs) {
+        this.typeArgs = typeArgs;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/NameExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/NameExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/NameExpr.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public class NameExpr extends Expression {
+
+    private String name;
+
+    public NameExpr() {
+    }
+
+    public NameExpr(String name) {
+        this.name = name;
+    }
+
+    public NameExpr(int beginLine, int beginColumn, int endLine, int endColumn, String name) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.name = name;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public final String getName() {
+        return name;
+    }
+
+    public final void setName(String name) {
+        this.name = name;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/NormalAnnotationExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/NormalAnnotationExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/NormalAnnotationExpr.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 21/11/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class NormalAnnotationExpr extends AnnotationExpr {
+
+    private NameExpr name;
+
+    private List<MemberValuePair> pairs;
+
+    public NormalAnnotationExpr() {
+    }
+
+    public NormalAnnotationExpr(NameExpr name, List<MemberValuePair> pairs) {
+        this.name = name;
+        this.pairs = pairs;
+    }
+
+    public NormalAnnotationExpr(int beginLine, int beginColumn, int endLine, int endColumn, NameExpr name, List<MemberValuePair> pairs) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.name = name;
+        this.pairs = pairs;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public NameExpr getName() {
+        return name;
+    }
+
+    public List<MemberValuePair> getPairs() {
+        return pairs;
+    }
+
+    public void setName(NameExpr name) {
+        this.name = name;
+    }
+
+    public void setPairs(List<MemberValuePair> pairs) {
+        this.pairs = pairs;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/NullLiteralExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/NullLiteralExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/NullLiteralExpr.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 02/03/2007
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class NullLiteralExpr extends LiteralExpr {
+
+    public NullLiteralExpr() {
+    }
+
+    public NullLiteralExpr(int beginLine, int beginColumn, int endLine, int endColumn) {
+        super(beginLine, beginColumn, endLine, endColumn);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/ObjectCreationExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/ObjectCreationExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/ObjectCreationExpr.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.body.BodyDeclaration;
+import japa.parser.ast.type.ClassOrInterfaceType;
+import japa.parser.ast.type.Type;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ObjectCreationExpr extends Expression {
+
+    private Expression scope;
+
+    private ClassOrInterfaceType type;
+
+    private List<Type> typeArgs;
+
+    private List<Expression> args;
+
+    private List<BodyDeclaration> anonymousClassBody;
+
+    public ObjectCreationExpr() {
+    }
+
+    public ObjectCreationExpr(Expression scope, ClassOrInterfaceType type, List<Expression> args) {
+        this.scope = scope;
+        this.type = type;
+        this.args = args;
+    }
+
+    public ObjectCreationExpr(int beginLine, int beginColumn, int endLine, int endColumn, Expression scope, ClassOrInterfaceType type, List<Type> typeArgs, List<Expression> args, List<BodyDeclaration> anonymousBody) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.scope = scope;
+        this.type = type;
+        this.typeArgs = typeArgs;
+        this.args = args;
+        this.anonymousClassBody = anonymousBody;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public List<BodyDeclaration> getAnonymousClassBody() {
+        return anonymousClassBody;
+    }
+
+    public List<Expression> getArgs() {
+        return args;
+    }
+
+    public Expression getScope() {
+        return scope;
+    }
+
+    public ClassOrInterfaceType getType() {
+        return type;
+    }
+
+    public List<Type> getTypeArgs() {
+        return typeArgs;
+    }
+
+    public void setAnonymousClassBody(List<BodyDeclaration> anonymousClassBody) {
+        this.anonymousClassBody = anonymousClassBody;
+    }
+
+    public void setArgs(List<Expression> args) {
+        this.args = args;
+    }
+
+    public void setScope(Expression scope) {
+        this.scope = scope;
+    }
+
+    public void setType(ClassOrInterfaceType type) {
+        this.type = type;
+    }
+
+    public void setTypeArgs(List<Type> typeArgs) {
+        this.typeArgs = typeArgs;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/QualifiedNameExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/QualifiedNameExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/QualifiedNameExpr.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class QualifiedNameExpr extends NameExpr {
+
+    private NameExpr qualifier;
+
+    public QualifiedNameExpr() {
+    }
+
+    public QualifiedNameExpr(NameExpr scope, String name) {
+        super(name);
+        this.qualifier = scope;
+    }
+
+    public QualifiedNameExpr(int beginLine, int beginColumn, int endLine, int endColumn, NameExpr scope, String name) {
+        super(beginLine, beginColumn, endLine, endColumn, name);
+        this.qualifier = scope;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public NameExpr getQualifier() {
+        return qualifier;
+    }
+
+    public void setQualifier(NameExpr qualifier) {
+        this.qualifier = qualifier;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/SingleMemberAnnotationExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/SingleMemberAnnotationExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/SingleMemberAnnotationExpr.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 21/11/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class SingleMemberAnnotationExpr extends AnnotationExpr {
+
+    private NameExpr name;
+
+    private Expression memberValue;
+
+    public SingleMemberAnnotationExpr() {
+    }
+
+    public SingleMemberAnnotationExpr(NameExpr name, Expression memberValue) {
+        this.name = name;
+        this.memberValue = memberValue;
+    }
+
+    public SingleMemberAnnotationExpr(int beginLine, int beginColumn, int endLine, int endColumn, NameExpr name, Expression memberValue) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.name = name;
+        this.memberValue = memberValue;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getMemberValue() {
+        return memberValue;
+    }
+
+    public NameExpr getName() {
+        return name;
+    }
+
+    public void setMemberValue(Expression memberValue) {
+        this.memberValue = memberValue;
+    }
+
+    public void setName(NameExpr name) {
+        this.name = name;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/StringLiteralExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/StringLiteralExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/StringLiteralExpr.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 02/03/2007
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public class StringLiteralExpr extends LiteralExpr {
+
+    protected String value;
+
+    public StringLiteralExpr() {
+    }
+
+    public StringLiteralExpr(String value) {
+        this.value = value;
+    }
+
+    public StringLiteralExpr(int beginLine, int beginColumn, int endLine, int endColumn, String value) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.value = value;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public final String getValue() {
+        return value;
+    }
+
+    public final void setValue(String value) {
+        this.value = value;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/SuperExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/SuperExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/SuperExpr.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 20/01/2007
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class SuperExpr extends Expression {
+
+    private Expression classExpr;
+
+    public SuperExpr() {
+    }
+
+    public SuperExpr(Expression classExpr) {
+        this.classExpr = classExpr;
+    }
+
+    public SuperExpr(int beginLine, int beginColumn, int endLine, int endColumn, Expression classExpr) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.classExpr = classExpr;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getClassExpr() {
+        return classExpr;
+    }
+
+    public void setClassExpr(Expression classExpr) {
+        this.classExpr = classExpr;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/ThisExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/ThisExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/ThisExpr.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ThisExpr extends Expression {
+
+    private Expression classExpr;
+
+    public ThisExpr() {
+    }
+
+    public ThisExpr(Expression classExpr) {
+        this.classExpr = classExpr;
+    }
+
+    public ThisExpr(int beginLine, int beginColumn, int endLine, int endColumn, Expression classExpr) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.classExpr = classExpr;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getClassExpr() {
+        return classExpr;
+    }
+
+    public void setClassExpr(Expression classExpr) {
+        this.classExpr = classExpr;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/UnaryExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/UnaryExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/UnaryExpr.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class UnaryExpr extends Expression {
+
+    public static enum Operator {
+        positive, // +
+        negative, // -
+        preIncrement, // ++
+        preDecrement, // --
+        not, // !
+        inverse, // ~
+        posIncrement, // ++
+        posDecrement, // --
+    }
+
+    private Expression expr;
+
+    private Operator op;
+
+    public UnaryExpr() {
+    }
+
+    public UnaryExpr(Expression expr, Operator op) {
+        this.expr = expr;
+        this.op = op;
+    }
+
+    public UnaryExpr(int beginLine, int beginColumn, int endLine, int endColumn, Expression expr, Operator op) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.expr = expr;
+        this.op = op;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getExpr() {
+        return expr;
+    }
+
+    public Operator getOperator() {
+        return op;
+    }
+
+    public void setExpr(Expression expr) {
+        this.expr = expr;
+    }
+
+    public void setOperator(Operator op) {
+        this.op = op;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/expr/VariableDeclarationExpr.java b/parser/html/java/javaparser/src/japa/parser/ast/expr/VariableDeclarationExpr.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/expr/VariableDeclarationExpr.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 03/11/2006
+ */
+package japa.parser.ast.expr;
+
+import japa.parser.ast.body.ModifierSet;
+import japa.parser.ast.body.VariableDeclarator;
+import japa.parser.ast.type.Type;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class VariableDeclarationExpr extends Expression {
+
+    private int modifiers;
+
+    private List<AnnotationExpr> annotations;
+
+    private Type type;
+
+    private List<VariableDeclarator> vars;
+
+    public VariableDeclarationExpr() {
+    }
+
+    public VariableDeclarationExpr(Type type, List<VariableDeclarator> vars) {
+        this.type = type;
+        this.vars = vars;
+    }
+
+    public VariableDeclarationExpr(int modifiers, Type type, List<VariableDeclarator> vars) {
+        this.modifiers = modifiers;
+        this.type = type;
+        this.vars = vars;
+    }
+
+    public VariableDeclarationExpr(int beginLine, int beginColumn, int endLine, int endColumn, int modifiers, List<AnnotationExpr> annotations, Type type, List<VariableDeclarator> vars) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.modifiers = modifiers;
+        this.annotations = annotations;
+        this.type = type;
+        this.vars = vars;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public List<AnnotationExpr> getAnnotations() {
+        return annotations;
+    }
+
+    /**
+     * Return the modifiers of this variable declaration.
+     * 
+     * @see ModifierSet
+     * @return modifiers
+     */
+    public int getModifiers() {
+        return modifiers;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    public List<VariableDeclarator> getVars() {
+        return vars;
+    }
+
+    public void setAnnotations(List<AnnotationExpr> annotations) {
+        this.annotations = annotations;
+    }
+
+    public void setModifiers(int modifiers) {
+        this.modifiers = modifiers;
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+    }
+
+    public void setVars(List<VariableDeclarator> vars) {
+        this.vars = vars;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/AssertStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/AssertStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/AssertStmt.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 04/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class AssertStmt extends Statement {
+
+    private Expression check;
+
+    private Expression msg;
+
+    public AssertStmt() {
+    }
+
+    public AssertStmt(Expression check) {
+        this.check = check;
+    }
+
+    public AssertStmt(Expression check, Expression msg) {
+        this.check = check;
+        this.msg = msg;
+    }
+
+    public AssertStmt(int beginLine, int beginColumn, int endLine, int endColumn, Expression check, Expression msg) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.check = check;
+        this.msg = msg;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getCheck() {
+        return check;
+    }
+
+    public Expression getMessage() {
+        return msg;
+    }
+
+    public void setCheck(Expression check) {
+        this.check = check;
+    }
+
+    public void setMessage(Expression msg) {
+        this.msg = msg;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/BlockStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/BlockStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/BlockStmt.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 04/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class BlockStmt extends Statement {
+
+    private List<Statement> stmts;
+
+    public BlockStmt() {
+    }
+
+    public BlockStmt(List<Statement> stmts) {
+        this.stmts = stmts;
+    }
+
+    public BlockStmt(int beginLine, int beginColumn, int endLine, int endColumn, List<Statement> stmts) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.stmts = stmts;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public List<Statement> getStmts() {
+        return stmts;
+    }
+
+    public void setStmts(List<Statement> stmts) {
+        this.stmts = stmts;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/BreakStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/BreakStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/BreakStmt.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 04/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class BreakStmt extends Statement {
+
+    private String id;
+
+    public BreakStmt() {
+    }
+
+    public BreakStmt(String id) {
+        this.id = id;
+    }
+
+    public BreakStmt(int beginLine, int beginColumn, int endLine, int endColumn, String id) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.id = id;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/CatchClause.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/CatchClause.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/CatchClause.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 18/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.Node;
+import japa.parser.ast.body.Parameter;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class CatchClause extends Node {
+
+    private Parameter except;
+
+    private BlockStmt catchBlock;
+
+    public CatchClause() {
+    }
+
+    public CatchClause(Parameter except, BlockStmt catchBlock) {
+        this.except = except;
+        this.catchBlock = catchBlock;
+    }
+
+    public CatchClause(int beginLine, int beginColumn, int endLine, int endColumn, Parameter except, BlockStmt catchBlock) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.except = except;
+        this.catchBlock = catchBlock;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public BlockStmt getCatchBlock() {
+        return catchBlock;
+    }
+
+    public Parameter getExcept() {
+        return except;
+    }
+
+    public void setCatchBlock(BlockStmt catchBlock) {
+        this.catchBlock = catchBlock;
+    }
+
+    public void setExcept(Parameter except) {
+        this.except = except;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/ContinueStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/ContinueStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/ContinueStmt.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 07/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ContinueStmt extends Statement {
+
+    private String id;
+
+    public ContinueStmt() {
+    }
+
+    public ContinueStmt(String id) {
+        this.id = id;
+    }
+
+    public ContinueStmt(int beginLine, int beginColumn, int endLine, int endColumn, String id) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.id = id;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/DoStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/DoStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/DoStmt.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 07/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class DoStmt extends Statement {
+
+    private Statement body;
+
+    private Expression condition;
+
+    public DoStmt() {
+    }
+
+    public DoStmt(Statement body, Expression condition) {
+        this.body = body;
+        this.condition = condition;
+    }
+
+    public DoStmt(int beginLine, int beginColumn, int endLine, int endColumn, Statement body, Expression condition) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.body = body;
+        this.condition = condition;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Statement getBody() {
+        return body;
+    }
+
+    public Expression getCondition() {
+        return condition;
+    }
+
+    public void setBody(Statement body) {
+        this.body = body;
+    }
+
+    public void setCondition(Expression condition) {
+        this.condition = condition;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/EmptyStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/EmptyStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/EmptyStmt.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 04/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class EmptyStmt extends Statement {
+
+    public EmptyStmt() {
+    }
+
+    public EmptyStmt(int beginLine, int beginColumn, int endLine, int endColumn) {
+        super(beginLine, beginColumn, endLine, endColumn);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/ExplicitConstructorInvocationStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/ExplicitConstructorInvocationStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/ExplicitConstructorInvocationStmt.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 03/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.type.Type;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ExplicitConstructorInvocationStmt extends Statement {
+
+    private List<Type> typeArgs;
+
+    private boolean isThis;
+
+    private Expression expr;
+
+    private List<Expression> args;
+
+    public ExplicitConstructorInvocationStmt() {
+    }
+
+    public ExplicitConstructorInvocationStmt(boolean isThis, Expression expr, List<Expression> args) {
+        this.isThis = isThis;
+        this.expr = expr;
+        this.args = args;
+    }
+
+    public ExplicitConstructorInvocationStmt(int beginLine, int beginColumn, int endLine, int endColumn, List<Type> typeArgs, boolean isThis, Expression expr, List<Expression> args) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.typeArgs = typeArgs;
+        this.isThis = isThis;
+        this.expr = expr;
+        this.args = args;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public List<Expression> getArgs() {
+        return args;
+    }
+
+    public Expression getExpr() {
+        return expr;
+    }
+
+    public List<Type> getTypeArgs() {
+        return typeArgs;
+    }
+
+    public boolean isThis() {
+        return isThis;
+    }
+
+    public void setArgs(List<Expression> args) {
+        this.args = args;
+    }
+
+    public void setExpr(Expression expr) {
+        this.expr = expr;
+    }
+
+    public void setThis(boolean isThis) {
+        this.isThis = isThis;
+    }
+
+    public void setTypeArgs(List<Type> typeArgs) {
+        this.typeArgs = typeArgs;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/ExpressionStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/ExpressionStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/ExpressionStmt.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 04/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ExpressionStmt extends Statement {
+
+    private Expression expr;
+
+    public ExpressionStmt() {
+    }
+
+    public ExpressionStmt(Expression expr) {
+        this.expr = expr;
+    }
+
+    public ExpressionStmt(int beginLine, int beginColumn, int endLine, int endColumn, Expression expr) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.expr = expr;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getExpression() {
+        return expr;
+    }
+
+    public void setExpression(Expression expr) {
+        this.expr = expr;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/ForStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/ForStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/ForStmt.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 07/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ForStmt extends Statement {
+
+    private List<Expression> init;
+
+    private Expression compare;
+
+    private List<Expression> update;
+
+    private Statement body;
+
+    public ForStmt() {
+    }
+
+    public ForStmt(List<Expression> init, Expression compare, List<Expression> update, Statement body) {
+        this.compare = compare;
+        this.init = init;
+        this.update = update;
+        this.body = body;
+    }
+
+    public ForStmt(int beginLine, int beginColumn, int endLine, int endColumn, List<Expression> init, Expression compare, List<Expression> update, Statement body) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.compare = compare;
+        this.init = init;
+        this.update = update;
+        this.body = body;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Statement getBody() {
+        return body;
+    }
+
+    public Expression getCompare() {
+        return compare;
+    }
+
+    public List<Expression> getInit() {
+        return init;
+    }
+
+    public List<Expression> getUpdate() {
+        return update;
+    }
+
+    public void setBody(Statement body) {
+        this.body = body;
+    }
+
+    public void setCompare(Expression compare) {
+        this.compare = compare;
+    }
+
+    public void setInit(List<Expression> init) {
+        this.init = init;
+    }
+
+    public void setUpdate(List<Expression> update) {
+        this.update = update;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/ForeachStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/ForeachStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/ForeachStmt.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 07/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.expr.VariableDeclarationExpr;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ForeachStmt extends Statement {
+
+    private VariableDeclarationExpr var;
+
+    private Expression iterable;
+
+    private Statement body;
+
+    public ForeachStmt() {
+    }
+
+    public ForeachStmt(VariableDeclarationExpr var, Expression iterable, Statement body) {
+        this.var = var;
+        this.iterable = iterable;
+        this.body = body;
+    }
+
+    public ForeachStmt(int beginLine, int beginColumn, int endLine, int endColumn, VariableDeclarationExpr var, Expression iterable, Statement body) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.var = var;
+        this.iterable = iterable;
+        this.body = body;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Statement getBody() {
+        return body;
+    }
+
+    public Expression getIterable() {
+        return iterable;
+    }
+
+    public VariableDeclarationExpr getVariable() {
+        return var;
+    }
+
+    public void setBody(Statement body) {
+        this.body = body;
+    }
+
+    public void setIterable(Expression iterable) {
+        this.iterable = iterable;
+    }
+
+    public void setVariable(VariableDeclarationExpr var) {
+        this.var = var;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/IfStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/IfStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/IfStmt.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 07/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class IfStmt extends Statement {
+
+    private Expression condition;
+
+    private Statement thenStmt;
+
+    private Statement elseStmt;
+
+    public IfStmt() {
+    }
+
+    public IfStmt(Expression condition, Statement thenStmt, Statement elseStmt) {
+        this.condition = condition;
+        this.thenStmt = thenStmt;
+        this.elseStmt = elseStmt;
+    }
+
+    public IfStmt(int beginLine, int beginColumn, int endLine, int endColumn, Expression condition, Statement thenStmt, Statement elseStmt) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.condition = condition;
+        this.thenStmt = thenStmt;
+        this.elseStmt = elseStmt;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getCondition() {
+        return condition;
+    }
+
+    public Statement getElseStmt() {
+        return elseStmt;
+    }
+
+    public Statement getThenStmt() {
+        return thenStmt;
+    }
+
+    public void setCondition(Expression condition) {
+        this.condition = condition;
+    }
+
+    public void setElseStmt(Statement elseStmt) {
+        this.elseStmt = elseStmt;
+    }
+
+    public void setThenStmt(Statement thenStmt) {
+        this.thenStmt = thenStmt;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/LabeledStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/LabeledStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/LabeledStmt.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 04/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class LabeledStmt extends Statement {
+
+    private String label;
+
+    private Statement stmt;
+
+    public LabeledStmt() {
+    }
+
+    public LabeledStmt(String label, Statement stmt) {
+        this.label = label;
+        this.stmt = stmt;
+    }
+
+    public LabeledStmt(int beginLine, int beginColumn, int endLine, int endColumn, String label, Statement stmt) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.label = label;
+        this.stmt = stmt;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public String getLabel() {
+        return label;
+    }
+
+    public Statement getStmt() {
+        return stmt;
+    }
+
+    public void setLabel(String label) {
+        this.label = label;
+    }
+
+    public void setStmt(Statement stmt) {
+        this.stmt = stmt;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/ReturnStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/ReturnStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/ReturnStmt.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 04/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ReturnStmt extends Statement {
+
+    private Expression expr;
+
+    public ReturnStmt() {
+    }
+
+    public ReturnStmt(Expression expr) {
+        this.expr = expr;
+    }
+
+    public ReturnStmt(int beginLine, int beginColumn, int endLine, int endColumn, Expression expr) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.expr = expr;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getExpr() {
+        return expr;
+    }
+
+    public void setExpr(Expression expr) {
+        this.expr = expr;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/Statement.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/Statement.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/Statement.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ *
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 03/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.Node;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public abstract class Statement extends Node {
+
+    public Statement() {
+    }
+
+    public Statement(int beginLine, int beginColumn, int endLine, int endColumn) {
+        super(beginLine, beginColumn, endLine, endColumn);
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/SwitchEntryStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/SwitchEntryStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/SwitchEntryStmt.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 04/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class SwitchEntryStmt extends Statement {
+
+    private Expression label;
+
+    private List<Statement> stmts;
+
+    public SwitchEntryStmt() {
+    }
+
+    public SwitchEntryStmt(Expression label, List<Statement> stmts) {
+        this.label = label;
+        this.stmts = stmts;
+    }
+
+    public SwitchEntryStmt(int beginLine, int beginColumn, int endLine, int endColumn, Expression label, List<Statement> stmts) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.label = label;
+        this.stmts = stmts;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getLabel() {
+        return label;
+    }
+
+    public List<Statement> getStmts() {
+        return stmts;
+    }
+
+    public void setLabel(Expression label) {
+        this.label = label;
+    }
+
+    public void setStmts(List<Statement> stmts) {
+        this.stmts = stmts;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/SwitchStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/SwitchStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/SwitchStmt.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 04/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class SwitchStmt extends Statement {
+
+    private Expression selector;
+
+    private List<SwitchEntryStmt> entries;
+
+    public SwitchStmt() {
+    }
+
+    public SwitchStmt(Expression selector, List<SwitchEntryStmt> entries) {
+        this.selector = selector;
+        this.entries = entries;
+    }
+
+    public SwitchStmt(int beginLine, int beginColumn, int endLine, int endColumn, Expression selector, List<SwitchEntryStmt> entries) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.selector = selector;
+        this.entries = entries;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public List<SwitchEntryStmt> getEntries() {
+        return entries;
+    }
+
+    public Expression getSelector() {
+        return selector;
+    }
+
+    public void setEntries(List<SwitchEntryStmt> entries) {
+        this.entries = entries;
+    }
+
+    public void setSelector(Expression selector) {
+        this.selector = selector;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/SynchronizedStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/SynchronizedStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/SynchronizedStmt.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 18/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class SynchronizedStmt extends Statement {
+
+    private Expression expr;
+
+    private BlockStmt block;
+
+    public SynchronizedStmt() {
+    }
+
+    public SynchronizedStmt(Expression expr, BlockStmt block) {
+        this.expr = expr;
+        this.block = block;
+    }
+
+    public SynchronizedStmt(int beginLine, int beginColumn, int endLine, int endColumn, Expression expr, BlockStmt block) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.expr = expr;
+        this.block = block;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public BlockStmt getBlock() {
+        return block;
+    }
+
+    public Expression getExpr() {
+        return expr;
+    }
+
+    public void setBlock(BlockStmt block) {
+        this.block = block;
+    }
+
+    public void setExpr(Expression expr) {
+        this.expr = expr;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/ThrowStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/ThrowStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/ThrowStmt.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 18/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ThrowStmt extends Statement {
+
+    private Expression expr;
+
+    public ThrowStmt() {
+    }
+
+    public ThrowStmt(Expression expr) {
+        this.expr = expr;
+    }
+
+    public ThrowStmt(int beginLine, int beginColumn, int endLine, int endColumn, Expression expr) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.expr = expr;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Expression getExpr() {
+        return expr;
+    }
+
+    public void setExpr(Expression expr) {
+        this.expr = expr;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/TryStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/TryStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/TryStmt.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 18/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class TryStmt extends Statement {
+
+    private BlockStmt tryBlock;
+
+    private List<CatchClause> catchs;
+
+    private BlockStmt finallyBlock;
+
+    public TryStmt() {
+    }
+
+    public TryStmt(BlockStmt tryBlock, List<CatchClause> catchs, BlockStmt finallyBlock) {
+        this.tryBlock = tryBlock;
+        this.catchs = catchs;
+        this.finallyBlock = finallyBlock;
+    }
+
+    public TryStmt(int beginLine, int beginColumn, int endLine, int endColumn, BlockStmt tryBlock, List<CatchClause> catchs, BlockStmt finallyBlock) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.tryBlock = tryBlock;
+        this.catchs = catchs;
+        this.finallyBlock = finallyBlock;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public List<CatchClause> getCatchs() {
+        return catchs;
+    }
+
+    public BlockStmt getFinallyBlock() {
+        return finallyBlock;
+    }
+
+    public BlockStmt getTryBlock() {
+        return tryBlock;
+    }
+
+    public void setCatchs(List<CatchClause> catchs) {
+        this.catchs = catchs;
+    }
+
+    public void setFinallyBlock(BlockStmt finallyBlock) {
+        this.finallyBlock = finallyBlock;
+    }
+
+    public void setTryBlock(BlockStmt tryBlock) {
+        this.tryBlock = tryBlock;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/TypeDeclarationStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/TypeDeclarationStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/TypeDeclarationStmt.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 04/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.body.TypeDeclaration;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class TypeDeclarationStmt extends Statement {
+
+    private TypeDeclaration typeDecl;
+
+    public TypeDeclarationStmt() {
+    }
+
+    public TypeDeclarationStmt(TypeDeclaration typeDecl) {
+        this.typeDecl = typeDecl;
+    }
+
+    public TypeDeclarationStmt(int beginLine, int beginColumn, int endLine, int endColumn, TypeDeclaration typeDecl) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.typeDecl = typeDecl;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public TypeDeclaration getTypeDeclaration() {
+        return typeDecl;
+    }
+
+    public void setTypeDeclaration(TypeDeclaration typeDecl) {
+        this.typeDecl = typeDecl;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/stmt/WhileStmt.java b/parser/html/java/javaparser/src/japa/parser/ast/stmt/WhileStmt.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/stmt/WhileStmt.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 07/11/2006
+ */
+package japa.parser.ast.stmt;
+
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class WhileStmt extends Statement {
+
+    private Expression condition;
+
+    private Statement body;
+
+    public WhileStmt() {
+    }
+
+    public WhileStmt(Expression condition, Statement body) {
+        this.condition = condition;
+        this.body = body;
+    }
+
+    public WhileStmt(int beginLine, int beginColumn, int endLine, int endColumn, Expression condition, Statement body) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.condition = condition;
+        this.body = body;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Statement getBody() {
+        return body;
+    }
+
+    public Expression getCondition() {
+        return condition;
+    }
+
+    public void setBody(Statement body) {
+        this.body = body;
+    }
+
+    public void setCondition(Expression condition) {
+        this.condition = condition;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/type/ClassOrInterfaceType.java b/parser/html/java/javaparser/src/japa/parser/ast/type/ClassOrInterfaceType.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/type/ClassOrInterfaceType.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.type;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ClassOrInterfaceType extends Type {
+
+    private ClassOrInterfaceType scope;
+
+    private String name;
+
+    private List<Type> typeArgs;
+
+    public ClassOrInterfaceType() {
+    }
+
+    public ClassOrInterfaceType(String name) {
+        this.name = name;
+    }
+
+    public ClassOrInterfaceType(ClassOrInterfaceType scope, String name) {
+        this.scope = scope;
+        this.name = name;
+    }
+
+    public ClassOrInterfaceType(int beginLine, int beginColumn, int endLine, int endColumn, ClassOrInterfaceType scope, String name, List<Type> typeArgs) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.scope = scope;
+        this.name = name;
+        this.typeArgs = typeArgs;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public ClassOrInterfaceType getScope() {
+        return scope;
+    }
+
+    public List<Type> getTypeArgs() {
+        return typeArgs;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public void setScope(ClassOrInterfaceType scope) {
+        this.scope = scope;
+    }
+
+    public void setTypeArgs(List<Type> typeArgs) {
+        this.typeArgs = typeArgs;
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/type/PrimitiveType.java b/parser/html/java/javaparser/src/japa/parser/ast/type/PrimitiveType.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/type/PrimitiveType.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.type;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class PrimitiveType extends Type {
+
+    public enum Primitive {
+        Boolean, Char, Byte, Short, Int, Long, Float, Double
+    }
+
+    private Primitive type;
+
+    public PrimitiveType() {
+    }
+
+    public PrimitiveType(Primitive type) {
+        this.type = type;
+    }
+
+    public PrimitiveType(int beginLine, int beginColumn, int endLine, int endColumn, Primitive type) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.type = type;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public Primitive getType() {
+        return type;
+    }
+
+    public void setType(Primitive type) {
+        this.type = type;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/type/ReferenceType.java b/parser/html/java/javaparser/src/japa/parser/ast/type/ReferenceType.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/type/ReferenceType.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.type;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class ReferenceType extends Type {
+
+    private Type type;
+
+    private int arrayCount;
+
+    public ReferenceType() {
+    }
+
+    public ReferenceType(Type type) {
+        this.type = type;
+    }
+
+    public ReferenceType(Type type, int arrayCount) {
+        this.type = type;
+        this.arrayCount = arrayCount;
+    }
+
+    public ReferenceType(int beginLine, int beginColumn, int endLine, int endColumn, Type type, int arrayCount) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.type = type;
+        this.arrayCount = arrayCount;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public int getArrayCount() {
+        return arrayCount;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    public void setArrayCount(int arrayCount) {
+        this.arrayCount = arrayCount;
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/type/Type.java b/parser/html/java/javaparser/src/japa/parser/ast/type/Type.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/type/Type.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.type;
+
+import japa.parser.ast.Node;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public abstract class Type extends Node {
+
+    public Type() {
+    }
+
+    public Type(int beginLine, int beginColumn, int endLine, int endColumn) {
+        super(beginLine, beginColumn, endLine, endColumn);
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/type/VoidType.java b/parser/html/java/javaparser/src/japa/parser/ast/type/VoidType.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/type/VoidType.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.type;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class VoidType extends Type {
+
+    public VoidType() {
+    }
+
+    public VoidType(int beginLine, int beginColumn, int endLine, int endColumn) {
+        super(beginLine, beginColumn, endLine, endColumn);
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/type/WildcardType.java b/parser/html/java/javaparser/src/japa/parser/ast/type/WildcardType.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/type/WildcardType.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.type;
+
+import japa.parser.ast.visitor.GenericVisitor;
+import japa.parser.ast.visitor.VoidVisitor;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public final class WildcardType extends Type {
+
+    private ReferenceType ext;
+
+    private ReferenceType sup;
+
+    public WildcardType() {
+    }
+
+    public WildcardType(ReferenceType ext) {
+        this.ext = ext;
+    }
+
+    public WildcardType(ReferenceType ext, ReferenceType sup) {
+        this.ext = ext;
+        this.sup = sup;
+    }
+
+    public WildcardType(int beginLine, int beginColumn, int endLine, int endColumn, ReferenceType ext, ReferenceType sup) {
+        super(beginLine, beginColumn, endLine, endColumn);
+        this.ext = ext;
+        this.sup = sup;
+    }
+
+    @Override
+    public <R, A> R accept(GenericVisitor<R, A> v, A arg) {
+        return v.visit(this, arg);
+    }
+
+    @Override
+    public <A> void accept(VoidVisitor<A> v, A arg) {
+        v.visit(this, arg);
+    }
+
+    public ReferenceType getExtends() {
+        return ext;
+    }
+
+    public ReferenceType getSuper() {
+        return sup;
+    }
+
+    public void setExtends(ReferenceType ext) {
+        this.ext = ext;
+    }
+
+    public void setSuper(ReferenceType sup) {
+        this.sup = sup;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/visitor/DumpVisitor.java b/parser/html/java/javaparser/src/japa/parser/ast/visitor/DumpVisitor.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/visitor/DumpVisitor.java
@@ -0,0 +1,1302 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.visitor;
+
+import japa.parser.ast.BlockComment;
+import japa.parser.ast.CompilationUnit;
+import japa.parser.ast.ImportDeclaration;
+import japa.parser.ast.LineComment;
+import japa.parser.ast.PackageDeclaration;
+import japa.parser.ast.TypeParameter;
+import japa.parser.ast.body.AnnotationDeclaration;
+import japa.parser.ast.body.AnnotationMemberDeclaration;
+import japa.parser.ast.body.BodyDeclaration;
+import japa.parser.ast.body.ClassOrInterfaceDeclaration;
+import japa.parser.ast.body.ConstructorDeclaration;
+import japa.parser.ast.body.EmptyMemberDeclaration;
+import japa.parser.ast.body.EmptyTypeDeclaration;
+import japa.parser.ast.body.EnumConstantDeclaration;
+import japa.parser.ast.body.EnumDeclaration;
+import japa.parser.ast.body.FieldDeclaration;
+import japa.parser.ast.body.InitializerDeclaration;
+import japa.parser.ast.body.JavadocComment;
+import japa.parser.ast.body.MethodDeclaration;
+import japa.parser.ast.body.ModifierSet;
+import japa.parser.ast.body.Parameter;
+import japa.parser.ast.body.TypeDeclaration;
+import japa.parser.ast.body.VariableDeclarator;
+import japa.parser.ast.body.VariableDeclaratorId;
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.expr.ArrayAccessExpr;
+import japa.parser.ast.expr.ArrayCreationExpr;
+import japa.parser.ast.expr.ArrayInitializerExpr;
+import japa.parser.ast.expr.AssignExpr;
+import japa.parser.ast.expr.BinaryExpr;
+import japa.parser.ast.expr.BooleanLiteralExpr;
+import japa.parser.ast.expr.CastExpr;
+import japa.parser.ast.expr.CharLiteralExpr;
+import japa.parser.ast.expr.ClassExpr;
+import japa.parser.ast.expr.ConditionalExpr;
+import japa.parser.ast.expr.DoubleLiteralExpr;
+import japa.parser.ast.expr.EnclosedExpr;
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.expr.FieldAccessExpr;
+import japa.parser.ast.expr.InstanceOfExpr;
+import japa.parser.ast.expr.IntegerLiteralExpr;
+import japa.parser.ast.expr.IntegerLiteralMinValueExpr;
+import japa.parser.ast.expr.LongLiteralExpr;
+import japa.parser.ast.expr.LongLiteralMinValueExpr;
+import japa.parser.ast.expr.MarkerAnnotationExpr;
+import japa.parser.ast.expr.MemberValuePair;
+import japa.parser.ast.expr.MethodCallExpr;
+import japa.parser.ast.expr.NameExpr;
+import japa.parser.ast.expr.NormalAnnotationExpr;
+import japa.parser.ast.expr.NullLiteralExpr;
+import japa.parser.ast.expr.ObjectCreationExpr;
+import japa.parser.ast.expr.QualifiedNameExpr;
+import japa.parser.ast.expr.SingleMemberAnnotationExpr;
+import japa.parser.ast.expr.StringLiteralExpr;
+import japa.parser.ast.expr.SuperExpr;
+import japa.parser.ast.expr.ThisExpr;
+import japa.parser.ast.expr.UnaryExpr;
+import japa.parser.ast.expr.VariableDeclarationExpr;
+import japa.parser.ast.stmt.AssertStmt;
+import japa.parser.ast.stmt.BlockStmt;
+import japa.parser.ast.stmt.BreakStmt;
+import japa.parser.ast.stmt.CatchClause;
+import japa.parser.ast.stmt.ContinueStmt;
+import japa.parser.ast.stmt.DoStmt;
+import japa.parser.ast.stmt.EmptyStmt;
+import japa.parser.ast.stmt.ExplicitConstructorInvocationStmt;
+import japa.parser.ast.stmt.ExpressionStmt;
+import japa.parser.ast.stmt.ForStmt;
+import japa.parser.ast.stmt.ForeachStmt;
+import japa.parser.ast.stmt.IfStmt;
+import japa.parser.ast.stmt.LabeledStmt;
+import japa.parser.ast.stmt.ReturnStmt;
+import japa.parser.ast.stmt.Statement;
+import japa.parser.ast.stmt.SwitchEntryStmt;
+import japa.parser.ast.stmt.SwitchStmt;
+import japa.parser.ast.stmt.SynchronizedStmt;
+import japa.parser.ast.stmt.ThrowStmt;
+import japa.parser.ast.stmt.TryStmt;
+import japa.parser.ast.stmt.TypeDeclarationStmt;
+import japa.parser.ast.stmt.WhileStmt;
+import japa.parser.ast.type.ClassOrInterfaceType;
+import japa.parser.ast.type.PrimitiveType;
+import japa.parser.ast.type.ReferenceType;
+import japa.parser.ast.type.Type;
+import japa.parser.ast.type.VoidType;
+import japa.parser.ast.type.WildcardType;
+
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+
+public final class DumpVisitor implements VoidVisitor<Object> {
+
+    private class SourcePrinter {
+
+        private int level = 0;
+
+        private boolean indented = false;
+
+        private final StringBuilder buf = new StringBuilder();
+
+        public void indent() {
+            level++;
+        }
+
+        public void unindent() {
+            level--;
+        }
+
+        private void makeIndent() {
+            for (int i = 0; i < level; i++) {
+                buf.append("    ");
+            }
+        }
+
+        public void print(String arg) {
+            if (!indented) {
+                makeIndent();
+                indented = true;
+            }
+            buf.append(arg);
+        }
+
+        public void printLn(String arg) {
+            print(arg);
+            printLn();
+        }
+
+        public void printLn() {
+            buf.append("\n");
+            indented = false;
+        }
+
+        public String getSource() {
+            return buf.toString();
+        }
+
+        @Override
+        public String toString() {
+            return getSource();
+        }
+    }
+
+    private final SourcePrinter printer = new SourcePrinter();
+
+    public String getSource() {
+        return printer.getSource();
+    }
+
+    private void printModifiers(int modifiers) {
+        if (ModifierSet.isPrivate(modifiers)) {
+            printer.print("private ");
+        }
+        if (ModifierSet.isProtected(modifiers)) {
+            printer.print("protected ");
+        }
+        if (ModifierSet.isPublic(modifiers)) {
+            printer.print("public ");
+        }
+        if (ModifierSet.isAbstract(modifiers)) {
+            printer.print("abstract ");
+        }
+        if (ModifierSet.isStatic(modifiers)) {
+            printer.print("static ");
+        }
+        if (ModifierSet.isFinal(modifiers)) {
+            printer.print("final ");
+        }
+        if (ModifierSet.isNative(modifiers)) {
+            printer.print("native ");
+        }
+        if (ModifierSet.isStrictfp(modifiers)) {
+            printer.print("strictfp ");
+        }
+        if (ModifierSet.isSynchronized(modifiers)) {
+            printer.print("synchronized ");
+        }
+        if (ModifierSet.isTransient(modifiers)) {
+            printer.print("transient ");
+        }
+        if (ModifierSet.isVolatile(modifiers)) {
+            printer.print("volatile ");
+        }
+    }
+
+    private void printMembers(List<BodyDeclaration> members, Object arg) {
+        for (BodyDeclaration member : members) {
+            printer.printLn();
+            member.accept(this, arg);
+            printer.printLn();
+        }
+    }
+
+    private void printMemberAnnotations(List<AnnotationExpr> annotations, Object arg) {
+        if (annotations != null) {
+            for (AnnotationExpr a : annotations) {
+                a.accept(this, arg);
+                printer.printLn();
+            }
+        }
+    }
+
+    private void printAnnotations(List<AnnotationExpr> annotations, Object arg) {
+        if (annotations != null) {
+            for (AnnotationExpr a : annotations) {
+                a.accept(this, arg);
+                printer.print(" ");
+            }
+        }
+    }
+
+    private void printTypeArgs(List<Type> args, Object arg) {
+        if (args != null) {
+            printer.print("<");
+            for (Iterator<Type> i = args.iterator(); i.hasNext();) {
+                Type t = i.next();
+                t.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+            printer.print(">");
+        }
+    }
+
+    private void printTypeParameters(List<TypeParameter> args, Object arg) {
+        if (args != null) {
+            printer.print("<");
+            for (Iterator<TypeParameter> i = args.iterator(); i.hasNext();) {
+                TypeParameter t = i.next();
+                t.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+            printer.print(">");
+        }
+    }
+
+    private void printArguments(List<Expression> args, Object arg) {
+        printer.print("(");
+        if (args != null) {
+            for (Iterator<Expression> i = args.iterator(); i.hasNext();) {
+                Expression e = i.next();
+                e.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        printer.print(")");
+    }
+
+    private void printJavadoc(JavadocComment javadoc, Object arg) {
+        if (javadoc != null) {
+            javadoc.accept(this, arg);
+        }
+    }
+
+    public void visit(CompilationUnit n, Object arg) {
+        if (n.getPackage() != null) {
+            n.getPackage().accept(this, arg);
+        }
+        if (n.getImports() != null) {
+            for (ImportDeclaration i : n.getImports()) {
+                i.accept(this, arg);
+            }
+            printer.printLn();
+        }
+        if (n.getTypes() != null) {
+            for (Iterator<TypeDeclaration> i = n.getTypes().iterator(); i.hasNext();) {
+                i.next().accept(this, arg);
+                printer.printLn();
+                if (i.hasNext()) {
+                    printer.printLn();
+                }
+            }
+        }
+    }
+
+    public void visit(PackageDeclaration n, Object arg) {
+        printAnnotations(n.getAnnotations(), arg);
+        printer.print("package ");
+        n.getName().accept(this, arg);
+        printer.printLn(";");
+        printer.printLn();
+    }
+
+    public void visit(NameExpr n, Object arg) {
+        printer.print(n.getName());
+    }
+
+    public void visit(QualifiedNameExpr n, Object arg) {
+        n.getQualifier().accept(this, arg);
+        printer.print(".");
+        printer.print(n.getName());
+    }
+
+    public void visit(ImportDeclaration n, Object arg) {
+        printer.print("import ");
+        if (n.isStatic()) {
+            printer.print("static ");
+        }
+        n.getName().accept(this, arg);
+        if (n.isAsterisk()) {
+            printer.print(".*");
+        }
+        printer.printLn(";");
+    }
+
+    public void visit(ClassOrInterfaceDeclaration n, Object arg) {
+        printJavadoc(n.getJavaDoc(), arg);
+        printMemberAnnotations(n.getAnnotations(), arg);
+        printModifiers(n.getModifiers());
+
+        if (n.isInterface()) {
+            printer.print("interface ");
+        } else {
+            printer.print("class ");
+        }
+
+        printer.print(n.getName());
+
+        printTypeParameters(n.getTypeParameters(), arg);
+
+        if (n.getExtends() != null) {
+            printer.print(" extends ");
+            for (Iterator<ClassOrInterfaceType> i = n.getExtends().iterator(); i.hasNext();) {
+                ClassOrInterfaceType c = i.next();
+                c.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+
+        if (n.getImplements() != null) {
+            printer.print(" implements ");
+            for (Iterator<ClassOrInterfaceType> i = n.getImplements().iterator(); i.hasNext();) {
+                ClassOrInterfaceType c = i.next();
+                c.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+
+        printer.printLn(" {");
+        printer.indent();
+        if (n.getMembers() != null) {
+            printMembers(n.getMembers(), arg);
+        }
+        printer.unindent();
+        printer.print("}");
+    }
+
+    public void visit(EmptyTypeDeclaration n, Object arg) {
+        printJavadoc(n.getJavaDoc(), arg);
+        printer.print(";");
+    }
+
+    public void visit(JavadocComment n, Object arg) {
+        printer.print("/**");
+        printer.print(n.getContent());
+        printer.printLn("*/");
+    }
+
+    public void visit(ClassOrInterfaceType n, Object arg) {
+        if (n.getScope() != null) {
+            n.getScope().accept(this, arg);
+            printer.print(".");
+        }
+        printer.print(n.getName());
+        printTypeArgs(n.getTypeArgs(), arg);
+    }
+
+    public void visit(TypeParameter n, Object arg) {
+        printer.print(n.getName());
+        if (n.getTypeBound() != null) {
+            printer.print(" extends ");
+            for (Iterator<ClassOrInterfaceType> i = n.getTypeBound().iterator(); i.hasNext();) {
+                ClassOrInterfaceType c = i.next();
+                c.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(" & ");
+                }
+            }
+        }
+    }
+
+    public void visit(PrimitiveType n, Object arg) {
+        switch (n.getType()) {
+            case Boolean:
+                printer.print("boolean");
+                break;
+            case Byte:
+                printer.print("byte");
+                break;
+            case Char:
+                printer.print("char");
+                break;
+            case Double:
+                printer.print("double");
+                break;
+            case Float:
+                printer.print("float");
+                break;
+            case Int:
+                printer.print("int");
+                break;
+            case Long:
+                printer.print("long");
+                break;
+            case Short:
+                printer.print("short");
+                break;
+        }
+    }
+
+    public void visit(ReferenceType n, Object arg) {
+        n.getType().accept(this, arg);
+        for (int i = 0; i < n.getArrayCount(); i++) {
+            printer.print("[]");
+        }
+    }
+
+    public void visit(WildcardType n, Object arg) {
+        printer.print("?");
+        if (n.getExtends() != null) {
+            printer.print(" extends ");
+            n.getExtends().accept(this, arg);
+        }
+        if (n.getSuper() != null) {
+            printer.print(" super ");
+            n.getSuper().accept(this, arg);
+        }
+    }
+
+    public void visit(FieldDeclaration n, Object arg) {
+        printJavadoc(n.getJavaDoc(), arg);
+        printMemberAnnotations(n.getAnnotations(), arg);
+        printModifiers(n.getModifiers());
+        n.getType().accept(this, arg);
+
+        printer.print(" ");
+        for (Iterator<VariableDeclarator> i = n.getVariables().iterator(); i.hasNext();) {
+            VariableDeclarator var = i.next();
+            var.accept(this, arg);
+            if (i.hasNext()) {
+                printer.print(", ");
+            }
+        }
+
+        printer.print(";");
+    }
+
+    public void visit(VariableDeclarator n, Object arg) {
+        n.getId().accept(this, arg);
+        if (n.getInit() != null) {
+            printer.print(" = ");
+            n.getInit().accept(this, arg);
+        }
+    }
+
+    public void visit(VariableDeclaratorId n, Object arg) {
+        printer.print(n.getName());
+        for (int i = 0; i < n.getArrayCount(); i++) {
+            printer.print("[]");
+        }
+    }
+
+    public void visit(ArrayInitializerExpr n, Object arg) {
+        printer.print("{");
+        if (n.getValues() != null) {
+            printer.print(" ");
+            for (Iterator<Expression> i = n.getValues().iterator(); i.hasNext();) {
+                Expression expr = i.next();
+                expr.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+            printer.print(" ");
+        }
+        printer.print("}");
+    }
+
+    public void visit(VoidType n, Object arg) {
+        printer.print("void");
+    }
+
+    public void visit(ArrayAccessExpr n, Object arg) {
+        n.getName().accept(this, arg);
+        printer.print("[");
+        n.getIndex().accept(this, arg);
+        printer.print("]");
+    }
+
+    public void visit(ArrayCreationExpr n, Object arg) {
+        printer.print("new ");
+        n.getType().accept(this, arg);
+
+        if (n.getDimensions() != null) {
+            for (Expression dim : n.getDimensions()) {
+                printer.print("[");
+                dim.accept(this, arg);
+                printer.print("]");
+            }
+            for (int i = 0; i < n.getArrayCount(); i++) {
+                printer.print("[]");
+            }
+        } else {
+            for (int i = 0; i < n.getArrayCount(); i++) {
+                printer.print("[]");
+            }
+            printer.print(" ");
+            n.getInitializer().accept(this, arg);
+        }
+    }
+
+    public void visit(AssignExpr n, Object arg) {
+        n.getTarget().accept(this, arg);
+        printer.print(" ");
+        switch (n.getOperator()) {
+            case assign:
+                printer.print("=");
+                break;
+            case and:
+                printer.print("&=");
+                break;
+            case or:
+                printer.print("|=");
+                break;
+            case xor:
+                printer.print("^=");
+                break;
+            case plus:
+                printer.print("+=");
+                break;
+            case minus:
+                printer.print("-=");
+                break;
+            case rem:
+                printer.print("%=");
+                break;
+            case slash:
+                printer.print("/=");
+                break;
+            case star:
+                printer.print("*=");
+                break;
+            case lShift:
+                printer.print("<<=");
+                break;
+            case rSignedShift:
+                printer.print(">>=");
+                break;
+            case rUnsignedShift:
+                printer.print(">>>=");
+                break;
+        }
+        printer.print(" ");
+        n.getValue().accept(this, arg);
+    }
+
+    public void visit(BinaryExpr n, Object arg) {
+        n.getLeft().accept(this, arg);
+        printer.print(" ");
+        switch (n.getOperator()) {
+            case or:
+                printer.print("||");
+                break;
+            case and:
+                printer.print("&&");
+                break;
+            case binOr:
+                printer.print("|");
+                break;
+            case binAnd:
+                printer.print("&");
+                break;
+            case xor:
+                printer.print("^");
+                break;
+            case equals:
+                printer.print("==");
+                break;
+            case notEquals:
+                printer.print("!=");
+                break;
+            case less:
+                printer.print("<");
+                break;
+            case greater:
+                printer.print(">");
+                break;
+            case lessEquals:
+                printer.print("<=");
+                break;
+            case greaterEquals:
+                printer.print(">=");
+                break;
+            case lShift:
+                printer.print("<<");
+                break;
+            case rSignedShift:
+                printer.print(">>");
+                break;
+            case rUnsignedShift:
+                printer.print(">>>");
+                break;
+            case plus:
+                printer.print("+");
+                break;
+            case minus:
+                printer.print("-");
+                break;
+            case times:
+                printer.print("*");
+                break;
+            case divide:
+                printer.print("/");
+                break;
+            case remainder:
+                printer.print("%");
+                break;
+        }
+        printer.print(" ");
+        n.getRight().accept(this, arg);
+    }
+
+    public void visit(CastExpr n, Object arg) {
+        printer.print("(");
+        n.getType().accept(this, arg);
+        printer.print(") ");
+        n.getExpr().accept(this, arg);
+    }
+
+    public void visit(ClassExpr n, Object arg) {
+        n.getType().accept(this, arg);
+        printer.print(".class");
+    }
+
+    public void visit(ConditionalExpr n, Object arg) {
+        n.getCondition().accept(this, arg);
+        printer.print(" ? ");
+        n.getThenExpr().accept(this, arg);
+        printer.print(" : ");
+        n.getElseExpr().accept(this, arg);
+    }
+
+    public void visit(EnclosedExpr n, Object arg) {
+        printer.print("(");
+        n.getInner().accept(this, arg);
+        printer.print(")");
+    }
+
+    public void visit(FieldAccessExpr n, Object arg) {
+        n.getScope().accept(this, arg);
+        printer.print(".");
+        printer.print(n.getField());
+    }
+
+    public void visit(InstanceOfExpr n, Object arg) {
+        n.getExpr().accept(this, arg);
+        printer.print(" instanceof ");
+        n.getType().accept(this, arg);
+    }
+
+    public void visit(CharLiteralExpr n, Object arg) {
+        printer.print("'");
+        printer.print(n.getValue());
+        printer.print("'");
+    }
+
+    public void visit(DoubleLiteralExpr n, Object arg) {
+        printer.print(n.getValue());
+    }
+
+    public void visit(IntegerLiteralExpr n, Object arg) {
+        printer.print(n.getValue());
+    }
+
+    public void visit(LongLiteralExpr n, Object arg) {
+        printer.print(n.getValue());
+    }
+
+    public void visit(IntegerLiteralMinValueExpr n, Object arg) {
+        printer.print(n.getValue());
+    }
+
+    public void visit(LongLiteralMinValueExpr n, Object arg) {
+        printer.print(n.getValue());
+    }
+
+    public void visit(StringLiteralExpr n, Object arg) {
+        printer.print("\"");
+        printer.print(n.getValue());
+        printer.print("\"");
+    }
+
+    public void visit(BooleanLiteralExpr n, Object arg) {
+        printer.print(String.valueOf(n.getValue()));
+    }
+
+    public void visit(NullLiteralExpr n, Object arg) {
+        printer.print("null");
+    }
+
+    public void visit(ThisExpr n, Object arg) {
+        if (n.getClassExpr() != null) {
+            n.getClassExpr().accept(this, arg);
+            printer.print(".");
+        }
+        printer.print("this");
+    }
+
+    public void visit(SuperExpr n, Object arg) {
+        if (n.getClassExpr() != null) {
+            n.getClassExpr().accept(this, arg);
+            printer.print(".");
+        }
+        printer.print("super");
+    }
+
+    public void visit(MethodCallExpr n, Object arg) {
+        if (n.getScope() != null) {
+            n.getScope().accept(this, arg);
+            printer.print(".");
+        }
+        printTypeArgs(n.getTypeArgs(), arg);
+        printer.print(n.getName());
+        printArguments(n.getArgs(), arg);
+    }
+
+    public void visit(ObjectCreationExpr n, Object arg) {
+        if (n.getScope() != null) {
+            n.getScope().accept(this, arg);
+            printer.print(".");
+        }
+
+        printer.print("new ");
+
+        printTypeArgs(n.getTypeArgs(), arg);
+        n.getType().accept(this, arg);
+
+        printArguments(n.getArgs(), arg);
+
+        if (n.getAnonymousClassBody() != null) {
+            printer.printLn(" {");
+            printer.indent();
+            printMembers(n.getAnonymousClassBody(), arg);
+            printer.unindent();
+            printer.print("}");
+        }
+    }
+
+    public void visit(UnaryExpr n, Object arg) {
+        switch (n.getOperator()) {
+            case positive:
+                printer.print("+");
+                break;
+            case negative:
+                printer.print("-");
+                break;
+            case inverse:
+                printer.print("~");
+                break;
+            case not:
+                printer.print("!");
+                break;
+            case preIncrement:
+                printer.print("++");
+                break;
+            case preDecrement:
+                printer.print("--");
+                break;
+        }
+
+        n.getExpr().accept(this, arg);
+
+        switch (n.getOperator()) {
+            case posIncrement:
+                printer.print("++");
+                break;
+            case posDecrement:
+                printer.print("--");
+                break;
+        }
+    }
+
+    public void visit(ConstructorDeclaration n, Object arg) {
+        printJavadoc(n.getJavaDoc(), arg);
+        printMemberAnnotations(n.getAnnotations(), arg);
+        printModifiers(n.getModifiers());
+
+        printTypeParameters(n.getTypeParameters(), arg);
+        if (n.getTypeParameters() != null) {
+            printer.print(" ");
+        }
+        printer.print(n.getName());
+
+        printer.print("(");
+        if (n.getParameters() != null) {
+            for (Iterator<Parameter> i = n.getParameters().iterator(); i.hasNext();) {
+                Parameter p = i.next();
+                p.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        printer.print(")");
+
+        if (n.getThrows() != null) {
+            printer.print(" throws ");
+            for (Iterator<NameExpr> i = n.getThrows().iterator(); i.hasNext();) {
+                NameExpr name = i.next();
+                name.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        printer.print(" ");
+        n.getBlock().accept(this, arg);
+    }
+
+    public void visit(MethodDeclaration n, Object arg) {
+        printJavadoc(n.getJavaDoc(), arg);
+        printMemberAnnotations(n.getAnnotations(), arg);
+        printModifiers(n.getModifiers());
+
+        printTypeParameters(n.getTypeParameters(), arg);
+        if (n.getTypeParameters() != null) {
+            printer.print(" ");
+        }
+
+        n.getType().accept(this, arg);
+        printer.print(" ");
+        printer.print(n.getName());
+
+        printer.print("(");
+        if (n.getParameters() != null) {
+            for (Iterator<Parameter> i = n.getParameters().iterator(); i.hasNext();) {
+                Parameter p = i.next();
+                p.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        printer.print(")");
+
+        for (int i = 0; i < n.getArrayCount(); i++) {
+            printer.print("[]");
+        }
+
+        if (n.getThrows() != null) {
+            printer.print(" throws ");
+            for (Iterator<NameExpr> i = n.getThrows().iterator(); i.hasNext();) {
+                NameExpr name = i.next();
+                name.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        if (n.getBody() == null) {
+            printer.print(";");
+        } else {
+            printer.print(" ");
+            n.getBody().accept(this, arg);
+        }
+    }
+
+    public void visit(Parameter n, Object arg) {
+        printAnnotations(n.getAnnotations(), arg);
+        printModifiers(n.getModifiers());
+
+        n.getType().accept(this, arg);
+        if (n.isVarArgs()) {
+            printer.print("...");
+        }
+        printer.print(" ");
+        n.getId().accept(this, arg);
+    }
+
+    public void visit(ExplicitConstructorInvocationStmt n, Object arg) {
+        if (n.isThis()) {
+            printTypeArgs(n.getTypeArgs(), arg);
+            printer.print("this");
+        } else {
+            if (n.getExpr() != null) {
+                n.getExpr().accept(this, arg);
+                printer.print(".");
+            }
+            printTypeArgs(n.getTypeArgs(), arg);
+            printer.print("super");
+        }
+        printArguments(n.getArgs(), arg);
+        printer.print(";");
+    }
+
+    public void visit(VariableDeclarationExpr n, Object arg) {
+        printAnnotations(n.getAnnotations(), arg);
+        printModifiers(n.getModifiers());
+
+        n.getType().accept(this, arg);
+        printer.print(" ");
+
+        for (Iterator<VariableDeclarator> i = n.getVars().iterator(); i.hasNext();) {
+            VariableDeclarator v = i.next();
+            v.accept(this, arg);
+            if (i.hasNext()) {
+                printer.print(", ");
+            }
+        }
+    }
+
+    public void visit(TypeDeclarationStmt n, Object arg) {
+        n.getTypeDeclaration().accept(this, arg);
+    }
+
+    public void visit(AssertStmt n, Object arg) {
+        printer.print("assert ");
+        n.getCheck().accept(this, arg);
+        if (n.getMessage() != null) {
+            printer.print(" : ");
+            n.getMessage().accept(this, arg);
+        }
+        printer.print(";");
+    }
+
+    public void visit(BlockStmt n, Object arg) {
+        printer.printLn("{");
+        if (n.getStmts() != null) {
+            printer.indent();
+            for (Statement s : n.getStmts()) {
+                s.accept(this, arg);
+                printer.printLn();
+            }
+            printer.unindent();
+        }
+        printer.print("}");
+
+    }
+
+    public void visit(LabeledStmt n, Object arg) {
+        printer.print(n.getLabel());
+        printer.print(": ");
+        n.getStmt().accept(this, arg);
+    }
+
+    public void visit(EmptyStmt n, Object arg) {
+        printer.print(";");
+    }
+
+    public void visit(ExpressionStmt n, Object arg) {
+        n.getExpression().accept(this, arg);
+        printer.print(";");
+    }
+
+    public void visit(SwitchStmt n, Object arg) {
+        printer.print("switch(");
+        n.getSelector().accept(this, arg);
+        printer.printLn(") {");
+        if (n.getEntries() != null) {
+            printer.indent();
+            for (SwitchEntryStmt e : n.getEntries()) {
+                e.accept(this, arg);
+            }
+            printer.unindent();
+        }
+        printer.print("}");
+
+    }
+
+    public void visit(SwitchEntryStmt n, Object arg) {
+        if (n.getLabel() != null) {
+            printer.print("case ");
+            n.getLabel().accept(this, arg);
+            printer.print(":");
+        } else {
+            printer.print("default:");
+        }
+        printer.printLn();
+        printer.indent();
+        if (n.getStmts() != null) {
+            for (Statement s : n.getStmts()) {
+                s.accept(this, arg);
+                printer.printLn();
+            }
+        }
+        printer.unindent();
+    }
+
+    public void visit(BreakStmt n, Object arg) {
+        printer.print("break");
+        if (n.getId() != null) {
+            printer.print(" ");
+            printer.print(n.getId());
+        }
+        printer.print(";");
+    }
+
+    public void visit(ReturnStmt n, Object arg) {
+        printer.print("return");
+        if (n.getExpr() != null) {
+            printer.print(" ");
+            n.getExpr().accept(this, arg);
+        }
+        printer.print(";");
+    }
+
+    public void visit(EnumDeclaration n, Object arg) {
+        printJavadoc(n.getJavaDoc(), arg);
+        printMemberAnnotations(n.getAnnotations(), arg);
+        printModifiers(n.getModifiers());
+
+        printer.print("enum ");
+        printer.print(n.getName());
+
+        if (n.getImplements() != null) {
+            printer.print(" implements ");
+            for (Iterator<ClassOrInterfaceType> i = n.getImplements().iterator(); i.hasNext();) {
+                ClassOrInterfaceType c = i.next();
+                c.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+
+        printer.printLn(" {");
+        printer.indent();
+        if (n.getEntries() != null) {
+            printer.printLn();
+            for (Iterator<EnumConstantDeclaration> i = n.getEntries().iterator(); i.hasNext();) {
+                EnumConstantDeclaration e = i.next();
+                e.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        if (n.getMembers() != null) {
+            printer.printLn(";");
+            printMembers(n.getMembers(), arg);
+        } else {
+            if (n.getEntries() != null) {
+                printer.printLn();
+            }
+        }
+        printer.unindent();
+        printer.print("}");
+    }
+
+    public void visit(EnumConstantDeclaration n, Object arg) {
+        printJavadoc(n.getJavaDoc(), arg);
+        printMemberAnnotations(n.getAnnotations(), arg);
+        printer.print(n.getName());
+
+        if (n.getArgs() != null) {
+            printArguments(n.getArgs(), arg);
+        }
+
+        if (n.getClassBody() != null) {
+            printer.printLn(" {");
+            printer.indent();
+            printMembers(n.getClassBody(), arg);
+            printer.unindent();
+            printer.printLn("}");
+        }
+    }
+
+    public void visit(EmptyMemberDeclaration n, Object arg) {
+        printJavadoc(n.getJavaDoc(), arg);
+        printer.print(";");
+    }
+
+    public void visit(InitializerDeclaration n, Object arg) {
+        printJavadoc(n.getJavaDoc(), arg);
+        if (n.isStatic()) {
+            printer.print("static ");
+        }
+        n.getBlock().accept(this, arg);
+    }
+
+    public void visit(IfStmt n, Object arg) {
+        printer.print("if (");
+        n.getCondition().accept(this, arg);
+        printer.print(") ");
+        n.getThenStmt().accept(this, arg);
+        if (n.getElseStmt() != null) {
+            printer.print(" else ");
+            n.getElseStmt().accept(this, arg);
+        }
+    }
+
+    public void visit(WhileStmt n, Object arg) {
+        printer.print("while (");
+        n.getCondition().accept(this, arg);
+        printer.print(") ");
+        n.getBody().accept(this, arg);
+    }
+
+    public void visit(ContinueStmt n, Object arg) {
+        printer.print("continue");
+        if (n.getId() != null) {
+            printer.print(" ");
+            printer.print(n.getId());
+        }
+        printer.print(";");
+    }
+
+    public void visit(DoStmt n, Object arg) {
+        printer.print("do ");
+        n.getBody().accept(this, arg);
+        printer.print(" while (");
+        n.getCondition().accept(this, arg);
+        printer.print(");");
+    }
+
+    public void visit(ForeachStmt n, Object arg) {
+        printer.print("for (");
+        n.getVariable().accept(this, arg);
+        printer.print(" : ");
+        n.getIterable().accept(this, arg);
+        printer.print(") ");
+        n.getBody().accept(this, arg);
+    }
+
+    public void visit(ForStmt n, Object arg) {
+        printer.print("for (");
+        if (n.getInit() != null) {
+            for (Iterator<Expression> i = n.getInit().iterator(); i.hasNext();) {
+                Expression e = i.next();
+                e.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        printer.print("; ");
+        if (n.getCompare() != null) {
+            n.getCompare().accept(this, arg);
+        }
+        printer.print("; ");
+        if (n.getUpdate() != null) {
+            for (Iterator<Expression> i = n.getUpdate().iterator(); i.hasNext();) {
+                Expression e = i.next();
+                e.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        printer.print(") ");
+        n.getBody().accept(this, arg);
+    }
+
+    public void visit(ThrowStmt n, Object arg) {
+        printer.print("throw ");
+        n.getExpr().accept(this, arg);
+        printer.print(";");
+    }
+
+    public void visit(SynchronizedStmt n, Object arg) {
+        printer.print("synchronized (");
+        n.getExpr().accept(this, arg);
+        printer.print(") ");
+        n.getBlock().accept(this, arg);
+    }
+
+    public void visit(TryStmt n, Object arg) {
+        printer.print("try ");
+        n.getTryBlock().accept(this, arg);
+        if (n.getCatchs() != null) {
+            for (CatchClause c : n.getCatchs()) {
+                c.accept(this, arg);
+            }
+        }
+        if (n.getFinallyBlock() != null) {
+            printer.print(" finally ");
+            n.getFinallyBlock().accept(this, arg);
+        }
+    }
+
+    public void visit(CatchClause n, Object arg) {
+        printer.print(" catch (");
+        n.getExcept().accept(this, arg);
+        printer.print(") ");
+        n.getCatchBlock().accept(this, arg);
+
+    }
+
+    public void visit(AnnotationDeclaration n, Object arg) {
+        printJavadoc(n.getJavaDoc(), arg);
+        printMemberAnnotations(n.getAnnotations(), arg);
+        printModifiers(n.getModifiers());
+
+        printer.print("@interface ");
+        printer.print(n.getName());
+        printer.printLn(" {");
+        printer.indent();
+        if (n.getMembers() != null) {
+            printMembers(n.getMembers(), arg);
+        }
+        printer.unindent();
+        printer.print("}");
+    }
+
+    public void visit(AnnotationMemberDeclaration n, Object arg) {
+        printJavadoc(n.getJavaDoc(), arg);
+        printMemberAnnotations(n.getAnnotations(), arg);
+        printModifiers(n.getModifiers());
+
+        n.getType().accept(this, arg);
+        printer.print(" ");
+        printer.print(n.getName());
+        printer.print("()");
+        if (n.getDefaultValue() != null) {
+            printer.print(" default ");
+            n.getDefaultValue().accept(this, arg);
+        }
+        printer.print(";");
+    }
+
+    public void visit(MarkerAnnotationExpr n, Object arg) {
+        printer.print("@");
+        n.getName().accept(this, arg);
+    }
+
+    public void visit(SingleMemberAnnotationExpr n, Object arg) {
+        printer.print("@");
+        n.getName().accept(this, arg);
+        printer.print("(");
+        n.getMemberValue().accept(this, arg);
+        printer.print(")");
+    }
+
+    public void visit(NormalAnnotationExpr n, Object arg) {
+        printer.print("@");
+        n.getName().accept(this, arg);
+        printer.print("(");
+        if (n.getPairs() != null) {
+            for (Iterator<MemberValuePair> i = n.getPairs().iterator(); i.hasNext();) {
+                MemberValuePair m = i.next();
+                m.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        printer.print(")");
+    }
+
+    public void visit(MemberValuePair n, Object arg) {
+        printer.print(n.getName());
+        printer.print(" = ");
+        n.getValue().accept(this, arg);
+    }
+
+    public void visit(LineComment n, Object arg) {
+        printer.print("//");
+        printer.printLn(n.getContent());
+    }
+
+    public void visit(BlockComment n, Object arg) {
+        printer.print("/*");
+        printer.print(n.getContent());
+        printer.printLn("*/");
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/visitor/GenericVisitor.java b/parser/html/java/javaparser/src/japa/parser/ast/visitor/GenericVisitor.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/visitor/GenericVisitor.java
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.visitor;
+
+import japa.parser.ast.BlockComment;
+import japa.parser.ast.CompilationUnit;
+import japa.parser.ast.ImportDeclaration;
+import japa.parser.ast.LineComment;
+import japa.parser.ast.PackageDeclaration;
+import japa.parser.ast.TypeParameter;
+import japa.parser.ast.body.AnnotationDeclaration;
+import japa.parser.ast.body.AnnotationMemberDeclaration;
+import japa.parser.ast.body.ClassOrInterfaceDeclaration;
+import japa.parser.ast.body.ConstructorDeclaration;
+import japa.parser.ast.body.EmptyMemberDeclaration;
+import japa.parser.ast.body.EmptyTypeDeclaration;
+import japa.parser.ast.body.EnumConstantDeclaration;
+import japa.parser.ast.body.EnumDeclaration;
+import japa.parser.ast.body.FieldDeclaration;
+import japa.parser.ast.body.InitializerDeclaration;
+import japa.parser.ast.body.JavadocComment;
+import japa.parser.ast.body.MethodDeclaration;
+import japa.parser.ast.body.Parameter;
+import japa.parser.ast.body.VariableDeclarator;
+import japa.parser.ast.body.VariableDeclaratorId;
+import japa.parser.ast.expr.ArrayAccessExpr;
+import japa.parser.ast.expr.ArrayCreationExpr;
+import japa.parser.ast.expr.ArrayInitializerExpr;
+import japa.parser.ast.expr.AssignExpr;
+import japa.parser.ast.expr.BinaryExpr;
+import japa.parser.ast.expr.BooleanLiteralExpr;
+import japa.parser.ast.expr.CastExpr;
+import japa.parser.ast.expr.CharLiteralExpr;
+import japa.parser.ast.expr.ClassExpr;
+import japa.parser.ast.expr.ConditionalExpr;
+import japa.parser.ast.expr.DoubleLiteralExpr;
+import japa.parser.ast.expr.EnclosedExpr;
+import japa.parser.ast.expr.FieldAccessExpr;
+import japa.parser.ast.expr.InstanceOfExpr;
+import japa.parser.ast.expr.IntegerLiteralExpr;
+import japa.parser.ast.expr.IntegerLiteralMinValueExpr;
+import japa.parser.ast.expr.LongLiteralExpr;
+import japa.parser.ast.expr.LongLiteralMinValueExpr;
+import japa.parser.ast.expr.MarkerAnnotationExpr;
+import japa.parser.ast.expr.MemberValuePair;
+import japa.parser.ast.expr.MethodCallExpr;
+import japa.parser.ast.expr.NameExpr;
+import japa.parser.ast.expr.NormalAnnotationExpr;
+import japa.parser.ast.expr.NullLiteralExpr;
+import japa.parser.ast.expr.ObjectCreationExpr;
+import japa.parser.ast.expr.QualifiedNameExpr;
+import japa.parser.ast.expr.SingleMemberAnnotationExpr;
+import japa.parser.ast.expr.StringLiteralExpr;
+import japa.parser.ast.expr.SuperExpr;
+import japa.parser.ast.expr.ThisExpr;
+import japa.parser.ast.expr.UnaryExpr;
+import japa.parser.ast.expr.VariableDeclarationExpr;
+import japa.parser.ast.stmt.AssertStmt;
+import japa.parser.ast.stmt.BlockStmt;
+import japa.parser.ast.stmt.BreakStmt;
+import japa.parser.ast.stmt.CatchClause;
+import japa.parser.ast.stmt.ContinueStmt;
+import japa.parser.ast.stmt.DoStmt;
+import japa.parser.ast.stmt.EmptyStmt;
+import japa.parser.ast.stmt.ExplicitConstructorInvocationStmt;
+import japa.parser.ast.stmt.ExpressionStmt;
+import japa.parser.ast.stmt.ForStmt;
+import japa.parser.ast.stmt.ForeachStmt;
+import japa.parser.ast.stmt.IfStmt;
+import japa.parser.ast.stmt.LabeledStmt;
+import japa.parser.ast.stmt.ReturnStmt;
+import japa.parser.ast.stmt.SwitchEntryStmt;
+import japa.parser.ast.stmt.SwitchStmt;
+import japa.parser.ast.stmt.SynchronizedStmt;
+import japa.parser.ast.stmt.ThrowStmt;
+import japa.parser.ast.stmt.TryStmt;
+import japa.parser.ast.stmt.TypeDeclarationStmt;
+import japa.parser.ast.stmt.WhileStmt;
+import japa.parser.ast.type.ClassOrInterfaceType;
+import japa.parser.ast.type.PrimitiveType;
+import japa.parser.ast.type.ReferenceType;
+import japa.parser.ast.type.VoidType;
+import japa.parser.ast.type.WildcardType;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public interface GenericVisitor<R, A> {
+
+    //- Compilation Unit ----------------------------------
+
+    public R visit(CompilationUnit n, A arg);
+
+    public R visit(PackageDeclaration n, A arg);
+
+    public R visit(ImportDeclaration n, A arg);
+
+    public R visit(TypeParameter n, A arg);
+
+    public R visit(LineComment n, A arg);
+
+    public R visit(BlockComment n, A arg);
+
+    //- Body ----------------------------------------------
+
+    public R visit(ClassOrInterfaceDeclaration n, A arg);
+
+    public R visit(EnumDeclaration n, A arg);
+
+    public R visit(EmptyTypeDeclaration n, A arg);
+
+    public R visit(EnumConstantDeclaration n, A arg);
+
+    public R visit(AnnotationDeclaration n, A arg);
+
+    public R visit(AnnotationMemberDeclaration n, A arg);
+
+    public R visit(FieldDeclaration n, A arg);
+
+    public R visit(VariableDeclarator n, A arg);
+
+    public R visit(VariableDeclaratorId n, A arg);
+
+    public R visit(ConstructorDeclaration n, A arg);
+
+    public R visit(MethodDeclaration n, A arg);
+
+    public R visit(Parameter n, A arg);
+
+    public R visit(EmptyMemberDeclaration n, A arg);
+
+    public R visit(InitializerDeclaration n, A arg);
+
+    public R visit(JavadocComment n, A arg);
+
+    //- Type ----------------------------------------------
+
+    public R visit(ClassOrInterfaceType n, A arg);
+
+    public R visit(PrimitiveType n, A arg);
+
+    public R visit(ReferenceType n, A arg);
+
+    public R visit(VoidType n, A arg);
+
+    public R visit(WildcardType n, A arg);
+
+    //- Expression ----------------------------------------
+
+    public R visit(ArrayAccessExpr n, A arg);
+
+    public R visit(ArrayCreationExpr n, A arg);
+
+    public R visit(ArrayInitializerExpr n, A arg);
+
+    public R visit(AssignExpr n, A arg);
+
+    public R visit(BinaryExpr n, A arg);
+
+    public R visit(CastExpr n, A arg);
+
+    public R visit(ClassExpr n, A arg);
+
+    public R visit(ConditionalExpr n, A arg);
+
+    public R visit(EnclosedExpr n, A arg);
+
+    public R visit(FieldAccessExpr n, A arg);
+
+    public R visit(InstanceOfExpr n, A arg);
+
+    public R visit(StringLiteralExpr n, A arg);
+
+    public R visit(IntegerLiteralExpr n, A arg);
+
+    public R visit(LongLiteralExpr n, A arg);
+
+    public R visit(IntegerLiteralMinValueExpr n, A arg);
+
+    public R visit(LongLiteralMinValueExpr n, A arg);
+
+    public R visit(CharLiteralExpr n, A arg);
+
+    public R visit(DoubleLiteralExpr n, A arg);
+
+    public R visit(BooleanLiteralExpr n, A arg);
+
+    public R visit(NullLiteralExpr n, A arg);
+
+    public R visit(MethodCallExpr n, A arg);
+
+    public R visit(NameExpr n, A arg);
+
+    public R visit(ObjectCreationExpr n, A arg);
+
+    public R visit(QualifiedNameExpr n, A arg);
+
+    public R visit(ThisExpr n, A arg);
+
+    public R visit(SuperExpr n, A arg);
+
+    public R visit(UnaryExpr n, A arg);
+
+    public R visit(VariableDeclarationExpr n, A arg);
+
+    public R visit(MarkerAnnotationExpr n, A arg);
+
+    public R visit(SingleMemberAnnotationExpr n, A arg);
+
+    public R visit(NormalAnnotationExpr n, A arg);
+
+    public R visit(MemberValuePair n, A arg);
+
+    //- Statements ----------------------------------------
+
+    public R visit(ExplicitConstructorInvocationStmt n, A arg);
+
+    public R visit(TypeDeclarationStmt n, A arg);
+
+    public R visit(AssertStmt n, A arg);
+
+    public R visit(BlockStmt n, A arg);
+
+    public R visit(LabeledStmt n, A arg);
+
+    public R visit(EmptyStmt n, A arg);
+
+    public R visit(ExpressionStmt n, A arg);
+
+    public R visit(SwitchStmt n, A arg);
+
+    public R visit(SwitchEntryStmt n, A arg);
+
+    public R visit(BreakStmt n, A arg);
+
+    public R visit(ReturnStmt n, A arg);
+
+    public R visit(IfStmt n, A arg);
+
+    public R visit(WhileStmt n, A arg);
+
+    public R visit(ContinueStmt n, A arg);
+
+    public R visit(DoStmt n, A arg);
+
+    public R visit(ForeachStmt n, A arg);
+
+    public R visit(ForStmt n, A arg);
+
+    public R visit(ThrowStmt n, A arg);
+
+    public R visit(SynchronizedStmt n, A arg);
+
+    public R visit(TryStmt n, A arg);
+
+    public R visit(CatchClause n, A arg);
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/visitor/GenericVisitorAdapter.java b/parser/html/java/javaparser/src/japa/parser/ast/visitor/GenericVisitorAdapter.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/visitor/GenericVisitorAdapter.java
@@ -0,0 +1,825 @@
+/*
+ * Copyright (C) 2008 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 09/06/2008
+ */
+package japa.parser.ast.visitor;
+
+import japa.parser.ast.BlockComment;
+import japa.parser.ast.CompilationUnit;
+import japa.parser.ast.ImportDeclaration;
+import japa.parser.ast.LineComment;
+import japa.parser.ast.PackageDeclaration;
+import japa.parser.ast.TypeParameter;
+import japa.parser.ast.body.AnnotationDeclaration;
+import japa.parser.ast.body.AnnotationMemberDeclaration;
+import japa.parser.ast.body.BodyDeclaration;
+import japa.parser.ast.body.ClassOrInterfaceDeclaration;
+import japa.parser.ast.body.ConstructorDeclaration;
+import japa.parser.ast.body.EmptyMemberDeclaration;
+import japa.parser.ast.body.EmptyTypeDeclaration;
+import japa.parser.ast.body.EnumConstantDeclaration;
+import japa.parser.ast.body.EnumDeclaration;
+import japa.parser.ast.body.FieldDeclaration;
+import japa.parser.ast.body.InitializerDeclaration;
+import japa.parser.ast.body.JavadocComment;
+import japa.parser.ast.body.MethodDeclaration;
+import japa.parser.ast.body.Parameter;
+import japa.parser.ast.body.TypeDeclaration;
+import japa.parser.ast.body.VariableDeclarator;
+import japa.parser.ast.body.VariableDeclaratorId;
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.expr.ArrayAccessExpr;
+import japa.parser.ast.expr.ArrayCreationExpr;
+import japa.parser.ast.expr.ArrayInitializerExpr;
+import japa.parser.ast.expr.AssignExpr;
+import japa.parser.ast.expr.BinaryExpr;
+import japa.parser.ast.expr.BooleanLiteralExpr;
+import japa.parser.ast.expr.CastExpr;
+import japa.parser.ast.expr.CharLiteralExpr;
+import japa.parser.ast.expr.ClassExpr;
+import japa.parser.ast.expr.ConditionalExpr;
+import japa.parser.ast.expr.DoubleLiteralExpr;
+import japa.parser.ast.expr.EnclosedExpr;
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.expr.FieldAccessExpr;
+import japa.parser.ast.expr.InstanceOfExpr;
+import japa.parser.ast.expr.IntegerLiteralExpr;
+import japa.parser.ast.expr.IntegerLiteralMinValueExpr;
+import japa.parser.ast.expr.LongLiteralExpr;
+import japa.parser.ast.expr.LongLiteralMinValueExpr;
+import japa.parser.ast.expr.MarkerAnnotationExpr;
+import japa.parser.ast.expr.MemberValuePair;
+import japa.parser.ast.expr.MethodCallExpr;
+import japa.parser.ast.expr.NameExpr;
+import japa.parser.ast.expr.NormalAnnotationExpr;
+import japa.parser.ast.expr.NullLiteralExpr;
+import japa.parser.ast.expr.ObjectCreationExpr;
+import japa.parser.ast.expr.QualifiedNameExpr;
+import japa.parser.ast.expr.SingleMemberAnnotationExpr;
+import japa.parser.ast.expr.StringLiteralExpr;
+import japa.parser.ast.expr.SuperExpr;
+import japa.parser.ast.expr.ThisExpr;
+import japa.parser.ast.expr.UnaryExpr;
+import japa.parser.ast.expr.VariableDeclarationExpr;
+import japa.parser.ast.stmt.AssertStmt;
+import japa.parser.ast.stmt.BlockStmt;
+import japa.parser.ast.stmt.BreakStmt;
+import japa.parser.ast.stmt.CatchClause;
+import japa.parser.ast.stmt.ContinueStmt;
+import japa.parser.ast.stmt.DoStmt;
+import japa.parser.ast.stmt.EmptyStmt;
+import japa.parser.ast.stmt.ExplicitConstructorInvocationStmt;
+import japa.parser.ast.stmt.ExpressionStmt;
+import japa.parser.ast.stmt.ForStmt;
+import japa.parser.ast.stmt.ForeachStmt;
+import japa.parser.ast.stmt.IfStmt;
+import japa.parser.ast.stmt.LabeledStmt;
+import japa.parser.ast.stmt.ReturnStmt;
+import japa.parser.ast.stmt.Statement;
+import japa.parser.ast.stmt.SwitchEntryStmt;
+import japa.parser.ast.stmt.SwitchStmt;
+import japa.parser.ast.stmt.SynchronizedStmt;
+import japa.parser.ast.stmt.ThrowStmt;
+import japa.parser.ast.stmt.TryStmt;
+import japa.parser.ast.stmt.TypeDeclarationStmt;
+import japa.parser.ast.stmt.WhileStmt;
+import japa.parser.ast.type.ClassOrInterfaceType;
+import japa.parser.ast.type.PrimitiveType;
+import japa.parser.ast.type.ReferenceType;
+import japa.parser.ast.type.Type;
+import japa.parser.ast.type.VoidType;
+import japa.parser.ast.type.WildcardType;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public abstract class GenericVisitorAdapter<R, A> implements GenericVisitor<R, A> {
+
+    public R visit(AnnotationDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        if (n.getMembers() != null) {
+            for (BodyDeclaration member : n.getMembers()) {
+                member.accept(this, arg);
+            }
+        }
+        return null;
+    }
+
+    public R visit(AnnotationMemberDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        n.getType().accept(this, arg);
+        if (n.getDefaultValue() != null) {
+            n.getDefaultValue().accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(ArrayAccessExpr n, A arg) {
+        n.getName().accept(this, arg);
+        n.getIndex().accept(this, arg);
+        return null;
+    }
+
+    public R visit(ArrayCreationExpr n, A arg) {
+        n.getType().accept(this, arg);
+        if (n.getDimensions() != null) {
+            for (Expression dim : n.getDimensions()) {
+                dim.accept(this, arg);
+            }
+        } else {
+            n.getInitializer().accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(ArrayInitializerExpr n, A arg) {
+        if (n.getValues() != null) {
+            for (Expression expr : n.getValues()) {
+                expr.accept(this, arg);
+            }
+        }
+        return null;
+    }
+
+    public R visit(AssertStmt n, A arg) {
+        n.getCheck().accept(this, arg);
+        if (n.getMessage() != null) {
+            n.getMessage().accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(AssignExpr n, A arg) {
+        n.getTarget().accept(this, arg);
+        n.getValue().accept(this, arg);
+        return null;
+    }
+
+    public R visit(BinaryExpr n, A arg) {
+        n.getLeft().accept(this, arg);
+        n.getRight().accept(this, arg);
+        return null;
+    }
+
+    public R visit(BlockStmt n, A arg) {
+        if (n.getStmts() != null) {
+            for (Statement s : n.getStmts()) {
+                s.accept(this, arg);
+            }
+        }
+        return null;
+
+    }
+
+    public R visit(BooleanLiteralExpr n, A arg) {
+        return null;
+    }
+
+    public R visit(BreakStmt n, A arg) {
+        return null;
+    }
+
+    public R visit(CastExpr n, A arg) {
+        n.getType().accept(this, arg);
+        n.getExpr().accept(this, arg);
+        return null;
+    }
+
+    public R visit(CatchClause n, A arg) {
+        n.getExcept().accept(this, arg);
+        n.getCatchBlock().accept(this, arg);
+        return null;
+
+    }
+
+    public R visit(CharLiteralExpr n, A arg) {
+        return null;
+    }
+
+    public R visit(ClassExpr n, A arg) {
+        n.getType().accept(this, arg);
+        return null;
+    }
+
+    public R visit(ClassOrInterfaceDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        if (n.getTypeParameters() != null) {
+            for (TypeParameter t : n.getTypeParameters()) {
+                t.accept(this, arg);
+            }
+        }
+        if (n.getExtends() != null) {
+            for (ClassOrInterfaceType c : n.getExtends()) {
+                c.accept(this, arg);
+            }
+        }
+
+        if (n.getImplements() != null) {
+            for (ClassOrInterfaceType c : n.getImplements()) {
+                c.accept(this, arg);
+            }
+        }
+        if (n.getMembers() != null) {
+            for (BodyDeclaration member : n.getMembers()) {
+                member.accept(this, arg);
+            }
+        }
+        return null;
+    }
+
+    public R visit(ClassOrInterfaceType n, A arg) {
+        if (n.getScope() != null) {
+            n.getScope().accept(this, arg);
+        }
+        if (n.getTypeArgs() != null) {
+            for (Type t : n.getTypeArgs()) {
+                t.accept(this, arg);
+            }
+        }
+        return null;
+    }
+
+    public R visit(CompilationUnit n, A arg) {
+        if (n.getPackage() != null) {
+            n.getPackage().accept(this, arg);
+        }
+        if (n.getImports() != null) {
+            for (ImportDeclaration i : n.getImports()) {
+                i.accept(this, arg);
+            }
+        }
+        if (n.getTypes() != null) {
+            for (TypeDeclaration typeDeclaration : n.getTypes()) {
+                typeDeclaration.accept(this, arg);
+            }
+        }
+        return null;
+    }
+
+    public R visit(ConditionalExpr n, A arg) {
+        n.getCondition().accept(this, arg);
+        n.getThenExpr().accept(this, arg);
+        n.getElseExpr().accept(this, arg);
+        return null;
+    }
+
+    public R visit(ConstructorDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        if (n.getTypeParameters() != null) {
+            for (TypeParameter t : n.getTypeParameters()) {
+                t.accept(this, arg);
+            }
+        }
+        if (n.getParameters() != null) {
+            for (Parameter p : n.getParameters()) {
+                p.accept(this, arg);
+            }
+        }
+        if (n.getThrows() != null) {
+            for (NameExpr name : n.getThrows()) {
+                name.accept(this, arg);
+            }
+        }
+        n.getBlock().accept(this, arg);
+        return null;
+    }
+
+    public R visit(ContinueStmt n, A arg) {
+        return null;
+    }
+
+    public R visit(DoStmt n, A arg) {
+        n.getBody().accept(this, arg);
+        n.getCondition().accept(this, arg);
+        return null;
+    }
+
+    public R visit(DoubleLiteralExpr n, A arg) {
+        return null;
+    }
+
+    public R visit(EmptyMemberDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(EmptyStmt n, A arg) {
+        return null;
+    }
+
+    public R visit(EmptyTypeDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(EnclosedExpr n, A arg) {
+        n.getInner().accept(this, arg);
+        return null;
+    }
+
+    public R visit(EnumConstantDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        if (n.getArgs() != null) {
+            for (Expression e : n.getArgs()) {
+                e.accept(this, arg);
+            }
+        }
+        if (n.getClassBody() != null) {
+            for (BodyDeclaration member : n.getClassBody()) {
+                member.accept(this, arg);
+            }
+        }
+        return null;
+    }
+
+    public R visit(EnumDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        if (n.getImplements() != null) {
+            for (ClassOrInterfaceType c : n.getImplements()) {
+                c.accept(this, arg);
+            }
+        }
+        if (n.getEntries() != null) {
+            for (EnumConstantDeclaration e : n.getEntries()) {
+                e.accept(this, arg);
+            }
+        }
+        if (n.getMembers() != null) {
+            for (BodyDeclaration member : n.getMembers()) {
+                member.accept(this, arg);
+            }
+        }
+        return null;
+    }
+
+    public R visit(ExplicitConstructorInvocationStmt n, A arg) {
+        if (!n.isThis()) {
+            if (n.getExpr() != null) {
+                n.getExpr().accept(this, arg);
+            }
+        }
+        if (n.getTypeArgs() != null) {
+            for (Type t : n.getTypeArgs()) {
+                t.accept(this, arg);
+            }
+        }
+        if (n.getArgs() != null) {
+            for (Expression e : n.getArgs()) {
+                e.accept(this, arg);
+            }
+        }
+        return null;
+    }
+
+    public R visit(ExpressionStmt n, A arg) {
+        n.getExpression().accept(this, arg);
+        return null;
+    }
+
+    public R visit(FieldAccessExpr n, A arg) {
+        n.getScope().accept(this, arg);
+        return null;
+    }
+
+    public R visit(FieldDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        n.getType().accept(this, arg);
+        for (VariableDeclarator var : n.getVariables()) {
+            var.accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(ForeachStmt n, A arg) {
+        n.getVariable().accept(this, arg);
+        n.getIterable().accept(this, arg);
+        n.getBody().accept(this, arg);
+        return null;
+    }
+
+    public R visit(ForStmt n, A arg) {
+        if (n.getInit() != null) {
+            for (Expression e : n.getInit()) {
+                e.accept(this, arg);
+            }
+        }
+        if (n.getCompare() != null) {
+            n.getCompare().accept(this, arg);
+        }
+        if (n.getUpdate() != null) {
+            for (Expression e : n.getUpdate()) {
+                e.accept(this, arg);
+            }
+        }
+        n.getBody().accept(this, arg);
+        return null;
+    }
+
+    public R visit(IfStmt n, A arg) {
+        n.getCondition().accept(this, arg);
+        n.getThenStmt().accept(this, arg);
+        if (n.getElseStmt() != null) {
+            n.getElseStmt().accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(ImportDeclaration n, A arg) {
+        n.getName().accept(this, arg);
+        return null;
+    }
+
+    public R visit(InitializerDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        n.getBlock().accept(this, arg);
+        return null;
+    }
+
+    public R visit(InstanceOfExpr n, A arg) {
+        n.getExpr().accept(this, arg);
+        n.getType().accept(this, arg);
+        return null;
+    }
+
+    public R visit(IntegerLiteralExpr n, A arg) {
+        return null;
+    }
+
+    public R visit(IntegerLiteralMinValueExpr n, A arg) {
+        return null;
+    }
+
+    public R visit(JavadocComment n, A arg) {
+        return null;
+    }
+
+    public R visit(LabeledStmt n, A arg) {
+        n.getStmt().accept(this, arg);
+        return null;
+    }
+
+    public R visit(LongLiteralExpr n, A arg) {
+        return null;
+    }
+
+    public R visit(LongLiteralMinValueExpr n, A arg) {
+        return null;
+    }
+
+    public R visit(MarkerAnnotationExpr n, A arg) {
+        n.getName().accept(this, arg);
+        return null;
+    }
+
+    public R visit(MemberValuePair n, A arg) {
+        n.getValue().accept(this, arg);
+        return null;
+    }
+
+    public R visit(MethodCallExpr n, A arg) {
+        if (n.getScope() != null) {
+            n.getScope().accept(this, arg);
+        }
+        if (n.getTypeArgs() != null) {
+            for (Type t : n.getTypeArgs()) {
+                t.accept(this, arg);
+            }
+        }
+        if (n.getArgs() != null) {
+            for (Expression e : n.getArgs()) {
+                e.accept(this, arg);
+            }
+        }
+        return null;
+    }
+
+    public R visit(MethodDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        if (n.getTypeParameters() != null) {
+            for (TypeParameter t : n.getTypeParameters()) {
+                t.accept(this, arg);
+            }
+        }
+        n.getType().accept(this, arg);
+        if (n.getParameters() != null) {
+            for (Parameter p : n.getParameters()) {
+                p.accept(this, arg);
+            }
+        }
+        if (n.getThrows() != null) {
+            for (NameExpr name : n.getThrows()) {
+                name.accept(this, arg);
+            }
+        }
+        if (n.getBody() != null) {
+            n.getBody().accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(NameExpr n, A arg) {
+        return null;
+    }
+
+    public R visit(NormalAnnotationExpr n, A arg) {
+        n.getName().accept(this, arg);
+        if (n.getPairs() != null) {
+            for (MemberValuePair m : n.getPairs()) {
+                m.accept(this, arg);
+            }
+        }
+        return null;
+    }
+
+    public R visit(NullLiteralExpr n, A arg) {
+        return null;
+    }
+
+    public R visit(ObjectCreationExpr n, A arg) {
+        if (n.getScope() != null) {
+            n.getScope().accept(this, arg);
+        }
+        if (n.getTypeArgs() != null) {
+            for (Type t : n.getTypeArgs()) {
+                t.accept(this, arg);
+            }
+        }
+        n.getType().accept(this, arg);
+        if (n.getArgs() != null) {
+            for (Expression e : n.getArgs()) {
+                e.accept(this, arg);
+            }
+        }
+        if (n.getAnonymousClassBody() != null) {
+            for (BodyDeclaration member : n.getAnonymousClassBody()) {
+                member.accept(this, arg);
+            }
+        }
+        return null;
+    }
+
+    public R visit(PackageDeclaration n, A arg) {
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        n.getName().accept(this, arg);
+        return null;
+    }
+
+    public R visit(Parameter n, A arg) {
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        n.getType().accept(this, arg);
+        n.getId().accept(this, arg);
+        return null;
+    }
+
+    public R visit(PrimitiveType n, A arg) {
+        return null;
+    }
+
+    public R visit(QualifiedNameExpr n, A arg) {
+        n.getQualifier().accept(this, arg);
+        return null;
+    }
+
+    public R visit(ReferenceType n, A arg) {
+        n.getType().accept(this, arg);
+        return null;
+    }
+
+    public R visit(ReturnStmt n, A arg) {
+        if (n.getExpr() != null) {
+            n.getExpr().accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(SingleMemberAnnotationExpr n, A arg) {
+        n.getName().accept(this, arg);
+        n.getMemberValue().accept(this, arg);
+        return null;
+    }
+
+    public R visit(StringLiteralExpr n, A arg) {
+        return null;
+    }
+
+    public R visit(SuperExpr n, A arg) {
+        if (n.getClassExpr() != null) {
+            n.getClassExpr().accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(SwitchEntryStmt n, A arg) {
+        if (n.getLabel() != null) {
+            n.getLabel().accept(this, arg);
+        }
+        if (n.getStmts() != null) {
+            for (Statement s : n.getStmts()) {
+                s.accept(this, arg);
+            }
+        }
+        return null;
+    }
+
+    public R visit(SwitchStmt n, A arg) {
+        n.getSelector().accept(this, arg);
+        if (n.getEntries() != null) {
+            for (SwitchEntryStmt e : n.getEntries()) {
+                e.accept(this, arg);
+            }
+        }
+        return null;
+
+    }
+
+    public R visit(SynchronizedStmt n, A arg) {
+        n.getExpr().accept(this, arg);
+        n.getBlock().accept(this, arg);
+        return null;
+    }
+
+    public R visit(ThisExpr n, A arg) {
+        if (n.getClassExpr() != null) {
+            n.getClassExpr().accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(ThrowStmt n, A arg) {
+        n.getExpr().accept(this, arg);
+        return null;
+    }
+
+    public R visit(TryStmt n, A arg) {
+        n.getTryBlock().accept(this, arg);
+        if (n.getCatchs() != null) {
+            for (CatchClause c : n.getCatchs()) {
+                c.accept(this, arg);
+            }
+        }
+        if (n.getFinallyBlock() != null) {
+            n.getFinallyBlock().accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(TypeDeclarationStmt n, A arg) {
+        n.getTypeDeclaration().accept(this, arg);
+        return null;
+    }
+
+    public R visit(TypeParameter n, A arg) {
+        if (n.getTypeBound() != null) {
+            for (ClassOrInterfaceType c : n.getTypeBound()) {
+                c.accept(this, arg);
+            }
+        }
+        return null;
+    }
+
+    public R visit(UnaryExpr n, A arg) {
+        n.getExpr().accept(this, arg);
+        return null;
+    }
+
+    public R visit(VariableDeclarationExpr n, A arg) {
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        n.getType().accept(this, arg);
+        for (VariableDeclarator v : n.getVars()) {
+            v.accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(VariableDeclarator n, A arg) {
+        n.getId().accept(this, arg);
+        if (n.getInit() != null) {
+            n.getInit().accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(VariableDeclaratorId n, A arg) {
+        return null;
+    }
+
+    public R visit(VoidType n, A arg) {
+        return null;
+    }
+
+    public R visit(WhileStmt n, A arg) {
+        n.getCondition().accept(this, arg);
+        n.getBody().accept(this, arg);
+        return null;
+    }
+
+    public R visit(WildcardType n, A arg) {
+        if (n.getExtends() != null) {
+            n.getExtends().accept(this, arg);
+        }
+        if (n.getSuper() != null) {
+            n.getSuper().accept(this, arg);
+        }
+        return null;
+    }
+
+    public R visit(BlockComment n, A arg) {
+        return null;
+    }
+
+    public R visit(LineComment n, A arg) {
+        return null;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/visitor/ModifierVisitorAdapter.java b/parser/html/java/javaparser/src/japa/parser/ast/visitor/ModifierVisitorAdapter.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/visitor/ModifierVisitorAdapter.java
@@ -0,0 +1,940 @@
+/*
+ * Copyright (C) 2008 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 09/06/2008
+ */
+package japa.parser.ast.visitor;
+
+import japa.parser.ast.BlockComment;
+import japa.parser.ast.CompilationUnit;
+import japa.parser.ast.ImportDeclaration;
+import japa.parser.ast.LineComment;
+import japa.parser.ast.Node;
+import japa.parser.ast.PackageDeclaration;
+import japa.parser.ast.TypeParameter;
+import japa.parser.ast.body.AnnotationDeclaration;
+import japa.parser.ast.body.AnnotationMemberDeclaration;
+import japa.parser.ast.body.BodyDeclaration;
+import japa.parser.ast.body.ClassOrInterfaceDeclaration;
+import japa.parser.ast.body.ConstructorDeclaration;
+import japa.parser.ast.body.EmptyMemberDeclaration;
+import japa.parser.ast.body.EmptyTypeDeclaration;
+import japa.parser.ast.body.EnumConstantDeclaration;
+import japa.parser.ast.body.EnumDeclaration;
+import japa.parser.ast.body.FieldDeclaration;
+import japa.parser.ast.body.InitializerDeclaration;
+import japa.parser.ast.body.JavadocComment;
+import japa.parser.ast.body.MethodDeclaration;
+import japa.parser.ast.body.Parameter;
+import japa.parser.ast.body.TypeDeclaration;
+import japa.parser.ast.body.VariableDeclarator;
+import japa.parser.ast.body.VariableDeclaratorId;
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.expr.ArrayAccessExpr;
+import japa.parser.ast.expr.ArrayCreationExpr;
+import japa.parser.ast.expr.ArrayInitializerExpr;
+import japa.parser.ast.expr.AssignExpr;
+import japa.parser.ast.expr.BinaryExpr;
+import japa.parser.ast.expr.BooleanLiteralExpr;
+import japa.parser.ast.expr.CastExpr;
+import japa.parser.ast.expr.CharLiteralExpr;
+import japa.parser.ast.expr.ClassExpr;
+import japa.parser.ast.expr.ConditionalExpr;
+import japa.parser.ast.expr.DoubleLiteralExpr;
+import japa.parser.ast.expr.EnclosedExpr;
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.expr.FieldAccessExpr;
+import japa.parser.ast.expr.InstanceOfExpr;
+import japa.parser.ast.expr.IntegerLiteralExpr;
+import japa.parser.ast.expr.IntegerLiteralMinValueExpr;
+import japa.parser.ast.expr.LongLiteralExpr;
+import japa.parser.ast.expr.LongLiteralMinValueExpr;
+import japa.parser.ast.expr.MarkerAnnotationExpr;
+import japa.parser.ast.expr.MemberValuePair;
+import japa.parser.ast.expr.MethodCallExpr;
+import japa.parser.ast.expr.NameExpr;
+import japa.parser.ast.expr.NormalAnnotationExpr;
+import japa.parser.ast.expr.NullLiteralExpr;
+import japa.parser.ast.expr.ObjectCreationExpr;
+import japa.parser.ast.expr.QualifiedNameExpr;
+import japa.parser.ast.expr.SingleMemberAnnotationExpr;
+import japa.parser.ast.expr.StringLiteralExpr;
+import japa.parser.ast.expr.SuperExpr;
+import japa.parser.ast.expr.ThisExpr;
+import japa.parser.ast.expr.UnaryExpr;
+import japa.parser.ast.expr.VariableDeclarationExpr;
+import japa.parser.ast.stmt.AssertStmt;
+import japa.parser.ast.stmt.BlockStmt;
+import japa.parser.ast.stmt.BreakStmt;
+import japa.parser.ast.stmt.CatchClause;
+import japa.parser.ast.stmt.ContinueStmt;
+import japa.parser.ast.stmt.DoStmt;
+import japa.parser.ast.stmt.EmptyStmt;
+import japa.parser.ast.stmt.ExplicitConstructorInvocationStmt;
+import japa.parser.ast.stmt.ExpressionStmt;
+import japa.parser.ast.stmt.ForStmt;
+import japa.parser.ast.stmt.ForeachStmt;
+import japa.parser.ast.stmt.IfStmt;
+import japa.parser.ast.stmt.LabeledStmt;
+import japa.parser.ast.stmt.ReturnStmt;
+import japa.parser.ast.stmt.Statement;
+import japa.parser.ast.stmt.SwitchEntryStmt;
+import japa.parser.ast.stmt.SwitchStmt;
+import japa.parser.ast.stmt.SynchronizedStmt;
+import japa.parser.ast.stmt.ThrowStmt;
+import japa.parser.ast.stmt.TryStmt;
+import japa.parser.ast.stmt.TypeDeclarationStmt;
+import japa.parser.ast.stmt.WhileStmt;
+import japa.parser.ast.type.ClassOrInterfaceType;
+import japa.parser.ast.type.PrimitiveType;
+import japa.parser.ast.type.ReferenceType;
+import japa.parser.ast.type.Type;
+import japa.parser.ast.type.VoidType;
+import japa.parser.ast.type.WildcardType;
+
+import java.util.List;
+
+/**
+ * This visitor adapter can be used to save time when some specific nodes needs
+ * to be changed. To do that just extend this class and override the methods
+ * from the nodes who needs to be changed, returning the changed node.
+ * 
+ * @author Julio Vilmar Gesser
+ */
+public abstract class ModifierVisitorAdapter<A> implements GenericVisitor<Node, A> {
+
+    private void removeNulls(List< ? > list) {
+        for (int i = list.size() - 1; i >= 0; i--) {
+            if (list.get(i) == null) {
+                list.remove(i);
+            }
+        }
+    }
+
+    public Node visit(AnnotationDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.setJavaDoc((JavadocComment) n.getJavaDoc().accept(this, arg));
+        }
+        List<AnnotationExpr> annotations = n.getAnnotations();
+        if (annotations != null) {
+            for (int i = 0; i < annotations.size(); i++) {
+                annotations.set(i, (AnnotationExpr) annotations.get(i).accept(this, arg));
+            }
+            removeNulls(annotations);
+        }
+        List<BodyDeclaration> members = n.getMembers();
+        if (members != null) {
+            for (int i = 0; i < members.size(); i++) {
+                members.set(i, (BodyDeclaration) members.get(i).accept(this, arg));
+            }
+            removeNulls(members);
+        }
+        return n;
+    }
+
+    public Node visit(AnnotationMemberDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.setJavaDoc((JavadocComment) n.getJavaDoc().accept(this, arg));
+        }
+        List<AnnotationExpr> annotations = n.getAnnotations();
+        if (annotations != null) {
+            for (int i = 0; i < annotations.size(); i++) {
+                annotations.set(i, (AnnotationExpr) annotations.get(i).accept(this, arg));
+            }
+            removeNulls(annotations);
+        }
+        n.setType((Type) n.getType().accept(this, arg));
+        if (n.getDefaultValue() != null) {
+            n.setDefaultValue((Expression) n.getDefaultValue().accept(this, arg));
+        }
+        return n;
+    }
+
+    public Node visit(ArrayAccessExpr n, A arg) {
+        n.setName((Expression) n.getName().accept(this, arg));
+        n.setIndex((Expression) n.getIndex().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(ArrayCreationExpr n, A arg) {
+        n.setType((Type) n.getType().accept(this, arg));
+        if (n.getDimensions() != null) {
+            List<Expression> dimensions = n.getDimensions();
+            if (dimensions != null) {
+                for (int i = 0; i < dimensions.size(); i++) {
+                    dimensions.set(i, (Expression) dimensions.get(i).accept(this, arg));
+                }
+                removeNulls(dimensions);
+            }
+        } else {
+            n.setInitializer((ArrayInitializerExpr) n.getInitializer().accept(this, arg));
+        }
+        return n;
+    }
+
+    public Node visit(ArrayInitializerExpr n, A arg) {
+        if (n.getValues() != null) {
+            List<Expression> values = n.getValues();
+            if (values != null) {
+                for (int i = 0; i < values.size(); i++) {
+                    values.set(i, (Expression) values.get(i).accept(this, arg));
+                }
+                removeNulls(values);
+            }
+        }
+        return n;
+    }
+
+    public Node visit(AssertStmt n, A arg) {
+        n.setCheck((Expression) n.getCheck().accept(this, arg));
+        if (n.getMessage() != null) {
+            n.setMessage((Expression) n.getMessage().accept(this, arg));
+        }
+        return n;
+    }
+
+    public Node visit(AssignExpr n, A arg) {
+        n.setTarget((Expression) n.getTarget().accept(this, arg));
+        n.setValue((Expression) n.getValue().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(BinaryExpr n, A arg) {
+        n.setLeft((Expression) n.getLeft().accept(this, arg));
+        n.setRight((Expression) n.getRight().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(BlockStmt n, A arg) {
+        List<Statement> stmts = n.getStmts();
+        if (stmts != null) {
+            for (int i = 0; i < stmts.size(); i++) {
+                stmts.set(i, (Statement) stmts.get(i).accept(this, arg));
+            }
+            removeNulls(stmts);
+        }
+        return n;
+    }
+
+    public Node visit(BooleanLiteralExpr n, A arg) {
+        return n;
+    }
+
+    public Node visit(BreakStmt n, A arg) {
+        return n;
+    }
+
+    public Node visit(CastExpr n, A arg) {
+        n.setType((Type) n.getType().accept(this, arg));
+        n.setExpr((Expression) n.getExpr().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(CatchClause n, A arg) {
+        n.setExcept((Parameter) n.getExcept().accept(this, arg));
+        n.setCatchBlock((BlockStmt) n.getCatchBlock().accept(this, arg));
+        return n;
+
+    }
+
+    public Node visit(CharLiteralExpr n, A arg) {
+        return n;
+    }
+
+    public Node visit(ClassExpr n, A arg) {
+        n.setType((Type) n.getType().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(ClassOrInterfaceDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.setJavaDoc((JavadocComment) n.getJavaDoc().accept(this, arg));
+        }
+        List<AnnotationExpr> annotations = n.getAnnotations();
+        if (annotations != null) {
+            for (int i = 0; i < annotations.size(); i++) {
+                annotations.set(i, (AnnotationExpr) annotations.get(i).accept(this, arg));
+            }
+            removeNulls(annotations);
+        }
+        List<TypeParameter> typeParameters = n.getTypeParameters();
+        if (typeParameters != null) {
+            for (int i = 0; i < typeParameters.size(); i++) {
+                typeParameters.set(i, (TypeParameter) typeParameters.get(i).accept(this, arg));
+            }
+            removeNulls(typeParameters);
+        }
+        List<ClassOrInterfaceType> extendz = n.getExtends();
+        if (extendz != null) {
+            for (int i = 0; i < extendz.size(); i++) {
+                extendz.set(i, (ClassOrInterfaceType) extendz.get(i).accept(this, arg));
+            }
+            removeNulls(extendz);
+        }
+        List<ClassOrInterfaceType> implementz = n.getImplements();
+        if (implementz != null) {
+            for (int i = 0; i < implementz.size(); i++) {
+                implementz.set(i, (ClassOrInterfaceType) implementz.get(i).accept(this, arg));
+            }
+            removeNulls(implementz);
+        }
+        List<BodyDeclaration> members = n.getMembers();
+        if (members != null) {
+            for (int i = 0; i < members.size(); i++) {
+                members.set(i, (BodyDeclaration) members.get(i).accept(this, arg));
+            }
+            removeNulls(members);
+        }
+        return n;
+    }
+
+    public Node visit(ClassOrInterfaceType n, A arg) {
+        if (n.getScope() != null) {
+            n.setScope((ClassOrInterfaceType) n.getScope().accept(this, arg));
+        }
+        List<Type> typeArgs = n.getTypeArgs();
+        if (typeArgs != null) {
+            for (int i = 0; i < typeArgs.size(); i++) {
+                typeArgs.set(i, (Type) typeArgs.get(i).accept(this, arg));
+            }
+            removeNulls(typeArgs);
+        }
+        return n;
+    }
+
+    public Node visit(CompilationUnit n, A arg) {
+        if (n.getPackage() != null) {
+            n.setPackage((PackageDeclaration) n.getPackage().accept(this, arg));
+        }
+        List<ImportDeclaration> imports = n.getImports();
+        if (imports != null) {
+            for (int i = 0; i < imports.size(); i++) {
+                imports.set(i, (ImportDeclaration) imports.get(i).accept(this, arg));
+            }
+            removeNulls(imports);
+        }
+        List<TypeDeclaration> types = n.getTypes();
+        if (types != null) {
+            for (int i = 0; i < types.size(); i++) {
+                types.set(i, (TypeDeclaration) types.get(i).accept(this, arg));
+            }
+            removeNulls(types);
+        }
+        return n;
+    }
+
+    public Node visit(ConditionalExpr n, A arg) {
+        n.setCondition((Expression) n.getCondition().accept(this, arg));
+        n.setThenExpr((Expression) n.getThenExpr().accept(this, arg));
+        n.setElseExpr((Expression) n.getElseExpr().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(ConstructorDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.setJavaDoc((JavadocComment) n.getJavaDoc().accept(this, arg));
+        }
+        List<AnnotationExpr> annotations = n.getAnnotations();
+        if (annotations != null) {
+            for (int i = 0; i < annotations.size(); i++) {
+                annotations.set(i, (AnnotationExpr) annotations.get(i).accept(this, arg));
+            }
+            removeNulls(annotations);
+        }
+        List<TypeParameter> typeParameters = n.getTypeParameters();
+        if (typeParameters != null) {
+            for (int i = 0; i < typeParameters.size(); i++) {
+                typeParameters.set(i, (TypeParameter) typeParameters.get(i).accept(this, arg));
+            }
+            removeNulls(typeParameters);
+        }
+        List<Parameter> parameters = n.getParameters();
+        if (parameters != null) {
+            for (int i = 0; i < parameters.size(); i++) {
+                parameters.set(i, (Parameter) parameters.get(i).accept(this, arg));
+            }
+            removeNulls(parameters);
+        }
+        List<NameExpr> throwz = n.getThrows();
+        if (throwz != null) {
+            for (int i = 0; i < throwz.size(); i++) {
+                throwz.set(i, (NameExpr) throwz.get(i).accept(this, arg));
+            }
+            removeNulls(throwz);
+        }
+        n.setBlock((BlockStmt) n.getBlock().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(ContinueStmt n, A arg) {
+        return n;
+    }
+
+    public Node visit(DoStmt n, A arg) {
+        n.setBody((Statement) n.getBody().accept(this, arg));
+        n.setCondition((Expression) n.getCondition().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(DoubleLiteralExpr n, A arg) {
+        return n;
+    }
+
+    public Node visit(EmptyMemberDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.setJavaDoc((JavadocComment) n.getJavaDoc().accept(this, arg));
+        }
+        return n;
+    }
+
+    public Node visit(EmptyStmt n, A arg) {
+        return n;
+    }
+
+    public Node visit(EmptyTypeDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.setJavaDoc((JavadocComment) n.getJavaDoc().accept(this, arg));
+        }
+        return n;
+    }
+
+    public Node visit(EnclosedExpr n, A arg) {
+        n.setInner((Expression) n.getInner().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(EnumConstantDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.setJavaDoc((JavadocComment) n.getJavaDoc().accept(this, arg));
+        }
+        List<AnnotationExpr> annotations = n.getAnnotations();
+        if (annotations != null) {
+            for (int i = 0; i < annotations.size(); i++) {
+                annotations.set(i, (AnnotationExpr) annotations.get(i).accept(this, arg));
+            }
+            removeNulls(annotations);
+        }
+        List<Expression> args = n.getArgs();
+        if (args != null) {
+            for (int i = 0; i < args.size(); i++) {
+                args.set(i, (Expression) args.get(i).accept(this, arg));
+            }
+            removeNulls(args);
+        }
+        List<BodyDeclaration> classBody = n.getClassBody();
+        if (classBody != null) {
+            for (int i = 0; i < classBody.size(); i++) {
+                classBody.set(i, (BodyDeclaration) classBody.get(i).accept(this, arg));
+            }
+            removeNulls(classBody);
+        }
+        return n;
+    }
+
+    public Node visit(EnumDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.setJavaDoc((JavadocComment) n.getJavaDoc().accept(this, arg));
+        }
+        List<AnnotationExpr> annotations = n.getAnnotations();
+        if (annotations != null) {
+            for (int i = 0; i < annotations.size(); i++) {
+                annotations.set(i, (AnnotationExpr) annotations.get(i).accept(this, arg));
+            }
+            removeNulls(annotations);
+        }
+        List<ClassOrInterfaceType> implementz = n.getImplements();
+        if (implementz != null) {
+            for (int i = 0; i < implementz.size(); i++) {
+                implementz.set(i, (ClassOrInterfaceType) implementz.get(i).accept(this, arg));
+            }
+            removeNulls(implementz);
+        }
+        List<EnumConstantDeclaration> entries = n.getEntries();
+        if (entries != null) {
+            for (int i = 0; i < entries.size(); i++) {
+                entries.set(i, (EnumConstantDeclaration) entries.get(i).accept(this, arg));
+            }
+            removeNulls(entries);
+        }
+        List<BodyDeclaration> members = n.getMembers();
+        if (members != null) {
+            for (int i = 0; i < members.size(); i++) {
+                members.set(i, (BodyDeclaration) members.get(i).accept(this, arg));
+            }
+            removeNulls(members);
+        }
+        return n;
+    }
+
+    public Node visit(ExplicitConstructorInvocationStmt n, A arg) {
+        if (!n.isThis()) {
+            if (n.getExpr() != null) {
+                n.setExpr((Expression) n.getExpr().accept(this, arg));
+            }
+        }
+        List<Type> typeArgs = n.getTypeArgs();
+        if (typeArgs != null) {
+            for (int i = 0; i < typeArgs.size(); i++) {
+                typeArgs.set(i, (Type) typeArgs.get(i).accept(this, arg));
+            }
+            removeNulls(typeArgs);
+        }
+        List<Expression> args = n.getArgs();
+        if (args != null) {
+            for (int i = 0; i < args.size(); i++) {
+                args.set(i, (Expression) args.get(i).accept(this, arg));
+            }
+            removeNulls(args);
+        }
+        return n;
+    }
+
+    public Node visit(ExpressionStmt n, A arg) {
+        n.setExpression((Expression) n.getExpression().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(FieldAccessExpr n, A arg) {
+        n.setScope((Expression) n.getScope().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(FieldDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.setJavaDoc((JavadocComment) n.getJavaDoc().accept(this, arg));
+        }
+        List<AnnotationExpr> annotations = n.getAnnotations();
+        if (annotations != null) {
+            for (int i = 0; i < annotations.size(); i++) {
+                annotations.set(i, (AnnotationExpr) annotations.get(i).accept(this, arg));
+            }
+            removeNulls(annotations);
+        }
+        n.setType((Type) n.getType().accept(this, arg));
+        List<VariableDeclarator> variables = n.getVariables();
+        for (int i = 0; i < variables.size(); i++) {
+            variables.set(i, (VariableDeclarator) variables.get(i).accept(this, arg));
+        }
+        removeNulls(variables);
+        return n;
+    }
+
+    public Node visit(ForeachStmt n, A arg) {
+        n.setVariable((VariableDeclarationExpr) n.getVariable().accept(this, arg));
+        n.setIterable((Expression) n.getIterable().accept(this, arg));
+        n.setBody((Statement) n.getBody().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(ForStmt n, A arg) {
+        List<Expression> init = n.getInit();
+        if (init != null) {
+            for (int i = 0; i < init.size(); i++) {
+                init.set(i, (Expression) init.get(i).accept(this, arg));
+            }
+            removeNulls(init);
+        }
+        if (n.getCompare() != null) {
+            n.setCompare((Expression) n.getCompare().accept(this, arg));
+        }
+        List<Expression> update = n.getUpdate();
+        if (update != null) {
+            for (int i = 0; i < update.size(); i++) {
+                update.set(i, (Expression) update.get(i).accept(this, arg));
+            }
+            removeNulls(update);
+        }
+        n.setBody((Statement) n.getBody().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(IfStmt n, A arg) {
+        n.setCondition((Expression) n.getCondition().accept(this, arg));
+        n.setThenStmt((Statement) n.getThenStmt().accept(this, arg));
+        if (n.getElseStmt() != null) {
+            n.setElseStmt((Statement) n.getElseStmt().accept(this, arg));
+        }
+        return n;
+    }
+
+    public Node visit(ImportDeclaration n, A arg) {
+        n.setName((NameExpr) n.getName().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(InitializerDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.setJavaDoc((JavadocComment) n.getJavaDoc().accept(this, arg));
+        }
+        n.setBlock((BlockStmt) n.getBlock().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(InstanceOfExpr n, A arg) {
+        n.setExpr((Expression) n.getExpr().accept(this, arg));
+        n.setType((Type) n.getType().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(IntegerLiteralExpr n, A arg) {
+        return n;
+    }
+
+    public Node visit(IntegerLiteralMinValueExpr n, A arg) {
+        return n;
+    }
+
+    public Node visit(JavadocComment n, A arg) {
+        return n;
+    }
+
+    public Node visit(LabeledStmt n, A arg) {
+        n.setStmt((Statement) n.getStmt().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(LongLiteralExpr n, A arg) {
+        return n;
+    }
+
+    public Node visit(LongLiteralMinValueExpr n, A arg) {
+        return n;
+    }
+
+    public Node visit(MarkerAnnotationExpr n, A arg) {
+        n.setName((NameExpr) n.getName().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(MemberValuePair n, A arg) {
+        n.setValue((Expression) n.getValue().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(MethodCallExpr n, A arg) {
+        if (n.getScope() != null) {
+            n.setScope((Expression) n.getScope().accept(this, arg));
+        }
+        List<Type> typeArgs = n.getTypeArgs();
+        if (typeArgs != null) {
+            for (int i = 0; i < typeArgs.size(); i++) {
+                typeArgs.set(i, (Type) typeArgs.get(i).accept(this, arg));
+            }
+            removeNulls(typeArgs);
+        }
+        List<Expression> args = n.getArgs();
+        if (args != null) {
+            for (int i = 0; i < args.size(); i++) {
+                args.set(i, (Expression) args.get(i).accept(this, arg));
+            }
+            removeNulls(args);
+        }
+        return n;
+    }
+
+    public Node visit(MethodDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.setJavaDoc((JavadocComment) n.getJavaDoc().accept(this, arg));
+        }
+        List<AnnotationExpr> annotations = n.getAnnotations();
+        if (annotations != null) {
+            for (int i = 0; i < annotations.size(); i++) {
+                annotations.set(i, (AnnotationExpr) annotations.get(i).accept(this, arg));
+            }
+            removeNulls(annotations);
+        }
+        List<TypeParameter> typeParameters = n.getTypeParameters();
+        if (typeParameters != null) {
+            for (int i = 0; i < typeParameters.size(); i++) {
+                typeParameters.set(i, (TypeParameter) typeParameters.get(i).accept(this, arg));
+            }
+            removeNulls(typeParameters);
+        }
+        n.setType((Type) n.getType().accept(this, arg));
+        List<Parameter> parameters = n.getParameters();
+        if (parameters != null) {
+            for (int i = 0; i < parameters.size(); i++) {
+                parameters.set(i, (Parameter) parameters.get(i).accept(this, arg));
+            }
+            removeNulls(parameters);
+        }
+        List<NameExpr> throwz = n.getThrows();
+        if (throwz != null) {
+            for (int i = 0; i < throwz.size(); i++) {
+                throwz.set(i, (NameExpr) throwz.get(i).accept(this, arg));
+            }
+            removeNulls(throwz);
+        }
+        if (n.getBody() != null) {
+            n.setBody((BlockStmt) n.getBody().accept(this, arg));
+        }
+        return n;
+    }
+
+    public Node visit(NameExpr n, A arg) {
+        return n;
+    }
+
+    public Node visit(NormalAnnotationExpr n, A arg) {
+        n.setName((NameExpr) n.getName().accept(this, arg));
+        List<MemberValuePair> pairs = n.getPairs();
+        if (pairs != null) {
+            for (int i = 0; i < pairs.size(); i++) {
+                pairs.set(i, (MemberValuePair) pairs.get(i).accept(this, arg));
+            }
+            removeNulls(pairs);
+        }
+        return n;
+    }
+
+    public Node visit(NullLiteralExpr n, A arg) {
+        return n;
+    }
+
+    public Node visit(ObjectCreationExpr n, A arg) {
+        if (n.getScope() != null) {
+            n.setScope((Expression) n.getScope().accept(this, arg));
+        }
+        List<Type> typeArgs = n.getTypeArgs();
+        if (typeArgs != null) {
+            for (int i = 0; i < typeArgs.size(); i++) {
+                typeArgs.set(i, (Type) typeArgs.get(i).accept(this, arg));
+            }
+            removeNulls(typeArgs);
+        }
+        n.setType((ClassOrInterfaceType) n.getType().accept(this, arg));
+        List<Expression> args = n.getArgs();
+        if (args != null) {
+            for (int i = 0; i < args.size(); i++) {
+                args.set(i, (Expression) args.get(i).accept(this, arg));
+            }
+            removeNulls(args);
+        }
+        List<BodyDeclaration> anonymousClassBody = n.getAnonymousClassBody();
+        if (anonymousClassBody != null) {
+            for (int i = 0; i < anonymousClassBody.size(); i++) {
+                anonymousClassBody.set(i, (BodyDeclaration) anonymousClassBody.get(i).accept(this, arg));
+            }
+            removeNulls(anonymousClassBody);
+        }
+        return n;
+    }
+
+    public Node visit(PackageDeclaration n, A arg) {
+        List<AnnotationExpr> annotations = n.getAnnotations();
+        if (annotations != null) {
+            for (int i = 0; i < annotations.size(); i++) {
+                annotations.set(i, (AnnotationExpr) annotations.get(i).accept(this, arg));
+            }
+            removeNulls(annotations);
+        }
+        n.setName((NameExpr) n.getName().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(Parameter n, A arg) {
+        List<AnnotationExpr> annotations = n.getAnnotations();
+        if (annotations != null) {
+            for (int i = 0; i < annotations.size(); i++) {
+                annotations.set(i, (AnnotationExpr) annotations.get(i).accept(this, arg));
+            }
+            removeNulls(annotations);
+        }
+        n.setType((Type) n.getType().accept(this, arg));
+        n.setId((VariableDeclaratorId) n.getId().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(PrimitiveType n, A arg) {
+        return n;
+    }
+
+    public Node visit(QualifiedNameExpr n, A arg) {
+        n.setQualifier((NameExpr) n.getQualifier().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(ReferenceType n, A arg) {
+        n.setType((Type) n.getType().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(ReturnStmt n, A arg) {
+        if (n.getExpr() != null) {
+            n.setExpr((Expression) n.getExpr().accept(this, arg));
+        }
+        return n;
+    }
+
+    public Node visit(SingleMemberAnnotationExpr n, A arg) {
+        n.setName((NameExpr) n.getName().accept(this, arg));
+        n.setMemberValue((Expression) n.getMemberValue().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(StringLiteralExpr n, A arg) {
+        return n;
+    }
+
+    public Node visit(SuperExpr n, A arg) {
+        if (n.getClassExpr() != null) {
+            n.setClassExpr((Expression) n.getClassExpr().accept(this, arg));
+        }
+        return n;
+    }
+
+    public Node visit(SwitchEntryStmt n, A arg) {
+        if (n.getLabel() != null) {
+            n.setLabel((Expression) n.getLabel().accept(this, arg));
+        }
+        List<Statement> stmts = n.getStmts();
+        if (stmts != null) {
+            for (int i = 0; i < stmts.size(); i++) {
+                stmts.set(i, (Statement) stmts.get(i).accept(this, arg));
+            }
+            removeNulls(stmts);
+        }
+        return n;
+    }
+
+    public Node visit(SwitchStmt n, A arg) {
+        n.setSelector((Expression) n.getSelector().accept(this, arg));
+        List<SwitchEntryStmt> entries = n.getEntries();
+        if (entries != null) {
+            for (int i = 0; i < entries.size(); i++) {
+                entries.set(i, (SwitchEntryStmt) entries.get(i).accept(this, arg));
+            }
+            removeNulls(entries);
+        }
+        return n;
+
+    }
+
+    public Node visit(SynchronizedStmt n, A arg) {
+        n.setExpr((Expression) n.getExpr().accept(this, arg));
+        n.setBlock((BlockStmt) n.getBlock().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(ThisExpr n, A arg) {
+        if (n.getClassExpr() != null) {
+            n.setClassExpr((Expression) n.getClassExpr().accept(this, arg));
+        }
+        return n;
+    }
+
+    public Node visit(ThrowStmt n, A arg) {
+        n.setExpr((Expression) n.getExpr().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(TryStmt n, A arg) {
+        n.setTryBlock((BlockStmt) n.getTryBlock().accept(this, arg));
+        List<CatchClause> catchs = n.getCatchs();
+        if (catchs != null) {
+            for (int i = 0; i < catchs.size(); i++) {
+                catchs.set(i, (CatchClause) catchs.get(i).accept(this, arg));
+            }
+            removeNulls(catchs);
+        }
+        if (n.getFinallyBlock() != null) {
+            n.setFinallyBlock((BlockStmt) n.getFinallyBlock().accept(this, arg));
+        }
+        return n;
+    }
+
+    public Node visit(TypeDeclarationStmt n, A arg) {
+        n.setTypeDeclaration((TypeDeclaration) n.getTypeDeclaration().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(TypeParameter n, A arg) {
+        List<ClassOrInterfaceType> typeBound = n.getTypeBound();
+        if (typeBound != null) {
+            for (int i = 0; i < typeBound.size(); i++) {
+                typeBound.set(i, (ClassOrInterfaceType) typeBound.get(i).accept(this, arg));
+            }
+            removeNulls(typeBound);
+        }
+        return n;
+    }
+
+    public Node visit(UnaryExpr n, A arg) {
+        n.setExpr((Expression) n.getExpr().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(VariableDeclarationExpr n, A arg) {
+        List<AnnotationExpr> annotations = n.getAnnotations();
+        if (annotations != null) {
+            for (int i = 0; i < annotations.size(); i++) {
+                annotations.set(i, (AnnotationExpr) annotations.get(i).accept(this, arg));
+            }
+            removeNulls(annotations);
+        }
+        n.setType((Type) n.getType().accept(this, arg));
+        List<VariableDeclarator> vars = n.getVars();
+        for (int i = 0; i < vars.size(); i++) {
+            vars.set(i, (VariableDeclarator) vars.get(i).accept(this, arg));
+        }
+        removeNulls(vars);
+        return n;
+    }
+
+    public Node visit(VariableDeclarator n, A arg) {
+        n.setId((VariableDeclaratorId) n.getId().accept(this, arg));
+        if (n.getInit() != null) {
+            n.setInit((Expression) n.getInit().accept(this, arg));
+        }
+        return n;
+    }
+
+    public Node visit(VariableDeclaratorId n, A arg) {
+        return n;
+    }
+
+    public Node visit(VoidType n, A arg) {
+        return n;
+    }
+
+    public Node visit(WhileStmt n, A arg) {
+        n.setCondition((Expression) n.getCondition().accept(this, arg));
+        n.setBody((Statement) n.getBody().accept(this, arg));
+        return n;
+    }
+
+    public Node visit(WildcardType n, A arg) {
+        if (n.getExtends() != null) {
+            n.setExtends((ReferenceType) n.getExtends().accept(this, arg));
+        }
+        if (n.getSuper() != null) {
+            n.setSuper((ReferenceType) n.getSuper().accept(this, arg));
+        }
+        return n;
+    }
+
+    public Node visit(BlockComment n, A arg) {
+        return n;
+    }
+
+    public Node visit(LineComment n, A arg) {
+        return n;
+    }
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/visitor/VoidVisitor.java b/parser/html/java/javaparser/src/japa/parser/ast/visitor/VoidVisitor.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/visitor/VoidVisitor.java
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package japa.parser.ast.visitor;
+
+import japa.parser.ast.BlockComment;
+import japa.parser.ast.CompilationUnit;
+import japa.parser.ast.ImportDeclaration;
+import japa.parser.ast.LineComment;
+import japa.parser.ast.PackageDeclaration;
+import japa.parser.ast.TypeParameter;
+import japa.parser.ast.body.AnnotationDeclaration;
+import japa.parser.ast.body.AnnotationMemberDeclaration;
+import japa.parser.ast.body.ClassOrInterfaceDeclaration;
+import japa.parser.ast.body.ConstructorDeclaration;
+import japa.parser.ast.body.EmptyMemberDeclaration;
+import japa.parser.ast.body.EmptyTypeDeclaration;
+import japa.parser.ast.body.EnumConstantDeclaration;
+import japa.parser.ast.body.EnumDeclaration;
+import japa.parser.ast.body.FieldDeclaration;
+import japa.parser.ast.body.InitializerDeclaration;
+import japa.parser.ast.body.JavadocComment;
+import japa.parser.ast.body.MethodDeclaration;
+import japa.parser.ast.body.Parameter;
+import japa.parser.ast.body.VariableDeclarator;
+import japa.parser.ast.body.VariableDeclaratorId;
+import japa.parser.ast.expr.ArrayAccessExpr;
+import japa.parser.ast.expr.ArrayCreationExpr;
+import japa.parser.ast.expr.ArrayInitializerExpr;
+import japa.parser.ast.expr.AssignExpr;
+import japa.parser.ast.expr.BinaryExpr;
+import japa.parser.ast.expr.BooleanLiteralExpr;
+import japa.parser.ast.expr.CastExpr;
+import japa.parser.ast.expr.CharLiteralExpr;
+import japa.parser.ast.expr.ClassExpr;
+import japa.parser.ast.expr.ConditionalExpr;
+import japa.parser.ast.expr.DoubleLiteralExpr;
+import japa.parser.ast.expr.EnclosedExpr;
+import japa.parser.ast.expr.FieldAccessExpr;
+import japa.parser.ast.expr.InstanceOfExpr;
+import japa.parser.ast.expr.IntegerLiteralExpr;
+import japa.parser.ast.expr.IntegerLiteralMinValueExpr;
+import japa.parser.ast.expr.LongLiteralExpr;
+import japa.parser.ast.expr.LongLiteralMinValueExpr;
+import japa.parser.ast.expr.MarkerAnnotationExpr;
+import japa.parser.ast.expr.MemberValuePair;
+import japa.parser.ast.expr.MethodCallExpr;
+import japa.parser.ast.expr.NameExpr;
+import japa.parser.ast.expr.NormalAnnotationExpr;
+import japa.parser.ast.expr.NullLiteralExpr;
+import japa.parser.ast.expr.ObjectCreationExpr;
+import japa.parser.ast.expr.QualifiedNameExpr;
+import japa.parser.ast.expr.SingleMemberAnnotationExpr;
+import japa.parser.ast.expr.StringLiteralExpr;
+import japa.parser.ast.expr.SuperExpr;
+import japa.parser.ast.expr.ThisExpr;
+import japa.parser.ast.expr.UnaryExpr;
+import japa.parser.ast.expr.VariableDeclarationExpr;
+import japa.parser.ast.stmt.AssertStmt;
+import japa.parser.ast.stmt.BlockStmt;
+import japa.parser.ast.stmt.BreakStmt;
+import japa.parser.ast.stmt.CatchClause;
+import japa.parser.ast.stmt.ContinueStmt;
+import japa.parser.ast.stmt.DoStmt;
+import japa.parser.ast.stmt.EmptyStmt;
+import japa.parser.ast.stmt.ExplicitConstructorInvocationStmt;
+import japa.parser.ast.stmt.ExpressionStmt;
+import japa.parser.ast.stmt.ForStmt;
+import japa.parser.ast.stmt.ForeachStmt;
+import japa.parser.ast.stmt.IfStmt;
+import japa.parser.ast.stmt.LabeledStmt;
+import japa.parser.ast.stmt.ReturnStmt;
+import japa.parser.ast.stmt.SwitchEntryStmt;
+import japa.parser.ast.stmt.SwitchStmt;
+import japa.parser.ast.stmt.SynchronizedStmt;
+import japa.parser.ast.stmt.ThrowStmt;
+import japa.parser.ast.stmt.TryStmt;
+import japa.parser.ast.stmt.TypeDeclarationStmt;
+import japa.parser.ast.stmt.WhileStmt;
+import japa.parser.ast.type.ClassOrInterfaceType;
+import japa.parser.ast.type.PrimitiveType;
+import japa.parser.ast.type.ReferenceType;
+import japa.parser.ast.type.VoidType;
+import japa.parser.ast.type.WildcardType;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public interface VoidVisitor<A> {
+
+    //- Compilation Unit ----------------------------------
+
+    public void visit(CompilationUnit n, A arg);
+
+    public void visit(PackageDeclaration n, A arg);
+
+    public void visit(ImportDeclaration n, A arg);
+
+    public void visit(TypeParameter n, A arg);
+
+    public void visit(LineComment n, A arg);
+
+    public void visit(BlockComment n, A arg);
+
+    //- Body ----------------------------------------------
+
+    public void visit(ClassOrInterfaceDeclaration n, A arg);
+
+    public void visit(EnumDeclaration n, A arg);
+
+    public void visit(EmptyTypeDeclaration n, A arg);
+
+    public void visit(EnumConstantDeclaration n, A arg);
+
+    public void visit(AnnotationDeclaration n, A arg);
+
+    public void visit(AnnotationMemberDeclaration n, A arg);
+
+    public void visit(FieldDeclaration n, A arg);
+
+    public void visit(VariableDeclarator n, A arg);
+
+    public void visit(VariableDeclaratorId n, A arg);
+
+    public void visit(ConstructorDeclaration n, A arg);
+
+    public void visit(MethodDeclaration n, A arg);
+
+    public void visit(Parameter n, A arg);
+
+    public void visit(EmptyMemberDeclaration n, A arg);
+
+    public void visit(InitializerDeclaration n, A arg);
+
+    public void visit(JavadocComment n, A arg);
+
+    //- Type ----------------------------------------------
+
+    public void visit(ClassOrInterfaceType n, A arg);
+
+    public void visit(PrimitiveType n, A arg);
+
+    public void visit(ReferenceType n, A arg);
+
+    public void visit(VoidType n, A arg);
+
+    public void visit(WildcardType n, A arg);
+
+    //- Expression ----------------------------------------
+
+    public void visit(ArrayAccessExpr n, A arg);
+
+    public void visit(ArrayCreationExpr n, A arg);
+
+    public void visit(ArrayInitializerExpr n, A arg);
+
+    public void visit(AssignExpr n, A arg);
+
+    public void visit(BinaryExpr n, A arg);
+
+    public void visit(CastExpr n, A arg);
+
+    public void visit(ClassExpr n, A arg);
+
+    public void visit(ConditionalExpr n, A arg);
+
+    public void visit(EnclosedExpr n, A arg);
+
+    public void visit(FieldAccessExpr n, A arg);
+
+    public void visit(InstanceOfExpr n, A arg);
+
+    public void visit(StringLiteralExpr n, A arg);
+
+    public void visit(IntegerLiteralExpr n, A arg);
+
+    public void visit(LongLiteralExpr n, A arg);
+
+    public void visit(IntegerLiteralMinValueExpr n, A arg);
+
+    public void visit(LongLiteralMinValueExpr n, A arg);
+
+    public void visit(CharLiteralExpr n, A arg);
+
+    public void visit(DoubleLiteralExpr n, A arg);
+
+    public void visit(BooleanLiteralExpr n, A arg);
+
+    public void visit(NullLiteralExpr n, A arg);
+
+    public void visit(MethodCallExpr n, A arg);
+
+    public void visit(NameExpr n, A arg);
+
+    public void visit(ObjectCreationExpr n, A arg);
+
+    public void visit(QualifiedNameExpr n, A arg);
+
+    public void visit(ThisExpr n, A arg);
+
+    public void visit(SuperExpr n, A arg);
+
+    public void visit(UnaryExpr n, A arg);
+
+    public void visit(VariableDeclarationExpr n, A arg);
+
+    public void visit(MarkerAnnotationExpr n, A arg);
+
+    public void visit(SingleMemberAnnotationExpr n, A arg);
+
+    public void visit(NormalAnnotationExpr n, A arg);
+
+    public void visit(MemberValuePair n, A arg);
+
+    //- Statements ----------------------------------------
+
+    public void visit(ExplicitConstructorInvocationStmt n, A arg);
+
+    public void visit(TypeDeclarationStmt n, A arg);
+
+    public void visit(AssertStmt n, A arg);
+
+    public void visit(BlockStmt n, A arg);
+
+    public void visit(LabeledStmt n, A arg);
+
+    public void visit(EmptyStmt n, A arg);
+
+    public void visit(ExpressionStmt n, A arg);
+
+    public void visit(SwitchStmt n, A arg);
+
+    public void visit(SwitchEntryStmt n, A arg);
+
+    public void visit(BreakStmt n, A arg);
+
+    public void visit(ReturnStmt n, A arg);
+
+    public void visit(IfStmt n, A arg);
+
+    public void visit(WhileStmt n, A arg);
+
+    public void visit(ContinueStmt n, A arg);
+
+    public void visit(DoStmt n, A arg);
+
+    public void visit(ForeachStmt n, A arg);
+
+    public void visit(ForStmt n, A arg);
+
+    public void visit(ThrowStmt n, A arg);
+
+    public void visit(SynchronizedStmt n, A arg);
+
+    public void visit(TryStmt n, A arg);
+
+    public void visit(CatchClause n, A arg);
+
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/ast/visitor/VoidVisitorAdapter.java b/parser/html/java/javaparser/src/japa/parser/ast/visitor/VoidVisitorAdapter.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/ast/visitor/VoidVisitorAdapter.java
@@ -0,0 +1,743 @@
+/*
+ * Copyright (C) 2008 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 09/06/2008
+ */
+package japa.parser.ast.visitor;
+
+import japa.parser.ast.BlockComment;
+import japa.parser.ast.CompilationUnit;
+import japa.parser.ast.ImportDeclaration;
+import japa.parser.ast.LineComment;
+import japa.parser.ast.PackageDeclaration;
+import japa.parser.ast.TypeParameter;
+import japa.parser.ast.body.AnnotationDeclaration;
+import japa.parser.ast.body.AnnotationMemberDeclaration;
+import japa.parser.ast.body.BodyDeclaration;
+import japa.parser.ast.body.ClassOrInterfaceDeclaration;
+import japa.parser.ast.body.ConstructorDeclaration;
+import japa.parser.ast.body.EmptyMemberDeclaration;
+import japa.parser.ast.body.EmptyTypeDeclaration;
+import japa.parser.ast.body.EnumConstantDeclaration;
+import japa.parser.ast.body.EnumDeclaration;
+import japa.parser.ast.body.FieldDeclaration;
+import japa.parser.ast.body.InitializerDeclaration;
+import japa.parser.ast.body.JavadocComment;
+import japa.parser.ast.body.MethodDeclaration;
+import japa.parser.ast.body.Parameter;
+import japa.parser.ast.body.TypeDeclaration;
+import japa.parser.ast.body.VariableDeclarator;
+import japa.parser.ast.body.VariableDeclaratorId;
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.expr.ArrayAccessExpr;
+import japa.parser.ast.expr.ArrayCreationExpr;
+import japa.parser.ast.expr.ArrayInitializerExpr;
+import japa.parser.ast.expr.AssignExpr;
+import japa.parser.ast.expr.BinaryExpr;
+import japa.parser.ast.expr.BooleanLiteralExpr;
+import japa.parser.ast.expr.CastExpr;
+import japa.parser.ast.expr.CharLiteralExpr;
+import japa.parser.ast.expr.ClassExpr;
+import japa.parser.ast.expr.ConditionalExpr;
+import japa.parser.ast.expr.DoubleLiteralExpr;
+import japa.parser.ast.expr.EnclosedExpr;
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.expr.FieldAccessExpr;
+import japa.parser.ast.expr.InstanceOfExpr;
+import japa.parser.ast.expr.IntegerLiteralExpr;
+import japa.parser.ast.expr.IntegerLiteralMinValueExpr;
+import japa.parser.ast.expr.LongLiteralExpr;
+import japa.parser.ast.expr.LongLiteralMinValueExpr;
+import japa.parser.ast.expr.MarkerAnnotationExpr;
+import japa.parser.ast.expr.MemberValuePair;
+import japa.parser.ast.expr.MethodCallExpr;
+import japa.parser.ast.expr.NameExpr;
+import japa.parser.ast.expr.NormalAnnotationExpr;
+import japa.parser.ast.expr.NullLiteralExpr;
+import japa.parser.ast.expr.ObjectCreationExpr;
+import japa.parser.ast.expr.QualifiedNameExpr;
+import japa.parser.ast.expr.SingleMemberAnnotationExpr;
+import japa.parser.ast.expr.StringLiteralExpr;
+import japa.parser.ast.expr.SuperExpr;
+import japa.parser.ast.expr.ThisExpr;
+import japa.parser.ast.expr.UnaryExpr;
+import japa.parser.ast.expr.VariableDeclarationExpr;
+import japa.parser.ast.stmt.AssertStmt;
+import japa.parser.ast.stmt.BlockStmt;
+import japa.parser.ast.stmt.BreakStmt;
+import japa.parser.ast.stmt.CatchClause;
+import japa.parser.ast.stmt.ContinueStmt;
+import japa.parser.ast.stmt.DoStmt;
+import japa.parser.ast.stmt.EmptyStmt;
+import japa.parser.ast.stmt.ExplicitConstructorInvocationStmt;
+import japa.parser.ast.stmt.ExpressionStmt;
+import japa.parser.ast.stmt.ForStmt;
+import japa.parser.ast.stmt.ForeachStmt;
+import japa.parser.ast.stmt.IfStmt;
+import japa.parser.ast.stmt.LabeledStmt;
+import japa.parser.ast.stmt.ReturnStmt;
+import japa.parser.ast.stmt.Statement;
+import japa.parser.ast.stmt.SwitchEntryStmt;
+import japa.parser.ast.stmt.SwitchStmt;
+import japa.parser.ast.stmt.SynchronizedStmt;
+import japa.parser.ast.stmt.ThrowStmt;
+import japa.parser.ast.stmt.TryStmt;
+import japa.parser.ast.stmt.TypeDeclarationStmt;
+import japa.parser.ast.stmt.WhileStmt;
+import japa.parser.ast.type.ClassOrInterfaceType;
+import japa.parser.ast.type.PrimitiveType;
+import japa.parser.ast.type.ReferenceType;
+import japa.parser.ast.type.Type;
+import japa.parser.ast.type.VoidType;
+import japa.parser.ast.type.WildcardType;
+
+/**
+ * @author Julio Vilmar Gesser
+ */
+public abstract class VoidVisitorAdapter<A> implements VoidVisitor<A> {
+
+    public void visit(AnnotationDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        if (n.getMembers() != null) {
+            for (BodyDeclaration member : n.getMembers()) {
+                member.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(AnnotationMemberDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        n.getType().accept(this, arg);
+        if (n.getDefaultValue() != null) {
+            n.getDefaultValue().accept(this, arg);
+        }
+    }
+
+    public void visit(ArrayAccessExpr n, A arg) {
+        n.getName().accept(this, arg);
+        n.getIndex().accept(this, arg);
+    }
+
+    public void visit(ArrayCreationExpr n, A arg) {
+        n.getType().accept(this, arg);
+        if (n.getDimensions() != null) {
+            for (Expression dim : n.getDimensions()) {
+                dim.accept(this, arg);
+            }
+        } else {
+            n.getInitializer().accept(this, arg);
+        }
+    }
+
+    public void visit(ArrayInitializerExpr n, A arg) {
+        if (n.getValues() != null) {
+            for (Expression expr : n.getValues()) {
+                expr.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(AssertStmt n, A arg) {
+        n.getCheck().accept(this, arg);
+        if (n.getMessage() != null) {
+            n.getMessage().accept(this, arg);
+        }
+    }
+
+    public void visit(AssignExpr n, A arg) {
+        n.getTarget().accept(this, arg);
+        n.getValue().accept(this, arg);
+    }
+
+    public void visit(BinaryExpr n, A arg) {
+        n.getLeft().accept(this, arg);
+        n.getRight().accept(this, arg);
+    }
+
+    public void visit(BlockComment n, A arg) {
+    }
+
+    public void visit(BlockStmt n, A arg) {
+        if (n.getStmts() != null) {
+            for (Statement s : n.getStmts()) {
+                s.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(BooleanLiteralExpr n, A arg) {
+    }
+
+    public void visit(BreakStmt n, A arg) {
+    }
+
+    public void visit(CastExpr n, A arg) {
+        n.getType().accept(this, arg);
+        n.getExpr().accept(this, arg);
+    }
+
+    public void visit(CatchClause n, A arg) {
+        n.getExcept().accept(this, arg);
+        n.getCatchBlock().accept(this, arg);
+    }
+
+    public void visit(CharLiteralExpr n, A arg) {
+    }
+
+    public void visit(ClassExpr n, A arg) {
+        n.getType().accept(this, arg);
+    }
+
+    public void visit(ClassOrInterfaceDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        if (n.getTypeParameters() != null) {
+            for (TypeParameter t : n.getTypeParameters()) {
+                t.accept(this, arg);
+            }
+        }
+        if (n.getExtends() != null) {
+            for (ClassOrInterfaceType c : n.getExtends()) {
+                c.accept(this, arg);
+            }
+        }
+
+        if (n.getImplements() != null) {
+            for (ClassOrInterfaceType c : n.getImplements()) {
+                c.accept(this, arg);
+            }
+        }
+        if (n.getMembers() != null) {
+            for (BodyDeclaration member : n.getMembers()) {
+                member.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(ClassOrInterfaceType n, A arg) {
+        if (n.getScope() != null) {
+            n.getScope().accept(this, arg);
+        }
+        if (n.getTypeArgs() != null) {
+            for (Type t : n.getTypeArgs()) {
+                t.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(CompilationUnit n, A arg) {
+        if (n.getPackage() != null) {
+            n.getPackage().accept(this, arg);
+        }
+        if (n.getImports() != null) {
+            for (ImportDeclaration i : n.getImports()) {
+                i.accept(this, arg);
+            }
+        }
+        if (n.getTypes() != null) {
+            for (TypeDeclaration typeDeclaration : n.getTypes()) {
+                typeDeclaration.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(ConditionalExpr n, A arg) {
+        n.getCondition().accept(this, arg);
+        n.getThenExpr().accept(this, arg);
+        n.getElseExpr().accept(this, arg);
+    }
+
+    public void visit(ConstructorDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        if (n.getTypeParameters() != null) {
+            for (TypeParameter t : n.getTypeParameters()) {
+                t.accept(this, arg);
+            }
+        }
+        if (n.getParameters() != null) {
+            for (Parameter p : n.getParameters()) {
+                p.accept(this, arg);
+            }
+        }
+        if (n.getThrows() != null) {
+            for (NameExpr name : n.getThrows()) {
+                name.accept(this, arg);
+            }
+        }
+        n.getBlock().accept(this, arg);
+    }
+
+    public void visit(ContinueStmt n, A arg) {
+    }
+
+    public void visit(DoStmt n, A arg) {
+        n.getBody().accept(this, arg);
+        n.getCondition().accept(this, arg);
+    }
+
+    public void visit(DoubleLiteralExpr n, A arg) {
+    }
+
+    public void visit(EmptyMemberDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+    }
+
+    public void visit(EmptyStmt n, A arg) {
+    }
+
+    public void visit(EmptyTypeDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+    }
+
+    public void visit(EnclosedExpr n, A arg) {
+        n.getInner().accept(this, arg);
+    }
+
+    public void visit(EnumConstantDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        if (n.getArgs() != null) {
+            for (Expression e : n.getArgs()) {
+                e.accept(this, arg);
+            }
+        }
+        if (n.getClassBody() != null) {
+            for (BodyDeclaration member : n.getClassBody()) {
+                member.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(EnumDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        if (n.getImplements() != null) {
+            for (ClassOrInterfaceType c : n.getImplements()) {
+                c.accept(this, arg);
+            }
+        }
+        if (n.getEntries() != null) {
+            for (EnumConstantDeclaration e : n.getEntries()) {
+                e.accept(this, arg);
+            }
+        }
+        if (n.getMembers() != null) {
+            for (BodyDeclaration member : n.getMembers()) {
+                member.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(ExplicitConstructorInvocationStmt n, A arg) {
+        if (!n.isThis()) {
+            if (n.getExpr() != null) {
+                n.getExpr().accept(this, arg);
+            }
+        }
+        if (n.getTypeArgs() != null) {
+            for (Type t : n.getTypeArgs()) {
+                t.accept(this, arg);
+            }
+        }
+        if (n.getArgs() != null) {
+            for (Expression e : n.getArgs()) {
+                e.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(ExpressionStmt n, A arg) {
+        n.getExpression().accept(this, arg);
+    }
+
+    public void visit(FieldAccessExpr n, A arg) {
+        n.getScope().accept(this, arg);
+    }
+
+    public void visit(FieldDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        n.getType().accept(this, arg);
+        for (VariableDeclarator var : n.getVariables()) {
+            var.accept(this, arg);
+        }
+    }
+
+    public void visit(ForeachStmt n, A arg) {
+        n.getVariable().accept(this, arg);
+        n.getIterable().accept(this, arg);
+        n.getBody().accept(this, arg);
+    }
+
+    public void visit(ForStmt n, A arg) {
+        if (n.getInit() != null) {
+            for (Expression e : n.getInit()) {
+                e.accept(this, arg);
+            }
+        }
+        if (n.getCompare() != null) {
+            n.getCompare().accept(this, arg);
+        }
+        if (n.getUpdate() != null) {
+            for (Expression e : n.getUpdate()) {
+                e.accept(this, arg);
+            }
+        }
+        n.getBody().accept(this, arg);
+    }
+
+    public void visit(IfStmt n, A arg) {
+        n.getCondition().accept(this, arg);
+        n.getThenStmt().accept(this, arg);
+        if (n.getElseStmt() != null) {
+            n.getElseStmt().accept(this, arg);
+        }
+    }
+
+    public void visit(ImportDeclaration n, A arg) {
+        n.getName().accept(this, arg);
+    }
+
+    public void visit(InitializerDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        n.getBlock().accept(this, arg);
+    }
+
+    public void visit(InstanceOfExpr n, A arg) {
+        n.getExpr().accept(this, arg);
+        n.getType().accept(this, arg);
+    }
+
+    public void visit(IntegerLiteralExpr n, A arg) {
+    }
+
+    public void visit(IntegerLiteralMinValueExpr n, A arg) {
+    }
+
+    public void visit(JavadocComment n, A arg) {
+    }
+
+    public void visit(LabeledStmt n, A arg) {
+        n.getStmt().accept(this, arg);
+    }
+
+    public void visit(LineComment n, A arg) {
+    }
+
+    public void visit(LongLiteralExpr n, A arg) {
+    }
+
+    public void visit(LongLiteralMinValueExpr n, A arg) {
+    }
+
+    public void visit(MarkerAnnotationExpr n, A arg) {
+        n.getName().accept(this, arg);
+    }
+
+    public void visit(MemberValuePair n, A arg) {
+        n.getValue().accept(this, arg);
+    }
+
+    public void visit(MethodCallExpr n, A arg) {
+        if (n.getScope() != null) {
+            n.getScope().accept(this, arg);
+        }
+        if (n.getTypeArgs() != null) {
+            for (Type t : n.getTypeArgs()) {
+                t.accept(this, arg);
+            }
+        }
+        if (n.getArgs() != null) {
+            for (Expression e : n.getArgs()) {
+                e.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(MethodDeclaration n, A arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        if (n.getTypeParameters() != null) {
+            for (TypeParameter t : n.getTypeParameters()) {
+                t.accept(this, arg);
+            }
+        }
+        n.getType().accept(this, arg);
+        if (n.getParameters() != null) {
+            for (Parameter p : n.getParameters()) {
+                p.accept(this, arg);
+            }
+        }
+        if (n.getThrows() != null) {
+            for (NameExpr name : n.getThrows()) {
+                name.accept(this, arg);
+            }
+        }
+        if (n.getBody() != null) {
+            n.getBody().accept(this, arg);
+        }
+    }
+
+    public void visit(NameExpr n, A arg) {
+    }
+
+    public void visit(NormalAnnotationExpr n, A arg) {
+        n.getName().accept(this, arg);
+        if (n.getPairs() != null) {
+            for (MemberValuePair m : n.getPairs()) {
+                m.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(NullLiteralExpr n, A arg) {
+    }
+
+    public void visit(ObjectCreationExpr n, A arg) {
+        if (n.getScope() != null) {
+            n.getScope().accept(this, arg);
+        }
+        if (n.getTypeArgs() != null) {
+            for (Type t : n.getTypeArgs()) {
+                t.accept(this, arg);
+            }
+        }
+        n.getType().accept(this, arg);
+        if (n.getArgs() != null) {
+            for (Expression e : n.getArgs()) {
+                e.accept(this, arg);
+            }
+        }
+        if (n.getAnonymousClassBody() != null) {
+            for (BodyDeclaration member : n.getAnonymousClassBody()) {
+                member.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(PackageDeclaration n, A arg) {
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        n.getName().accept(this, arg);
+    }
+
+    public void visit(Parameter n, A arg) {
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        n.getType().accept(this, arg);
+        n.getId().accept(this, arg);
+    }
+
+    public void visit(PrimitiveType n, A arg) {
+    }
+
+    public void visit(QualifiedNameExpr n, A arg) {
+        n.getQualifier().accept(this, arg);
+    }
+
+    public void visit(ReferenceType n, A arg) {
+        n.getType().accept(this, arg);
+    }
+
+    public void visit(ReturnStmt n, A arg) {
+        if (n.getExpr() != null) {
+            n.getExpr().accept(this, arg);
+        }
+    }
+
+    public void visit(SingleMemberAnnotationExpr n, A arg) {
+        n.getName().accept(this, arg);
+        n.getMemberValue().accept(this, arg);
+    }
+
+    public void visit(StringLiteralExpr n, A arg) {
+    }
+
+    public void visit(SuperExpr n, A arg) {
+        if (n.getClassExpr() != null) {
+            n.getClassExpr().accept(this, arg);
+        }
+    }
+
+    public void visit(SwitchEntryStmt n, A arg) {
+        if (n.getLabel() != null) {
+            n.getLabel().accept(this, arg);
+        }
+        if (n.getStmts() != null) {
+            for (Statement s : n.getStmts()) {
+                s.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(SwitchStmt n, A arg) {
+        n.getSelector().accept(this, arg);
+        if (n.getEntries() != null) {
+            for (SwitchEntryStmt e : n.getEntries()) {
+                e.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(SynchronizedStmt n, A arg) {
+        n.getExpr().accept(this, arg);
+        n.getBlock().accept(this, arg);
+
+    }
+
+    public void visit(ThisExpr n, A arg) {
+        if (n.getClassExpr() != null) {
+            n.getClassExpr().accept(this, arg);
+        }
+    }
+
+    public void visit(ThrowStmt n, A arg) {
+        n.getExpr().accept(this, arg);
+    }
+
+    public void visit(TryStmt n, A arg) {
+        n.getTryBlock().accept(this, arg);
+        if (n.getCatchs() != null) {
+            for (CatchClause c : n.getCatchs()) {
+                c.accept(this, arg);
+            }
+        }
+        if (n.getFinallyBlock() != null) {
+            n.getFinallyBlock().accept(this, arg);
+        }
+    }
+
+    public void visit(TypeDeclarationStmt n, A arg) {
+        n.getTypeDeclaration().accept(this, arg);
+    }
+
+    public void visit(TypeParameter n, A arg) {
+        if (n.getTypeBound() != null) {
+            for (ClassOrInterfaceType c : n.getTypeBound()) {
+                c.accept(this, arg);
+            }
+        }
+    }
+
+    public void visit(UnaryExpr n, A arg) {
+        n.getExpr().accept(this, arg);
+    }
+
+    public void visit(VariableDeclarationExpr n, A arg) {
+        if (n.getAnnotations() != null) {
+            for (AnnotationExpr a : n.getAnnotations()) {
+                a.accept(this, arg);
+            }
+        }
+        n.getType().accept(this, arg);
+        for (VariableDeclarator v : n.getVars()) {
+            v.accept(this, arg);
+        }
+    }
+
+    public void visit(VariableDeclarator n, A arg) {
+        n.getId().accept(this, arg);
+        if (n.getInit() != null) {
+            n.getInit().accept(this, arg);
+        }
+    }
+
+    public void visit(VariableDeclaratorId n, A arg) {
+    }
+
+    public void visit(VoidType n, A arg) {
+    }
+
+    public void visit(WhileStmt n, A arg) {
+        n.getCondition().accept(this, arg);
+        n.getBody().accept(this, arg);
+    }
+
+    public void visit(WildcardType n, A arg) {
+        if (n.getExtends() != null) {
+            n.getExtends().accept(this, arg);
+        }
+        if (n.getSuper() != null) {
+            n.getSuper().accept(this, arg);
+        }
+    }
+}
diff --git a/parser/html/java/javaparser/src/japa/parser/java_1_5.jj b/parser/html/java/javaparser/src/japa/parser/java_1_5.jj
new file mode 100644
--- /dev/null
+++ b/parser/html/java/javaparser/src/japa/parser/java_1_5.jj
@@ -0,0 +1,3000 @@
+/*
+ * Copyright (C) 2008 Jlio Vilmar Gesser.
+ *
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+options {
+  LOOKAHEAD=1;
+  STATIC=false;
+  JAVA_UNICODE_ESCAPE=true;
+  COMMON_TOKEN_ACTION=true;
+  //SUPPORT_CLASS_VISIBILITY_PUBLIC=false;
+  JDK_VERSION = "1.5";
+  TOKEN_FACTORY = "ASTParser.GTToken";
+}
+
+PARSER_BEGIN(ASTParser)
+/*
+ * Copyright (C) 2008 Jlio Vilmar Gesser.
+ * 
+ * This file is part of Java 1.5 parser and Abstract Syntax Tree.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package japa.parser;
+
+import java.io.*;
+import java.util.*;
+import japa.parser.ast.*;
+import japa.parser.ast.body.*;
+import japa.parser.ast.expr.*;
+import japa.parser.ast.stmt.*;
+import japa.parser.ast.type.*;
+
+/**
+ * <p>This class was generated automatically by javacc, do not edit.</p>
+ * @author Jlio Vilmar Gesser
+ */
+final class ASTParser {
+
+    void reset(InputStream in, String encoding) {
+        ReInit(in, encoding);
+        token_source.clearComments();
+    }
+
+    private List add(List list, Object obj) {
+    	if (list == null) {
+    		list = new LinkedList();
+    	}
+    	list.add(obj);
+    	return list;
+    }
+
+    private List add(int pos, List list, Object obj) {
+    	if (list == null) {
+    		list = new LinkedList();
+    	}
+    	list.add(pos, obj);
+    	return list;
+    }
+
+	private class Modifier {
+
+		final int modifiers;
+		final List annotations;
+		final int beginLine;
+		final int beginColumn;
+
+		public Modifier(int beginLine, int beginColumn, int modifiers, List annotations) {
+			this.beginLine = beginLine;
+			this.beginColumn = beginColumn;
+			this.modifiers = modifiers;
+			this.annotations = annotations;
+		}
+	}
+
+    public int addModifier(int modifiers, int mod, Token token) throws ParseException {
+        if ((ModifierSet.hasModifier(modifiers, mod))) {
+            throwParseException(token, "Duplicated modifier");
+        }
+        return ModifierSet.addModifier(modifiers, mod);
+    }
+
+    private void pushJavadoc() {
+        token_source.pushJavadoc();
+    }
+
+    private JavadocComment popJavadoc() {
+        return token_source.popJavadoc();
+    }
+
+    private List<Comment> getComments() {
+        return token_source.getComments();
+    }
+    
+    private void throwParseException(Token token, String message) throws ParseException {
+        StringBuilder buf = new StringBuilder();
+        buf.append(message);
+        buf.append(": \"");
+        buf.append(token.image);
+        buf.append("\" at line ");
+        buf.append(token.beginLine);
+        buf.append(", column ");
+        buf.append(token.beginColumn);
+        ParseException e = new ParseException(buf.toString());
+        e.currentToken = token;
+        throw e;
+    }
+    
+    static final class GTToken extends Token {
+
+        int realKind = ASTParserConstants.GT;
+
+        GTToken(int kind, String image) {
+            this.kind = kind;
+            this.image = image;
+        }
+
+        public static Token newToken(int kind, String image) {
+            return new GTToken(kind, image);
+        }
+    }
+}
+
+PARSER_END(ASTParser)
+
+/* WHITE SPACE */
+
+SKIP :
+{
+  " "
+| "\t"
+| "\n"
+| "\r"
+| "\f"
+}
+
+/* COMMENTS */
+
+TOKEN_MGR_DECLS :
+{
+    private List<Comment> comments;
+    private final Stack<JavadocComment> javadocStack = new Stack<JavadocComment>();
+    private JavadocComment lastJavadoc;
+
+    void pushJavadoc() {
+        javadocStack.push(lastJavadoc);
+    }
+
+    JavadocComment popJavadoc() {
+        return javadocStack.pop();
+    }
+    
+    List<Comment> getComments() {
+        return comments;
+    }
+    
+    void clearComments() {
+    	comments = null;
+    	javadocStack.clear();
+    	lastJavadoc = null;
+    }
+
+    private void CommonTokenAction(Token token) {
+        lastJavadoc = null;
+        if (token.specialToken != null) {
+        	if(comments == null) {
+        	    comments = new LinkedList<Comment>();
+        	}
+            Token special = token.specialToken;
+            if(special.kind == JAVA_DOC_COMMENT) {
+                lastJavadoc = new JavadocComment(special.beginLine, special.beginColumn, special.endLine, special.endColumn, special.image.substring(3, special.image.length()-2));        	
+                comments.add(lastJavadoc);
+            } else if(special.kind == SINGLE_LINE_COMMENT) {
+                LineComment comment = new LineComment(special.beginLine, special.beginColumn, special.endLine, special.endColumn, special.image.substring(2));        	
+                comments.add(comment);
+            } else if(special.kind == MULTI_LINE_COMMENT) {
+                BlockComment comment = new BlockComment(special.beginLine, special.beginColumn, special.endLine, special.endColumn, special.image.substring(2, special.image.length()-2));        	
+                comments.add(comment);
+            }
+        }
+    }
+}
+
+SPECIAL_TOKEN :
+{
+  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? >
+}
+
+MORE :
+{
+  <"/**" ~["/"]> { input_stream.backup(1); } : IN_JAVA_DOC_COMMENT
+|
+  <"/*"> : IN_MULTI_LINE_COMMENT
+}
+
+<IN_JAVA_DOC_COMMENT>
+SPECIAL_TOKEN :
+{
+  <JAVA_DOC_COMMENT: "*/" > : DEFAULT
+}
+
+<IN_MULTI_LINE_COMMENT>
+SPECIAL_TOKEN :
+{
+  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
+}
+
+<IN_JAVA_DOC_COMMENT, IN_MULTI_LINE_COMMENT>
+MORE :
+{
+  < ~[] >
+}
+
+/* RESERVED WORDS AND LITERALS */
+
+TOKEN :
+{
+  < ABSTRACT: "abstract" >
+| < ASSERT: "assert" >
+| < BOOLEAN: "boolean" >
+| < BREAK: "break" >
+| < BYTE: "byte" >
+| < CASE: "case" >
+| < CATCH: "catch" >
+| < CHAR: "char" >
+| < CLASS: "class" >
+| < CONST: "const" >
+| < CONTINUE: "continue" >
+| < _DEFAULT: "default" >
+| < DO: "do" >
+| < DOUBLE: "double" >
+| < ELSE: "else" >
+| < ENUM: "enum" >
+| < EXTENDS: "extends" >
+| < FALSE: "false" >
+| < FINAL: "final" >
+| < FINALLY: "finally" >
+| < FLOAT: "float" >
+| < FOR: "for" >
+| < GOTO: "goto" >
+| < IF: "if" >
+| < IMPLEMENTS: "implements" >
+| < IMPORT: "import" >
+| < INSTANCEOF: "instanceof" >
+| < INT: "int" >
+| < INTERFACE: "interface" >
+| < LONG: "long" >
+| < NATIVE: "native" >
+| < NEW: "new" >
+| < NULL: "null" >
+| < PACKAGE: "package">
+| < PRIVATE: "private" >
+| < PROTECTED: "protected" >
+| < PUBLIC: "public" >
+| < RETURN: "return" >
+| < SHORT: "short" >
+| < STATIC: "static" >
+| < STRICTFP: "strictfp" >
+| < SUPER: "super" >
+| < SWITCH: "switch" >
+| < SYNCHRONIZED: "synchronized" >
+| < THIS: "this" >
+| < THROW: "throw" >
+| < THROWS: "throws" >
+| < TRANSIENT: "transient" >
+| < TRUE: "true" >
+| < TRY: "try" >
+| < VOID: "void" >
+| < VOLATILE: "volatile" >
+| < WHILE: "while" >
+}
+
+/* LITERALS */
+
+TOKEN :
+{
+  < LONG_LITERAL:
+        <DECIMAL_LITERAL> (["l","L"])
+      | <HEX_LITERAL> (["l","L"])
+      | <OCTAL_LITERAL> (["l","L"])
+  >
+|
+  < INTEGER_LITERAL:
+        <DECIMAL_LITERAL>
+      | <HEX_LITERAL>
+      | <OCTAL_LITERAL>
+  >
+|
+  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
+|
+  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
+|
+  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
+|
+  < FLOATING_POINT_LITERAL:
+        <DECIMAL_FLOATING_POINT_LITERAL>
+      | <HEXADECIMAL_FLOATING_POINT_LITERAL>
+  >
+|
+  < #DECIMAL_FLOATING_POINT_LITERAL:
+        (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
+      | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
+      | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])?
+      | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]
+  >
+|
+  < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
+|
+  < #HEXADECIMAL_FLOATING_POINT_LITERAL:
+        "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
+      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
+  >
+|
+  < #HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+ >
+|
+  < CHARACTER_LITERAL:
+      "'"
+      (   (~["'","\\","\n","\r"])
+        | ("\\"
+            ( ["n","t","b","r","f","\\","'","\""]
+            | ["0"-"7"] ( ["0"-"7"] )?
+            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
+            )
+          )
+        | ("\\u"
+        	["0"-"9","A"-"F","a"-"f"]
+        	["0"-"9","A"-"F","a"-"f"]
+        	["0"-"9","A"-"F","a"-"f"]
+        	["0"-"9","A"-"F","a"-"f"]
+          )
+      )
+      "'"
+  >
+|
+  < STRING_LITERAL:
+      "\""
+      (   (~["\"","\\","\n","\r"])
+        | ("\\"
+            ( ["n","t","b","r","f","\\","'","\""]
+            | ["0"-"7"] ( ["0"-"7"] )?
+            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
+            )
+          )
+        | ("\\u"
+        	["0"-"9","A"-"F","a"-"f"]
+        	["0"-"9","A"-"F","a"-"f"]
+        	["0"-"9","A"-"F","a"-"f"]
+        	["0"-"9","A"-"F","a"-"f"]
+          )
+      )*
+      "\""
+  >
+}
+
+/* IDENTIFIERS */
+
+TOKEN :
+{
+  < IDENTIFIER: <LETTER> (<PART_LETTER>)* >
+|
+  < #LETTER:
+      [  // all chars for which Character.isIdentifierStart is true
+         "\u0024",          // "$"
+         "\u0041"-"\u005a", // "A"-"Z"
+         "\u005f",          // "_"
+         "\u0061"-"\u007a", // "a"-"z"
+         "\u00a2"-"\u00a5",
+         "\u00aa",
+         "\u00b5",
+         "\u00ba",
+         "\u00c0"-"\u00d6",
+         "\u00d8"-"\u00f6",
+         "\u00f8"-"\u0236",
+         "\u0250"-"\u02c1",
+         "\u02c6"-"\u02d1",
+         "\u02e0"-"\u02e4",
+         "\u02ee",
+         "\u037a",
+         "\u0386",
+         "\u0388"-"\u038a",
+         "\u038c",
+         "\u038e"-"\u03a1",
+         "\u03a3"-"\u03ce",
+         "\u03d0"-"\u03f5",
+         "\u03f7"-"\u03fb",
+         "\u0400"-"\u0481",
+         "\u048a"-"\u04ce",
+         "\u04d0"-"\u04f5",
+         "\u04f8"-"\u04f9",
+         "\u0500"-"\u050f",
+         "\u0531"-"\u0556",
+         "\u0559",
+         "\u0561"-"\u0587",
+         "\u05d0"-"\u05ea",
+         "\u05f0"-"\u05f2",
+         "\u0621"-"\u063a",
+         "\u0640"-"\u064a",
+         "\u066e"-"\u066f",
+         "\u0671"-"\u06d3",
+         "\u06d5",
+         "\u06e5"-"\u06e6",
+         "\u06ee"-"\u06ef",
+         "\u06fa"-"\u06fc",
+         "\u06ff",
+         "\u0710",
+         "\u0712"-"\u072f",
+         "\u074d"-"\u074f",
+         "\u0780"-"\u07a5",
+         "\u07b1",
+         "\u0904"-"\u0939",
+         "\u093d",
+         "\u0950",
+         "\u0958"-"\u0961",
+         "\u0985"-"\u098c",
+         "\u098f"-"\u0990",
+         "\u0993"-"\u09a8",
+         "\u09aa"-"\u09b0",
+         "\u09b2",
+         "\u09b6"-"\u09b9",
+         "\u09bd",
+         "\u09dc"-"\u09dd",
+         "\u09df"-"\u09e1",
+         "\u09f0"-"\u09f3",
+         "\u0a05"-"\u0a0a",
+         "\u0a0f"-"\u0a10",
+         "\u0a13"-"\u0a28",
+         "\u0a2a"-"\u0a30",
+         "\u0a32"-"\u0a33",
+         "\u0a35"-"\u0a36",
+         "\u0a38"-"\u0a39",
+         "\u0a59"-"\u0a5c",
+         "\u0a5e",
+         "\u0a72"-"\u0a74",
+         "\u0a85"-"\u0a8d",
+         "\u0a8f"-"\u0a91",
+         "\u0a93"-"\u0aa8",
+         "\u0aaa"-"\u0ab0",
+         "\u0ab2"-"\u0ab3",
+         "\u0ab5"-"\u0ab9",
+         "\u0abd",
+         "\u0ad0",
+         "\u0ae0"-"\u0ae1",
+         "\u0af1",
+         "\u0b05"-"\u0b0c",
+         "\u0b0f"-"\u0b10",
+         "\u0b13"-"\u0b28",
+         "\u0b2a"-"\u0b30",
+         "\u0b32"-"\u0b33",
+         "\u0b35"-"\u0b39",
+         "\u0b3d",
+         "\u0b5c"-"\u0b5d",
+         "\u0b5f"-"\u0b61",
+         "\u0b71",
+         "\u0b83",
+         "\u0b85"-"\u0b8a",
+         "\u0b8e"-"\u0b90",
+         "\u0b92"-"\u0b95",
+         "\u0b99"-"\u0b9a",
+         "\u0b9c",
+         "\u0b9e"-"\u0b9f",
+         "\u0ba3"-"\u0ba4",
+         "\u0ba8"-"\u0baa",
+         "\u0bae"-"\u0bb5",
+         "\u0bb7"-"\u0bb9",
+         "\u0bf9",
+         "\u0c05"-"\u0c0c",
+         "\u0c0e"-"\u0c10",
+         "\u0c12"-"\u0c28",
+         "\u0c2a"-"\u0c33",
+         "\u0c35"-"\u0c39",
+         "\u0c60"-"\u0c61",
+         "\u0c85"-"\u0c8c",
+         "\u0c8e"-"\u0c90",
+         "\u0c92"-"\u0ca8",
+         "\u0caa"-"\u0cb3",
+         "\u0cb5"-"\u0cb9",
+         "\u0cbd",
+         "\u0cde",
+         "\u0ce0"-"\u0ce1",
+         "\u0d05"-"\u0d0c",
+         "\u0d0e"-"\u0d10",
+         "\u0d12"-"\u0d28",
+         "\u0d2a"-"\u0d39",
+         "\u0d60"-"\u0d61",
+         "\u0d85"-"\u0d96",
+         "\u0d9a"-"\u0db1",
+         "\u0db3"-"\u0dbb",
+         "\u0dbd",
+         "\u0dc0"-"\u0dc6",
+         "\u0e01"-"\u0e30",
+         "\u0e32"-"\u0e33",
+         "\u0e3f"-"\u0e46",
+         "\u0e81"-"\u0e82",
+         "\u0e84",
+         "\u0e87"-"\u0e88",
+         "\u0e8a",
+         "\u0e8d",
+         "\u0e94"-"\u0e97",
+         "\u0e99"-"\u0e9f",
+         "\u0ea1"-"\u0ea3",
+         "\u0ea5",
+         "\u0ea7",
+         "\u0eaa"-"\u0eab",
+         "\u0ead"-"\u0eb0",
+         "\u0eb2"-"\u0eb3",
+         "\u0ebd",
+         "\u0ec0"-"\u0ec4",
+         "\u0ec6",
+         "\u0edc"-"\u0edd",
+         "\u0f00",
+         "\u0f40"-"\u0f47",
+         "\u0f49"-"\u0f6a",
+         "\u0f88"-"\u0f8b",
+         "\u1000"-"\u1021",
+         "\u1023"-"\u1027",
+         "\u1029"-"\u102a",
+         "\u1050"-"\u1055",
+         "\u10a0"-"\u10c5",
+         "\u10d0"-"\u10f8",
+         "\u1100"-"\u1159",
+         "\u115f"-"\u11a2",
+         "\u11a8"-"\u11f9",
+         "\u1200"-"\u1206",
+         "\u1208"-"\u1246",
+         "\u1248",
+         "\u124a"-"\u124d",
+         "\u1250"-"\u1256",
+         "\u1258",
+         "\u125a"-"\u125d",
+         "\u1260"-"\u1286",
+         "\u1288",
+         "\u128a"-"\u128d",
+         "\u1290"-"\u12ae",
+         "\u12b0",
+         "\u12b2"-"\u12b5",
+         "\u12b8"-"\u12be",
+         "\u12c0",
+         "\u12c2"-"\u12c5",
+         "\u12c8"-"\u12ce",
+         "\u12d0"-"\u12d6",
+         "\u12d8"-"\u12ee",
+         "\u12f0"-"\u130e",
+         "\u1310",
+         "\u1312"-"\u1315",
+         "\u1318"-"\u131e",
+         "\u1320"-"\u1346",
+         "\u1348"-"\u135a",
+         "\u13a0"-"\u13f4",
+         "\u1401"-"\u166c",
+         "\u166f"-"\u1676",
+         "\u1681"-"\u169a",
+         "\u16a0"-"\u16ea",
+         "\u16ee"-"\u16f0",
+         "\u1700"-"\u170c",
+         "\u170e"-"\u1711",
+         "\u1720"-"\u1731",
+         "\u1740"-"\u1751",
+         "\u1760"-"\u176c",
+         "\u176e"-"\u1770",
+         "\u1780"-"\u17b3",
+         "\u17d7",
+         "\u17db"-"\u17dc",
+         "\u1820"-"\u1877",
+         "\u1880"-"\u18a8",
+         "\u1900"-"\u191c",
+         "\u1950"-"\u196d",
+         "\u1970"-"\u1974",
+         "\u1d00"-"\u1d6b",
+         "\u1e00"-"\u1e9b",
+         "\u1ea0"-"\u1ef9",
+         "\u1f00"-"\u1f15",
+         "\u1f18"-"\u1f1d",
+         "\u1f20"-"\u1f45",
+         "\u1f48"-"\u1f4d",
+         "\u1f50"-"\u1f57",
+         "\u1f59",
+         "\u1f5b",
+         "\u1f5d",
+         "\u1f5f"-"\u1f7d",
+         "\u1f80"-"\u1fb4",
+         "\u1fb6"-"\u1fbc",
+         "\u1fbe",
+         "\u1fc2"-"\u1fc4",
+         "\u1fc6"-"\u1fcc",
+         "\u1fd0"-"\u1fd3",
+         "\u1fd6"-"\u1fdb",
+         "\u1fe0"-"\u1fec",
+         "\u1ff2"-"\u1ff4",
+         "\u1ff6"-"\u1ffc",
+         "\u203f"-"\u2040",
+         "\u2054",
+         "\u2071",
+         "\u207f",
+         "\u20a0"-"\u20b1",
+         "\u2102",
+         "\u2107",
+         "\u210a"-"\u2113",
+         "\u2115",
+         "\u2119"-"\u211d",
+         "\u2124",
+         "\u2126",
+         "\u2128",
+         "\u212a"-"\u212d",
+         "\u212f"-"\u2131",
+         "\u2133"-"\u2139",
+         "\u213d"-"\u213f",
+         "\u2145"-"\u2149",
+         "\u2160"-"\u2183",
+         "\u3005"-"\u3007",
+         "\u3021"-"\u3029",
+         "\u3031"-"\u3035",
+         "\u3038"-"\u303c",
+         "\u3041"-"\u3096",
+         "\u309d"-"\u309f",
+         "\u30a1"-"\u30ff",
+         "\u3105"-"\u312c",
+         "\u3131"-"\u318e",
+         "\u31a0"-"\u31b7",
+         "\u31f0"-"\u31ff",
+         "\u3400"-"\u4db5",
+         "\u4e00"-"\u9fa5",
+         "\ua000"-"\ua48c",
+         "\uac00"-"\ud7a3",
+         "\ud801", //for supplementary characters suport
+         "\ud802", //for supplementary characters suport
+         "\uf900"-"\ufa2d",
+         "\ufa30"-"\ufa6a",
+         "\ufb00"-"\ufb06",
+         "\ufb13"-"\ufb17",
+         "\ufb1d",
+         "\ufb1f"-"\ufb28",
+         "\ufb2a"-"\ufb36",
+         "\ufb38"-"\ufb3c",
+         "\ufb3e",
+         "\ufb40"-"\ufb41",
+         "\ufb43"-"\ufb44",
+         "\ufb46"-"\ufbb1",
+         "\ufbd3"-"\ufd3d",
+         "\ufd50"-"\ufd8f",
+         "\ufd92"-"\ufdc7",
+         "\ufdf0"-"\ufdfc",
+         "\ufe33"-"\ufe34",
+         "\ufe4d"-"\ufe4f",
+         "\ufe69",
+         "\ufe70"-"\ufe74",
+         "\ufe76"-"\ufefc",
+         "\uff04",
+         "\uff21"-"\uff3a",
+         "\uff3f",
+         "\uff41"-"\uff5a",
+         "\uff65"-"\uffbe",
+         "\uffc2"-"\uffc7",
+         "\uffca"-"\uffcf",
+         "\uffd2"-"\uffd7",
+         "\uffda"-"\uffdc",
+         "\uffe0"-"\uffe1",
+         "\uffe5"-"\uffe6"
+      ]
+  >
+|
+  < #PART_LETTER:
+      [  // all chars for which Character.isIdentifierPart is true
+         "\u0000"-"\u0008",
+         "\u000e"-"\u001b",
+         "\u0024",          // "$"
+         "\u0030"-"\u0039", // "0"-"9"
+         "\u0041"-"\u005a", // "A"-"Z"
+         "\u005f",          // "_"
+         "\u0061"-"\u007a", // "a"-"z"
+         "\u007f"-"\u009f",
+         "\u00a2"-"\u00a5",
+         "\u00aa",
+         "\u00ad",
+         "\u00b5",
+         "\u00ba",
+         "\u00c0"-"\u00d6",
+         "\u00d8"-"\u00f6",
+         "\u00f8"-"\u0236",
+         "\u0250"-"\u02c1",
+         "\u02c6"-"\u02d1",
+         "\u02e0"-"\u02e4",
+         "\u02ee",
+         "\u0300"-"\u0357",
+         "\u035d"-"\u036f",
+         "\u037a",
+         "\u0386",
+         "\u0388"-"\u038a",
+         "\u038c",
+         "\u038e"-"\u03a1",
+         "\u03a3"-"\u03ce",
+         "\u03d0"-"\u03f5",
+         "\u03f7"-"\u03fb",
+         "\u0400"-"\u0481",
+         "\u0483"-"\u0486",
+         "\u048a"-"\u04ce",
+         "\u04d0"-"\u04f5",
+         "\u04f8"-"\u04f9",
+         "\u0500"-"\u050f",
+         "\u0531"-"\u0556",
+         "\u0559",
+         "\u0561"-"\u0587",
+         "\u0591"-"\u05a1",
+         "\u05a3"-"\u05b9",
+         "\u05bb"-"\u05bd",
+         "\u05bf",
+         "\u05c1"-"\u05c2",
+         "\u05c4",
+         "\u05d0"-"\u05ea",
+         "\u05f0"-"\u05f2",
+         "\u0600"-"\u0603",
+         "\u0610"-"\u0615",
+         "\u0621"-"\u063a",
+         "\u0640"-"\u0658",
+         "\u0660"-"\u0669",
+         "\u066e"-"\u06d3",
+         "\u06d5"-"\u06dd",
+         "\u06df"-"\u06e8",
+         "\u06ea"-"\u06fc",
+         "\u06ff",
+         "\u070f"-"\u074a",
+         "\u074d"-"\u074f",
+         "\u0780"-"\u07b1",
+         "\u0901"-"\u0939",
+         "\u093c"-"\u094d",
+         "\u0950"-"\u0954",
+         "\u0958"-"\u0963",
+         "\u0966"-"\u096f",
+         "\u0981"-"\u0983",
+         "\u0985"-"\u098c",
+         "\u098f"-"\u0990",
+         "\u0993"-"\u09a8",
+         "\u09aa"-"\u09b0",
+         "\u09b2",
+         "\u09b6"-"\u09b9",
+         "\u09bc"-"\u09c4",
+         "\u09c7"-"\u09c8",
+         "\u09cb"-"\u09cd",
+         "\u09d7",
+         "\u09dc"-"\u09dd",
+         "\u09df"-"\u09e3",
+         "\u09e6"-"\u09f3",
+         "\u0a01"-"\u0a03",
+         "\u0a05"-"\u0a0a",
+         "\u0a0f"-"\u0a10",
+         "\u0a13"-"\u0a28",
+         "\u0a2a"-"\u0a30",
+         "\u0a32"-"\u0a33",
+         "\u0a35"-"\u0a36",
+         "\u0a38"-"\u0a39",
+         "\u0a3c",
+         "\u0a3e"-"\u0a42",
+         "\u0a47"-"\u0a48",
+         "\u0a4b"-"\u0a4d",
+         "\u0a59"-"\u0a5c",
+         "\u0a5e",
+         "\u0a66"-"\u0a74",
+         "\u0a81"-"\u0a83",
+         "\u0a85"-"\u0a8d",
+         "\u0a8f"-"\u0a91",
+         "\u0a93"-"\u0aa8",
+         "\u0aaa"-"\u0ab0",
+         "\u0ab2"-"\u0ab3",
+         "\u0ab5"-"\u0ab9",
+         "\u0abc"-"\u0ac5",
+         "\u0ac7"-"\u0ac9",
+         "\u0acb"-"\u0acd",
+         "\u0ad0",
+         "\u0ae0"-"\u0ae3",
+         "\u0ae6"-"\u0aef",
+         "\u0af1",
+         "\u0b01"-"\u0b03",
+         "\u0b05"-"\u0b0c",
+         "\u0b0f"-"\u0b10",
+         "\u0b13"-"\u0b28",
+         "\u0b2a"-"\u0b30",
+         "\u0b32"-"\u0b33",
+         "\u0b35"-"\u0b39",
+         "\u0b3c"-"\u0b43",
+         "\u0b47"-"\u0b48",
+         "\u0b4b"-"\u0b4d",
+         "\u0b56"-"\u0b57",
+         "\u0b5c"-"\u0b5d",
+         "\u0b5f"-"\u0b61",
+         "\u0b66"-"\u0b6f",
+         "\u0b71",
+         "\u0b82"-"\u0b83",
+         "\u0b85"-"\u0b8a",
+         "\u0b8e"-"\u0b90",
+         "\u0b92"-"\u0b95",
+         "\u0b99"-"\u0b9a",
+         "\u0b9c",
+         "\u0b9e"-"\u0b9f",
+         "\u0ba3"-"\u0ba4",
+         "\u0ba8"-"\u0baa",
+         "\u0bae"-"\u0bb5",
+         "\u0bb7"-"\u0bb9",
+         "\u0bbe"-"\u0bc2",
+         "\u0bc6"-"\u0bc8",
+         "\u0bca"-"\u0bcd",
+         "\u0bd7",
+         "\u0be7"-"\u0bef",
+         "\u0bf9",
+         "\u0c01"-"\u0c03",
+         "\u0c05"-"\u0c0c",
+         "\u0c0e"-"\u0c10",
+         "\u0c12"-"\u0c28",
+         "\u0c2a"-"\u0c33",
+         "\u0c35"-"\u0c39",
+         "\u0c3e"-"\u0c44",
+         "\u0c46"-"\u0c48",
+         "\u0c4a"-"\u0c4d",
+         "\u0c55"-"\u0c56",
+         "\u0c60"-"\u0c61",
+         "\u0c66"-"\u0c6f",
+         "\u0c82"-"\u0c83",
+         "\u0c85"-"\u0c8c",
+         "\u0c8e"-"\u0c90",
+         "\u0c92"-"\u0ca8",
+         "\u0caa"-"\u0cb3",
+         "\u0cb5"-"\u0cb9",
+         "\u0cbc"-"\u0cc4",
+         "\u0cc6"-"\u0cc8",
+         "\u0cca"-"\u0ccd",
+         "\u0cd5"-"\u0cd6",
+         "\u0cde",
+         "\u0ce0"-"\u0ce1",
+         "\u0ce6"-"\u0cef",
+         "\u0d02"-"\u0d03",
+         "\u0d05"-"\u0d0c",
+         "\u0d0e"-"\u0d10",
+         "\u0d12"-"\u0d28",
+         "\u0d2a"-"\u0d39",
+         "\u0d3e"-"\u0d43",
+         "\u0d46"-"\u0d48",
+         "\u0d4a"-"\u0d4d",
+         "\u0d57",
+         "\u0d60"-"\u0d61",
+         "\u0d66"-"\u0d6f",
+         "\u0d82"-"\u0d83",
+         "\u0d85"-"\u0d96",
+         "\u0d9a"-"\u0db1",
+         "\u0db3"-"\u0dbb",
+         "\u0dbd",
+         "\u0dc0"-"\u0dc6",
+         "\u0dca",
+         "\u0dcf"-"\u0dd4",
+         "\u0dd6",
+         "\u0dd8"-"\u0ddf",
+         "\u0df2"-"\u0df3",
+         "\u0e01"-"\u0e3a",
+         "\u0e3f"-"\u0e4e",
+         "\u0e50"-"\u0e59",
+         "\u0e81"-"\u0e82",
+         "\u0e84",
+         "\u0e87"-"\u0e88",
+         "\u0e8a",
+         "\u0e8d",
+         "\u0e94"-"\u0e97",
+         "\u0e99"-"\u0e9f",
+         "\u0ea1"-"\u0ea3",
+         "\u0ea5",
+         "\u0ea7",
+         "\u0eaa"-"\u0eab",
+         "\u0ead"-"\u0eb9",
+         "\u0ebb"-"\u0ebd",
+         "\u0ec0"-"\u0ec4",
+         "\u0ec6",
+         "\u0ec8"-"\u0ecd",
+         "\u0ed0"-"\u0ed9",
+         "\u0edc"-"\u0edd",
+         "\u0f00",
+         "\u0f18"-"\u0f19",
+         "\u0f20"-"\u0f29",
+         "\u0f35",
+         "\u0f37",
+         "\u0f39",
+         "\u0f3e"-"\u0f47",
+         "\u0f49"-"\u0f6a",
+         "\u0f71"-"\u0f84",
+         "\u0f86"-"\u0f8b",
+         "\u0f90"-"\u0f97",
+         "\u0f99"-"\u0fbc",
+         "\u0fc6",
+         "\u1000"-"\u1021",
+         "\u1023"-"\u1027",
+         "\u1029"-"\u102a",
+         "\u102c"-"\u1032",
+         "\u1036"-"\u1039",
+         "\u1040"-"\u1049",
+         "\u1050"-"\u1059",
+         "\u10a0"-"\u10c5",
+         "\u10d0"-"\u10f8",
+         "\u1100"-"\u1159",
+         "\u115f"-"\u11a2",
+         "\u11a8"-"\u11f9",
+         "\u1200"-"\u1206",
+         "\u1208"-"\u1246",
+         "\u1248",
+         "\u124a"-"\u124d",
+         "\u1250"-"\u1256",
+         "\u1258",
+         "\u125a"-"\u125d",
+         "\u1260"-"\u1286",
+         "\u1288",
+         "\u128a"-"\u128d",
+         "\u1290"-"\u12ae",
+         "\u12b0",
+         "\u12b2"-"\u12b5",
+         "\u12b8"-"\u12be",
+         "\u12c0",
+         "\u12c2"-"\u12c5",
+         "\u12c8"-"\u12ce",
+         "\u12d0"-"\u12d6",
+         "\u12d8"-"\u12ee",
+         "\u12f0"-"\u130e",
+         "\u1310",
+         "\u1312"-"\u1315",
+         "\u1318"-"\u131e",
+         "\u1320"-"\u1346",
+         "\u1348"-"\u135a",
+         "\u1369"-"\u1371",
+         "\u13a0"-"\u13f4",
+         "\u1401"-"\u166c",
+         "\u166f"-"\u1676",
+         "\u1681"-"\u169a",
+         "\u16a0"-"\u16ea",
+         "\u16ee"-"\u16f0",
+         "\u1700"-"\u170c",
+         "\u170e"-"\u1714",
+         "\u1720"-"\u1734",
+         "\u1740"-"\u1753",
+         "\u1760"-"\u176c",
+         "\u176e"-"\u1770",
+         "\u1772"-"\u1773",
+         "\u1780"-"\u17d3",
+         "\u17d7",
+         "\u17db"-"\u17dd",
+         "\u17e0"-"\u17e9",
+         "\u180b"-"\u180d",
+         "\u1810"-"\u1819",
+         "\u1820"-"\u1877",
+         "\u1880"-"\u18a9",
+         "\u1900"-"\u191c",
+         "\u1920"-"\u192b",
+         "\u1930"-"\u193b",
+         "\u1946"-"\u196d",
+         "\u1970"-"\u1974",
+         "\u1d00"-"\u1d6b",
+         "\u1e00"-"\u1e9b",
+         "\u1ea0"-"\u1ef9",
+         "\u1f00"-"\u1f15",
+         "\u1f18"-"\u1f1d",
+         "\u1f20"-"\u1f45",
+         "\u1f48"-"\u1f4d",
+         "\u1f50"-"\u1f57",
+         "\u1f59",
+         "\u1f5b",
+         "\u1f5d",
+         "\u1f5f"-"\u1f7d",
+         "\u1f80"-"\u1fb4",
+         "\u1fb6"-"\u1fbc",
+         "\u1fbe",
+         "\u1fc2"-"\u1fc4",
+         "\u1fc6"-"\u1fcc",
+         "\u1fd0"-"\u1fd3",
+         "\u1fd6"-"\u1fdb",
+         "\u1fe0"-"\u1fec",
+         "\u1ff2"-"\u1ff4",
+         "\u1ff6"-"\u1ffc",
+         "\u200c"-"\u200f",
+         "\u202a"-"\u202e",
+         "\u203f"-"\u2040",
+         "\u2054",
+         "\u2060"-"\u2063",
+         "\u206a"-"\u206f",
+         "\u2071",
+         "\u207f",
+         "\u20a0"-"\u20b1",
+         "\u20d0"-"\u20dc",
+         "\u20e1",
+         "\u20e5"-"\u20ea",
+         "\u2102",
+         "\u2107",
+         "\u210a"-"\u2113",
+         "\u2115",
+         "\u2119"-"\u211d",
+         "\u2124",
+         "\u2126",
+         "\u2128",
+         "\u212a"-"\u212d",
+         "\u212f"-"\u2131",
+         "\u2133"-"\u2139",
+         "\u213d"-"\u213f",
+         "\u2145"-"\u2149",
+         "\u2160"-"\u2183",
+         "\u3005"-"\u3007",
+         "\u3021"-"\u302f",
+         "\u3031"-"\u3035",
+         "\u3038"-"\u303c",
+         "\u3041"-"\u3096",
+         "\u3099"-"\u309a",
+         "\u309d"-"\u309f",
+         "\u30a1"-"\u30ff",
+         "\u3105"-"\u312c",
+         "\u3131"-"\u318e",
+         "\u31a0"-"\u31b7",
+         "\u31f0"-"\u31ff",
+         "\u3400"-"\u4db5",
+         "\u4e00"-"\u9fa5",
+         "\ua000"-"\ua48c",
+         "\uac00"-"\ud7a3",
+         "\ud801", //for supplementary characters suport
+         "\ud802", //for supplementary characters suport
+         "\ud834", //for supplementary characters suport
+         "\udc00", //for supplementary characters suport
+         "\udc01", //for supplementary characters suport
+         "\udd7b", //for supplementary characters suport
+         "\uf900"-"\ufa2d",
+         "\ufa30"-"\ufa6a",
+         "\ufb00"-"\ufb06",
+         "\ufb13"-"\ufb17",
+         "\ufb1d"-"\ufb28",
+         "\ufb2a"-"\ufb36",
+         "\ufb38"-"\ufb3c",
+         "\ufb3e",
+         "\ufb40"-"\ufb41",
+         "\ufb43"-"\ufb44",
+         "\ufb46"-"\ufbb1",
+         "\ufbd3"-"\ufd3d",
+         "\ufd50"-"\ufd8f",
+         "\ufd92"-"\ufdc7",
+         "\ufdf0"-"\ufdfc",
+         "\ufe00"-"\ufe0f",
+         "\ufe20"-"\ufe23",
+         "\ufe33"-"\ufe34",
+         "\ufe4d"-"\ufe4f",
+         "\ufe69",
+         "\ufe70"-"\ufe74",
+         "\ufe76"-"\ufefc",
+         "\ufeff",
+         "\uff04",
+         "\uff10"-"\uff19",
+         "\uff21"-"\uff3a",
+         "\uff3f",
+         "\uff41"-"\uff5a",
+         "\uff65"-"\uffbe",
+         "\uffc2"-"\uffc7",
+         "\uffca"-"\uffcf",
+         "\uffd2"-"\uffd7",
+         "\uffda"-"\uffdc",
+         "\uffe0"-"\uffe1",
+         "\uffe5"-"\uffe6",
+         "\ufff9"-"\ufffb"
+      ]
+  >
+}
+
+/* SEPARATORS */
+
+TOKEN :
+{
+  < LPAREN: "(" >
+| < RPAREN: ")" >
+| < LBRACE: "{" >
+| < RBRACE: "}" >
+| < LBRACKET: "[" >
+| < RBRACKET: "]" >
+| < SEMICOLON: ";" >
+| < COMMA: "," >
+| < DOT: "." >
+| < AT: "@" >
+}
+
+/* OPERATORS */
+
+TOKEN :
+{
+  < ASSIGN: "=" >
+| < LT: "<" >
+| < BANG: "!" >
+| < TILDE: "~" >
+| < HOOK: "?" >
+| < COLON: ":" >
+| < EQ: "==" >
+| < LE: "<=" >
+| < GE: ">=" >
+| < NE: "!=" >
+| < SC_OR: "||" >
+| < SC_AND: "&&" >
+| < INCR: "++" >
+| < DECR: "--" >
+| < PLUS: "+" >
+| < MINUS: "-" >
+| < STAR: "*" >
+| < SLASH: "/" >
+| < BIT_AND: "&" >
+| < BIT_OR: "|" >
+| < XOR: "^" >
+| < REM: "%" >
+| < LSHIFT: "<<" >
+| < PLUSASSIGN: "+=" >
+| < MINUSASSIGN: "-=" >
+| < STARASSIGN: "*=" >
+| < SLASHASSIGN: "/=" >
+| < ANDASSIGN: "&=" >
+| < ORASSIGN: "|=" >
+| < XORASSIGN: "^=" >
+| < REMASSIGN: "%=" >
+| < LSHIFTASSIGN: "<<=" >
+| < RSIGNEDSHIFTASSIGN: ">>=" >
+| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
+| < ELLIPSIS: "..." >
+}
+
+/* >'s need special attention due to generics syntax. */
+TOKEN :
+{
+  < RUNSIGNEDSHIFT: ">>>" >
+  {
+     matchedToken.kind = GT;
+     ((ASTParser.GTToken)matchedToken).realKind = RUNSIGNEDSHIFT;
+     input_stream.backup(2);
+  }
+| < RSIGNEDSHIFT: ">>" >
+  {
+     matchedToken.kind = GT;
+     ((ASTParser.GTToken)matchedToken).realKind = RSIGNEDSHIFT;
+     input_stream.backup(1);
+  }
+| < GT: ">" >
+}
+
+
+/*****************************************
+ * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
+ *****************************************/
+
+/*
+ * Program structuring syntax follows.
+ */
+
+CompilationUnit CompilationUnit():
+{
+	PackageDeclaration pakage = null;
+	List imports = null;
+	ImportDeclaration in = null;
+	List types = null;
+	TypeDeclaration tn = null;
+	int line = -1;
+	int column = 0;
+}
+{
+  [ LOOKAHEAD(PackageDeclaration()) pakage = PackageDeclaration() {line = pakage.getBeginLine(); column = pakage.getBeginColumn();} ]
+  ( in = ImportDeclaration() { if(line==-1){line = in.getBeginLine(); column = in.getBeginColumn();} imports = add(imports, in); } )*
+  ( tn = TypeDeclaration() { if(line==-1){line = tn.getBeginLine(); column = tn.getBeginColumn();} types = add(types, tn); } )*
+  (<EOF> | "\u001A" /** ctrl+z char **/)
+  { return new CompilationUnit(line == -1 ? 0 : line, column, token.endLine, token.endColumn,pakage, imports, types, getComments()); }
+}
+
+PackageDeclaration PackageDeclaration():
+{
+	List annotations = null;
+	AnnotationExpr ann;
+	NameExpr name;
+	int line;
+	int column;
+}
+{
+( ann = Annotation() { annotations = add(annotations, ann); } )*
+  "package" {line=token.beginLine; column=token.beginColumn;}  name = Name() ";"
+  { return new PackageDeclaration(line, column, token.endLine, token.endColumn,annotations, name); }
+}
+
+ImportDeclaration ImportDeclaration():
+{
+	NameExpr name;
+	boolean isStatic = false;
+	boolean isAsterisk = false;
+	int line;
+	int column;
+}
+{
+  "import" {line=token.beginLine; column=token.beginColumn;} [ "static" { isStatic = true; } ] name = Name() [ "." "*" { isAsterisk = true; } ] ";"
+  { return new ImportDeclaration(line, column, token.endLine, token.endColumn,name, isStatic, isAsterisk); }
+}
+
+/*
+ * Modifiers. We match all modifiers in a single rule to reduce the chances of
+ * syntax errors for simple modifier mistakes. It will also enable us to give
+ * better error messages.
+ */
+
+Modifier Modifiers():
+{
+    int beginLine = -1;
+    int beginColumn = -1;
+    int modifiers = 0;
+    List annotations = null;
+    AnnotationExpr ann;
+}
+{
+ (
+  LOOKAHEAD(2)
+  (
+   "public" { modifiers = addModifier(modifiers, ModifierSet.PUBLIC, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
+  |
+   "static" { modifiers = addModifier(modifiers, ModifierSet.STATIC, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
+  |
+   "protected" { modifiers = addModifier(modifiers, ModifierSet.PROTECTED, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
+  |
+   "private" { modifiers = addModifier(modifiers, ModifierSet.PRIVATE, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
+  |
+   "final" { modifiers = addModifier(modifiers, ModifierSet.FINAL, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
+  |
+   "abstract" { modifiers = addModifier(modifiers, ModifierSet.ABSTRACT, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
+  |
+   "synchronized" { modifiers = addModifier(modifiers, ModifierSet.SYNCHRONIZED, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
+  |
+   "native" { modifiers = addModifier(modifiers, ModifierSet.NATIVE, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
+  |
+   "transient" { modifiers = addModifier(modifiers, ModifierSet.TRANSIENT, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
+  |
+   "volatile" { modifiers = addModifier(modifiers, ModifierSet.VOLATILE, token); if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
+  |
+   "strictfp" { modifiers = addModifier(modifiers, ModifierSet.STRICTFP, token);  if(beginLine==-1) {beginLine=token.beginLine; beginColumn=token.beginColumn;} }
+  |
+   ann = Annotation() { annotations = add(annotations, ann); if(beginLine==-1) {beginLine=ann.getBeginLine(); beginColumn=ann.getBeginColumn();} }
+  )
+ )*
+
+ {
+    return new Modifier(beginLine, beginColumn, modifiers, annotations);
+ }
+}
+
+/*
+ * Declaration syntax follows.
+ */
+TypeDeclaration TypeDeclaration():
+{
+   Modifier modifier;
+   TypeDeclaration ret;
+}
+{
+  { pushJavadoc(); }
+  (
+    ";" { ret = new EmptyTypeDeclaration(token.beginLine, token.beginColumn, token.endLine, token.endColumn, popJavadoc()); }
+  |
+    modifier = Modifiers()
+    (
+       ret = ClassOrInterfaceDeclaration(modifier)
+     |
+       ret = EnumDeclaration(modifier)
+     |
+       ret = AnnotationTypeDeclaration(modifier)
+    )
+  )
+  { return ret; }
+}
+
+
+ClassOrInterfaceDeclaration ClassOrInterfaceDeclaration(Modifier modifier):
+{
+   boolean isInterface = false;
+   String name;
+   List typePar = null;
+   List extList = null;
+   List impList = null;
+   List members;
+   int line = modifier.beginLine;
+   int column = modifier.beginColumn;
+}
+{
+  ( "class" | "interface" { isInterface = true; } ) { if (line == -1) {line=token.beginLine; column=token.beginColumn;} }
+  <IDENTIFIER> { name = token.image; }
+  [ typePar = TypeParameters() {typePar.remove(0);} ]
+  [ extList = ExtendsList(isInterface) ]
+  [ impList = ImplementsList(isInterface) ]
+  members = ClassOrInterfaceBody(isInterface)
+
+  { return new ClassOrInterfaceDeclaration(line, column, token.endLine, token.endColumn,popJavadoc(), modifier.modifiers, modifier.annotations, isInterface, name, typePar, extList, impList, members); }
+}
+
+List ExtendsList(boolean isInterface):
+{
+   boolean extendsMoreThanOne = false;
+   List ret = new LinkedList();
+   ClassOrInterfaceType cit;
+}
+{
+   "extends" cit = ClassOrInterfaceType() { ret.add(cit); }
+   ( "," cit = ClassOrInterfaceType() { ret.add(cit); extendsMoreThanOne = true; } )*
+   {
+      if (extendsMoreThanOne && !isInterface)
+         throwParseException(token, "A class cannot extend more than one other class");
+   }
+   { return ret; }
+}
+
+List ImplementsList(boolean isInterface):
+{
+   List ret = new LinkedList();
+   ClassOrInterfaceType cit;
+}
+{
+   "implements" cit = ClassOrInterfaceType() { ret.add(cit); }
+   ( "," cit = ClassOrInterfaceType() { ret.add(cit); } )*
+   {
+      if (isInterface)
+         throwParseException(token, "An interface cannot implement other interfaces");
+   }
+   { return ret; }
+}
+
+EnumDeclaration EnumDeclaration(Modifier modifier):
+{
+	String name;
+	List impList = null;
+	EnumConstantDeclaration entry;
+	List entries = null;
+	BodyDeclaration member;
+	List members = null;
+	int line = modifier.beginLine;
+	int column = modifier.beginColumn;
+}
+{
+  "enum" { if (line == -1) {line=token.beginLine; column=token.beginColumn;} }
+  <IDENTIFIER> { name = token.image; }
+  [ impList = ImplementsList(false) ]
+  "{"
+  	[
+    	{ entries = new LinkedList(); }
+    	entry = EnumConstantDeclaration() { entries.add(entry); } ( LOOKAHEAD(2) "," entry = EnumConstantDeclaration() { entries.add(entry); } )*
+  	]
+  	[ "," ]
+ 	[
+ 	 	( ";" ( member = ClassOrInterfaceBodyDeclaration(false) { members = add(members, member); } )* )
+ 	]
+  "}"
+
+  { return new EnumDeclaration(line, column, token.endLine, token.endColumn,popJavadoc(), modifier.modifiers, modifier.annotations, name, impList, entries, members); }
+}
+
+
+EnumConstantDeclaration EnumConstantDeclaration():
+{
+	List annotations = null;
+	AnnotationExpr ann;
+	String name;
+	List args = null;
+	List classBody = null;
+	int line = -1;
+	int column = -1;
+}
+{
+  { pushJavadoc(); }
+  ( ann = Annotation() { annotations = add(annotations, ann); if(line==-1){line=ann.getBeginLine(); column=ann.getBeginColumn();} } )*
+  <IDENTIFIER> { name = token.image; if(line==-1){line=token.beginLine; column=token.beginColumn;} } 
+  [ args = Arguments() ] [ classBody = ClassOrInterfaceBody(false) ]
+  { return new EnumConstantDeclaration(line, column, token.endLine, token.endColumn,popJavadoc(), annotations, name, args, classBody);  }
+}
+
+List TypeParameters():
+{
+	List ret = new LinkedList();
+	TypeParameter tp;
+}
+{
+   "<" { ret.add(new int[]{token.beginLine, token.beginColumn}); }
+   tp = TypeParameter() { ret.add(tp); }
+   ( "," tp = TypeParameter() { ret.add(tp); } )* 
+   ">"
+   { return ret; }
+}
+
+TypeParameter TypeParameter():
+{
+	String name;
+	List typeBound = null;
+	int line;
+	int column;
+}
+{
+   <IDENTIFIER> { name = token.image; line=token.beginLine; column=token.beginColumn;} [ typeBound = TypeBound() ]
+   { return new TypeParameter(line, column, token.endLine, token.endColumn,name, typeBound); }
+}
+
+List TypeBound():
+{
+	List ret = new LinkedList();
+	ClassOrInterfaceType cit;
+}
+{
+   "extends" cit = ClassOrInterfaceType() { ret.add(cit); }
+   ( "&"     cit = ClassOrInterfaceType() { ret.add(cit); } )*
+   { return ret; }
+}
+
+List ClassOrInterfaceBody(boolean isInterface):
+{
+	List ret = new LinkedList();
+	BodyDeclaration member;
+}
+{
+  "{" ( member = ClassOrInterfaceBodyDeclaration(isInterface) { ret.add(member); }  )* "}"
+  { return ret; }
+}
+
+BodyDeclaration ClassOrInterfaceBodyDeclaration(boolean isInterface):
+{
+   boolean isNestedInterface = false;
+   Modifier modifier;
+   BodyDeclaration ret;
+}
+{
+  { pushJavadoc(); }
+  (
+	  LOOKAHEAD(2)
+	  ret = InitializerDeclaration()
+	  {
+	     if (isInterface)
+	        throwParseException(token, "An interface cannot have initializers");
+	  }
+	|
+	  modifier = Modifiers() // Just get all the modifiers out of the way. If you want to do
+	              // more checks, pass the modifiers down to the member
+	  (
+	      ret = ClassOrInterfaceDeclaration(modifier)
+	    |
+	      ret = EnumDeclaration(modifier)
+	    |
+	      ret = AnnotationTypeDeclaration(modifier)
+	    |
+	      LOOKAHEAD( [ TypeParameters() ] <IDENTIFIER> "(" )
+	      ret = ConstructorDeclaration(modifier)
+	    |
+	      LOOKAHEAD( Type() <IDENTIFIER> ( "[" "]" )* ( "," | "=" | ";" ) )
+	      ret = FieldDeclaration(modifier)
+	    |
+	      ret = MethodDeclaration(modifier)
+	  )
+	|
+	  ";" { ret = new EmptyMemberDeclaration(token.beginLine, token.beginColumn, token.endLine, token.endColumn, popJavadoc()); }
+  )
+  { return ret; }
+}
+
+FieldDeclaration FieldDeclaration(Modifier modifier):
+{
+	Type type;
+	List variables = new LinkedList();
+	VariableDeclarator val;
+}
+{
+  // Modifiers are already matched in the caller
+  type = Type()
+        val = VariableDeclarator() { variables.add(val); }
+  ( "," val = VariableDeclarator() { variables.add(val); } )* ";"
+
+  { 
+  	int line = modifier.beginLine;
+  	int column = modifier.beginColumn;
+  	if (line == -1) { line=type.getBeginLine(); column=type.getBeginColumn(); }
+  	return new FieldDeclaration(line, column, token.endLine, token.endColumn, popJavadoc(), modifier.modifiers, modifier.annotations, type, variables); 
+  }
+}
+
+VariableDeclarator VariableDeclarator():
+{
+	VariableDeclaratorId id;
+	Expression init = null;
+}
+{
+  id = VariableDeclaratorId() [ "=" init = VariableInitializer() ]
+  { return new  VariableDeclarator(id.getBeginLine(), id.getBeginColumn(), token.endLine, token.endColumn, id, init); }
+}
+
+VariableDeclaratorId VariableDeclaratorId():
+{
+	String name;
+	int arrayCount = 0;
+	int line;
+	int column;
+}
+{
+  <IDENTIFIER> { name = token.image; line=token.beginLine; column=token.beginColumn;}  ( "[" "]" { arrayCount++; } )*
+  { return new VariableDeclaratorId(line, column, token.endLine, token.endColumn,name, arrayCount); }
+}
+
+Expression VariableInitializer():
+{
+	Expression ret;
+}
+{
+  (
+	  ret = ArrayInitializer()
+	|
+	  ret = Expression()
+  )
+  { return ret;}
+}
+
+ArrayInitializerExpr ArrayInitializer():
+{
+	List values = null;
+	Expression val;
+	int line;
+	int column;
+}
+{
+  "{" {line=token.beginLine; column=token.beginColumn;} [ val = VariableInitializer() { values = add(values, val); } ( LOOKAHEAD(2) "," val = VariableInitializer() { values = add(values, val); } )* ] [ "," ] "}"
+  { return new ArrayInitializerExpr(line, column, token.endLine, token.endColumn,values); }
+}
+
+MethodDeclaration MethodDeclaration(Modifier modifier):
+{
+	List typeParameters = null;
+	Type type;
+	String name;
+	List parameters;
+	int arrayCount = 0;
+	List throws_ = null;
+	BlockStmt block = null;
+	int line = modifier.beginLine;
+	int column = modifier.beginColumn;
+}
+{
+  // Modifiers already matched in the caller!
+  [ typeParameters = TypeParameters() { int[] lineCol=(int[])typeParameters.remove(0); if(line==-1){ line=lineCol[0]; column=lineCol[1];} } ]
+  type = ResultType() { if(line==-1){line=type.getBeginLine(); column=type.getBeginColumn();}}
+  <IDENTIFIER> { name = token.image; } parameters = FormalParameters() ( "[" "]" { arrayCount++; } )*
+  [ "throws" throws_ = NameList() ]
+  ( block = Block() | ";" )
+
+  { return new MethodDeclaration(line, column, token.endLine, token.endColumn,popJavadoc(), modifier.modifiers, modifier.annotations, typeParameters, type, name, parameters, arrayCount, throws_, block); }
+}
+
+List FormalParameters():
+{
+	List ret = null;
+	Parameter par;
+}
+{
+  "(" [ par = FormalParameter() { ret = add(ret, par); } ( "," par = FormalParameter() { ret = add(ret, par); } )* ] ")"
+
+  { return ret; }
+}
+
+Parameter FormalParameter():
+{
+	Modifier modifier;
+	Type type;
+	boolean isVarArg = false;
+	VariableDeclaratorId id;
+}
+{
+  modifier = Modifiers() type = Type() [ "..." { isVarArg = true;} ] id = VariableDeclaratorId()
+
+  {
+    int line = modifier.beginLine;
+    int column = modifier.beginColumn;
+    if(line==-1){ line=type.getBeginLine(); column=type.getBeginColumn(); }
+    return new Parameter(line, column, token.endLine, token.endColumn, modifier.modifiers, modifier.annotations, type, isVarArg, id);
+  }
+}
+
+ConstructorDeclaration ConstructorDeclaration(Modifier modifier):
+{
+	List typeParameters = null;
+	String name;
+	List parameters;
+	List throws_ = null;
+	ExplicitConstructorInvocationStmt exConsInv = null;
+	List stmts;
+	int line = modifier.beginLine;
+	int column = modifier.beginColumn;
+	int bbLine = 0;
+	int bbColumn = 0;
+	int beLine = 0;
+	int beColumn = 0;
+}
+{
+  [ typeParameters = TypeParameters() { int[] lineCol=(int[])typeParameters.remove(0); if(line==-1){ line=lineCol[0]; column=lineCol[1];} } ]
+  // Modifiers matched in the caller
+  <IDENTIFIER> { name = token.image; if(line==-1){line=token.beginLine; column=token.beginColumn;}} parameters = FormalParameters() [ "throws" throws_ = NameList() ]
+  "{" { bbLine=token.beginLine; bbColumn=token.beginColumn; }
+    [ LOOKAHEAD(ExplicitConstructorInvocation()) exConsInv = ExplicitConstructorInvocation() ]
+    stmts = Statements()
+  "}"
+
+  {
+  	if (exConsInv != null) {
+  		stmts = add(0, stmts, exConsInv);
+  	}
+  	return new ConstructorDeclaration(line, column, token.endLine, token.endColumn,popJavadoc(), modifier.modifiers, modifier.annotations, typeParameters, name, parameters, throws_, new BlockStmt(bbLine, bbColumn, token.endLine, token.endColumn, stmts));
+  }
+}
+
+ExplicitConstructorInvocationStmt ExplicitConstructorInvocation():
+{
+	boolean isThis = false;
+	List args;
+	Expression expr = null;
+	List typeArgs = null;
+	int line = -1;
+	int column = 0;
+}
+{
+  (
+	  LOOKAHEAD([ TypeArguments() ] "this" "(")
+	  [ typeArgs = TypeArguments() { int[] lineCol=(int[])typeArgs.remove(0); line=lineCol[0]; column=lineCol[1]; } ]
+	  "this" { if (line == -1) {line=token.beginLine; column=token.beginColumn;} isThis = true; }
+	  args = Arguments() ";"
+	|
+	  [
+	    LOOKAHEAD( PrimaryExpressionWithoutSuperSuffix() "." )
+	  	expr = PrimaryExpressionWithoutSuperSuffix() "."
+	  	{ line=expr.getBeginLine(); column=expr.getBeginColumn(); }
+	  ]
+	  [ typeArgs = TypeArguments() {int[] lineCol=(int[])typeArgs.remove(0); if (line == -1) {line=lineCol[0]; column=lineCol[1];}} ]
+	  "super" {if (line == -1) {line=token.beginLine; column=token.beginColumn;}}
+	  args = Arguments() ";"
+  )
+  { return new ExplicitConstructorInvocationStmt(line, column, token.endLine, token.endColumn,typeArgs, isThis, expr, args); }
+}
+
+List Statements():
+{
+	List ret = null;
+	Statement stmt;
+}
+{
+	( stmt = BlockStatement() { ret = add(ret, stmt); } )*
+	{ return ret; }
+}
+
+InitializerDeclaration InitializerDeclaration():
+{
+	BlockStmt block;
+	int line = -1;
+	int column = 0;
+	boolean isStatic = false;
+}
+{
+  [ "static" { isStatic = true; line=token.beginLine; column=token.beginColumn;} ] block = Block() {if(line==-1){line=block.getBeginLine(); column=block.getBeginColumn();}}
+  { return new InitializerDeclaration(line, column, token.endLine, token.endColumn,popJavadoc(), isStatic, block); }
+}
+
+
+/*
+ * Type, name and expression syntax follows.
+ */
+
+Type Type():
+{
+	Type ret;
+}
+{
+ (
+   LOOKAHEAD(2) ret = ReferenceType()
+ |
+   ret = PrimitiveType()
+ )
+ { return ret; }
+}
+
+ReferenceType ReferenceType():
+{
+	Type type;
+	int arrayCount = 0;
+}
+{
+  (
+   type = PrimitiveType() ( LOOKAHEAD(2) "[" "]" { arrayCount++; } )+
+  |
+   type = ClassOrInterfaceType() ( LOOKAHEAD(2) "[" "]" { arrayCount++; } )*
+  )
+  { return new ReferenceType(type.getBeginLine(), type.getBeginColumn(), token.endLine, token.endColumn, type, arrayCount); }
+}
+
+ClassOrInterfaceType ClassOrInterfaceType():
+{
+	ClassOrInterfaceType ret;
+	String name;
+	List typeArgs = null;
+	int line;
+	int column;
+}
+{
+  <IDENTIFIER> {line=token.beginLine; column=token.beginColumn;} { name = token.image; }
+  [ LOOKAHEAD(2) typeArgs = TypeArguments() {typeArgs.remove(0);} ]
+  { ret = new ClassOrInterfaceType(line, column, token.endLine, token.endColumn,null, name, typeArgs); }
+  (
+	  LOOKAHEAD(2) "." <IDENTIFIER> { name = token.image; }
+	  [ LOOKAHEAD(2) typeArgs = TypeArguments() {typeArgs.remove(0);} ] { ret = new ClassOrInterfaceType(line, column, token.endLine, token.endColumn,ret, name, typeArgs); }
+  )*
+  { return ret; }
+}
+
+List TypeArguments():
+{
+	List ret = new LinkedList();
+	Type type;
+}
+{
+   "<" { ret.add(new int[]{token.beginLine, token.beginColumn}); }
+   type = TypeArgument() { ret.add(type); } ( "," type = TypeArgument() { ret.add(type); } )*
+   ">"
+   { return ret; }
+}
+
+Type TypeArgument():
+{
+	Type ret;
+}
+{
+ (
+   ret = ReferenceType()
+ |
+   ret = Wildcard()
+ )
+ { return ret; }
+}
+
+WildcardType Wildcard():
+{
+	ReferenceType ext = null;
+	ReferenceType sup = null;
+	int line;
+	int column;
+}
+{
+   "?" {line=token.beginLine; column=token.beginColumn;}
+   [
+		"extends" ext = ReferenceType()
+	|
+		"super" sup = ReferenceType()
+   ]
+   { return new WildcardType(line, column, token.endLine, token.endColumn,ext, sup); }
+}
+
+PrimitiveType PrimitiveType():
+{
+	PrimitiveType ret;
+}
+{
+(
+  "boolean" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Boolean); }
+|
+  "char" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Char); }
+|
+  "byte" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Byte); }
+|
+  "short" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Short); }
+|
+  "int" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Int); }
+|
+  "long" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Long); }
+|
+  "float" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Float); }
+|
+  "double" { ret = new PrimitiveType(token.beginLine, token.beginColumn, token.endLine, token.endColumn, PrimitiveType.Primitive.Double); }
+)
+{ return ret; }
+}
+
+Type ResultType():
+{
+	Type ret;
+}
+{
+  (
+	  "void" { ret = new VoidType(token.beginLine, token.beginColumn, token.endLine, token.endColumn); }
+	|
+	  ret = Type()
+  )
+  { return ret; }
+}
+
+NameExpr Name():
+/*
+ * A lookahead of 2 is required below since "Name" can be followed
+ * by a ".*" when used in the context of an "ImportDeclaration".
+ */
+{
+	NameExpr ret;
+}
+{
+  <IDENTIFIER> { ret = new NameExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image); }
+  ( LOOKAHEAD(2) "." <IDENTIFIER> { ret = new QualifiedNameExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, token.image); } )*
+  { return ret; }
+}
+
+List NameList():
+{
+	List ret = new LinkedList();
+	NameExpr name;
+}
+{
+  name = Name() { ret.add(name); }  ( "," name = Name() { ret.add(name); } )*
+
+  { return ret; }
+}
+
+
+/*
+ * Expression syntax follows.
+ */
+
+Expression Expression():
+/*
+ * This expansion has been written this way instead of:
+ *   Assignment() | ConditionalExpression()
+ * for performance reasons.
+ * However, it is a weakening of the grammar for it allows the LHS of
+ * assignments to be any conditional expression whereas it can only be
+ * a primary expression.  Consider adding a semantic predicate to work
+ * around this.
+ */
+{
+	Expression ret;
+	AssignExpr.Operator op;
+	Expression value;
+}
+{
+  ret = ConditionalExpression()
+  [
+    LOOKAHEAD(2)
+    op = AssignmentOperator() value = Expression() { ret = new AssignExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, value, op); }
+  ]
+  { return ret; }
+}
+
+AssignExpr.Operator AssignmentOperator():
+{
+	AssignExpr.Operator ret;
+}
+{
+  (
+      "="    { ret = AssignExpr.Operator.assign; }
+    | "*="   { ret = AssignExpr.Operator.star; }
+    | "/="   { ret = AssignExpr.Operator.slash; }
+    | "%="   { ret = AssignExpr.Operator.rem; }
+    | "+="   { ret = AssignExpr.Operator.plus; }
+    | "-="   { ret = AssignExpr.Operator.minus; }
+    | "<<="  { ret = AssignExpr.Operator.lShift; }
+    | ">>="  { ret = AssignExpr.Operator.rSignedShift; }
+    | ">>>=" { ret = AssignExpr.Operator.rUnsignedShift; }
+    | "&="   { ret = AssignExpr.Operator.and; }
+    | "^="   { ret = AssignExpr.Operator.xor; }
+    | "|="   { ret = AssignExpr.Operator.or; }
+  )
+  { return ret; }
+}
+
+Expression ConditionalExpression():
+{
+	Expression ret;
+	Expression left;
+	Expression right;
+}
+{
+  ret = ConditionalOrExpression()
+  [ "?" left = Expression() ":" right = ConditionalExpression() { ret = new ConditionalExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, left, right); } ]
+  { return ret; }
+}
+
+Expression ConditionalOrExpression():
+{
+	Expression ret;
+	Expression right;
+}
+{
+  ret = ConditionalAndExpression() ( "||" right = ConditionalAndExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.or); } )*
+  { return ret; }
+}
+
+Expression ConditionalAndExpression():
+{
+	Expression ret;
+	Expression right;
+}
+{
+  ret = InclusiveOrExpression() ( "&&" right = InclusiveOrExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.and); } )*
+  { return ret; }
+}
+
+Expression InclusiveOrExpression():
+{
+	Expression ret;
+	Expression right;
+}
+{
+  ret = ExclusiveOrExpression() ( "|" right = ExclusiveOrExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.binOr); } )*
+  { return ret; }
+}
+
+Expression ExclusiveOrExpression():
+{
+	Expression ret;
+	Expression right;
+}
+{
+  ret = AndExpression() ( "^" right = AndExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.xor); } )*
+  { return ret; }
+}
+
+Expression AndExpression():
+{
+	Expression ret;
+	Expression right;
+}
+{
+  ret = EqualityExpression() ( "&" right = EqualityExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, BinaryExpr.Operator.binAnd); } )*
+  { return ret; }
+}
+
+Expression EqualityExpression():
+{
+	Expression ret;
+	Expression right;
+	BinaryExpr.Operator op;
+}
+{
+  ret = InstanceOfExpression()
+  (
+    ( "==" { op = BinaryExpr.Operator.equals; } |
+      "!=" { op = BinaryExpr.Operator.notEquals; }
+    ) right = InstanceOfExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op); }
+  )*
+  { return ret; }
+}
+
+Expression InstanceOfExpression():
+{
+	Expression ret;
+	Type type;
+}
+{
+  ret = RelationalExpression() [ "instanceof" type = Type() { ret = new InstanceOfExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, type); } ]
+  { return ret; }
+}
+
+Expression RelationalExpression():
+{
+	Expression ret;
+	Expression right;
+	BinaryExpr.Operator op;
+}
+{
+  ret = ShiftExpression()
+  (
+  	( "<"  { op = BinaryExpr.Operator.less; } |
+  	  ">"  { op = BinaryExpr.Operator.greater; } |
+  	  "<=" { op = BinaryExpr.Operator.lessEquals; } |
+  	  ">=" { op = BinaryExpr.Operator.greaterEquals; }
+  	) right = ShiftExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op); }
+  )*
+  { return ret; }
+}
+
+Expression ShiftExpression():
+{
+	Expression ret;
+	Expression right;
+	BinaryExpr.Operator op;
+}
+{
+  ret = AdditiveExpression()
+  (
+  	( "<<"             { op = BinaryExpr.Operator.lShift; } |
+  	  RSIGNEDSHIFT()   { op = BinaryExpr.Operator.rSignedShift; } |
+  	  RUNSIGNEDSHIFT() { op = BinaryExpr.Operator.rUnsignedShift; }
+  	) right = AdditiveExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op); }
+  )*
+  { return ret; }
+}
+
+Expression AdditiveExpression():
+{
+	Expression ret;
+	Expression right;
+	BinaryExpr.Operator op;
+}
+{
+  ret = MultiplicativeExpression()
+  (
+  	( "+" { op = BinaryExpr.Operator.plus; } |
+  	  "-" { op = BinaryExpr.Operator.minus; }
+  	) right = MultiplicativeExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op); }
+  )*
+  { return ret; }
+}
+
+Expression MultiplicativeExpression():
+{
+	Expression ret;
+	Expression right;
+	BinaryExpr.Operator op;
+}
+{
+  ret = UnaryExpression()
+  (
+  	( "*" { op = BinaryExpr.Operator.times; } |
+  	  "/" { op = BinaryExpr.Operator.divide; } |
+  	  "%" { op = BinaryExpr.Operator.remainder; }
+  	) right = UnaryExpression() { ret = new BinaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, right, op); }
+  )*
+  { return ret; }
+}
+
+Expression UnaryExpression():
+{
+	Expression ret;
+	UnaryExpr.Operator op;
+	int line = 0;
+	int column = 0;
+}
+{
+  (
+	  ret = PreIncrementExpression()
+	|
+	  ret = PreDecrementExpression()
+	|
+	  ( "+" { op = UnaryExpr.Operator.positive; line=token.beginLine; column=token.beginColumn;} |
+	    "-" { op = UnaryExpr.Operator.negative; line=token.beginLine; column=token.beginColumn;}
+	  ) ret = UnaryExpression()
+	  {
+	  	 if(op == UnaryExpr.Operator.negative) {
+	  	 	if (ret instanceof IntegerLiteralExpr && ((IntegerLiteralExpr)ret).isMinValue()) {
+	  	 		ret = new IntegerLiteralMinValueExpr(line, column, token.endLine, token.endColumn);
+	  	 	} else if (ret instanceof LongLiteralExpr && ((LongLiteralExpr)ret).isMinValue()) {
+	  	 		ret = new LongLiteralMinValueExpr(line, column, token.endLine, token.endColumn);
+	  	 	} else {
+	  	 		ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, op);
+	  	 	}
+	  	 } else {
+	  	 	ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, op);
+	  	 }
+	  }
+	|
+	  ret = UnaryExpressionNotPlusMinus()
+  )
+  { return ret; }
+}
+
+Expression PreIncrementExpression():
+{
+	Expression ret;
+	int line;
+	int column;
+}
+{
+  "++" {line=token.beginLine; column=token.beginColumn;} ret = UnaryExpression() { ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, UnaryExpr.Operator.preIncrement); }
+  { return ret; }
+}
+
+Expression PreDecrementExpression():
+{
+	Expression ret;
+	int line;
+	int column;
+}
+{
+  "--" {line=token.beginLine; column=token.beginColumn;} ret = UnaryExpression() { ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, UnaryExpr.Operator.preDecrement); }
+  { return ret; }
+}
+
+Expression UnaryExpressionNotPlusMinus():
+{
+	Expression ret;
+	UnaryExpr.Operator op;
+	int line = 0;
+	int column = 0;
+}
+{
+  (
+	  ( "~" { op = UnaryExpr.Operator.inverse; line=token.beginLine; column=token.beginColumn;} |
+	    "!" { op = UnaryExpr.Operator.not;     line=token.beginLine; column=token.beginColumn;}
+	  ) ret = UnaryExpression() { ret = new UnaryExpr(line, column, token.endLine, token.endColumn,ret, op); }
+	|
+	  LOOKAHEAD( CastExpression() )
+	  ret = CastExpression()
+	|
+      ret = PostfixExpression()
+  )
+  { return ret; }
+}
+
+Expression PostfixExpression():
+{
+	Expression ret;
+	UnaryExpr.Operator op;
+}
+{
+  ret = PrimaryExpression()
+  [
+  	LOOKAHEAD(2)
+    ( "++" { op = UnaryExpr.Operator.posIncrement; } |
+      "--" { op = UnaryExpr.Operator.posDecrement; }
+    ) { ret = new UnaryExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, op); }
+  ]
+  { return ret; }
+}
+
+Expression CastExpression():
+{
+	Expression ret;
+	Type type;
+	int line;
+	int column;
+}
+{
+  "(" {line=token.beginLine; column=token.beginColumn;} 
+  (
+  	  LOOKAHEAD(2)
+  	  type = PrimitiveType() ")" ret = UnaryExpression() { ret = new CastExpr(line, column, token.endLine, token.endColumn,type, ret); }
+  	|
+  	  type = ReferenceType() ")" ret = UnaryExpressionNotPlusMinus() { ret = new CastExpr(line, column, token.endLine, token.endColumn,type, ret); }
+  )
+  { return ret; }
+}
+
+Expression PrimaryExpression():
+{
+	Expression ret;
+	Expression inner;
+}
+{
+  ret = PrimaryPrefix() ( LOOKAHEAD(2) ret = PrimarySuffix(ret) )*
+  { return ret; }
+}
+
+Expression PrimaryExpressionWithoutSuperSuffix():
+{
+	Expression ret;
+	Expression inner;
+}
+{
+  ret = PrimaryPrefix() ( LOOKAHEAD( PrimarySuffixWithoutSuper(null) ) ret = PrimarySuffixWithoutSuper(ret) )*
+  { return ret; }
+}
+
+Expression PrimaryPrefix():
+{
+	Expression ret;
+	String name;
+	List typeArgs = null;
+	List args = null;
+	boolean hasArgs = false;
+	Type type;
+	int line;
+	int column;
+}
+{
+  (
+	  ret = Literal()
+	|
+	  "this" { ret = new ThisExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, null); }
+	|
+	  "super" { ret = new SuperExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, null); }
+	  "."
+	  [ typeArgs = TypeArguments() {typeArgs.remove(0);} ]
+	  <IDENTIFIER> { name = token.image; }
+	  [ args = Arguments() {hasArgs=true;} ]
+	  	{
+	  		ret = hasArgs
+	  			? new MethodCallExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, typeArgs, name, args)
+	  			: new FieldAccessExpr(ret.getBeginLine(), ret.getBeginColumn(), token.endLine, token.endColumn, ret, null, name);
+	  	}
+	|
+	  "(" {line=token.beginLine; column=token.beginColumn;} ret = Expression() ")" { ret = new EnclosedExpr(line, column, token.endLine, token.endColumn,ret); }
+	|
+	  ret = AllocationExpression(null)
+	|
+	  LOOKAHEAD( ResultType() "." "class" )
+	  type = ResultType() "." "class" { ret = new ClassExpr(type.getBeginLine(), type.getBeginColumn(), token.endLine, token.endColumn, type); }
+	|
+	  	<IDENTIFIER> { name = token.image; line=token.beginLine; column=token.beginColumn; }
+	  	[ args = Arguments() {hasArgs=true;} ]
+	  	{
+	  		ret = hasArgs
+	  			? new MethodCallExpr(line, column, token.endLine, token.endColumn, null, null, name, args)
+	  			: new NameExpr(line, column, token.endLine, token.endColumn, name);
+	  	}
+  )
+  { return ret; }
+}
+
+Expression PrimarySuffix(Expression scope):
+{
+	Expression ret;
+}
+{
+  (
+  	LOOKAHEAD(2)
+	ret = PrimarySuffixWithoutSuper(scope)
+	|
+  	"." "super" { ret = new SuperExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope); }
+  )
+  { return ret; }
+}
+
+Expression PrimarySuffixWithoutSuper(Expression scope):
+{
+	Expression ret;
+	List typeArgs = null;
+	List args = null;
+	boolean hasArgs = false;
+	String name;
+}
+{
+  (
+  	"."
+  	(
+  	// TODO: est deixando passar "this.this", verificar na JLS se  possvel
+		"this" { ret = new ThisExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope); }
+	  |
+	  	ret = AllocationExpression(scope)
+	  |
+	  	LOOKAHEAD( [ TypeArguments() ] <IDENTIFIER> )
+	  	[ typeArgs = TypeArguments() {typeArgs.remove(0);} ]
+	  	<IDENTIFIER> { name = token.image; }
+	  	[ args = Arguments() {hasArgs=true;} ]
+	  	{
+	  		ret = hasArgs
+	  			? new MethodCallExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope, typeArgs, name, args)
+	  			: new FieldAccessExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope, typeArgs, name);
+	  	}
+	)
+	|
+	  "["ret = Expression() "]" { ret = new ArrayAccessExpr(scope.getBeginLine(), scope.getBeginColumn(), token.endLine, token.endColumn, scope, ret); }
+  )
+  { return ret; }
+}
+
+Expression Literal():
+{
+	Expression ret;
+}
+{
+  (
+	  <INTEGER_LITERAL> {
+	  		ret = new IntegerLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);
+	  }
+	|
+	  <LONG_LITERAL> {
+	  		ret = new LongLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);
+	  }
+	|
+	  <FLOATING_POINT_LITERAL> {
+	  		ret = new DoubleLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image);
+	  }
+	|
+	  <CHARACTER_LITERAL> {
+	  	ret = new CharLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image.substring(1, token.image.length()-1));
+	  }
+	|
+	  <STRING_LITERAL> {
+	  	ret = new StringLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, token.image.substring(1, token.image.length()-1));
+	  }
+	|
+	  ret = BooleanLiteral()
+	|
+	  ret = NullLiteral()
+  )
+  { return ret; }
+}
+
+Expression BooleanLiteral():
+{
+	Expression ret;
+}
+{
+  (
+	  "true" { ret = new BooleanLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, true); }
+	|
+	  "false" { ret = new BooleanLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn, false); }
+  )
+  { return ret; }
+}
+
+Expression NullLiteral():
+{}
+{
+  "null"
+  { return new NullLiteralExpr(token.beginLine, token.beginColumn, token.endLine, token.endColumn); }
+}
+
+List Arguments():
+{
+	List ret = null;
+}
+{
+  "(" [ ret = ArgumentList() ] ")"
+  { return ret; }
+}
+
+List ArgumentList():
+{
+	List ret = new LinkedList();
+	Expression expr;
+}
+{
+  expr = Expression() { ret.add(expr); } ( "," expr = Expression() { ret.add(expr); } )*
+  { return ret; }
+}
+
+Expression AllocationExpression(Expression scope):
+{
+	Expression ret;
+	Type type;
+	Object[] arr = null;
+	List typeArgs = null;
+	List anonymousBody = null;
+	List args;
+	int line;
+	int column;
+}
+{
+  "new" { if(scope==null) {line=token.beginLine; column=token.beginColumn;} else {line=scope.getBeginLine(); column=scope.getBeginColumn();} }
+  (
+	  type = PrimitiveType()
+	  arr = ArrayDimsAndInits()
+	  {
+	  	if (arr[0] instanceof Integer) {
+		  	ret = new ArrayCreationExpr(line, column, token.endLine, token.endColumn, type, ((Integer)arr[0]).intValue(), (ArrayInitializerExpr)arr[1]);
+	  	} else {
+		  	ret = new ArrayCreationExpr(line, column, token.endLine, token.endColumn, type, (List)arr[0], ((Integer)arr[1]).intValue());
+	  	}
+	  }
+	|
+  	  LOOKAHEAD(ClassOrInterfaceType() ArrayDimsAndInits())
+	  type = ClassOrInterfaceType()
+      arr = ArrayDimsAndInits()
+	  {
+	  	if (arr[0] instanceof Integer) {
+		  	ret = new ArrayCreationExpr(line, column, token.endLine, token.endColumn, type, ((Integer)arr[0]).intValue(), (ArrayInitializerExpr)arr[1]);
+	  	} else {
+		  	ret = new ArrayCreationExpr(line, column, token.endLine, token.endColumn, type, (List)arr[0], ((Integer)arr[1]).intValue());
+	  	}
+	  }
+    |
+  	  [ typeArgs = TypeArguments() {typeArgs.remove(0);} ]
+  	  type = ClassOrInterfaceType()
+      args = Arguments() [ LOOKAHEAD(2) anonymousBody = ClassOrInterfaceBody(false) ]
+      { ret = new ObjectCreationExpr(line, column, token.endLine, token.endColumn, scope, (ClassOrInterfaceType) type, typeArgs, args, anonymousBody); }
+  )
+  { return ret; }
+}
+
+/*
+ * The third LOOKAHEAD specification below is to parse to PrimarySuffix
+ * if there is an expression between the "[...]".
+ */
+Object[] ArrayDimsAndInits():
+{
+	Object[] ret = new Object[2];
+	Expression expr;
+	List inits = null;
+	int i = 0;
+}
+{
+  (
+	  LOOKAHEAD(2)
+	  ( LOOKAHEAD(2) "[" expr = Expression() { inits = add(inits, expr); } "]" )+ ( LOOKAHEAD(2) "[" "]" { i++; } )* { ret[0] = inits; ret[1] = new Integer(i); }
+	|
+	  ( "[" "]" { i++; } )+ expr = ArrayInitializer() { ret[0] = new Integer(i); ret[1] = expr; }
+  )
+  { return ret; }
+}
+
+
+/*
+ * Statement syntax follows.
+ */
+
+Statement Statement():
+{
+	Statement ret;
+}
+{
+  (
+	  LOOKAHEAD(2)
+	  ret = LabeledStatement()
+	|
+	  ret = AssertStatement()
+	|
+	  ret = Block()
+	|
+	  ret = EmptyStatement()
+	|
+	  ret = StatementExpression()
+	|
+	  ret = SwitchStatement()
+	|
+	  ret = IfStatement()
+	|
+	  ret = WhileStatement()
+	|
+	  ret = DoStatement()
+	|
+	  ret = ForStatement()
+	|
+	  ret = BreakStatement()
+	|
+	  ret = ContinueStatement()
+	|
+	  ret = ReturnStatement()
+	|
+	  ret = ThrowStatement()
+	|
+	  ret = SynchronizedStatement()
+	|
+	  ret = TryStatement()
+  )
+  { return ret; }
+}
+
+AssertStmt AssertStatement():
+{
+	Expression check;
+	Expression msg = null;
+	int line;
+	int column;
+}
+{
+  "assert" {line=token.beginLine; column=token.beginColumn;} check = Expression() [ ":" msg = Expression() ] ";"
+  { return new AssertStmt(line, column, token.endLine, token.endColumn,check, msg);  }
+}
+
+LabeledStmt LabeledStatement():
+{
+	String label;
+	Statement stmt;
+	int line;
+	int column;
+}
+{
+  <IDENTIFIER> {line=token.beginLine; column=token.beginColumn;} { label = token.image; } ":" stmt = Statement()
+  { return new LabeledStmt(line, column, token.endLine, token.endColumn,label, stmt); }
+}
+
+BlockStmt Block():
+{
+	List stmts;
+	int beginLine;
+	int beginColumn;
+}
+{
+  "{" {beginLine=token.beginLine; beginColumn=token.beginColumn;}
+  	stmts = Statements()
+  "}"
+  { return new BlockStmt(beginLine, beginColumn, token.endLine, token.endColumn, stmts); }
+}
+
+/*
+ * Classes inside block stametents can only be abstract or final. The semantic must check it.
+ */
+Statement BlockStatement():
+{
+	Statement ret;
+	Expression expr;
+	ClassOrInterfaceDeclaration typeDecl;
+	Modifier modifier;
+}
+{
+  (
+	  LOOKAHEAD( Modifiers() ("class" | "interface") )
+  	  { pushJavadoc(); }
+	  modifier = Modifiers()
+	  typeDecl = ClassOrInterfaceDeclaration(modifier) { ret = new TypeDeclarationStmt(typeDecl.getBeginLine(), typeDecl.getBeginColumn(), token.endLine, token.endColumn, typeDecl); }
+	|
+  	  LOOKAHEAD(VariableDeclarationExpression() )
+	  expr = VariableDeclarationExpression() ";"
+	  { ret = new ExpressionStmt(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr); } 
+    |
+	  ret = Statement()
+  )
+  { return ret; }
+}
+
+VariableDeclarationExpr VariableDeclarationExpression():
+{
+	Modifier modifier;
+	Type type;
+	List vars = new LinkedList();
+	VariableDeclarator var;
+}
+{
+  modifier = Modifiers() type = Type() var = VariableDeclarator() { vars.add(var); } ( "," var = VariableDeclarator() { vars.add(var); } )*
+  {
+    int line = modifier.beginLine;
+    int column = modifier.beginColumn;
+    if(line==-1) {line=type.getBeginLine(); column=type.getBeginColumn(); }
+    return new VariableDeclarationExpr(line, column, token.endLine, token.endColumn, modifier.modifiers, modifier.annotations, type, vars);
+  }
+}
+
+EmptyStmt EmptyStatement():
+{}
+{
+  ";"
+  { return new EmptyStmt(token.beginLine, token.beginColumn, token.endLine, token.endColumn); }
+}
+
+ExpressionStmt StatementExpression():
+/*
+ * The last expansion of this production accepts more than the legal
+ * Java expansions for StatementExpression.  This expansion does not
+ * use PostfixExpression for performance reasons.
+ */
+{
+	Expression expr;
+	AssignExpr.Operator op;
+	Expression value;
+}
+{
+  (
+	  expr = PreIncrementExpression()
+	|
+	  expr = PreDecrementExpression()
+	|
+	  expr = PrimaryExpression()
+	  [
+	    "++" { expr = new UnaryExpr(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr, UnaryExpr.Operator.posIncrement);  }
+	  |
+	    "--" { expr = new UnaryExpr(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr, UnaryExpr.Operator.posDecrement);  }
+	  |
+	    op = AssignmentOperator() value = Expression() { expr = new AssignExpr(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr, value, op); }
+	  ]
+  )
+  ";"
+  { return new ExpressionStmt(expr.getBeginLine(), expr.getBeginColumn(), token.endLine, token.endColumn, expr); }
+}
+
+SwitchStmt SwitchStatement():
+{
+	Expression selector;
+	SwitchEntryStmt entry;
+	List entries = null;
+	int line;
+	int column;
+}
+{
+  "switch" {line=token.beginLine; column=token.beginColumn;} "(" selector = Expression() ")" "{"
+    ( entry = SwitchEntry() { entries = add(entries, entry); } )*
+  "}"
+
+  { return new SwitchStmt(line, column, token.endLine, token.endColumn,selector, entries); }
+}
+
+SwitchEntryStmt SwitchEntry():
+{
+	Expression label = null;
+	List stmts;
+	int line;
+	int column;
+}
+{
+  (
+	  "case" {line=token.beginLine; column=token.beginColumn;} label = Expression()
+	|
+	  "default" {line=token.beginLine; column=token.beginColumn;}
+  )
+  ":" stmts = Statements()
+
+  { return new SwitchEntryStmt(line, column, token.endLine, token.endColumn,label, stmts); }
+}
+
+IfStmt IfStatement():
+/*
+ * The disambiguating algorithm of JavaCC automatically binds dangling
+ * else's to the innermost if statement.  The LOOKAHEAD specification
+ * is to tell JavaCC that we know what we are doing.
+ */
+{
+	Expression condition;
+	Statement thenStmt;
+	Statement elseStmt = null;
+	int line;
+	int column;
+}
+{
+  "if" {line=token.beginLine; column=token.beginColumn;} "(" condition = Expression() ")" thenStmt = Statement() [ LOOKAHEAD(1) "else" elseStmt = Statement() ]
+  { return new IfStmt(line, column, token.endLine, token.endColumn,condition, thenStmt, elseStmt); }
+}
+
+WhileStmt WhileStatement():
+{
+	Expression condition;
+	Statement body;
+	int line;
+	int column;
+}
+{
+  "while" {line=token.beginLine; column=token.beginColumn;} "(" condition = Expression() ")" body = Statement()
+  { return new WhileStmt(line, column, token.endLine, token.endColumn,condition, body); }
+}
+
+DoStmt DoStatement():
+{
+	Expression condition;
+	Statement body;
+	int line;
+	int column;
+}
+{
+  "do" {line=token.beginLine; column=token.beginColumn;} body = Statement() "while" "(" condition = Expression() ")" ";"
+  { return new DoStmt(line, column, token.endLine, token.endColumn,body, condition); }
+}
+
+Statement ForStatement():
+{
+	String id = null;
+	VariableDeclarationExpr varExpr = null;
+	Expression expr = null;
+	List init = null;
+	List update = null;
+	Statement body;
+	int line;
+	int column;
+}
+{
+  "for" {line=token.beginLine; column=token.beginColumn;} "("
+
+  (
+      LOOKAHEAD(VariableDeclarationExpression() ":")
+      varExpr = VariableDeclarationExpression() ":" expr = Expression()
+    |
+     [ init = ForInit() ] ";" [ expr = Expression() ] ";" [ update = ForUpdate() ]
+  )
+
+  ")" body = Statement()
+
+  {
+  	if (varExpr != null) {
+  		return new ForeachStmt(line, column, token.endLine, token.endColumn,varExpr, expr, body);
+  	}
+	return new ForStmt(line, column, token.endLine, token.endColumn,init, expr, update, body);
+  }
+}
+
+List ForInit():
+{
+	List ret;
+	Expression expr;
+}
+{
+  (
+	  LOOKAHEAD( Modifiers() Type() <IDENTIFIER> )
+	  expr = VariableDeclarationExpression() { ret = new LinkedList(); ret.add(expr); }
+	|
+	  ret = ExpressionList()
+  )
+  { return ret; }
+}
+
+List ExpressionList():
+{
+	List ret = new LinkedList();
+	Expression expr;
+}
+{
+  expr = Expression() { ret.add(expr); } ( "," expr = Expression()  { ret.add(expr); } )*
+
+  { return ret; }
+}
+
+List ForUpdate():
+{
+	List ret;
+}
+{
+  ret = ExpressionList()
+
+  { return ret; }
+}
+
+BreakStmt BreakStatement():
+{
+	String id = null;
+	int line;
+	int column;
+}
+{
+  "break" {line=token.beginLine; column=token.beginColumn;} [ <IDENTIFIER> { id = token.image; } ] ";"
+  { return new BreakStmt(line, column, token.endLine, token.endColumn,id); }
+}
+
+ContinueStmt ContinueStatement():
+{
+	String id = null;
+	int line;
+	int column;
+}
+{
+  "continue" {line=token.beginLine; column=token.beginColumn;} [ <IDENTIFIER> { id = token.image; } ] ";"
+  { return new ContinueStmt(line, column, token.endLine, token.endColumn,id); }
+}
+
+ReturnStmt ReturnStatement():
+{
+	Expression expr = null;
+	int line;
+	int column;
+}
+{
+  "return" {line=token.beginLine; column=token.beginColumn;} [ expr = Expression() ] ";"
+  { return new ReturnStmt(line, column, token.endLine, token.endColumn,expr); }
+}
+
+ThrowStmt ThrowStatement():
+{
+	Expression expr;
+	int line;
+	int column;
+}
+{
+  "throw" {line=token.beginLine; column=token.beginColumn;} expr = Expression() ";"
+  { return new ThrowStmt(line, column, token.endLine, token.endColumn,expr); }
+}
+
+SynchronizedStmt SynchronizedStatement():
+{
+	Expression expr;
+	BlockStmt block;
+	int line;
+	int column;
+}
+{
+  "synchronized" {line=token.beginLine; column=token.beginColumn;} "(" expr = Expression() ")" block = Block()
+  { return new SynchronizedStmt(line, column, token.endLine, token.endColumn,expr, block); }
+}
+
+TryStmt TryStatement():
+/*
+ * Semantic check required here to make sure that at least one
+ * finally/catch is present.
+ */
+{
+	BlockStmt tryBlock;
+	BlockStmt finallyBlock = null;
+	List catchs = null;
+	Parameter except;
+	BlockStmt catchBlock;
+	int line;
+	int column;
+	int cLine;
+	int cColumn;
+}
+{
+  "try" {line=token.beginLine; column=token.beginColumn;} tryBlock = Block()
+  (
+  		(
+  			"catch" {cLine=token.beginLine; cColumn=token.beginColumn;}
+  			"(" except = FormalParameter() ")" catchBlock = Block()
+  			{ catchs = add(catchs, new CatchClause(cLine, cColumn, token.endLine, token.endColumn, except, catchBlock)); }
+  		)+
+  		[ "finally" finallyBlock = Block() ]
+  	|
+  		"finally" finallyBlock = Block()
+  )
+  { return new TryStmt(line, column, token.endLine, token.endColumn,tryBlock, catchs, finallyBlock); }
+}
+
+
+
+/* We use productions to match >>>, >> and > so that we can keep the
+ * type declaration syntax with generics clean
+ */
+
+void RUNSIGNEDSHIFT():
+{}
+{
+  ( LOOKAHEAD({ getToken(1).kind == GT &&
+                ((GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT} )
+   ">" ">" ">"
+  )
+}
+
+void RSIGNEDSHIFT():
+{}
+{
+  ( LOOKAHEAD({ getToken(1).kind == GT &&
+                ((GTToken)getToken(1)).realKind == RSIGNEDSHIFT} )
+  ">" ">"
+  )
+}
+
+/* Annotation syntax follows. */
+
+AnnotationExpr Annotation():
+{
+	AnnotationExpr ret;
+}
+{
+  (
+	   LOOKAHEAD( "@" Name() "(" ( <IDENTIFIER> "=" | ")" ))
+	   ret = NormalAnnotation()
+	 |
+	   LOOKAHEAD( "@" Name() "(" )
+	   ret = SingleMemberAnnotation()
+	 |
+	   ret = MarkerAnnotation()
+  )
+  { return ret; }
+}
+
+NormalAnnotationExpr NormalAnnotation():
+{
+	NameExpr name;
+	List pairs = null;
+	int line;
+	int column;
+}
+{
+   "@" {line=token.beginLine; column=token.beginColumn;} name = Name() "(" [ pairs = MemberValuePairs() ] ")"
+   { return new NormalAnnotationExpr(line, column, token.endLine, token.endColumn,name, pairs); }
+}
+
+MarkerAnnotationExpr MarkerAnnotation():
+{
+	NameExpr name;
+	int line;
+	int column;
+}
+{
+  "@" {line=token.beginLine; column=token.beginColumn;} name = Name()
+  { return new MarkerAnnotationExpr(line, column, token.endLine, token.endColumn,name); }
+}
+
+SingleMemberAnnotationExpr SingleMemberAnnotation():
+{
+	NameExpr name;
+	Expression memberVal;
+	int line;
+	int column;
+}
+{
+  "@" {line=token.beginLine; column=token.beginColumn;} name = Name() "(" memberVal = MemberValue() ")"
+  { return new SingleMemberAnnotationExpr(line, column, token.endLine, token.endColumn,name, memberVal); }
+}
+
+List MemberValuePairs():
+{
+	List ret = new LinkedList();
+	MemberValuePair pair;
+}
+{
+   pair = MemberValuePair() { ret.add(pair); } ( "," pair = MemberValuePair() { ret.add(pair); } )*
+   { return ret; }
+}
+
+MemberValuePair MemberValuePair():
+{
+	String name;
+	Expression value;
+	int line;
+	int column;
+}
+{
+    <IDENTIFIER> { name = token.image; line=token.beginLine; column=token.beginColumn;} "=" value = MemberValue()
+    { return new MemberValuePair(line, column, token.endLine, token.endColumn,name, value); }
+}
+
+Expression MemberValue():
+{
+	Expression ret;
+}
+{
+  (
+	   ret = Annotation()
+	 |
+	   ret = MemberValueArrayInitializer()
+	 |
+	   ret = ConditionalExpression()
+  )
+  { return ret; }
+}
+
+Expression  MemberValueArrayInitializer():
+{
+	List ret = new LinkedList();
+	Expression member;
+	int line;
+	int column;
+}
+{
+  "{" {line=token.beginLine; column=token.beginColumn;}
+  (	member = MemberValue() { ret.add(member); } ( LOOKAHEAD(2) "," member = MemberValue() { ret.add(member); } )*  )? [ "," ]
+  "}"
+  { return new ArrayInitializerExpr(line, column, token.endLine, token.endColumn,ret); }
+}
+
+
+/* Annotation Types. */
+
+AnnotationDeclaration AnnotationTypeDeclaration(Modifier modifier):
+{
+	String name;
+	List members;
+	int line = modifier.beginLine;
+	int column = modifier.beginColumn;
+}
+{
+  "@" { if (line == -1) {line=token.beginLine; column=token.beginColumn;} }
+  "interface" <IDENTIFIER> { name = token.image; } members = AnnotationTypeBody()
+
+  { return new AnnotationDeclaration(line, column, token.endLine, token.endColumn,popJavadoc(), modifier.modifiers, modifier.annotations, name, members); }
+}
+
+List AnnotationTypeBody():
+{
+	List ret = null;
+	BodyDeclaration member;
+}
+{
+  "{" ( member = AnnotationBodyDeclaration() { ret = add(ret, member); } )* "}"
+
+  { return ret; }
+}
+
+BodyDeclaration AnnotationBodyDeclaration():
+{
+   Modifier modifier;
+   BodyDeclaration ret;
+}
+{
+  { pushJavadoc(); }
+  (
+	";" { ret = new EmptyTypeDeclaration(token.beginLine, token.beginColumn, token.endLine, token.endColumn, popJavadoc()); }
+  |
+    modifier = Modifiers()
+    (
+	   LOOKAHEAD(Type() <IDENTIFIER> "(")
+	   ret = AnnotationTypeMemberDeclaration(modifier)
+	  |
+	   ret = ClassOrInterfaceDeclaration(modifier)
+	  |
+	   ret = EnumDeclaration(modifier)
+	  |
+	   ret = AnnotationTypeDeclaration(modifier)
+	  |
+	   ret = FieldDeclaration(modifier)
+    )
+  )
+  { return ret; }
+}
+
+AnnotationMemberDeclaration AnnotationTypeMemberDeclaration(Modifier modifier):
+{
+	Type type;
+	String name;
+	Expression defaultVal = null;
+}
+{
+  type = Type() <IDENTIFIER> { name = token.image; } "(" ")" [ defaultVal = DefaultValue() ] ";"
+
+  {
+    int line = modifier.beginLine;
+    int column = modifier.beginColumn;
+    { if (line == -1) {line=type.getBeginLine(); column=type.getBeginColumn();} }
+    return new AnnotationMemberDeclaration(line, column, token.endLine, token.endColumn, popJavadoc(), modifier.modifiers, modifier.annotations, type, name, defaultVal); 
+  }
+}
+
+Expression DefaultValue():
+{
+	Expression ret;
+}
+{
+  "default" ret = MemberValue()
+  { return ret; }
+}
diff --git a/parser/html/java/translator/LICENSE.txt b/parser/html/java/translator/LICENSE.txt
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/LICENSE.txt
@@ -0,0 +1,85 @@
+This is for the HTML parser as a whole except the rewindable input stream,
+and the Live DOM Viewer. 
+For the copyright notices for individual files, please see individual files.
+
+/*
+ * Copyright (c) 2005, 2006, 2007 Henri Sivonen
+ * Copyright (c) 2007-2009 Mozilla Foundation
+ * Portions of comments Copyright 2004-2007 Apple Computer, Inc., Mozilla 
+ * Foundation, and Opera Software ASA.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+ 
+The following license is for the rewindable input stream.
+
+/*
+ * Copyright (c) 2001-2003 Thai Open Source Software Center Ltd
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions 
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright 
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above 
+ *    copyright notice, this list of conditions and the following 
+ *    disclaimer in the documentation and/or other materials provided 
+ *    with the distribution.
+ *  * Neither the name of the Thai Open Source Software Center Ltd nor 
+ *    the names of its contributors may be used to endorse or promote 
+ *    products derived from this software without specific prior 
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
+ * REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+The following license applies to the Live DOM Viewer:
+
+Copyright (c) 2000, 2006, 2008 Ian Hickson and various contributors
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/parser/html/java/translator/Makefile b/parser/html/java/translator/Makefile
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/Makefile
@@ -0,0 +1,58 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Makefile.
+#
+# The Initial Developer of the Original Code is
+#   Ben Newman <b{enjam,newma}n@mozilla.com>
+#
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+SVN_BASE=http://svn.versiondude.net/whattf/htmlparser/trunk
+
+libs:: \
+; mkdir -p bin ; \
+  find src -name "*.java" | \
+    xargs javac -cp ../javaparser.jar -g -d bin && \
+  jar cfm translator.jar manifest.txt -C bin .
+
+sync:: \
+; rm -rf src && \
+  svn co $(SVN_BASE)/translator-src src && \
+  find src -name .svn | xargs rm -rf ; \
+  \
+  for file in LICENSE.txt README.txt ; \
+  do \
+    rm -f $$file ; \
+    svn cat $(SVN_BASE)/$$file > $$file ; \
+  done
+
+clean:: \
+; rm -rf bin translator.jar
diff --git a/parser/html/java/translator/README.txt b/parser/html/java/translator/README.txt
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/README.txt
@@ -0,0 +1,5 @@
+An HTML5 parser.
+
+Please see http://about.validator.nu/htmlparser/
+
+-- Henri Sivonen (hsivonen@iki.fi).
diff --git a/parser/html/java/translator/manifest.txt b/parser/html/java/translator/manifest.txt
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/manifest.txt
@@ -0,0 +1,2 @@
+Main-Class: nu.validator.htmlparser.cpptranslate.Main
+Class-Path: javaparser.jar
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/CppTypes.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/CppTypes.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/CppTypes.java
@@ -0,0 +1,309 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is HTML Parser C++ Translator code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008-2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Henri Sivonen <hsivonen@iki.fi>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+package nu.validator.htmlparser.cpptranslate;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+public class CppTypes {
+
+    private static Set<String> reservedWords = new HashSet<String>();
+
+    static {
+        reservedWords.add("small");
+        reservedWords.add("for");
+        reservedWords.add("false");
+        reservedWords.add("true");
+        reservedWords.add("default");
+        reservedWords.add("class");
+        reservedWords.add("switch");
+        reservedWords.add("union");
+        reservedWords.add("template");
+        reservedWords.add("int");
+        reservedWords.add("char");
+        reservedWords.add("operator");
+        reservedWords.add("or");
+        reservedWords.add("and");
+        reservedWords.add("not");
+        reservedWords.add("xor");
+        reservedWords.add("unicode");
+    }
+
+    private static final String[] TREE_BUILDER_INCLUDES = { "prtypes",
+            "nsIAtom", "nsITimer", "nsString", "nsINameSpaceManager", "nsIContent",
+            "nsIDocument", "nsTraceRefcnt", "jArray", "nsHtml5DocumentMode",
+            "nsHtml5ArrayCopy", "nsHtml5NamedCharacters", "nsHtml5Parser",
+            "nsHtml5Atoms", "nsHtml5ByteReadable", "nsHtml5TreeOperation",
+            "nsHtml5PendingNotification", "nsHtml5StateSnapshot", "nsHtml5StackNode" };
+
+    private static final String[] INCLUDES = { "prtypes", "nsIAtom",
+            "nsString", "nsINameSpaceManager", "nsIContent", "nsIDocument",
+            "nsTraceRefcnt", "jArray", "nsHtml5DocumentMode",
+            "nsHtml5ArrayCopy", "nsHtml5NamedCharacters",
+            "nsHtml5Atoms", "nsHtml5ByteReadable", };
+
+    private static final String[] OTHER_DECLATIONS = {};
+
+    private static final String[] TREE_BUILDER_OTHER_DECLATIONS = { "typedef nsIContent* nsIContentPtr;" };
+
+    private static final String[] NAMED_CHARACTERS_INCLUDES = { "prtypes",
+            "jArray", "nscore" };
+
+    private static final String[] FORWARD_DECLARATIONS = { "nsHtml5Parser", };
+    
+    private static final String[] CLASSES_THAT_NEED_SUPPLEMENT = {
+        "MetaScanner",
+        "StackNode",
+        "TreeBuilder",
+        "UTF16Buffer",
+    };
+    
+    private final Map<String, String> atomMap = new HashMap<String, String>();
+
+    private final Writer atomWriter;
+
+    public CppTypes(File atomList) {
+        if (atomList == null) {
+            atomWriter = null;
+        } else {
+            try {
+                atomWriter = new OutputStreamWriter(new FileOutputStream(
+                        atomList), "utf-8");
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+
+    public void finished() {
+        try {
+            if (atomWriter != null) {
+                atomWriter.flush();
+                atomWriter.close();
+            }
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public String classPrefix() {
+        return "nsHtml5";
+    }
+
+    public String booleanType() {
+        return "PRBool";
+    }
+
+    public String charType() {
+        return "PRUnichar";
+    }
+
+    public String intType() {
+        return "PRInt32";
+    }
+
+    public String stringType() {
+        return "nsString*";
+    }
+
+    public String localType() {
+        return "nsIAtom*";
+    }
+
+    public String prefixType() {
+        return "nsIAtom*";
+    }
+
+    public String nsUriType() {
+        return "PRInt32";
+    }
+
+    public String falseLiteral() {
+        return "PR_FALSE";
+    }
+
+    public String trueLiteral() {
+        return "PR_TRUE";
+    }
+
+    public String nullLiteral() {
+        return "nsnull";
+    }
+
+    public String encodingDeclarationHandlerType() {
+        return "nsHtml5Parser*";
+    }
+
+    public String nodeType() {
+        return "nsIContent*";
+    }
+
+    public String xhtmlNamespaceLiteral() {
+        return "kNameSpaceID_XHTML";
+    }
+
+    public String svgNamespaceLiteral() {
+        return "kNameSpaceID_SVG";
+    }
+
+    public String xmlnsNamespaceLiteral() {
+        return "kNameSpaceID_XMLNS";
+    }
+
+    public String xmlNamespaceLiteral() {
+        return "kNameSpaceID_XML";
+    }
+
+    public String noNamespaceLiteral() {
+        return "kNameSpaceID_None";
+    }
+
+    public String xlinkNamespaceLiteral() {
+        return "kNameSpaceID_XLink";
+    }
+
+    public String mathmlNamespaceLiteral() {
+        return "kNameSpaceID_MathML";
+    }
+
+    public String arrayTemplate() {
+        return "jArray";
+    }
+
+    public String localForLiteral(String literal) {
+        String atom = atomMap.get(literal);
+        if (atom == null) {
+            atom = createAtomName(literal);
+            atomMap.put(literal, atom);
+            if (atomWriter != null) {
+                try {
+                    atomWriter.write("HTML5_ATOM(" + atom + ", \"" + literal
+                            + "\")\n");
+                } catch (IOException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        }
+        return "nsHtml5Atoms::" + atom;
+    }
+
+    private String createAtomName(String literal) {
+        String candidate = literal.replaceAll("[^a-zA-Z0-9_]", "_");
+        if ("".equals(candidate)) {
+            candidate = "emptystring";
+        }
+        while (atomMap.values().contains(candidate)
+                || reservedWords.contains(candidate)) {
+            candidate = candidate + '_';
+        }
+        return candidate;
+    }
+
+    public String stringForLiteral(String literal) {
+        return '"' + literal + '"';
+    }
+
+    public String staticArrayMacro() {
+        return "J_ARRAY_STATIC";
+    }
+
+    public String[] boilerplateIncludes(String javaClass) {
+        if ("TreeBuilder".equals(javaClass)) {
+            return TREE_BUILDER_INCLUDES;
+        } else {
+            return INCLUDES;
+        }
+    }
+    
+    public String[] boilerplateDeclarations(String javaClass) {
+        if ("TreeBuilder".equals(javaClass)) {
+            return TREE_BUILDER_OTHER_DECLATIONS;
+        } else {
+            return OTHER_DECLATIONS;
+        }
+    }
+
+    public String[] namedCharactersIncludes() {
+        return NAMED_CHARACTERS_INCLUDES;
+    }
+
+    public String[] boilerplateForwardDeclarations() {
+        return FORWARD_DECLARATIONS;
+    }
+
+    public String documentModeHandlerType() {
+        return "nsHtml5Parser*";
+    }
+
+    public String documentModeType() {
+        return "nsHtml5DocumentMode";
+    }
+
+    public String arrayCopy() {
+        return "nsHtml5ArrayCopy::arraycopy";
+    }
+
+    public String maxInteger() {
+        return "PR_INT32_MAX";
+    }
+
+    public String constructorBoilerplate(String className) {
+        return "MOZ_COUNT_CTOR(" + className + ");";
+    }
+
+    public String destructorBoilderplate(String className) {
+        return "MOZ_COUNT_DTOR(" + className + ");";
+    }
+
+    public String literalType() {
+        return "const char*";
+    }
+    
+    public boolean hasSupplement(String javaClass) {
+        return Arrays.binarySearch(CLASSES_THAT_NEED_SUPPLEMENT, javaClass) > -1;
+    }
+
+}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/CppVisitor.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/CppVisitor.java
new file mode 100755
--- /dev/null
+++ b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/CppVisitor.java
@@ -0,0 +1,2169 @@
+/*
+ * Copyright (C) 2007 Jlio Vilmar Gesser.
+ * Copyright (C) 2008 Mozilla Foundation
+ * 
+ * This file is part of HTML Parser C++ Translator. It was derived from DumpVisitor
+ * which was part of Java 1.5 parser and Abstract Syntax Tree and came with the following notice:
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Java 1.5 parser and Abstract Syntax Tree is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Java 1.5 parser and Abstract Syntax Tree.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+ * Created on 05/10/2006
+ */
+package nu.validator.htmlparser.cpptranslate;
+
+import japa.parser.ast.BlockComment;
+import japa.parser.ast.CompilationUnit;
+import japa.parser.ast.ImportDeclaration;
+import japa.parser.ast.LineComment;
+import japa.parser.ast.Node;
+import japa.parser.ast.PackageDeclaration;
+import japa.parser.ast.TypeParameter;
+import japa.parser.ast.body.AnnotationDeclaration;
+import japa.parser.ast.body.AnnotationMemberDeclaration;
+import japa.parser.ast.body.BodyDeclaration;
+import japa.parser.ast.body.ClassOrInterfaceDeclaration;
+import japa.parser.ast.body.ConstructorDeclaration;
+import japa.parser.ast.body.EmptyMemberDeclaration;
+import japa.parser.ast.body.EmptyTypeDeclaration;
+import japa.parser.ast.body.EnumConstantDeclaration;
+import japa.parser.ast.body.EnumDeclaration;
+import japa.parser.ast.body.FieldDeclaration;
+import japa.parser.ast.body.InitializerDeclaration;
+import japa.parser.ast.body.JavadocComment;
+import japa.parser.ast.body.MethodDeclaration;
+import japa.parser.ast.body.ModifierSet;
+import japa.parser.ast.body.Parameter;
+import japa.parser.ast.body.TypeDeclaration;
+import japa.parser.ast.body.VariableDeclarator;
+import japa.parser.ast.body.VariableDeclaratorId;
+import japa.parser.ast.expr.AnnotationExpr;
+import japa.parser.ast.expr.ArrayAccessExpr;
+import japa.parser.ast.expr.ArrayCreationExpr;
+import japa.parser.ast.expr.ArrayInitializerExpr;
+import japa.parser.ast.expr.AssignExpr;
+import japa.parser.ast.expr.BinaryExpr;
+import japa.parser.ast.expr.BooleanLiteralExpr;
+import japa.parser.ast.expr.CastExpr;
+import japa.parser.ast.expr.CharLiteralExpr;
+import japa.parser.ast.expr.ClassExpr;
+import japa.parser.ast.expr.ConditionalExpr;
+import japa.parser.ast.expr.DoubleLiteralExpr;
+import japa.parser.ast.expr.EnclosedExpr;
+import japa.parser.ast.expr.Expression;
+import japa.parser.ast.expr.FieldAccessExpr;
+import japa.parser.ast.expr.InstanceOfExpr;
+import japa.parser.ast.expr.IntegerLiteralExpr;
+import japa.parser.ast.expr.IntegerLiteralMinValueExpr;
+import japa.parser.ast.expr.LongLiteralExpr;
+import japa.parser.ast.expr.LongLiteralMinValueExpr;
+import japa.parser.ast.expr.MarkerAnnotationExpr;
+import japa.parser.ast.expr.MemberValuePair;
+import japa.parser.ast.expr.MethodCallExpr;
+import japa.parser.ast.expr.NameExpr;
+import japa.parser.ast.expr.NormalAnnotationExpr;
+import japa.parser.ast.expr.NullLiteralExpr;
+import japa.parser.ast.expr.ObjectCreationExpr;
+import japa.parser.ast.expr.QualifiedNameExpr;
+import japa.parser.ast.expr.SingleMemberAnnotationExpr;
+import japa.parser.ast.expr.StringLiteralExpr;
+import japa.parser.ast.expr.SuperExpr;
+import japa.parser.ast.expr.ThisExpr;
+import japa.parser.ast.expr.UnaryExpr;
+import japa.parser.ast.expr.VariableDeclarationExpr;
+import japa.parser.ast.stmt.AssertStmt;
+import japa.parser.ast.stmt.BlockStmt;
+import japa.parser.ast.stmt.BreakStmt;
+import japa.parser.ast.stmt.CatchClause;
+import japa.parser.ast.stmt.ContinueStmt;
+import japa.parser.ast.stmt.DoStmt;
+import japa.parser.ast.stmt.EmptyStmt;
+import japa.parser.ast.stmt.ExplicitConstructorInvocationStmt;
+import japa.parser.ast.stmt.ExpressionStmt;
+import japa.parser.ast.stmt.ForStmt;
+import japa.parser.ast.stmt.ForeachStmt;
+import japa.parser.ast.stmt.IfStmt;
+import japa.parser.ast.stmt.LabeledStmt;
+import japa.parser.ast.stmt.ReturnStmt;
+import japa.parser.ast.stmt.Statement;
+import japa.parser.ast.stmt.SwitchEntryStmt;
+import japa.parser.ast.stmt.SwitchStmt;
+import japa.parser.ast.stmt.SynchronizedStmt;
+import japa.parser.ast.stmt.ThrowStmt;
+import japa.parser.ast.stmt.TryStmt;
+import japa.parser.ast.stmt.TypeDeclarationStmt;
+import japa.parser.ast.stmt.WhileStmt;
+import japa.parser.ast.type.ClassOrInterfaceType;
+import japa.parser.ast.type.PrimitiveType;
+import japa.parser.ast.type.ReferenceType;
+import japa.parser.ast.type.Type;
+import japa.parser.ast.type.VoidType;
+import japa.parser.ast.type.WildcardType;
+import japa.parser.ast.visitor.VoidVisitor;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * @author Julio Vilmar Gesser
+ * @author Henri Sivonen
+ */
+
+public class CppVisitor implements VoidVisitor<Object> {
+
+    private static final String[] CLASS_NAMES = { "AttributeName",
+            "ElementName", "HtmlAttributes", "LocatorImpl", "MetaScanner",
+            "NamedCharacters", "Portability", "StackNode", "Tokenizer",
+            "TreeBuilder", "UTF16Buffer" };
+
+    public class SourcePrinter {
+
+        private int level = 0;
+
+        private boolean indented = false;
+
+        private final StringBuilder buf = new StringBuilder();
+
+        public void indent() {
+            level++;
+        }
+
+        public void unindent() {
+            level--;
+        }
+
+        private void makeIndent() {
+            for (int i = 0; i < level; i++) {
+                buf.append("  ");
+            }
+        }
+
+        public void print(String arg) {
+            if (!indented) {
+                makeIndent();
+                indented = true;
+            }
+            buf.append(arg);
+        }
+
+        public void printLn(String arg) {
+            print(arg);
+            printLn();
+        }
+
+        public void printLn() {
+            buf.append("\n");
+            indented = false;
+        }
+
+        public String getSource() {
+            return buf.toString();
+        }
+
+        @Override public String toString() {
+            return getSource();
+        }
+    }
+
+    protected SourcePrinter printer = new SourcePrinter();
+
+    private SourcePrinter staticInitializerPrinter = new SourcePrinter();
+
+    private SourcePrinter tempPrinterHolder;
+
+    protected final CppTypes cppTypes;
+
+    protected String className = "";
+
+    protected List<AnnotationExpr> currentAnnotations;
+
+    protected int currentArrayCount;
+
+    protected Set<String> forLoopsWithCondition = new HashSet<String>();
+
+    protected boolean inPrimitiveNoLengthFieldDeclarator = false;
+
+    protected final SymbolTable symbolTable;
+
+    protected String definePrefix;
+
+    protected String javaClassName;
+
+    protected boolean suppressPointer = false;
+
+    private final List<String> staticReleases = new LinkedList<String>();
+
+    private boolean inConstructorBody = false;
+
+    private String currentMethod = null;
+
+    private Set<String> labels = null;
+
+    private boolean destructor;
+
+    /**
+     * @param cppTypes
+     */
+    public CppVisitor(CppTypes cppTypes, SymbolTable symbolTable) {
+        this.cppTypes = cppTypes;
+        this.symbolTable = symbolTable;
+        staticInitializerPrinter.indent();
+    }
+
+    public String getSource() {
+        return printer.getSource();
+    }
+
+    private String classNameFromExpression(Expression e) {
+        if (e instanceof NameExpr) {
+            NameExpr nameExpr = (NameExpr) e;
+            String name = nameExpr.getName();
+            if (Arrays.binarySearch(CLASS_NAMES, name) > -1) {
+                return name;
+            }
+        }
+        return null;
+    }
+
+    protected void printModifiers(int modifiers) {
+    }
+
+    private void printMembers(List<BodyDeclaration> members, Object arg) {
+        for (BodyDeclaration member : members) {
+            member.accept(this, arg);
+        }
+    }
+
+    private void printTypeArgs(List<Type> args, Object arg) {
+        // if (args != null) {
+        // printer.print("<");
+        // for (Iterator<Type> i = args.iterator(); i.hasNext();) {
+        // Type t = i.next();
+        // t.accept(this, arg);
+        // if (i.hasNext()) {
+        // printer.print(", ");
+        // }
+        // }
+        // printer.print(">");
+        // }
+    }
+
+    private void printTypeParameters(List<TypeParameter> args, Object arg) {
+        // if (args != null) {
+        // printer.print("<");
+        // for (Iterator<TypeParameter> i = args.iterator(); i.hasNext();) {
+        // TypeParameter t = i.next();
+        // t.accept(this, arg);
+        // if (i.hasNext()) {
+        // printer.print(", ");
+        // }
+        // }
+        // printer.print(">");
+        // }
+    }
+
+    public void visit(Node n, Object arg) {
+        throw new IllegalStateException(n.getClass().getName());
+    }
+
+    public void visit(CompilationUnit n, Object arg) {
+        if (n.getTypes() != null) {
+            for (Iterator<TypeDeclaration> i = n.getTypes().iterator(); i.hasNext();) {
+                i.next().accept(this, arg);
+                printer.printLn();
+                if (i.hasNext()) {
+                    printer.printLn();
+                }
+            }
+        }
+    }
+
+    public void visit(PackageDeclaration n, Object arg) {
+        throw new IllegalStateException(n.getClass().getName());
+    }
+
+    public void visit(NameExpr n, Object arg) {
+        if ("mappingLangToXmlLang".equals(n.getName())) {
+            printer.print("0");
+        } else if ("LANG_NS".equals(n.getName())) {
+            printer.print("ALL_NO_NS");
+        } else if ("LANG_PREFIX".equals(n.getName())) {
+            printer.print("ALL_NO_PREFIX");
+        } else if ("HTML_LOCAL".equals(n.getName())) {
+            printer.print(cppTypes.localForLiteral("html"));
+        } else if ("documentModeHandler".equals(n.getName())) {
+            printer.print("parser");
+        } else {
+            String prefixedName = javaClassName + "." + n.getName();
+            String constant = symbolTable.cppDefinesByJavaNames.get(prefixedName);
+            if (constant != null) {
+                printer.print(constant);
+            } else {
+                printer.print(n.getName());
+            }
+        }
+    }
+
+    public void visit(QualifiedNameExpr n, Object arg) {
+        n.getQualifier().accept(this, arg);
+        printer.print(".");
+        printer.print(n.getName());
+    }
+
+    public void visit(ImportDeclaration n, Object arg) {
+        throw new IllegalStateException(n.getClass().getName());
+    }
+
+    public void visit(ClassOrInterfaceDeclaration n, Object arg) {
+        javaClassName = n.getName();
+        className = cppTypes.classPrefix() + javaClassName;
+        definePrefix = makeDefinePrefix(className);
+
+        startClassDeclaration();
+
+        if (n.getMembers() != null) {
+            printMembers(n.getMembers(), arg);
+        }
+
+        endClassDeclaration();
+    }
+
+    private String makeDefinePrefix(String name) {
+        StringBuilder sb = new StringBuilder();
+        boolean prevWasLowerCase = true;
+        for (int i = 0; i < name.length(); i++) {
+            char c = name.charAt(i);
+            if (c >= 'a' && c <= 'z') {
+                sb.append((char) (c - 0x20));
+                prevWasLowerCase = true;
+            } else if (c >= 'A' && c <= 'Z') {
+                if (prevWasLowerCase) {
+                    sb.append('_');
+                }
+                sb.append(c);
+                prevWasLowerCase = false;
+            } else if (c >= '0' && c <= '9') {
+                sb.append(c);
+                prevWasLowerCase = false;
+            }
+        }
+        sb.append('_');
+        return sb.toString();
+    }
+
+    protected void endClassDeclaration() {
+        printer.printLn("void");
+        printer.print(className);
+        printer.printLn("::initializeStatics()");
+        printer.printLn("{");
+        printer.print(staticInitializerPrinter.getSource());
+        printer.printLn("}");
+        printer.printLn();
+
+        printer.printLn("void");
+        printer.print(className);
+        printer.printLn("::releaseStatics()");
+        printer.printLn("{");
+        printer.indent();
+        for (String del : staticReleases) {
+            printer.print(del);
+            printer.printLn(";");
+        }
+        printer.unindent();
+        printer.printLn("}");
+        printer.printLn();
+
+        if (cppTypes.hasSupplement(javaClassName)) {
+            printer.printLn();
+            printer.print("#include \"");
+            printer.print(className);
+            printer.printLn("CppSupplement.h\"");
+        }
+    }
+
+    protected void startClassDeclaration() {
+        printer.print("#define ");
+        printer.print(className);
+        printer.printLn("_cpp__");
+        printer.printLn();
+
+        String[] incs = cppTypes.boilerplateIncludes(javaClassName);
+        for (int i = 0; i < incs.length; i++) {
+            String inc = incs[i];
+            printer.print("#include \"");
+            printer.print(inc);
+            printer.printLn(".h\"");
+        }
+
+        printer.printLn();
+
+        for (int i = 0; i < Main.H_LIST.length; i++) {
+            String klazz = Main.H_LIST[i];
+            if (!klazz.equals(javaClassName)) {
+                printer.print("#include \"");
+                printer.print(cppTypes.classPrefix());
+                printer.print(klazz);
+                printer.printLn(".h\"");
+            }
+        }
+
+        printer.printLn();
+        printer.print("#include \"");
+        printer.print(className);
+        printer.printLn(".h\"");
+        if ("AttributeName".equals(javaClassName)
+                || "ElementName".equals(javaClassName)) {
+            printer.print("#include \"");
+            printer.print(cppTypes.classPrefix());
+            printer.print("Releasable");
+            printer.print(javaClassName);
+            printer.printLn(".h\"");
+        }
+        printer.printLn();
+    }
+
+    public void visit(EmptyTypeDeclaration n, Object arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        printer.print(";");
+    }
+
+    public void visit(JavadocComment n, Object arg) {
+        printer.print("/**");
+        printer.print(n.getContent());
+        printer.printLn("*/");
+    }
+
+    public void visit(ClassOrInterfaceType n, Object arg) {
+        if (n.getScope() != null) {
+            n.getScope().accept(this, arg);
+            printer.print(".");
+            throw new IllegalStateException("Can't translate nested classes.");
+        }
+        String name = n.getName();
+        if ("String".equals(name)) {
+            if (local()) {
+                name = cppTypes.localType();
+            } else if (prefix()) {
+                name = cppTypes.prefixType();
+            } else if (nsUri()) {
+                name = cppTypes.nsUriType();
+            } else if (literal()) {
+                name = cppTypes.literalType();
+            } else {
+                name = cppTypes.stringType();
+            }
+        } else if ("T".equals(name) || "Object".equals(name)) {
+            name = cppTypes.nodeType();
+        } else if ("TokenHandler".equals(name)) {
+            name = cppTypes.classPrefix() + "TreeBuilder*";
+        } else if ("EncodingDeclarationHandler".equals(name)) {
+            name = cppTypes.encodingDeclarationHandlerType();
+        } else if ("DocumentModeHandler".equals(name)) {
+            name = cppTypes.documentModeHandlerType();
+        } else if ("DocumentMode".equals(name)) {
+            name = cppTypes.documentModeType();
+        } else {
+            name = cppTypes.classPrefix() + name + (suppressPointer ? "" : "*");
+        }
+        printer.print(name);
+        printTypeArgs(n.getTypeArgs(), arg);
+    }
+
+    private boolean nsUri() {
+        return hasAnnotation("NsUri");
+    }
+
+    private boolean prefix() {
+        return hasAnnotation("Prefix");
+    }
+
+    private boolean local() {
+        return hasAnnotation("Local");
+    }
+
+    private boolean literal() {
+        return hasAnnotation("Literal");
+    }
+
+    protected boolean inline() {
+        return hasAnnotation("Inline");
+    }
+
+    protected boolean inHeader() {
+        return false;
+    }
+
+    public void visit(TypeParameter n, Object arg) {
+        printer.print(n.getName());
+        if (n.getTypeBound() != null) {
+            printer.print(" extends ");
+            for (Iterator<ClassOrInterfaceType> i = n.getTypeBound().iterator(); i.hasNext();) {
+                ClassOrInterfaceType c = i.next();
+                c.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(" & ");
+                }
+            }
+        }
+    }
+
+    public void visit(PrimitiveType n, Object arg) {
+        switch (n.getType()) {
+            case Boolean:
+                printer.print(cppTypes.booleanType());
+                break;
+            case Byte:
+                throw new IllegalStateException("Unsupported primitive.");
+            case Char:
+                printer.print(cppTypes.charType());
+                break;
+            case Double:
+                throw new IllegalStateException("Unsupported primitive.");
+            case Float:
+                throw new IllegalStateException("Unsupported primitive.");
+            case Int:
+                printer.print(cppTypes.intType());
+                break;
+            case Long:
+                throw new IllegalStateException("Unsupported primitive.");
+            case Short:
+                throw new IllegalStateException("Unsupported primitive.");
+        }
+    }
+
+    public void visit(ReferenceType n, Object arg) {
+        if (noLength()) {
+            n.getType().accept(this, arg);
+            for (int i = 0; i < n.getArrayCount(); i++) {
+                if (!inPrimitiveNoLengthFieldDeclarator) {
+                    printer.print("*");
+                }
+            }
+        } else {
+            for (int i = 0; i < n.getArrayCount(); i++) {
+                printer.print(cppTypes.arrayTemplate());
+                printer.print("<");
+            }
+            n.getType().accept(this, arg);
+            for (int i = 0; i < n.getArrayCount(); i++) {
+                printer.print(",");
+                printer.print(cppTypes.intType());
+                printer.print(">");
+            }
+        }
+    }
+
+    protected boolean noLength() {
+        return hasAnnotation("NoLength");
+    }
+
+    protected boolean virtual() {
+        return hasAnnotation("Virtual");
+    }
+
+    private boolean hasAnnotation(String anno) {
+        if (currentAnnotations == null) {
+            return false;
+        }
+        for (AnnotationExpr ann : currentAnnotations) {
+            if (ann instanceof MarkerAnnotationExpr) {
+                MarkerAnnotationExpr marker = (MarkerAnnotationExpr) ann;
+                if (marker.getName().getName().equals(anno)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    public void visit(WildcardType n, Object arg) {
+        printer.print("?");
+        if (n.getExtends() != null) {
+            printer.print(" extends ");
+            n.getExtends().accept(this, arg);
+        }
+        if (n.getSuper() != null) {
+            printer.print(" super ");
+            n.getSuper().accept(this, arg);
+        }
+    }
+
+    public void visit(FieldDeclaration n, Object arg) {
+        currentAnnotations = n.getAnnotations();
+        fieldDeclaration(n, arg);
+        currentAnnotations = null;
+    }
+
+    protected boolean isNonToCharArrayMethodCall(Expression exp) {
+        if (exp instanceof MethodCallExpr) {
+            MethodCallExpr mce = (MethodCallExpr) exp;
+            return !"toCharArray".equals(mce.getName());
+        } else {
+            return false;
+        }
+    }
+
+    protected void fieldDeclaration(FieldDeclaration n, Object arg) {
+        tempPrinterHolder = printer;
+        printer = staticInitializerPrinter;
+        int modifiers = n.getModifiers();
+        List<VariableDeclarator> variables = n.getVariables();
+        VariableDeclarator declarator = variables.get(0);
+        if (ModifierSet.isStatic(modifiers) && ModifierSet.isFinal(modifiers)
+                && !(n.getType() instanceof PrimitiveType)
+                && declarator.getInit() != null) {
+            if (n.getType() instanceof ReferenceType) {
+                ReferenceType rt = (ReferenceType) n.getType();
+                currentArrayCount = rt.getArrayCount();
+                if (currentArrayCount > 0) {
+                    if (currentArrayCount != 1) {
+                        throw new IllegalStateException(
+                                "Multidimensional arrays not supported. " + n);
+                    }
+                    if (noLength()) {
+                        if (rt.getType() instanceof PrimitiveType) {
+                            // do nothing
+                        } else {
+                            staticReleases.add("delete[] "
+                                    + declarator.getId().getName());
+
+                            ArrayInitializerExpr aie = (ArrayInitializerExpr) declarator.getInit();
+
+                            declarator.getId().accept(this, arg);
+                            printer.print(" = new ");
+                            // suppressPointer = true;
+                            rt.getType().accept(this, arg);
+                            // suppressPointer = false;
+                            printer.print("[");
+                            printer.print("" + aie.getValues().size());
+                            printer.printLn("];");
+
+                            printArrayInit(declarator.getId(), aie.getValues(),
+                                    arg);
+                        }
+                    } else if (isNonToCharArrayMethodCall(declarator.getInit())
+                            || !(rt.getType() instanceof PrimitiveType)) {
+                        staticReleases.add(declarator.getId().getName()
+                                + ".release()");
+                        declarator.getId().accept(this, arg);
+                        printer.print(" = ");
+                        if (declarator.getInit() instanceof ArrayInitializerExpr) {
+
+                            ArrayInitializerExpr aie = (ArrayInitializerExpr) declarator.getInit();
+                            printer.print(cppTypes.arrayTemplate());
+                            printer.print("<");
+                            suppressPointer = true;
+                            rt.getType().accept(this, arg);
+                            suppressPointer = false;
+                            printer.print(",");
+                            printer.print(cppTypes.intType());
+                            printer.print(">(");
+                            printer.print("" + aie.getValues().size());
+                            printer.printLn(");");
+                            printArrayInit(declarator.getId(), aie.getValues(),
+                                    arg);
+                        } else {
+                            declarator.getInit().accept(this, arg);
+                            printer.printLn(";");
+                        }
+                    } else if ((rt.getType() instanceof PrimitiveType)) {
+                        printer = tempPrinterHolder;
+                        printer.print("static ");
+                        rt.getType().accept(this, arg);
+                        printer.print(" const ");
+                        declarator.getId().accept(this, arg);
+                        printer.print("_DATA[] = ");
+                        declarator.getInit().accept(this, arg);
+                        printer.printLn(";");
+                        printer = staticInitializerPrinter;
+
+                        declarator.getId().accept(this, arg);
+                        printer.print(" = ");
+                        printer.print(cppTypes.arrayTemplate());
+                        printer.print("<");
+                        rt.getType().accept(this, arg);
+                        printer.print(",");
+                        printer.print(cppTypes.intType());
+                        printer.print(">((");
+                        rt.getType().accept(this, arg);
+                        printer.print("*)");
+                        declarator.getId().accept(this, arg);
+                        printer.print("_DATA, ");
+                        printer.print(Integer.toString(((ArrayInitializerExpr) declarator.getInit()).getValues().size()));
+                        printer.printLn(");");
+                    }
+                } else {
+
+                    if ("AttributeName".equals(n.getType().toString())) {
+                        printer.print("ATTR_");
+                        staticReleases.add("delete ATTR_"
+                                + declarator.getId().getName());
+                    } else if ("ElementName".equals(n.getType().toString())) {
+                        printer.print("ELT_");
+                        staticReleases.add("delete ELT_"
+                                + declarator.getId().getName());
+                    } else {
+                        staticReleases.add("delete "
+                                + declarator.getId().getName());
+                    }
+                    declarator.accept(this, arg);
+                    printer.printLn(";");
+                }
+            } else {
+                throw new IllegalStateException(
+                        "Non-reference, non-primitive fields not supported.");
+            }
+        }
+        currentArrayCount = 0;
+        printer = tempPrinterHolder;
+    }
+
+    private void printArrayInit(VariableDeclaratorId variableDeclaratorId,
+            List<Expression> values, Object arg) {
+        for (int i = 0; i < values.size(); i++) {
+            Expression exp = values.get(i);
+            variableDeclaratorId.accept(this, arg);
+            printer.print("[");
+            printer.print("" + i);
+            printer.print("] = ");
+            if (exp instanceof NameExpr) {
+                if ("AttributeName".equals(javaClassName)) {
+                    printer.print("ATTR_");
+                } else if ("ElementName".equals(javaClassName)) {
+                    printer.print("ELT_");
+                }
+            }
+            exp.accept(this, arg);
+            printer.printLn(";");
+        }
+    }
+
+    public void visit(VariableDeclarator n, Object arg) {
+        n.getId().accept(this, arg);
+
+        if (n.getInit() != null) {
+            printer.print(" = ");
+            n.getInit().accept(this, arg);
+        }
+    }
+
+    public void visit(VariableDeclaratorId n, Object arg) {
+        String name = n.getName();
+        if ("documentModeHandler".equals(name)) {
+            printer.print("parser");
+        } else {
+            printer.print(n.getName());
+        }
+        if (noLength()) {
+            for (int i = 0; i < currentArrayCount; i++) {
+                if (inPrimitiveNoLengthFieldDeclarator) {
+                    printer.print("[]");
+                }
+            }
+        }
+        for (int i = 0; i < n.getArrayCount(); i++) {
+            printer.print("[]");
+        }
+    }
+
+    public void visit(ArrayInitializerExpr n, Object arg) {
+        printer.print("{");
+        if (n.getValues() != null) {
+            printer.print(" ");
+            for (Iterator<Expression> i = n.getValues().iterator(); i.hasNext();) {
+                Expression expr = i.next();
+                expr.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+            printer.print(" ");
+        }
+        printer.print("}");
+    }
+
+    public void visit(VoidType n, Object arg) {
+        printer.print("void");
+    }
+
+    public void visit(ArrayAccessExpr n, Object arg) {
+        n.getName().accept(this, arg);
+        printer.print("[");
+        n.getIndex().accept(this, arg);
+        printer.print("]");
+    }
+
+    public void visit(ArrayCreationExpr n, Object arg) {
+        // printer.print("new ");
+        // n.getType().accept(this, arg);
+        // printTypeArgs(n.getTypeArgs(), arg);
+
+        if (n.getDimensions() != null) {
+            if (noLength()) {
+                for (Expression dim : n.getDimensions()) {
+                    printer.print("new ");
+                    n.getType().accept(this, arg);
+                    printer.print("[");
+                    dim.accept(this, arg);
+                    printer.print("]");
+                }
+            } else {
+                for (Expression dim : n.getDimensions()) {
+                    printer.print(cppTypes.arrayTemplate());
+                    printer.print("<");
+                    n.getType().accept(this, arg);
+                    printer.print(",");
+                    printer.print(cppTypes.intType());
+                    printer.print(">(");
+                    dim.accept(this, arg);
+                    printer.print(")");
+                }
+            }
+            if (n.getArrayCount() > 0) {
+                throw new IllegalStateException(
+                        "Nested array allocation not supported. "
+                                + n.toString());
+            }
+        } else {
+            throw new IllegalStateException(
+                    "Array initializer as part of array creation not supported. "
+                            + n.toString());
+        }
+    }
+
+    public void visit(AssignExpr n, Object arg) {
+        if (inConstructorBody) {
+            n.getTarget().accept(this, arg);
+            printer.print("(");
+            n.getValue().accept(this, arg);
+            printer.print(")");
+        } else {
+            n.getTarget().accept(this, arg);
+            printer.print(" ");
+            switch (n.getOperator()) {
+                case assign:
+                    printer.print("=");
+                    break;
+                case and:
+                    printer.print("&=");
+                    break;
+                case or:
+                    printer.print("|=");
+                    break;
+                case xor:
+                    printer.print("^=");
+                    break;
+                case plus:
+                    printer.print("+=");
+                    break;
+                case minus:
+                    printer.print("-=");
+                    break;
+                case rem:
+                    printer.print("%=");
+                    break;
+                case slash:
+                    printer.print("/=");
+                    break;
+                case star:
+                    printer.print("*=");
+                    break;
+                case lShift:
+                    printer.print("<<=");
+                    break;
+                case rSignedShift:
+                    printer.print(">>=");
+                    break;
+                case rUnsignedShift:
+                    printer.print(">>>=");
+                    break;
+            }
+            printer.print(" ");
+            n.getValue().accept(this, arg);
+        }
+    }
+
+    public void visit(BinaryExpr n, Object arg) {
+        Expression right = n.getRight();
+        switch (n.getOperator()) {
+            case notEquals:
+                if (right instanceof NullLiteralExpr) {
+                    printer.print("!!");
+                    n.getLeft().accept(this, arg);
+                    return;
+                } else if (right instanceof IntegerLiteralExpr) {
+                    IntegerLiteralExpr ile = (IntegerLiteralExpr) right;
+                    if ("0".equals(ile.getValue())) {
+                        n.getLeft().accept(this, arg);
+                        return;
+                    }
+                }
+            case equals:
+                if (right instanceof NullLiteralExpr) {
+                    printer.print("!");
+                    n.getLeft().accept(this, arg);
+                    return;
+                } else if (right instanceof IntegerLiteralExpr) {
+                    IntegerLiteralExpr ile = (IntegerLiteralExpr) right;
+                    if ("0".equals(ile.getValue())) {
+                        printer.print("!");
+                        n.getLeft().accept(this, arg);
+                        return;
+                    }
+                }
+            default:
+                // fall thru
+        }
+
+        n.getLeft().accept(this, arg);
+        printer.print(" ");
+        switch (n.getOperator()) {
+            case or:
+                printer.print("||");
+                break;
+            case and:
+                printer.print("&&");
+                break;
+            case binOr:
+                printer.print("|");
+                break;
+            case binAnd:
+                printer.print("&");
+                break;
+            case xor:
+                printer.print("^");
+                break;
+            case equals:
+                printer.print("==");
+                break;
+            case notEquals:
+                printer.print("!=");
+                break;
+            case less:
+                printer.print("<");
+                break;
+            case greater:
+                printer.print(">");
+                break;
+            case lessEquals:
+                printer.print("<=");
+                break;
+            case greaterEquals:
+                printer.print(">=");
+                break;
+            case lShift:
+                printer.print("<<");
+                break;
+            case rSignedShift:
+                printer.print(">>");
+                break;
+            case rUnsignedShift:
+                printer.print(">>>");
+                break;
+            case plus:
+                printer.print("+");
+                break;
+            case minus:
+                printer.print("-");
+                break;
+            case times:
+                printer.print("*");
+                break;
+            case divide:
+                printer.print("/");
+                break;
+            case remainder:
+                printer.print("%");
+                break;
+        }
+        printer.print(" ");
+        n.getRight().accept(this, arg);
+    }
+
+    public void visit(CastExpr n, Object arg) {
+        printer.print("(");
+        n.getType().accept(this, arg);
+        printer.print(") ");
+        n.getExpr().accept(this, arg);
+    }
+
+    public void visit(ClassExpr n, Object arg) {
+        n.getType().accept(this, arg);
+        printer.print(".class");
+    }
+
+    public void visit(ConditionalExpr n, Object arg) {
+        n.getCondition().accept(this, arg);
+        printer.print(" ? ");
+        n.getThenExpr().accept(this, arg);
+        printer.print(" : ");
+        n.getElseExpr().accept(this, arg);
+    }
+
+    public void visit(EnclosedExpr n, Object arg) {
+        printer.print("(");
+        n.getInner().accept(this, arg);
+        printer.print(")");
+    }
+
+    public void visit(FieldAccessExpr n, Object arg) {
+        Expression scope = n.getScope();
+        String field = n.getField();
+        if (inConstructorBody && (scope instanceof ThisExpr)) {
+            printer.print(field);
+        } else if ("length".equals(field) && !(scope instanceof ThisExpr)) {
+            scope.accept(this, arg);
+            printer.print(".length");
+        } else if ("MAX_VALUE".equals(field)
+                && "Integer".equals(scope.toString())) {
+            printer.print(cppTypes.maxInteger());
+        } else {
+            String clazzName = classNameFromExpression(scope);
+            if (clazzName == null) {
+                if ("DocumentMode".equals(scope.toString())) {
+                    // printer.print(cppTypes.documentModeType());
+                    // printer.print(".");
+                } else {
+                    scope.accept(this, arg);
+                    printer.print("->");
+                }
+            } else {
+                String prefixedName = clazzName + "." + field;
+                String constant = symbolTable.cppDefinesByJavaNames.get(prefixedName);
+                if (constant != null) {
+                    printer.print(constant);
+                    return;
+                } else {
+                    printer.print(cppTypes.classPrefix());
+                    printer.print(clazzName);
+                    printer.print("::");
+                    if (symbolTable.isNotAnAttributeOrElementName(field)) {
+                        if ("AttributeName".equals(clazzName)) {
+                            printer.print("ATTR_");
+                        } else if ("ElementName".equals(clazzName)) {
+                            printer.print("ELT_");
+                        }
+                    }
+                }
+            }
+            printer.print(field);
+        }
+    }
+
+    public void visit(InstanceOfExpr n, Object arg) {
+        n.getExpr().accept(this, arg);
+        printer.print(" instanceof ");
+        n.getType().accept(this, arg);
+    }
+
+    public void visit(CharLiteralExpr n, Object arg) {
+        printCharLiteral(n.getValue());
+    }
+
+    private void printCharLiteral(String val) {
+        if (val.length() != 1) {
+            printer.print("'");
+            printer.print(val);
+            printer.print("'");
+            return;
+        }
+        char c = val.charAt(0);
+        switch (c) {
+            case 0:
+                printer.print("'\\0'");
+                break;
+            case '\n':
+                printer.print("'\\n'");
+                break;
+            case '\t':
+                printer.print("'\\t'");
+                break;
+            case 0xB:
+                printer.print("'\\v'");
+                break;
+            case '\b':
+                printer.print("'\\b'");
+                break;
+            case '\r':
+                printer.print("'\\r'");
+                break;
+            case 0xC:
+                printer.print("'\\f'");
+                break;
+            case 0x7:
+                printer.print("'\\a'");
+                break;
+            case '\\':
+                printer.print("'\\\\'");
+                break;
+            case '?':
+                printer.print("'\\?'");
+                break;
+            case '\'':
+                printer.print("'\\''");
+                break;
+            case '"':
+                printer.print("'\\\"'");
+                break;
+            default:
+                if (c >= 0x20 && c <= 0x7F) {
+                    printer.print("'" + c);
+                    printer.print("'");
+                } else {
+                    printer.print("0x");
+                    printer.print(Integer.toHexString(c));
+                }
+                break;
+        }
+    }
+
+    public void visit(DoubleLiteralExpr n, Object arg) {
+        printer.print(n.getValue());
+    }
+
+    public void visit(IntegerLiteralExpr n, Object arg) {
+        printer.print(n.getValue());
+    }
+
+    public void visit(LongLiteralExpr n, Object arg) {
+        printer.print(n.getValue());
+    }
+
+    public void visit(IntegerLiteralMinValueExpr n, Object arg) {
+        printer.print(n.getValue());
+    }
+
+    public void visit(LongLiteralMinValueExpr n, Object arg) {
+        printer.print(n.getValue());
+    }
+
+    public void visit(StringLiteralExpr n, Object arg) {
+        String val = n.getValue();
+        if ("http://www.w3.org/1999/xhtml".equals(val)) {
+            printer.print(cppTypes.xhtmlNamespaceLiteral());
+        } else if ("http://www.w3.org/2000/svg".equals(val)) {
+            printer.print(cppTypes.svgNamespaceLiteral());
+        } else if ("http://www.w3.org/2000/xmlns/".equals(val)) {
+            printer.print(cppTypes.xmlnsNamespaceLiteral());
+        } else if ("http://www.w3.org/XML/1998/namespace".equals(val)) {
+            printer.print(cppTypes.xmlNamespaceLiteral());
+        } else if ("http://www.w3.org/1999/xlink".equals(val)) {
+            printer.print(cppTypes.xlinkNamespaceLiteral());
+        } else if ("http://www.w3.org/1998/Math/MathML".equals(val)) {
+            printer.print(cppTypes.mathmlNamespaceLiteral());
+        } else if ("".equals(val) && "AttributeName".equals(javaClassName)) {
+            printer.print(cppTypes.noNamespaceLiteral());
+        } else if (val.startsWith("-/") || val.startsWith("+//")
+                || val.startsWith("http://") || val.startsWith("XSLT")) {
+            printer.print(cppTypes.stringForLiteral(val));
+        } else if (("hidden".equals(val) || "isindex".equals(val))
+                && "TreeBuilder".equals(javaClassName)) {
+            printer.print(cppTypes.stringForLiteral(val));
+        } else if ("isQuirky".equals(currentMethod) && "html".equals(val)) {
+            printer.print(cppTypes.stringForLiteral(val));
+        } else {
+            printer.print(cppTypes.localForLiteral(val));
+        }
+    }
+
+    public void visit(BooleanLiteralExpr n, Object arg) {
+        if (n.getValue()) {
+            printer.print(cppTypes.trueLiteral());
+        } else {
+            printer.print(cppTypes.falseLiteral());
+        }
+    }
+
+    public void visit(NullLiteralExpr n, Object arg) {
+        printer.print(cppTypes.nullLiteral());
+    }
+
+    public void visit(ThisExpr n, Object arg) {
+        if (n.getClassExpr() != null) {
+            n.getClassExpr().accept(this, arg);
+            printer.print(".");
+        }
+        printer.print("this");
+    }
+
+    public void visit(SuperExpr n, Object arg) {
+        if (n.getClassExpr() != null) {
+            n.getClassExpr().accept(this, arg);
+            printer.print(".");
+        }
+        printer.print("super");
+    }
+
+    public void visit(MethodCallExpr n, Object arg) {
+        if ("releaseArray".equals(n.getName())
+                && "Portability".equals(n.getScope().toString())) {
+            n.getArgs().get(0).accept(this, arg);
+            printer.print(".release()");
+        } else if ("deleteArray".equals(n.getName())
+                && "Portability".equals(n.getScope().toString())) {
+            printer.print("delete[] ");
+            n.getArgs().get(0).accept(this, arg);
+        } else if ("delete".equals(n.getName())
+                && "Portability".equals(n.getScope().toString())) {
+            printer.print("delete ");
+            n.getArgs().get(0).accept(this, arg);
+        } else if ("arraycopy".equals(n.getName())
+                && "System".equals(n.getScope().toString())) {
+            printer.print(cppTypes.arrayCopy());
+            printer.print("(");
+            if (n.getArgs().get(0).toString().equals(
+                    n.getArgs().get(2).toString())) {
+                n.getArgs().get(0).accept(this, arg);
+                printer.print(", ");
+                n.getArgs().get(1).accept(this, arg);
+                printer.print(", ");
+                n.getArgs().get(3).accept(this, arg);
+                printer.print(", ");
+                n.getArgs().get(4).accept(this, arg);
+            } else if (n.getArgs().get(1).toString().equals("0")
+                    && n.getArgs().get(3).toString().equals("0")) {
+                n.getArgs().get(0).accept(this, arg);
+                printer.print(", ");
+                n.getArgs().get(2).accept(this, arg);
+                printer.print(", ");
+                n.getArgs().get(4).accept(this, arg);
+            } else {
+                for (Iterator<Expression> i = n.getArgs().iterator(); i.hasNext();) {
+                    Expression e = i.next();
+                    e.accept(this, arg);
+                    if (i.hasNext()) {
+                        printer.print(", ");
+                    }
+                }
+            }
+            printer.print(")");
+        } else if ("binarySearch".equals(n.getName())
+                && "Arrays".equals(n.getScope().toString())) {
+            n.getArgs().get(0).accept(this, arg);
+            printer.print(".binarySearch(");
+            n.getArgs().get(1).accept(this, arg);
+            printer.print(")");
+        } else {
+            Expression scope = n.getScope();
+            if (scope != null) {
+                if (scope instanceof StringLiteralExpr) {
+                    StringLiteralExpr strLit = (StringLiteralExpr) scope;
+                    String str = strLit.getValue();
+                    if (!"toCharArray".equals(n.getName())) {
+                        throw new IllegalStateException(
+                                "Unsupported method call on string literal: "
+                                        + n.getName());
+                    }
+                    printer.print("{ ");
+                    for (int i = 0; i < str.length(); i++) {
+                        char c = str.charAt(i);
+                        if (i != 0) {
+                            printer.print(", ");
+                        }
+                        printCharLiteral("" + c);
+                    }
+                    printer.print(" }");
+                    return;
+                } else {
+                    String clazzName = classNameFromExpression(scope);
+                    if (clazzName == null) {
+                        scope.accept(this, arg);
+                        printer.print("->");
+                    } else {
+                        printer.print(cppTypes.classPrefix());
+                        printer.print(clazzName);
+                        printer.print("::");
+                    }
+                }
+            }
+            printTypeArgs(n.getTypeArgs(), arg);
+            printer.print(n.getName());
+            printer.print("(");
+            if (n.getArgs() != null) {
+                for (Iterator<Expression> i = n.getArgs().iterator(); i.hasNext();) {
+                    Expression e = i.next();
+                    e.accept(this, arg);
+                    if (i.hasNext()) {
+                        printer.print(", ");
+                    }
+                }
+            }
+            printer.print(")");
+        }
+    }
+
+    public void visit(ObjectCreationExpr n, Object arg) {
+        if (n.getScope() != null) {
+            n.getScope().accept(this, arg);
+            printer.print(".");
+        }
+
+        printer.print("new ");
+
+        suppressPointer = true;
+        printTypeArgs(n.getTypeArgs(), arg);
+        if ("createAttributeName".equals(currentMethod)
+                || "elementNameByBuffer".equals(currentMethod)) {
+            printer.print(cppTypes.classPrefix());
+            printer.print("Releasable");
+            printer.print(n.getType().getName());
+        } else {
+            n.getType().accept(this, arg);
+        }
+        suppressPointer = false;
+
+        if ("AttributeName".equals(n.getType().getName())) {
+            List<Expression> args = n.getArgs();
+            while (args.size() > 3) {
+                args.remove(3);
+            }
+        }
+
+        printer.print("(");
+        if (n.getArgs() != null) {
+            for (Iterator<Expression> i = n.getArgs().iterator(); i.hasNext();) {
+                Expression e = i.next();
+                e.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        printer.print(")");
+
+        if (n.getAnonymousClassBody() != null) {
+            printer.printLn(" {");
+            printer.indent();
+            printMembers(n.getAnonymousClassBody(), arg);
+            printer.unindent();
+            printer.print("}");
+        }
+    }
+
+    public void visit(UnaryExpr n, Object arg) {
+        switch (n.getOperator()) {
+            case positive:
+                printer.print("+");
+                break;
+            case negative:
+                printer.print("-");
+                break;
+            case inverse:
+                printer.print("~");
+                break;
+            case not:
+                printer.print("!");
+                break;
+            case preIncrement:
+                printer.print("++");
+                break;
+            case preDecrement:
+                printer.print("--");
+                break;
+        }
+
+        n.getExpr().accept(this, arg);
+
+        switch (n.getOperator()) {
+            case posIncrement:
+                printer.print("++");
+                break;
+            case posDecrement:
+                printer.print("--");
+                break;
+        }
+    }
+
+    public void visit(ConstructorDeclaration n, Object arg) {
+        if ("TreeBuilder".equals(javaClassName)
+                || "MetaScanner".equals(javaClassName)) {
+            return;
+        }
+
+        // if (n.getJavaDoc() != null) {
+        // n.getJavaDoc().accept(this, arg);
+        // }
+        currentAnnotations = n.getAnnotations();
+        // if (annotations != null) {
+        // for (AnnotationExpr a : annotations) {
+        // a.accept(this, arg);
+        // printer.printLn();
+        // }
+        // }
+        printModifiers(n.getModifiers());
+
+        // printTypeParameters(n.getTypeParameters(), arg);
+        // if (n.getTypeParameters() != null) {
+        // printer.print(" ");
+        // }
+
+        printMethodNamespace();
+        printer.print(className);
+        currentAnnotations = null;
+
+        printer.print("(");
+        if (n.getParameters() != null) {
+            for (Iterator<Parameter> i = n.getParameters().iterator(); i.hasNext();) {
+                Parameter p = i.next();
+                p.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        printer.print(")");
+
+        // if (n.getThrows() != null) {
+        // printer.print(" throws ");
+        // for (Iterator<NameExpr> i = n.getThrows().iterator(); i.hasNext();) {
+        // NameExpr name = i.next();
+        // name.accept(this, arg);
+        // if (i.hasNext()) {
+        // printer.print(", ");
+        // }
+        // }
+        // }
+        printConstructorBody(n.getBlock(), arg);
+    }
+
+    protected void printConstructorBody(BlockStmt block, Object arg) {
+        inConstructorBody = true;
+        List<Statement> statements = block.getStmts();
+        List<Statement> nonAssigns = new LinkedList<Statement>();
+        int i = 0;
+        boolean needOutdent = false;
+        for (Statement statement : statements) {
+            if (statement instanceof ExpressionStmt
+                    && ((ExpressionStmt) statement).getExpression() instanceof AssignExpr) {
+                if (i == 0) {
+                    printer.printLn();
+                    printer.indent();
+                    printer.print(": ");
+                    needOutdent = true;
+                } else {
+                    printer.print(",");
+                    printer.printLn();
+                    printer.print("  ");
+                }
+                statement.accept(this, arg);
+                i++;
+            } else {
+                nonAssigns.add(statement);
+            }
+        }
+        if (needOutdent) {
+            printer.unindent();
+        }
+        inConstructorBody = false;
+        printer.printLn();
+        printer.printLn("{");
+        printer.indent();
+        String boilerplate = cppTypes.constructorBoilerplate(className);
+        if (boilerplate != null) {
+            printer.printLn(boilerplate);
+        }
+        for (Statement statement : nonAssigns) {
+            statement.accept(this, arg);
+            printer.printLn();
+        }
+        printer.unindent();
+        printer.printLn("}");
+        printer.printLn();
+    }
+
+    public void visit(MethodDeclaration n, Object arg) {
+        if (isPrintableMethod(n.getModifiers())
+                && !(n.getName().equals("endCoalescing") || n.getName().equals(
+                        "startCoalescing"))) {
+            printMethodDeclaration(n, arg);
+        }
+    }
+
+    private boolean isPrintableMethod(int modifiers) {
+        return !(ModifierSet.isAbstract(modifiers) || (ModifierSet.isProtected(modifiers) && !(ModifierSet.isFinal(modifiers) || "Tokenizer".equals(javaClassName))));
+    }
+
+    protected void printMethodDeclaration(MethodDeclaration n, Object arg) {
+        if (n.getName().startsWith("fatal") || n.getName().startsWith("err")
+                || n.getName().startsWith("warn")
+                || n.getName().startsWith("maybeErr")
+                || n.getName().startsWith("maybeWarn")
+                || "releaseArray".equals(n.getName())
+                || "deleteArray".equals(n.getName())
+                || "delete".equals(n.getName())) {
+            return;
+        }
+
+        currentMethod = n.getName();
+
+        destructor = "destructor".equals(n.getName());
+
+        // if (n.getJavaDoc() != null) {
+        // n.getJavaDoc().accept(this, arg);
+        // }
+        currentAnnotations = n.getAnnotations();
+        boolean isInline = inline();
+        if (isInline && !inHeader()) {
+            return;
+        }
+
+        if (destructor) {
+            printModifiers(ModifierSet.PUBLIC);
+        } else {
+            printModifiers(n.getModifiers());
+        }
+
+        printTypeParameters(n.getTypeParameters(), arg);
+        if (n.getTypeParameters() != null) {
+            printer.print(" ");
+        }
+        if (!destructor) {
+            n.getType().accept(this, arg);
+            printer.print(" ");
+        }
+        printMethodNamespace();
+        if (destructor) {
+            printer.print("~");
+            printer.print(className);
+        } else {
+            printer.print(n.getName());
+        }
+
+        currentAnnotations = null;
+        printer.print("(");
+        if (n.getParameters() != null) {
+            for (Iterator<Parameter> i = n.getParameters().iterator(); i.hasNext();) {
+                Parameter p = i.next();
+                p.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        printer.print(")");
+
+        for (int i = 0; i < n.getArrayCount(); i++) {
+            printer.print("[]");
+        }
+
+        if (inHeader() == isInline) {
+            printMethodBody(n.getBody(), arg);
+        } else {
+            printer.printLn(";");
+        }
+    }
+
+    private void printMethodBody(BlockStmt n, Object arg) {
+        if (n == null) {
+            printer.print(";");
+        } else {
+            printer.printLn();
+            printer.printLn("{");
+            printer.indent();
+            if (destructor) {
+                String boilerplate = cppTypes.destructorBoilderplate(className);
+                if (boilerplate != null) {
+                    printer.printLn(boilerplate);
+                }
+            }
+            if (n.getStmts() != null) {
+                for (Statement s : n.getStmts()) {
+                    s.accept(this, arg);
+                    printer.printLn();
+                }
+            }
+            printer.unindent();
+            printer.print("}");
+        }
+        printer.printLn();
+        printer.printLn();
+    }
+
+    protected void printMethodNamespace() {
+        printer.printLn();
+        printer.print(className);
+        printer.print("::");
+    }
+
+    public void visit(Parameter n, Object arg) {
+        currentAnnotations = n.getAnnotations();
+        // if (annotations != null) {
+        // for (AnnotationExpr a : annotations) {
+        // a.accept(this, arg);
+        // printer.print(" ");
+        // }
+        // }
+        // printModifiers(n.getModifiers());
+
+        n.getType().accept(this, arg);
+        if (n.isVarArgs()) {
+            printer.print("...");
+        }
+        printer.print(" ");
+        n.getId().accept(this, arg);
+        currentAnnotations = null;
+    }
+
+    public void visit(ExplicitConstructorInvocationStmt n, Object arg) {
+        if (n.isThis()) {
+            printTypeArgs(n.getTypeArgs(), arg);
+            printer.print("this");
+        } else {
+            if (n.getExpr() != null) {
+                n.getExpr().accept(this, arg);
+                printer.print(".");
+            }
+            printTypeArgs(n.getTypeArgs(), arg);
+            printer.print("super");
+        }
+        printer.print("(");
+        if (n.getArgs() != null) {
+            for (Iterator<Expression> i = n.getArgs().iterator(); i.hasNext();) {
+                Expression e = i.next();
+                e.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        printer.print(");");
+    }
+
+    public void visit(VariableDeclarationExpr n, Object arg) {
+        currentAnnotations = n.getAnnotations();
+        // if (annotations != null) {
+        // for (AnnotationExpr a : annotations) {
+        // a.accept(this, arg);
+        // printer.print(" ");
+        // }
+        // }
+        // printModifiers(n.getModifiers());
+
+        n.getType().accept(this, arg);
+        printer.print(" ");
+
+        for (Iterator<VariableDeclarator> i = n.getVars().iterator(); i.hasNext();) {
+            VariableDeclarator v = i.next();
+            v.accept(this, arg);
+            if (i.hasNext()) {
+                printer.print(", ");
+            }
+        }
+        currentAnnotations = null;
+    }
+
+    public void visit(TypeDeclarationStmt n, Object arg) {
+        n.getTypeDeclaration().accept(this, arg);
+    }
+
+    public void visit(AssertStmt n, Object arg) {
+    }
+
+    public void visit(BlockStmt n, Object arg) {
+        printer.printLn("{");
+        if (n.getStmts() != null) {
+            printer.indent();
+            for (Statement s : n.getStmts()) {
+                s.accept(this, arg);
+                printer.printLn();
+            }
+            printer.unindent();
+        }
+        printer.print("}");
+
+    }
+
+    public void visit(LabeledStmt n, Object arg) {
+        // Only conditionless for loops are needed and supported
+        // Not implementing general Java continue semantics in order
+        // to keep the generated C++ more readable.
+        Statement stmt = n.getStmt();
+        if (stmt instanceof ForStmt) {
+            ForStmt forLoop = (ForStmt) stmt;
+            if (!(forLoop.getInit() == null && forLoop.getCompare() == null && forLoop.getUpdate() == null)) {
+                forLoopsWithCondition.add(n.getLabel());
+            }
+        } else {
+            throw new IllegalStateException(
+                    "Only for loop supported as labeled statement. Line: "
+                            + n.getBeginLine());
+        }
+        String label = n.getLabel();
+        if (labels.contains(label)) {
+            printer.print(label);
+            printer.print(": ");
+        }
+        stmt.accept(this, arg);
+        printer.printLn();
+        label += "_end";
+        if (labels.contains(label)) {
+            printer.print(label);
+            printer.print(": ;");
+        }
+    }
+
+    public void visit(EmptyStmt n, Object arg) {
+        printer.print(";");
+    }
+
+    public void visit(ExpressionStmt n, Object arg) {
+        Expression e = n.getExpression();
+        if (isDroppedExpression(e)) {
+            return;
+        }
+        e.accept(this, arg);
+        if (!inConstructorBody) {
+            printer.print(";");
+        }
+    }
+
+    private boolean isDroppedExpression(Expression e) {
+        if (e instanceof MethodCallExpr) {
+            MethodCallExpr methodCallExpr = (MethodCallExpr) e;
+            String name = methodCallExpr.getName();
+            if (name.startsWith("fatal") || name.startsWith("err")
+                    || name.startsWith("warn") || name.startsWith("maybeErr")
+                    || name.startsWith("maybeWarn")) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public void visit(SwitchStmt n, Object arg) {
+        printer.print("switch(");
+        n.getSelector().accept(this, arg);
+        printer.printLn(") {");
+        if (n.getEntries() != null) {
+            printer.indent();
+            for (SwitchEntryStmt e : n.getEntries()) {
+                e.accept(this, arg);
+            }
+            printer.unindent();
+        }
+        printer.print("}");
+
+    }
+
+    public void visit(SwitchEntryStmt n, Object arg) {
+        if (n.getLabel() != null) {
+            printer.print("case ");
+            n.getLabel().accept(this, arg);
+            printer.print(":");
+        } else {
+            printer.print("default:");
+        }
+        if (isNoStatement(n.getStmts())) {
+            printer.printLn();
+            printer.indent();
+            if (n.getLabel() == null) {
+                printer.printLn("; // fall through");
+            }
+            printer.unindent();
+        } else {
+            printer.printLn(" {");
+            printer.indent();
+            for (Statement s : n.getStmts()) {
+                s.accept(this, arg);
+                printer.printLn();
+            }
+            printer.unindent();
+            printer.printLn("}");
+        }
+    }
+
+    private boolean isNoStatement(List<Statement> stmts) {
+        if (stmts == null) {
+            return true;
+        }
+        for (Statement statement : stmts) {
+            if (!isDroppableStatement(statement)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private boolean isDroppableStatement(Statement statement) {
+        if (statement instanceof AssertStmt) {
+            return true;
+        } else if (statement instanceof ExpressionStmt) {
+            ExpressionStmt es = (ExpressionStmt) statement;
+            if (isDroppedExpression(es.getExpression())) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public void visit(BreakStmt n, Object arg) {
+        if (n.getId() != null) {
+            printer.print("goto ");
+            printer.print(n.getId());
+            printer.print("_end");
+        } else {
+            printer.print("break");
+        }
+        printer.print(";");
+    }
+
+    public void visit(ReturnStmt n, Object arg) {
+        printer.print("return");
+        if (n.getExpr() != null) {
+            printer.print(" ");
+            n.getExpr().accept(this, arg);
+        }
+        printer.print(";");
+    }
+
+    public void visit(EnumDeclaration n, Object arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        currentAnnotations = n.getAnnotations();
+        // if (annotations != null) {
+        // for (AnnotationExpr a : annotations) {
+        // a.accept(this, arg);
+        // printer.printLn();
+        // }
+        // }
+        printModifiers(n.getModifiers());
+
+        printer.print("enum ");
+        printer.print(n.getName());
+
+        currentAnnotations = null;
+
+        if (n.getImplements() != null) {
+            printer.print(" implements ");
+            for (Iterator<ClassOrInterfaceType> i = n.getImplements().iterator(); i.hasNext();) {
+                ClassOrInterfaceType c = i.next();
+                c.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+
+        printer.printLn(" {");
+        printer.indent();
+        if (n.getEntries() != null) {
+            printer.printLn();
+            for (Iterator<EnumConstantDeclaration> i = n.getEntries().iterator(); i.hasNext();) {
+                EnumConstantDeclaration e = i.next();
+                e.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        if (n.getMembers() != null) {
+            printer.printLn(";");
+            printMembers(n.getMembers(), arg);
+        } else {
+            if (n.getEntries() != null) {
+                printer.printLn();
+            }
+        }
+        printer.unindent();
+        printer.print("}");
+    }
+
+    public void visit(EnumConstantDeclaration n, Object arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        currentAnnotations = n.getAnnotations();
+        // if (annotations != null) {
+        // for (AnnotationExpr a : annotations) {
+        // a.accept(this, arg);
+        // printer.printLn();
+        // }
+        // }
+        printer.print(n.getName());
+
+        currentAnnotations = null;
+
+        if (n.getArgs() != null) {
+            printer.print("(");
+            for (Iterator<Expression> i = n.getArgs().iterator(); i.hasNext();) {
+                Expression e = i.next();
+                e.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+            printer.print(")");
+        }
+
+        if (n.getClassBody() != null) {
+            printer.printLn(" {");
+            printer.indent();
+            printMembers(n.getClassBody(), arg);
+            printer.unindent();
+            printer.printLn("}");
+        }
+    }
+
+    public void visit(EmptyMemberDeclaration n, Object arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        printer.print(";");
+    }
+
+    public void visit(InitializerDeclaration n, Object arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        if (n.isStatic()) {
+            printer.print("static ");
+        }
+        n.getBlock().accept(this, arg);
+    }
+
+    public void visit(IfStmt n, Object arg) {
+        if (!isErrorHandlerIf(n.getCondition())) {
+            printer.print("if (");
+            n.getCondition().accept(this, arg);
+            printer.print(") ");
+            n.getThenStmt().accept(this, arg);
+            if (n.getElseStmt() != null) {
+                printer.print(" else ");
+                n.getElseStmt().accept(this, arg);
+            }
+        }
+    }
+
+    private boolean isErrorHandlerIf(Expression condition) {
+        if (condition instanceof BinaryExpr) {
+            BinaryExpr be = (BinaryExpr) condition;
+            return be.getLeft().toString().equals("errorHandler");
+        }
+        return false;
+    }
+
+    public void visit(WhileStmt n, Object arg) {
+        printer.print("while (");
+        n.getCondition().accept(this, arg);
+        printer.print(") ");
+        n.getBody().accept(this, arg);
+    }
+
+    public void visit(ContinueStmt n, Object arg) {
+        // Not supporting the general Java continue semantics.
+        // Instead, making the generated code more readable for the
+        // case at hand.
+        if (n.getId() != null) {
+            printer.print("goto ");
+            printer.print(n.getId());
+            if (forLoopsWithCondition.contains(n.getId())) {
+                throw new IllegalStateException(
+                        "Continue attempted with a loop that has a condition. "
+                                + className + " " + n.getId());
+            }
+        } else {
+            printer.print("continue");
+        }
+        printer.print(";");
+    }
+
+    public void visit(DoStmt n, Object arg) {
+        printer.print("do ");
+        n.getBody().accept(this, arg);
+        printer.print(" while (");
+        n.getCondition().accept(this, arg);
+        printer.print(");");
+    }
+
+    public void visit(ForeachStmt n, Object arg) {
+        printer.print("for (");
+        n.getVariable().accept(this, arg);
+        printer.print(" : ");
+        n.getIterable().accept(this, arg);
+        printer.print(") ");
+        n.getBody().accept(this, arg);
+    }
+
+    public void visit(ForStmt n, Object arg) {
+        printer.print("for (");
+        if (n.getInit() != null) {
+            for (Iterator<Expression> i = n.getInit().iterator(); i.hasNext();) {
+                Expression e = i.next();
+                e.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        printer.print("; ");
+        if (n.getCompare() != null) {
+            n.getCompare().accept(this, arg);
+        }
+        printer.print("; ");
+        if (n.getUpdate() != null) {
+            for (Iterator<Expression> i = n.getUpdate().iterator(); i.hasNext();) {
+                Expression e = i.next();
+                e.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        printer.print(") ");
+        n.getBody().accept(this, arg);
+    }
+
+    public void visit(ThrowStmt n, Object arg) {
+        printer.print("throw ");
+        n.getExpr().accept(this, arg);
+        printer.print(";");
+    }
+
+    public void visit(SynchronizedStmt n, Object arg) {
+        printer.print("synchronized (");
+        n.getExpr().accept(this, arg);
+        printer.print(") ");
+        n.getBlock().accept(this, arg);
+    }
+
+    public void visit(TryStmt n, Object arg) {
+        printer.print("try ");
+        n.getTryBlock().accept(this, arg);
+        if (n.getCatchs() != null) {
+            for (CatchClause c : n.getCatchs()) {
+                c.accept(this, arg);
+            }
+        }
+        if (n.getFinallyBlock() != null) {
+            printer.print(" finally ");
+            n.getFinallyBlock().accept(this, arg);
+        }
+    }
+
+    public void visit(CatchClause n, Object arg) {
+        printer.print(" catch (");
+        n.getExcept().accept(this, arg);
+        printer.print(") ");
+        n.getCatchBlock().accept(this, arg);
+
+    }
+
+    public void visit(AnnotationDeclaration n, Object arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        currentAnnotations = n.getAnnotations();
+        // if (annotations != null) {
+        // for (AnnotationExpr a : annotations) {
+        // a.accept(this, arg);
+        // printer.printLn();
+        // }
+        // }
+        printModifiers(n.getModifiers());
+
+        printer.print("@interface ");
+        printer.print(n.getName());
+        currentAnnotations = null;
+        printer.printLn(" {");
+        printer.indent();
+        if (n.getMembers() != null) {
+            printMembers(n.getMembers(), arg);
+        }
+        printer.unindent();
+        printer.print("}");
+    }
+
+    public void visit(AnnotationMemberDeclaration n, Object arg) {
+        if (n.getJavaDoc() != null) {
+            n.getJavaDoc().accept(this, arg);
+        }
+        currentAnnotations = n.getAnnotations();
+        // if (annotations != null) {
+        // for (AnnotationExpr a : annotations) {
+        // a.accept(this, arg);
+        // printer.printLn();
+        // }
+        // }
+        printModifiers(n.getModifiers());
+
+        n.getType().accept(this, arg);
+        printer.print(" ");
+        printer.print(n.getName());
+        currentAnnotations = null;
+        printer.print("()");
+        if (n.getDefaultValue() != null) {
+            printer.print(" default ");
+            n.getDefaultValue().accept(this, arg);
+        }
+        printer.print(";");
+    }
+
+    public void visit(MarkerAnnotationExpr n, Object arg) {
+        printer.print("@");
+        n.getName().accept(this, arg);
+    }
+
+    public void visit(SingleMemberAnnotationExpr n, Object arg) {
+        printer.print("@");
+        n.getName().accept(this, arg);
+        printer.print("(");
+        n.getMemberValue().accept(this, arg);
+        printer.print(")");
+    }
+
+    public void visit(NormalAnnotationExpr n, Object arg) {
+        printer.print("@");
+        n.getName().accept(this, arg);
+        printer.print("(");
+        if (n.getPairs() != null) {
+            for (Iterator<MemberValuePair> i = n.getPairs().iterator(); i.hasNext();) {
+                MemberValuePair m = i.next();
+                m.accept(this, arg);
+                if (i.hasNext()) {
+                    printer.print(", ");
+                }
+            }
+        }
+        printer.print(")");
+    }
+
+    public void visit(MemberValuePair n, Object arg) {
+        printer.print(n.getName());
+        printer.print(" = ");
+        n.getValue().accept(this, arg);
+    }
+
+    public void visit(LineComment n, Object arg) {
+        printer.print("//");
+        printer.printLn(n.getContent());
+    }
+
+    public void visit(BlockComment n, Object arg) {
+        printer.print("/*");
+        printer.print(n.getContent());
+        printer.printLn("*/");
+    }
+
+    public void setLabels(Set<String> labels) {
+        this.labels = labels;
+    }
+
+}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/GkAtomParser.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/GkAtomParser.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/GkAtomParser.java
@@ -0,0 +1,70 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is HTML Parser C++ Translator code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Henri Sivonen <hsivonen@iki.fi>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+package nu.validator.htmlparser.cpptranslate;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.Reader;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class GkAtomParser {
+
+    private static final Pattern ATOM = Pattern.compile("^GK_ATOM\\(([^,]+),\\s*\"([^\"]*)\"\\).*$");
+    
+    private final BufferedReader reader;
+    
+    public GkAtomParser(Reader reader) {
+        this.reader = new BufferedReader(reader);
+    }
+    
+    public Map<String, String> parse() throws IOException {
+        Map<String, String> map = new HashMap<String, String>();
+        String line;
+        while((line = reader.readLine()) != null) {
+            Matcher m = ATOM.matcher(line);
+            if (m.matches()) {
+                map.put(m.group(2), m.group(1));
+            }
+        }
+        return map;
+    }
+    
+}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/HVisitor.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/HVisitor.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/HVisitor.java
@@ -0,0 +1,351 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is HTML Parser C++ Translator code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Henri Sivonen <hsivonen@iki.fi>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+package nu.validator.htmlparser.cpptranslate;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import japa.parser.ast.body.FieldDeclaration;
+import japa.parser.ast.body.MethodDeclaration;
+import japa.parser.ast.body.ModifierSet;
+import japa.parser.ast.body.VariableDeclarator;
+import japa.parser.ast.expr.IntegerLiteralExpr;
+import japa.parser.ast.expr.MethodCallExpr;
+import japa.parser.ast.stmt.BlockStmt;
+import japa.parser.ast.type.PrimitiveType;
+import japa.parser.ast.type.ReferenceType;
+import japa.parser.ast.type.Type;
+
+public class HVisitor extends CppVisitor {
+
+    private enum Visibility {
+        NONE, PRIVATE, PUBLIC, PROTECTED,
+    }
+
+    private Visibility previousVisibility = Visibility.NONE;
+
+    private List<String> defines = new LinkedList<String>();
+
+    private SourcePrinter arrayInitPrinter = new SourcePrinter();
+    private SourcePrinter mainPrinterHolder;
+
+    /**
+     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#printMethodNamespace()
+     */
+    @Override protected void printMethodNamespace() {
+    }
+
+    public HVisitor(CppTypes cppTypes, SymbolTable symbolTable) {
+        super(cppTypes, symbolTable);
+    }
+
+    /**
+     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#startClassDeclaration()
+     */
+    @Override protected void startClassDeclaration() {
+        printer.print("#ifndef ");        
+        printer.print(className);
+        printer.printLn("_h__");
+        printer.print("#define ");        
+        printer.print(className);
+        printer.printLn("_h__");
+        
+        printer.printLn();
+        
+        String[] incs = cppTypes.boilerplateIncludes(javaClassName);
+        for (int i = 0; i < incs.length; i++) {
+            String inc = incs[i];
+            if (className.equals(inc)) {
+                continue;
+            }
+            printer.print("#include \"");
+            printer.print(inc);
+            printer.printLn(".h\"");
+        }
+
+        printer.printLn();
+
+        String[] forwDecls = cppTypes.boilerplateForwardDeclarations();
+        for (int i = 0; i < forwDecls.length; i++) {
+            String decl = forwDecls[i];
+            printer.print("class ");
+            printer.print(decl);
+            printer.printLn(";");            
+        }
+        
+        printer.printLn();
+
+        for (int i = 0; i < Main.H_LIST.length; i++) {
+            String klazz = Main.H_LIST[i];
+            if (!(klazz.equals(javaClassName) || klazz.equals("StackNode"))) {
+                printer.print("class ");
+                printer.print(cppTypes.classPrefix());
+                printer.print(klazz);
+                printer.printLn(";");
+            }
+        }
+        
+        printer.printLn();
+        
+        String[] otherDecls = cppTypes.boilerplateDeclarations(javaClassName);
+        for (int i = 0; i < otherDecls.length; i++) {
+            String decl = otherDecls[i];
+            printer.printLn(decl);
+        }
+        
+        printer.printLn();
+
+        printer.print("class ");
+        printer.printLn(className);
+        printer.printLn("{");
+        printer.indent();
+        printer.indent();
+    }
+
+    /**
+     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#endClassDeclaration()
+     */
+    @Override protected void endClassDeclaration() {
+        printModifiers(ModifierSet.PUBLIC | ModifierSet.STATIC);
+        printer.printLn("void initializeStatics();");        
+        printModifiers(ModifierSet.PUBLIC | ModifierSet.STATIC);
+        printer.printLn("void releaseStatics();");        
+        
+        printer.unindent();
+        printer.unindent();
+        
+        if (cppTypes.hasSupplement(javaClassName)) {
+            printer.printLn();
+            printer.print("#include \"");
+            printer.print(className);
+            printer.printLn("HSupplement.h\"");
+        }
+        
+        printer.printLn("};");
+        printer.printLn();
+
+        // This stuff should probably go into the .cpp anyway. sigh.
+        printer.print("#ifdef ");
+        printer.print(className);
+        printer.printLn("_cpp__");
+        printer.print(arrayInitPrinter.getSource());
+        printer.printLn("#endif");
+        printer.printLn();
+        
+        for (String define : defines) {
+            printer.printLn(define);
+        }
+        
+        printer.printLn();
+        printer.printLn();
+        printer.printLn("#endif");
+    }
+
+    /**
+     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#printModifiers(int)
+     */
+    @Override protected void printModifiers(int modifiers) {
+        if (ModifierSet.isPrivate(modifiers)) {
+            if (previousVisibility != Visibility.PRIVATE) {
+                printer.unindent();
+                printer.printLn("private:");
+                printer.indent();
+                previousVisibility = Visibility.PRIVATE;
+            }
+        } else if (ModifierSet.isProtected(modifiers)) {
+            if (previousVisibility != Visibility.PROTECTED) {
+                printer.unindent();
+                printer.printLn("protected:");
+                printer.indent();
+                previousVisibility = Visibility.PROTECTED;
+            }
+        } else {
+            if (previousVisibility != Visibility.PUBLIC) {
+                printer.unindent();
+                printer.printLn("public:");
+                printer.indent();
+                previousVisibility = Visibility.PUBLIC;
+            }
+        }
+        if (inline()) {
+            printer.print("inline ");            
+        }
+        if (virtual()) {
+            printer.print("virtual ");            
+        }
+        if (ModifierSet.isStatic(modifiers)) {
+            printer.print("static ");
+        }
+    }
+
+    /**
+     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#fieldDeclaration(japa.parser.ast.body.FieldDeclaration, java.lang.Object)
+     */
+    @Override protected void fieldDeclaration(FieldDeclaration n, Object arg) {
+        int modifiers = n.getModifiers();
+        List<VariableDeclarator> variables = n.getVariables();
+        VariableDeclarator declarator = variables.get(0);
+        if (ModifierSet.isStatic(modifiers) && ModifierSet.isFinal(modifiers)
+                && n.getType() instanceof PrimitiveType) {
+            PrimitiveType type = (PrimitiveType) n.getType();
+            if (type.getType() != PrimitiveType.Primitive.Int) {
+                throw new IllegalStateException(
+                        "Only int constant #defines supported.");
+            }
+            if (variables.size() != 1) {
+                throw new IllegalStateException(
+                        "More than one variable declared by one declarator.");
+            }
+            String name = javaClassName + "." + declarator.getId().getName();
+            String value = declarator.getInit().toString();
+            if ("Integer.MAX_VALUE".equals(value)) {
+                value = cppTypes.maxInteger();
+            }
+            String longName = definePrefix + declarator.getId().getName();
+            if (symbolTable.cppDefinesByJavaNames.containsKey(name)) {
+                throw new IllegalStateException(
+                        "Duplicate #define constant local name: " + name);
+            }
+            symbolTable.cppDefinesByJavaNames.put(name, longName);
+            defines.add("#define " + longName + " " + value);
+        } else {
+            if (n.getType() instanceof ReferenceType) {
+                ReferenceType rt = (ReferenceType) n.getType();
+                currentArrayCount = rt.getArrayCount();
+                if (currentArrayCount > 0
+                        && (rt.getType() instanceof PrimitiveType) && declarator.getInit() != null) {
+                    if (!ModifierSet.isStatic(modifiers)) {
+                        throw new IllegalStateException(
+                                "Non-static array case not supported here." + declarator);
+                    }
+                    if (noLength()) {
+                        inPrimitiveNoLengthFieldDeclarator = true;
+                        
+                        mainPrinterHolder = printer;
+                        printer = arrayInitPrinter;
+                        n.getType().accept(this, arg);
+                        printer.print(" ");
+                        printer.print(className);
+                        printer.print("::");
+                        declarator.getId().accept(this, arg);
+
+                        printer.print(" = ");                    
+                        
+                        declarator.getInit().accept(this, arg);
+                       
+                        printer.printLn(";");                    
+                        printer = mainPrinterHolder;                        
+                    } else if (!isNonToCharArrayMethodCall(declarator.getInit())) {
+                        mainPrinterHolder = printer;
+                        printer = arrayInitPrinter;
+                        
+                        printer.print(cppTypes.arrayTemplate());
+                        printer.print("<");
+                        suppressPointer = true;
+                        rt.getType().accept(this, arg);
+                        suppressPointer = false;
+                        printer.print(",");
+                        printer.print(cppTypes.intType());
+                        printer.print("> ");
+                        printer.print(className);
+                        printer.print("::");
+                        declarator.getId().accept(this, arg);
+                        printer.printLn(" = 0;");                    
+                        
+                        printer = mainPrinterHolder;    
+                                            }
+                } else if (ModifierSet.isStatic(modifiers)) {
+                    mainPrinterHolder = printer;
+                    printer = arrayInitPrinter;
+
+                    n.getType().accept(this, arg);
+                    printer.print(" ");
+                    printer.print(className);
+                    printer.print("::");
+                    if ("AttributeName".equals(n.getType().toString())) {
+                        printer.print("ATTR_");
+                    } else if ("ElementName".equals(n.getType().toString())) {
+                        printer.print("ELT_");
+                    }
+                    declarator.getId().accept(this, arg);
+                    printer.print(" = ");
+                    printer.print(cppTypes.nullLiteral());
+                    printer.printLn(";");
+                    
+                    printer = mainPrinterHolder;    
+                }
+            }
+            printModifiers(modifiers);
+            n.getType().accept(this, arg);
+            printer.print(" ");
+            if (ModifierSet.isStatic(modifiers)) {
+                if ("AttributeName".equals(n.getType().toString())) {
+                    printer.print("ATTR_");
+                } else if ("ElementName".equals(n.getType().toString())) {
+                    printer.print("ELT_");
+                }
+            }
+            declarator.getId().accept(this, arg);
+            printer.printLn(";");
+            currentArrayCount = 0;
+            inPrimitiveNoLengthFieldDeclarator = false;
+        }
+    }
+
+    /**
+     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#printConstructorBody(japa.parser.ast.stmt.BlockStmt, java.lang.Object)
+     */
+    @Override protected void printConstructorBody(BlockStmt block, Object arg) {
+        printer.printLn(";");
+    }
+
+    /**
+     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#visit(japa.parser.ast.body.MethodDeclaration, java.lang.Object)
+     */
+    @Override public void visit(MethodDeclaration n, Object arg) {
+        printMethodDeclaration(n, arg);
+    }
+
+    /**
+     * @see nu.validator.htmlparser.cpptranslate.CppVisitor#inHeader()
+     */
+    @Override protected boolean inHeader() {
+        return true;
+    }
+
+}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LabelVisitor.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LabelVisitor.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LabelVisitor.java
@@ -0,0 +1,84 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is HTML Parser C++ Translator code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Henri Sivonen <hsivonen@iki.fi>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+package nu.validator.htmlparser.cpptranslate;
+
+import japa.parser.ast.stmt.BreakStmt;
+import japa.parser.ast.stmt.ContinueStmt;
+import japa.parser.ast.visitor.VoidVisitorAdapter;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public class LabelVisitor extends VoidVisitorAdapter<Object> {
+
+    private final Set<String> labels = new HashSet<String>();
+    
+    public LabelVisitor() {
+    }
+
+    /**
+     * @see japa.parser.ast.visitor.VoidVisitorAdapter#visit(japa.parser.ast.stmt.BreakStmt, java.lang.Object)
+     */
+    @Override
+    public void visit(BreakStmt n, Object arg) {
+        String label = n.getId();
+        if (label != null) {
+            labels.add(label + "_end");
+        }
+    }
+
+    /**
+     * @see japa.parser.ast.visitor.VoidVisitorAdapter#visit(japa.parser.ast.stmt.ContinueStmt, java.lang.Object)
+     */
+    @Override
+    public void visit(ContinueStmt n, Object arg) {
+        String label = n.getId();
+        if (label != null) {
+            labels.add(label);
+        }
+    }
+
+    /**
+     * Returns the labels.
+     * 
+     * @return the labels
+     */
+    public Set<String> getLabels() {
+        return labels;
+    }
+}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LicenseExtractor.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LicenseExtractor.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/LicenseExtractor.java
@@ -0,0 +1,75 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is HTML Parser C++ Translator code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Henri Sivonen <hsivonen@iki.fi>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+package nu.validator.htmlparser.cpptranslate;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.Reader;
+
+public class LicenseExtractor {
+
+    private final Reader reader;
+    
+    public LicenseExtractor(File file) throws IOException {
+        this.reader = new InputStreamReader(new FileInputStream(file), "utf-8");
+    }
+    
+    public String extract() throws IOException {
+        boolean prevWasAsterisk = false;
+        StringBuilder sb = new StringBuilder();
+        int c;
+        while ((c = reader.read()) != -1) {
+            sb.append((char)c);
+            switch (c) {
+                case '*':
+                    prevWasAsterisk = true;
+                    continue;
+                case '/':
+                    if (prevWasAsterisk) {
+                        return sb.toString();                        
+                    }
+                default:
+                    prevWasAsterisk = false;
+                    continue;
+            }
+        }
+        return "";
+    }
+}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/Main.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/Main.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/Main.java
@@ -0,0 +1,137 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is HTML Parser C++ Translator code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Henri Sivonen <hsivonen@iki.fi>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+package nu.validator.htmlparser.cpptranslate;
+
+import japa.parser.JavaParser;
+import japa.parser.ParseException;
+import japa.parser.ast.CompilationUnit;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
+
+public class Main {
+
+    static final String[] H_LIST = {
+        "Tokenizer",
+        "TreeBuilder",
+        "MetaScanner",
+        "AttributeName",
+        "ElementName",
+        "HtmlAttributes",
+        "StackNode",
+        "UTF16Buffer",
+        "StateSnapshot",
+        "Portability",
+    };
+    
+    private static final String[] CPP_LIST = {
+        "Tokenizer",
+        "TreeBuilder",
+        "MetaScanner",
+        "AttributeName",
+        "ElementName",
+        "HtmlAttributes",
+        "StackNode",
+        "UTF16Buffer",
+        "StateSnapshot",
+    };
+    
+    /**
+     * @param args
+     * @throws ParseException 
+     * @throws IOException 
+     */
+    public static void main(String[] args) throws ParseException, IOException {
+        CppTypes cppTypes = new CppTypes(new File(args[2]));
+        SymbolTable symbolTable = new SymbolTable();
+        
+        File javaDirectory = new File(args[0]);
+        File targetDirectory = new File(args[1]);
+        File cppDirectory = targetDirectory;
+        File javaCopyDirectory = new File(targetDirectory, "javasrc");
+        
+        for (int i = 0; i < H_LIST.length; i++) {
+            parseFile(cppTypes, javaDirectory, cppDirectory, H_LIST[i], ".h", new HVisitor(cppTypes, symbolTable));
+            copyFile(new File(javaDirectory, H_LIST[i] + ".java"), new File(javaCopyDirectory, H_LIST[i] + ".java"));
+        }
+        for (int i = 0; i < CPP_LIST.length; i++) {
+            parseFile(cppTypes, javaDirectory, cppDirectory, CPP_LIST[i], ".cpp", new CppVisitor(cppTypes, symbolTable));
+        }
+        cppTypes.finished();
+    }
+
+    private static void copyFile(File input, File output) throws IOException {
+        if (input.getCanonicalFile().equals(output.getCanonicalFile())) {
+            return; // files are the same!
+        }
+        // This is horribly inefficient, but perf is not really much of a concern here.
+        FileInputStream in = new FileInputStream(input);
+        FileOutputStream out = new FileOutputStream(output);
+        int b;
+        while ((b = in.read()) != -1) {
+            out.write(b);
+        }
+        out.flush();
+        out.close();
+        in.close();
+    }
+    
+    private static void parseFile(CppTypes cppTypes, File javaDirectory, File cppDirectory, String className, String fne, CppVisitor visitor) throws ParseException,
+            FileNotFoundException, UnsupportedEncodingException, IOException {
+        File file = new File(javaDirectory, className + ".java");
+        String license = new LicenseExtractor(file).extract();
+        CompilationUnit cu = JavaParser.parse(new NoCppInputStream(new FileInputStream(file)), "utf-8");
+        LabelVisitor labelVisitor = new LabelVisitor();
+        cu.accept(labelVisitor, null);
+        visitor.setLabels(labelVisitor.getLabels());
+        cu.accept(visitor, null);
+        FileOutputStream out = new FileOutputStream(new File(cppDirectory, cppTypes.classPrefix() + className + fne));
+        OutputStreamWriter w = new OutputStreamWriter(out, "utf-8");
+        w.write(license);
+        w.write("\n\n/*\n * THIS IS A GENERATED FILE. PLEASE DO NOT EDIT.\n * Please edit " + className + ".java instead and regenerate.\n */\n\n");
+        w.write(visitor.getSource());
+        w.close();
+    }
+
+}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/NoCppInputStream.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/NoCppInputStream.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/NoCppInputStream.java
@@ -0,0 +1,86 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is HTML Parser C++ Translator code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Henri Sivonen <hsivonen@iki.fi>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+package nu.validator.htmlparser.cpptranslate;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+public class NoCppInputStream extends InputStream {
+
+    private final static char[] START = "[NOCPP[".toCharArray();
+    
+    private final static char[] END = "]NOCPP]".toCharArray();
+    
+    private int state;
+    
+    private final InputStream delegate;
+    
+    
+    
+    /**
+     * @param delegate
+     */
+    public NoCppInputStream(InputStream delegate) {
+        this.delegate = delegate;
+        this.state = 0;
+    }
+
+    @Override public int read() throws IOException {
+        int c;
+        if (state == START.length) {
+            int endState = 0;
+            while (endState != END.length) {
+                c = delegate.read();
+                if (END[endState] == c) {
+                    endState++;
+                } else {
+                    endState = 0;
+                }
+            }
+            state = 0;
+        }
+        c = delegate.read();
+        if (START[state] == c) {
+            state++;
+        } else {
+            state = 0;
+        }
+        return c;
+    }
+
+}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/StringLiteralParser.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/StringLiteralParser.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/StringLiteralParser.java
@@ -0,0 +1,70 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is HTML Parser C++ Translator code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Henri Sivonen <hsivonen@iki.fi>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+package nu.validator.htmlparser.cpptranslate;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.Reader;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class StringLiteralParser {
+
+    private static final Pattern STRING_DECL = Pattern.compile("^.*\\(([^ ]+) = new nsString\\(\\)\\)->Assign\\(NS_LITERAL_STRING\\(\"([^\"]*)\"\\)\\);.*$");
+    
+    private final BufferedReader reader;
+    
+    public StringLiteralParser(Reader reader) {
+        this.reader = new BufferedReader(reader);
+    }
+    
+    public Map<String, String> parse() throws IOException {
+        Map<String, String> map = new HashMap<String, String>();
+        String line;
+        while((line = reader.readLine()) != null) {
+            Matcher m = STRING_DECL.matcher(line);
+            if (m.matches()) {
+                map.put(m.group(2), m.group(1));
+            }
+        }
+        return map;
+    }
+    
+}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/SymbolTable.java b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/SymbolTable.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/src/nu/validator/htmlparser/cpptranslate/SymbolTable.java
@@ -0,0 +1,60 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is HTML Parser C++ Translator code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Henri Sivonen <hsivonen@iki.fi>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+package nu.validator.htmlparser.cpptranslate;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class SymbolTable {
+
+    public final Map<String, String> cppDefinesByJavaNames = new HashMap<String, String>();
+
+    /**
+     * This is a sad hack to work around the fact the there's no real symbol
+     * table yet.
+     * 
+     * @param name
+     * @return
+     */
+    public boolean isNotAnAttributeOrElementName(String name) {
+        return !("ATTRIBUTE_HASHES".equals(name)
+                || "ATTRIBUTE_NAMES".equals(name)
+                || "ELEMENT_HASHES".equals(name)
+                || "ELEMENT_NAMES".equals(name) || "ALL_NO_NS".equals(name));
+    }
+}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/generator/GenerateNamedCharacters.java b/parser/html/java/translator/src/nu/validator/htmlparser/generator/GenerateNamedCharacters.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/src/nu/validator/htmlparser/generator/GenerateNamedCharacters.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2008 Mozilla Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in 
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+package nu.validator.htmlparser.generator;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class GenerateNamedCharacters {
+
+    private static final int LEAD_OFFSET = 0xD800 - (0x10000 >> 10);
+    
+    private static final Pattern LINE_PATTERN = Pattern.compile("^\\s*<tr> <td> <code title=\"\">([^<]*)</code> </td> <td> U\\+(\\S*) </td> </tr>.*$");
+    
+    private static String toUString(int c) {
+        String hexString = Integer.toHexString(c);
+        switch (hexString.length()) {
+            case 1:
+                return "\\u000" + hexString;
+            case 2:
+                return "\\u00" + hexString;
+            case 3:
+                return "\\u0" + hexString;
+            case 4:
+                return "\\u" + hexString;
+            default:
+                throw new RuntimeException("Unreachable.");
+        }
+    }
+
+    
+    /**
+     * @param args
+     * @throws IOException 
+     */
+    public static void main(String[] args) throws IOException {
+        TreeMap<String, String> entities = new TreeMap<String, String>();
+        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in, "utf-8"));
+        String line;
+        while ((line = reader.readLine()) != null) {
+            Matcher m = LINE_PATTERN.matcher(line);
+            if (m.matches()) {
+                entities.put(m.group(1), m.group(2));
+            }
+        }
+        System.out.println("static final char[][] NAMES = {");
+        for (Map.Entry<String, String> entity : entities.entrySet()) {
+            String name = entity.getKey();
+            System.out.print("\"");
+            System.out.print(name);
+            System.out.println("\".toCharArray(),");
+        }
+        System.out.println("};");
+
+        System.out.println("static final @NoLength char[][] VALUES = {");
+        for (Map.Entry<String, String> entity : entities.entrySet()) {
+            String value = entity.getValue();
+            int intVal = Integer.parseInt(value, 16);
+            System.out.print("{");
+            if (intVal == '\'') {
+                System.out.print("\'\\\'\'");                
+            } else if (intVal == '\n') {
+                System.out.print("\'\\n\'");                
+            } else if (intVal == '\\') {
+                System.out.print("\'\\\\\'");                
+            } else if (intVal <= 0xFFFF) {
+                System.out.print("\'");                
+                System.out.print(toUString(intVal));                                
+                System.out.print("\'");                
+            } else {
+                int hi = (LEAD_OFFSET + (intVal >> 10));
+                int lo = (0xDC00 + (intVal & 0x3FF));
+                System.out.print("\'");                
+                System.out.print(toUString(hi));                                
+                System.out.print("\', \'");                
+                System.out.print(toUString(lo));                                
+                System.out.print("\'");                
+            }
+            System.out.println("},");
+        }
+        System.out.println("};");
+
+    }
+
+}
diff --git a/parser/html/java/translator/src/nu/validator/htmlparser/generator/GenerateNamedCharactersCpp.java b/parser/html/java/translator/src/nu/validator/htmlparser/generator/GenerateNamedCharactersCpp.java
new file mode 100644
--- /dev/null
+++ b/parser/html/java/translator/src/nu/validator/htmlparser/generator/GenerateNamedCharactersCpp.java
@@ -0,0 +1,295 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is HTML Parser C++ Translator code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Henri Sivonen <hsivonen@iki.fi>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+package nu.validator.htmlparser.generator;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import nu.validator.htmlparser.cpptranslate.CppTypes;
+
+public class GenerateNamedCharactersCpp {
+
+    private static final int LEAD_OFFSET = 0xD800 - (0x10000 >> 10);
+
+    private static final Pattern LINE_PATTERN = Pattern.compile("^\\s*<tr> <td> <code title=\"\">([^<]*)</code> </td> <td> U\\+(\\S*) </td> </tr>.*$");
+
+    private static String toHexString(int c) {
+        String hexString = Integer.toHexString(c);
+        switch (hexString.length()) {
+            case 1:
+                return "0x000" + hexString;
+            case 2:
+                return "0x00" + hexString;
+            case 3:
+                return "0x0" + hexString;
+            case 4:
+                return "0x" + hexString;
+            default:
+                throw new RuntimeException("Unreachable.");
+        }
+    }
+
+    /**
+     * @param args
+     * @throws IOException
+     */
+    public static void main(String[] args) throws IOException {
+        TreeMap<String, String> entities = new TreeMap<String, String>();
+        BufferedReader reader = new BufferedReader(new InputStreamReader(
+                new FileInputStream(args[0]), "utf-8"));
+        String line;
+        while ((line = reader.readLine()) != null) {
+            Matcher m = LINE_PATTERN.matcher(line);
+            if (m.matches()) {
+                entities.put(m.group(1), m.group(2));
+            }
+        }
+
+        CppTypes cppTypes = new CppTypes(null);
+        File targetDirectory = new File(args[1]);
+
+        generateH(targetDirectory, cppTypes, entities);
+        generateCpp(targetDirectory, cppTypes, entities);
+    }
+
+    private static void generateH(File targetDirectory, CppTypes cppTypes,
+            Map<String, String> entities) throws IOException {
+        File hFile = new File(targetDirectory, cppTypes.classPrefix()
+                + "NamedCharacters.h");
+        Writer out = new OutputStreamWriter(new FileOutputStream(hFile),
+                "utf-8");
+        out.write("#ifndef " + cppTypes.classPrefix() + "NamedCharacters_h__\n");
+        out.write("#define " + cppTypes.classPrefix() + "NamedCharacters_h__\n");
+        out.write('\n');
+
+        String[] includes = cppTypes.namedCharactersIncludes();
+        for (int i = 0; i < includes.length; i++) {
+            String include = includes[i];
+            out.write("#include \"" + include + ".h\"\n");
+        }
+
+        out.write('\n');
+
+        out.write("class " + cppTypes.classPrefix() + "NamedCharacters\n");
+        out.write("{\n");
+        out.write("  public:\n");
+        out.write("    static " + cppTypes.arrayTemplate() + "<"
+                + cppTypes.arrayTemplate() + "<" + cppTypes.charType() + ","
+                + cppTypes.intType() + ">," + cppTypes.intType() + "> NAMES;\n");
+        out.write("    static " + cppTypes.arrayTemplate() + "<"
+                + cppTypes.charType() + "," + cppTypes.intType()
+                + ">* VALUES;\n");
+        out.write("    static " + cppTypes.charType() + "** WINDOWS_1252;\n");
+        out.write("    static void initializeStatics();\n");
+        out.write("    static void releaseStatics();\n");
+        out.write("};\n");
+
+        out.write("\n#endif // " + cppTypes.classPrefix()
+                + "NamedCharacters_h__\n");
+        out.flush();
+        out.close();
+    }
+
+    private static void generateCpp(File targetDirectory, CppTypes cppTypes,
+            Map<String, String> entities) throws IOException {
+        File hFile = new File(targetDirectory, cppTypes.classPrefix()
+                + "NamedCharacters.cpp");
+        Writer out = new OutputStreamWriter(new FileOutputStream(hFile),
+                "utf-8");
+
+        out.write("#define " + cppTypes.classPrefix()
+                + "NamedCharacters_cpp__\n");
+
+        String[] includes = cppTypes.namedCharactersIncludes();
+        for (int i = 0; i < includes.length; i++) {
+            String include = includes[i];
+            out.write("#include \"" + include + ".h\"\n");
+        }
+
+        out.write('\n');
+        out.write("#include \"" + cppTypes.classPrefix()
+                + "NamedCharacters.h\"\n");
+        out.write("\n");
+
+        out.write("" + cppTypes.arrayTemplate() + "<"
+                + cppTypes.arrayTemplate() + "<" + cppTypes.charType() + ","
+                + cppTypes.intType() + ">," + cppTypes.intType() + "> "
+                + cppTypes.classPrefix() + "NamedCharacters::NAMES;\n");
+
+        out.write("static " + cppTypes.charType() + " const WINDOWS_1252_DATA[] = {\n");
+        out.write("  0x20AC,\n");
+        out.write("  0xFFFD,\n");
+        out.write("  0x201A,\n");
+        out.write("  0x0192,\n");
+        out.write("  0x201E,\n");
+        out.write("  0x2026,\n");
+        out.write("  0x2020,\n");
+        out.write("  0x2021,\n");
+        out.write("  0x02C6,\n");
+        out.write("  0x2030,\n");
+        out.write("  0x0160,\n");
+        out.write("  0x2039,\n");
+        out.write("  0x0152,\n");
+        out.write("  0xFFFD,\n");
+        out.write("  0x017D,\n");
+        out.write("  0xFFFD,\n");
+        out.write("  0xFFFD,\n");
+        out.write("  0x2018,\n");
+        out.write("  0x2019,\n");
+        out.write("  0x201C,\n");
+        out.write("  0x201D,\n");
+        out.write("  0x2022,\n");
+        out.write("  0x2013,\n");
+        out.write("  0x2014,\n");
+        out.write("  0x02DC,\n");
+        out.write("  0x2122,\n");
+        out.write("  0x0161,\n");
+        out.write("  0x203A,\n");
+        out.write("  0x0153,\n");
+        out.write("  0xFFFD,\n");
+        out.write("  0x017E,\n");
+        out.write("  0x0178\n");
+        out.write("};\n");
+
+        int k = 0;
+        for (Map.Entry<String, String> entity : entities.entrySet()) {
+            String name = entity.getKey();
+            int value = Integer.parseInt(entity.getValue(), 16);
+
+            out.write("static " + cppTypes.charType() + " const NAME_" + k
+                    + "[] = {\n");
+            out.write("  ");
+
+            for (int j = 0; j < name.length(); j++) {
+                char c = name.charAt(j);
+                if (j != 0) {
+                    out.write(", ");
+                }
+                out.write('\'');
+                out.write(c);
+                out.write('\'');
+            }
+
+            out.write("\n};\n");
+
+            out.write("static " + cppTypes.charType() + " const VALUE_" + k
+                    + "[] = {\n");
+            out.write("  ");
+
+            if (value <= 0xFFFF) {
+                out.write(toHexString(value));
+            } else {
+                int hi = (LEAD_OFFSET + (value >> 10));
+                int lo = (0xDC00 + (value & 0x3FF));
+                out.write(toHexString(hi));
+                out.write(", ");
+                out.write(toHexString(lo));
+            }
+
+            out.write("\n};\n");
+
+            k++;
+        }
+
+        out.write("\n// XXX bug 501082: for some reason, msvc takes forever to optimize this function\n");
+        out.write("#ifdef _MSC_VER\n");
+        out.write("#pragma optimize(\"\", off)\n");
+        out.write("#endif\n\n");
+        
+        out.write("void\n");
+        out.write(cppTypes.classPrefix()
+                + "NamedCharacters::initializeStatics()\n");
+        out.write("{\n");
+        out.write("  NAMES = " + cppTypes.arrayTemplate() + "<"
+                + cppTypes.arrayTemplate() + "<" + cppTypes.charType() + ","
+                + cppTypes.intType() + ">," + cppTypes.intType() + ">("
+                + entities.size() + ");\n");
+        int i = 0;
+        for (Map.Entry<String, String> entity : entities.entrySet()) {
+            out.write("  NAMES[" + i + "] = " + cppTypes.arrayTemplate() + "<"
+                    + cppTypes.charType() + "," + cppTypes.intType() + ">(("
+                    + cppTypes.charType() + "*)NAME_" + i + ", "
+                    + entity.getKey().length() + ");\n");
+            i++;
+        }
+        out.write("  VALUES = new " + cppTypes.arrayTemplate() + "<"
+                + cppTypes.charType() + "," + cppTypes.intType() + ">["
+                + entities.size() + "];\n");
+        i = 0;
+        for (Map.Entry<String, String> entity : entities.entrySet()) {
+            int value = Integer.parseInt(entity.getValue(), 16);
+            out.write("  VALUES[" + i + "] = " + cppTypes.arrayTemplate() + "<"
+                    + cppTypes.charType() + "," + cppTypes.intType() + ">(("
+                    + cppTypes.charType() + "*)VALUE_" + i + ", "
+                    + ((value <= 0xFFFF) ? "1" : "2") + ");\n");
+            i++;
+        }
+        out.write("\n");
+        out.write("  WINDOWS_1252 = new " + cppTypes.charType() + "*[32];\n");
+        out.write("  for (" + cppTypes.intType() + " i = 0; i < 32; ++i) {\n");
+        out.write("    WINDOWS_1252[i] = (" + cppTypes.charType() + "*)&(WINDOWS_1252_DATA[i]);\n");
+        out.write("  }\n");
+        out.write("}\n");
+        out.write("\n");
+
+        out.write("#ifdef _MSC_VER\n");
+        out.write("#pragma optimize(\"\", on)\n");
+        out.write("#endif\n\n");
+        
+        out.write("void\n");
+        out.write(cppTypes.classPrefix()
+                + "NamedCharacters::releaseStatics()\n");
+        out.write("{\n");
+        out.write("  NAMES.release();\n");
+        out.write("  delete[] VALUES;\n");
+        out.write("  delete[] WINDOWS_1252;\n");
+        out.write("}\n");
+        out.flush();
+        out.close();
+    }
+}
diff --git a/parser/html/javasrc b/parser/html/javasrc
new file mode 120000
--- /dev/null
+++ b/parser/html/javasrc
@@ -0,0 +1,1 @@
+java/htmlparser/src
\ No newline at end of file
