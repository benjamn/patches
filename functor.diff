* * *
* * *

diff --git a/xpcom/glue/Bind.h b/xpcom/glue/Bind.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/Bind.h
@@ -0,0 +1,201 @@
+#ifndef Bind_h__
+#define Bind_h__
+
+#include "Functor.h"
+
+// [[[cog
+// from cogutil import tlist, MAX_FUNCTOR_ARITY
+// rng = range(MAX_FUNCTOR_ARITY+1)
+// ijs = zip(rng, rng[1:])
+// ]]]
+// [[[end]]]
+
+#define COOPT(N) typedef typename Outgoing::P##N P##N
+#define Pp(N) P##N p##N
+#define COOPT_OUTGOING_PARAM_TYPEDEFS(N) JOIN##N(COOPT,SEMI)
+
+template <typename Result, typename Params, typename Bound>
+class Binder
+  : public FunctorImpl<Result, typename Params::Tail>
+{
+public:
+  typedef Functor<Result, Params> Incoming;
+  typedef typename Incoming::ResultType ResultType;
+  typedef Functor<Result, typename Params::Tail> Outgoing;
+
+  COOPT_OUTGOING_PARAM_TYPEDEFS(16);
+
+  Binder(const Incoming& fun, Bound bound)
+    : mFun(fun)
+    , mBound(bound)
+  {}
+
+  #define cp(N) , p##N
+  #define DECL_BINDER_CALL_OP(N)                                              \
+    ResultType operator()(JOIN##N(Pp,COMMA)) {                                \
+      return mFun(mBound JOIN##N(cp,EMPTY));                                  \
+    }
+  JOIN16(DECL_BINDER_CALL_OP,EMPTY)
+  #undef DECL_BINDER_CALL_OP
+  #undef cp
+
+private:
+  Incoming mFun;
+  Bound mBound;
+};
+
+#define p(N) p##N
+
+template <typename NewResult, typename ParentFunctor>
+class ResultBinder
+  : public FunctorImpl<NewResult, typename ParentFunctor::ParamList>
+{
+public:
+  typedef ParentFunctor Incoming;
+  typedef NewResult ResultType;
+  typedef Functor<NewResult, typename ParentFunctor::ParamList>
+          Outgoing;
+
+  COOPT_OUTGOING_PARAM_TYPEDEFS(16);
+
+  ResultBinder(const Incoming& fun, NewResult bound)
+    : mFun(fun)
+    , mBound(bound)
+  {}
+
+  #define DECL_RESULT_BINDER_CALL_OP(N)                                       \
+    NewResult operator()(JOIN##N(Pp,COMMA)) {                                 \
+      mFun(JOIN##N(p,COMMA));                                                 \
+      return mBound;                                                          \
+    }
+  JOIN16(DECL_RESULT_BINDER_CALL_OP,EMPTY)
+  #undef DECL_RESULT_BINDER_CALL_OP
+
+private:
+  Incoming mFun;
+  NewResult mBound;
+};
+
+template <typename ParentFunctor>
+class ResultBinder<void, ParentFunctor>
+  : public FunctorImpl<void, typename ParentFunctor::ParamList>
+{
+public:
+  typedef ParentFunctor Incoming;
+  typedef void ResultType;
+  typedef Functor<void, typename ParentFunctor::ParamList>
+          Outgoing;
+
+  COOPT_OUTGOING_PARAM_TYPEDEFS(16);
+
+  ResultBinder(const Incoming& fun)
+    : mFun(fun)
+  {}
+
+  #define DECL_VOID_RESULT_BINDER_CALL_OP(N)                                  \
+    void operator()(JOIN##N(Pp,COMMA)) {                                      \
+      mFun(JOIN##N(p,COMMA));                                                 \
+    }
+  JOIN16(DECL_VOID_RESULT_BINDER_CALL_OP,EMPTY)
+  #undef DECL_VOID_RESULT_BINDER_CALL_OP
+
+private:
+  Incoming mFun;
+};
+
+// Used in the ResultBinder classes, now no longer needed:
+#undef p
+// Used in every *Binder class, now no longer needed:
+#undef Pp
+#undef COOPT
+
+
+template <typename Result, class Params, typename Bound>
+typename Binder<Result, Params, Bound>::Outgoing
+bind(Functor<Result, Params> fun, Bound bound) {
+  typedef Binder<Result, Params, Bound> B;
+  typedef typename B::Outgoing O;
+  typedef typename O::ImplType I;
+  I* binder = new B(fun, bound);
+  return O(binder);
+}
+
+template <typename NewResult, typename Functor>
+typename ResultBinder<NewResult, Functor>::Outgoing
+bind_result(Functor fun, NewResult bound) {
+  typedef ResultBinder<NewResult, Functor> B;
+  typedef typename B::Outgoing O;
+  typedef typename O::ImplType I;
+  I* binder = new B(fun, bound);
+  return O(binder);
+}
+
+template <typename Functor>
+typename ResultBinder<void, Functor>::Outgoing
+void_result(Functor fun) {
+  typedef ResultBinder<void, Functor> B;
+  typedef typename B::Outgoing O;
+  typedef typename O::ImplType I;
+  I* binder = new B(fun);
+  return O(binder);
+}
+
+
+#define BIND1(F, A) bind(functor(F), A)
+
+// [[[cog
+// slash = "\\"
+// for (i, j) in ijs[1:]:
+//   alist = tlist("A", j)
+//   ainit = tlist("A", i)
+//   alast = "A%d" % j;
+//   cog.out(r"""
+// #define BIND%(j)d(F, %(alist)s) %(slash)s
+//    bind(BIND%(i)d(F, %(ainit)s), %(alast)s)
+// """ % locals())
+// ]]]
+
+#define BIND2(F, A1, A2) \
+   bind(BIND1(F, A1), A2)
+
+#define BIND3(F, A1, A2, A3) \
+   bind(BIND2(F, A1, A2), A3)
+
+#define BIND4(F, A1, A2, A3, A4) \
+   bind(BIND3(F, A1, A2, A3), A4)
+
+#define BIND5(F, A1, A2, A3, A4, A5) \
+   bind(BIND4(F, A1, A2, A3, A4), A5)
+
+#define BIND6(F, A1, A2, A3, A4, A5, A6) \
+   bind(BIND5(F, A1, A2, A3, A4, A5), A6)
+
+#define BIND7(F, A1, A2, A3, A4, A5, A6, A7) \
+   bind(BIND6(F, A1, A2, A3, A4, A5, A6), A7)
+
+#define BIND8(F, A1, A2, A3, A4, A5, A6, A7, A8) \
+   bind(BIND7(F, A1, A2, A3, A4, A5, A6, A7), A8)
+
+#define BIND9(F, A1, A2, A3, A4, A5, A6, A7, A8, A9) \
+   bind(BIND8(F, A1, A2, A3, A4, A5, A6, A7, A8), A9)
+
+#define BIND10(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) \
+   bind(BIND9(F, A1, A2, A3, A4, A5, A6, A7, A8, A9), A10)
+
+#define BIND11(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) \
+   bind(BIND10(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), A11)
+
+#define BIND12(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) \
+   bind(BIND11(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), A12)
+
+#define BIND13(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) \
+   bind(BIND12(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), A13)
+
+#define BIND14(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) \
+   bind(BIND13(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), A14)
+
+#define BIND15(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) \
+   bind(BIND14(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), A15)
+// [[[end]]]
+
+#endif
\ No newline at end of file
diff --git a/xpcom/glue/Functor.h b/xpcom/glue/Functor.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/Functor.h
@@ -0,0 +1,292 @@
+#ifndef Functor_h__
+#define Functor_h__
+
+#include "nsISupports.h"
+#include "nsIRunnable.h"
+#include "nsAutoPtr.h"
+#include "TList.h"
+#include "Join.h"
+
+class FunctorSupports : public nsISupports {
+public:
+  // nsISupports implementation must be inlined so that this file can be
+  // included across modules.  Because NS_IMPL_ISUPPORTS0 appears inline,
+  // the method prototypes for AddRef, Release, and QueryInterface provided by
+  // NS_DECL_ISUPPORTS are not needed, but the nsAutoRefCnt and
+  // NS_DECL_OWNINGTHREAD members (also provided by NS_DECL_ISUPPORTS)
+  // must now be declared manually.
+  virtual ~FunctorSupports() {}
+  NS_IMPL_ISUPPORTS0(FunctorSupports)
+protected:
+  nsAutoRefCnt mRefCnt;
+  NS_DECL_OWNINGTHREAD
+};
+
+
+// [[[cog
+// from cogutil import tlist, MAX_FUNCTOR_ARITY
+// rng = range(MAX_FUNCTOR_ARITY+1)
+// ijs = zip(rng, rng[1:])
+// ]]]
+// [[[end]]]
+
+
+template <typename Result, class Params>
+class FunctorImpl;
+
+#define ctnT(N) , typename T##N
+#define T(N) T##N
+#define DECL_FUNCTORIMPL_CLASS(N, TS)                                         \
+  template <typename R JOIN##N(ctnT,EMPTY)>                                   \
+  class FunctorImpl<R, TLIST##N TS> : public FunctorSupports {                \
+  public:                                                                     \
+    virtual R operator()TS = 0;                                               \
+  }
+
+#define DFC(N) DECL_FUNCTORIMPL_CLASS(N, (JOIN##N(T,COMMA)))
+JOIN16(DFC,SEMI);
+#undef DFC
+#undef DECL_FUNCTORIMPL_CLASS
+#undef ctnT
+#undef T
+
+
+template <class ParentFunctor, typename Callable>
+class CallableHandler;
+
+template <class ParentFunctor, typename Method>
+class MethodHandler;
+
+
+template <typename Result, class Params>
+class Functor
+{
+public:
+  typedef FunctorImpl<Result, Params> ImplType;
+  typedef Result ResultType;
+  typedef Params ParamList;
+
+  #define EXTRACT_TYPE(N)                                                     \
+    typedef typename tlist::TypeAtNS<Params, N>::type P##N
+  JOIN16(EXTRACT_TYPE,SEMI);
+  #undef EXTRACT_TYPE
+
+  // for compatibility with std::bind{1st,2nd}
+  typedef P1  first_argument_type;
+  typedef P2 second_argument_type;
+  typedef Result      result_type;
+
+public:
+  Functor(const Functor& f) : mImpl(f.mImpl) {}
+  Functor(ImplType* impl)   : mImpl(impl) {}
+ ~Functor() {}
+
+  template <typename Callable>
+  static Functor callable(Callable c) {
+    return Functor(new CallableHandler<Functor, Callable>(c));
+  }
+
+  template <typename Method>
+  static Functor method(Method m) {
+    return Functor(new MethodHandler<Functor, Method>(m));
+  }
+
+  #define Pp(N) P##N p##N
+  #define p(N) p##N
+  #define DECL_FUNCTOR_CALL_OP(N)                                             \
+    ResultType operator()(JOIN##N(Pp,COMMA)) {                                \
+      return (*mImpl)(JOIN##N(p,COMMA));                                      \
+    }
+  JOIN16(DECL_FUNCTOR_CALL_OP,EMPTY)
+  #undef DECL_FUNCTOR_CALL_OP
+  #undef Pp
+  #undef p
+
+private:
+  nsRefPtr<ImplType> mImpl;
+};
+
+
+template <class ParentFunctor, typename Callable>
+class CallableHandler
+  : public FunctorImpl<
+      typename ParentFunctor::ResultType,
+      typename ParentFunctor::ParamList>
+{
+public:
+  typedef typename ParentFunctor::ResultType ResultType;
+
+  #define COOPT(N) typedef typename ParentFunctor::P##N P##N
+  JOIN16(COOPT,SEMI);
+  #undef COOPT
+
+  CallableHandler(Callable c) : mCallable(c) {}
+
+  #define Pp(N) P##N p##N
+  #define p(N) p##N
+  #define DECL_CALLABLE_CALL_OP(N)                                            \
+    ResultType operator()(JOIN##N(Pp,COMMA)) {                                \
+      return mCallable(JOIN##N(p,COMMA));                                     \
+    }
+  JOIN16(DECL_CALLABLE_CALL_OP,EMPTY)
+  #undef DECL_CALLABLE_CALL_OP
+  #undef Pp
+  #undef p
+
+private:
+  Callable mCallable;
+};
+
+
+template <class ParentFunctor, typename Method>
+class MethodHandler
+  : public FunctorImpl<
+      typename ParentFunctor::ResultType,
+      typename ParentFunctor::ParamList>
+{
+public:
+  typedef typename ParentFunctor::ResultType ResultType;
+
+  #define COOPT(N) typedef typename ParentFunctor::P##N P##N
+  JOIN16(COOPT,SEMI);
+  #undef COOPT
+
+  MethodHandler(Method m) : mMethod(m) {}
+
+  #define Pp(N) P##N p##N
+
+  // [[[cog
+  // for i in [i+1 for i in rng]:
+  //   ps1 = tlist("p", rfirst=1, rlast=i-1)
+  //   cog.out("""
+  // ResultType operator()(JOIN%(i)d(Pp,COMMA)) {
+  //   return ((*p0).*mMethod)(%(ps1)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()(JOIN1(Pp,COMMA)) {
+    return ((*p0).*mMethod)();
+  }
+  ResultType operator()(JOIN2(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1);
+  }
+  ResultType operator()(JOIN3(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1, p2);
+  }
+  ResultType operator()(JOIN4(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1, p2, p3);
+  }
+  ResultType operator()(JOIN5(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4);
+  }
+  ResultType operator()(JOIN6(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(JOIN7(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(JOIN8(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(JOIN9(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(JOIN10(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  ResultType operator()(JOIN11(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
+  }
+  ResultType operator()(JOIN12(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);
+  }
+  ResultType operator()(JOIN13(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
+  }
+  ResultType operator()(JOIN14(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13);
+  }
+  ResultType operator()(JOIN15(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
+  }
+  ResultType operator()(JOIN16(Pp,COMMA)) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15);
+  }
+  // [[[end]]]
+
+  #undef Pp
+
+private:
+  Method mMethod;
+};
+
+// Just pass Functors through:
+template <typename Result, class Params>
+Functor<Result, Params>
+functor(Functor<Result, Params> f) {
+  return f;
+}
+
+#define ctnP(N) , typename P##N
+#define P(N) P##N
+#define cP(N) , P(N)
+
+// Being able to declare the const version at the same time as the non-const
+// version makes all of this macro abstraction worthwhile.
+#define DECL_GLOBAL_METHOD_ADAPTERS(TLIST, CPs, N)                            \
+  template <typename R, class C JOIN##N(ctnP,EMPTY)>                          \
+  Functor<R, TLIST CPs> functor(R (C::*m)(JOIN##N(P,COMMA))) {                \
+    return Functor<R, TLIST CPs>::method(m);                                  \
+  }                                                                           \
+  template <typename R, class C JOIN##N(ctnP,EMPTY)>                          \
+  Functor<R, TLIST CPs> functor(R (C::*m)(JOIN##N(P,COMMA)) const) {          \
+    return Functor<R, TLIST CPs>::method(m);                                  \
+  }
+
+#define DECL_GLOBAL_FUNCTION_ADAPTER(TLIST, Ps, N)                            \
+  template <typename R JOIN##N(ctnP,EMPTY)>                                   \
+  Functor<R, TLIST Ps> functor(R (*f)Ps) {                                    \
+    return Functor<R, TLIST Ps>::callable(f);                                 \
+  }
+
+#define DGMA(Np1, N)                                                          \
+  DECL_GLOBAL_METHOD_ADAPTERS(TLIST##Np1, (C* JOIN##N(cP,EMPTY)), N)
+
+#define DGFA(N)                                                               \
+  DECL_GLOBAL_FUNCTION_ADAPTER(TLIST##N, (JOIN##N(P,COMMA)), N)
+
+  ;
+// [[[cog
+// cog.out("\n".join("DGMA(%(j)d, %(i)d)" % locals() for (i, j) in ijs))
+// ]]]
+DGMA(1, 0)
+DGMA(2, 1)
+DGMA(3, 2)
+DGMA(4, 3)
+DGMA(5, 4)
+DGMA(6, 5)
+DGMA(7, 6)
+DGMA(8, 7)
+DGMA(9, 8)
+DGMA(10, 9)
+DGMA(11, 10)
+DGMA(12, 11)
+DGMA(13, 12)
+DGMA(14, 13)
+DGMA(15, 14)
+// [[[end]]]
+
+// This becomes easy:
+JOIN16(DGFA,EMPTY)
+
+// Sayonara, macro scum!
+
+#undef DECL_GLOBAL_FUNCTION_ADAPTERS
+#undef DECL_GLOBAL_METHOD_ADAPTER
+#undef DGMA
+#undef DGFA
+#undef ctnP
+#undef P
+#undef cP
+
+#endif
diff --git a/xpcom/glue/Makefile.in b/xpcom/glue/Makefile.in
--- a/xpcom/glue/Makefile.in
+++ b/xpcom/glue/Makefile.in
@@ -66,16 +66,17 @@ CSRCS		= \
 CSRCS		= \
 		$(XPCOM_GLUE_SRC_LCSRCS) \
 		$(NULL)  
 
 CPPSRCS		= \
 		$(XPCOM_GLUE_SRC_LCPPSRCS) \
 		$(XPCOM_GLUENS_SRC_LCPPSRCS) \
 		nsStringAPI.cpp \
+		test.cpp \
 		$(NULL)
 
 SDK_HEADERS = \
 		pldhash.h \
 		nsArrayEnumerator.h \
 		nsArrayUtils.h \
 		nsAutoLock.h \
 		nsBaseHashtable.h \
@@ -120,16 +121,19 @@ SDK_HEADERS = \
 		nsDeque.h \
 		$(NULL)
 
 EXPORTS = \
 		nsThreadUtils.h \
 		nsProxyRelease.h \
 		nsXPTCUtils.h \
 		Join.h \
+		TList.h \
+		Functor.h \
+		Bind.h \
 		$(NULL)
 
 SDK_LIBRARY     =                        \
 		$(LIB_PREFIX)xpcomglue_s.$(LIB_SUFFIX) \
 		$(NULL)
 
 # we don't want the shared lib, but we want to force the creation of a static lib.
 FORCE_STATIC_LIB = 1
diff --git a/xpcom/glue/TList.h b/xpcom/glue/TList.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/TList.h
@@ -0,0 +1,131 @@
+#ifndef __tlist_h__
+#define __tlist_h__
+
+// [[[cog
+// from cogutil import tlist, MAX_FUNCTOR_ARITY
+// rng = range(MAX_FUNCTOR_ARITY+1)
+// ijs = zip(rng, rng[1:])
+// ]]]
+// [[[end]]]
+
+class NullType {};
+struct EmptyType {};
+
+template <typename T, typename U>
+struct TList {
+  typedef T Head;
+  typedef U Tail;
+};
+
+#define TLIST0() NullType
+
+// [[[cog
+// for (i, j) in ijs:
+//   Ts = tlist("T", j)
+//   Tcdr = tlist("T", rfirst=2, rlast=j)
+//   slash = "\\"
+//   cog.out(r"""
+// #define TLIST%(j)d(%(Ts)s) %(slash)s
+//   TList<T1, TLIST%(i)d(%(Tcdr)s)>
+// """ % locals())
+// ]]]
+
+#define TLIST1(T1) \
+  TList<T1, TLIST0()>
+
+#define TLIST2(T1, T2) \
+  TList<T1, TLIST1(T2)>
+
+#define TLIST3(T1, T2, T3) \
+  TList<T1, TLIST2(T2, T3)>
+
+#define TLIST4(T1, T2, T3, T4) \
+  TList<T1, TLIST3(T2, T3, T4)>
+
+#define TLIST5(T1, T2, T3, T4, T5) \
+  TList<T1, TLIST4(T2, T3, T4, T5)>
+
+#define TLIST6(T1, T2, T3, T4, T5, T6) \
+  TList<T1, TLIST5(T2, T3, T4, T5, T6)>
+
+#define TLIST7(T1, T2, T3, T4, T5, T6, T7) \
+  TList<T1, TLIST6(T2, T3, T4, T5, T6, T7)>
+
+#define TLIST8(T1, T2, T3, T4, T5, T6, T7, T8) \
+  TList<T1, TLIST7(T2, T3, T4, T5, T6, T7, T8)>
+
+#define TLIST9(T1, T2, T3, T4, T5, T6, T7, T8, T9) \
+  TList<T1, TLIST8(T2, T3, T4, T5, T6, T7, T8, T9)>
+
+#define TLIST10(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) \
+  TList<T1, TLIST9(T2, T3, T4, T5, T6, T7, T8, T9, T10)>
+
+#define TLIST11(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) \
+  TList<T1, TLIST10(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
+
+#define TLIST12(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) \
+  TList<T1, TLIST11(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
+
+#define TLIST13(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) \
+  TList<T1, TLIST12(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
+
+#define TLIST14(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) \
+  TList<T1, TLIST13(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)>
+
+#define TLIST15(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) \
+  TList<T1, TLIST14(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)>
+// [[[end]]]
+
+namespace tlist {
+
+  template <typename List>
+  struct Length { enum { value = 0 }; };
+
+  template <typename T, typename U>
+  struct Length<TList<T, U> > {
+    enum { value = 1 + Length<U>::value };
+  };
+
+
+  template <typename List, unsigned N> struct TypeAt_;
+  template <typename T, typename U>
+  struct TypeAt_<TList<T, U>, 0> { typedef T type; };
+  template <typename T, typename U, unsigned N>
+  struct TypeAt_<TList<T, U>, N> {
+    typedef typename TypeAt_<U, N-1>::type type;
+  };
+
+  // allows negative indices
+  template <typename List, int N>
+  struct TypeAt {
+    typedef typename TypeAt_<
+        List,
+        N < 0 ? Length<List>::value + N : N
+      >::type type;
+  };
+
+
+  template <typename List, unsigned N, typename D> struct TypeAtNS_;
+  template <unsigned N, typename D>
+  struct TypeAtNS_<NullType, N, D> { typedef D type; };
+  template <typename T, typename U, unsigned N, typename D>
+  struct TypeAtNS_<TList<T, U>, N, D> {
+    typedef typename TypeAtNS_<U, N-1, D>::type type;
+  };
+  template <typename T, typename U, typename D>
+  struct TypeAtNS_<TList<T, U>, 0, D> { typedef T type; };
+
+  // allows negative indices
+  template <typename List, int N, typename Default=EmptyType>
+  struct TypeAtNS {
+    typedef typename TypeAtNS_<
+        List,
+        N < 0 ? Length<List>::value + N : N,
+        Default
+      >::type type;
+  };
+
+
+};
+
+#endif
diff --git a/xpcom/glue/cogutil.py b/xpcom/glue/cogutil.py
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/cogutil.py
@@ -0,0 +1,14 @@
+#!/usr/bin/env python
+
+import cog
+import re
+
+tpat = re.compile(r"\b[a-z]\b", re.I)
+npat = re.compile(r"\b0\b")
+def tlist(tmpl, rlast, rfirst=1, sep=", "):
+  return sep.join(tpat.sub("\g<0>%u" % i,
+                           npat.sub("%u" % i, tmpl))
+                  for i in range(rfirst, rlast+1))
+
+MAX_FUNCTOR_ARITY = 15
+
diff --git a/xpcom/glue/test.cpp b/xpcom/glue/test.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/test.cpp
@@ -0,0 +1,81 @@
+#include <iostream>
+#include "Functor.h"
+#include "Bind.h"
+
+int Succ(int n) {
+  return n + 1;
+}
+
+struct Pred
+{
+  int operator()(int n) {
+    return n - 1;
+  }
+};
+
+struct DiffStruct
+{
+  int Sub(int a, int b) {
+    return a - b;
+  }
+  static int Add2(int a, int b) {
+    return a + b;
+  }
+};
+
+void is(int x, int y) {
+  std::cout << (x == y ? "OK: " : "FAIL: ")
+            << x << " = " << y << std::endl;
+}
+
+void example()
+{
+  Functor<int, TLIST1(int)> s = functor(&Succ);
+
+  Pred pred;
+  Functor<int, TLIST1(int)> p = BIND1(&Pred::operator(), &pred);
+
+  Functor<int, TLIST3(DiffStruct*, int, int)> ds =
+    functor(&DiffStruct::Sub);
+
+  Functor<int, TLIST2(int, int)> a2 = functor(&DiffStruct::Add2);
+
+  int a = 1, b = 5;
+  is(s(a), a + 1);
+  is(p(b), b - 1);
+  is(ds(new DiffStruct, s(a), p(b)), a - b + 2);
+
+  // is(std::bind1st(ds, 6)(4), 2);
+  // is(std::bind2nd(ds, 6)(4), -2);
+
+  is(a2(2, 3), 5);
+}
+
+void test_bind()
+{
+  // Interesting (near-)equivalences:
+  is(Pred()(2), 1);
+  is((Pred().*(&Pred::operator()))(2), 1);
+  is(Pred().operator()(2), 1);
+  is(BIND1(&Pred::operator(), new Pred)(2), 1);
+
+  Functor<int, TLIST2(int, int)> a2 = functor(&DiffStruct::Add2);
+  is(BIND1(a2, 2)(3), 5);
+  is(BIND2(a2, 2, 3)(), 5);
+  is(BIND1(BIND1(a2, 2), 3)(), 5);
+
+  double x = 5, y = 3;
+  DiffStruct ds;
+  Functor<int, TLIST2(int, int)> sub = BIND1(&DiffStruct::Sub, &ds);
+  Functor<int, TLIST1(int)> f = BIND1(sub, x);
+  is(sub(x, y), x - y);
+  is(sub(y, x), y - x);
+  is(f(x), 0);
+  is(f(y), x - y);
+}
+
+int main() {
+  example();
+  test_bind();
+  return 0;
+}
