Improved FunctorSupports and Functor::bind implementations (bug 486440).

diff --git a/xpcom/glue/Bind.h b/xpcom/glue/Bind.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/Bind.h
@@ -0,0 +1,238 @@
+/* -*- Mode: c++; tab-width: 2; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is BIND/bind.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef Bind_h__
+#define Bind_h__
+
+#include "Functor.h"
+#include "nsAutoPtr.h"
+
+/**
+ * For an overview of BIND usage, see bug 486440.
+ *
+ * This implementation was inspired by Andrei Alexandrescu's book
+ *
+ *   Modern C++ Design: Generic Programming and Design Patterns Applied,
+ *
+ * which has a great deal more to say on the topic.
+ *
+ * Instructions pertaining to the cog.py code generation tool are available
+ * here: http://nedbatchelder.com/code/cog/
+ *
+ * Once you have installed cog.py, run
+ *
+ *   cog.py -r Bind.h
+ *
+ * to regenerate the portions of this file delimited by the triple square
+ * bracket markers.  The file changes in place, but the python generating code
+ * remains, so repeatedly regenerating the file is really very easy.
+ */
+
+// [[[cog
+// from functor_cog_utils import tlist, MAX_FUNCTOR_ARITY
+// rng = range(MAX_FUNCTOR_ARITY+1)
+// ijs = zip(rng, rng[1:])
+// ]]]
+// [[[end]]]
+
+/**
+ * ClientManagedStoragePolicy assumes nothing about the allocation and
+ * management of T, and consequently provides the client no assistance of that
+ * sort.  This policy class is intended primarily for use by ref and cref.
+ */
+template <typename T>
+class ClientManagedStoragePolicy
+{
+  T* const mPtr;
+protected:
+  ClientManagedStoragePolicy(T* tp) : mPtr(tp) {}
+  T* GetPointer() { return mPtr; }
+  const T* GetConstPointer() const { return mPtr; }
+};
+
+/**
+ * nsRefPtr<T> enforces the availability of T::AddRef and T::Release, so it may
+ * be assumed that any object of type T is both reference counted and not stack
+ * allocated.  This guarantee makes it safe to provide a T* constructor without
+ * worry that the client may pass in a stack address.  For convenience, a zero-
+ * parameter constructor is also provided for situations where T is default-
+ * constructible and the client wants RefPtrStoragePolicy to do the allocation.
+ */
+template <typename T>
+class RefPtrStoragePolicy
+{
+  nsRefPtr<T> mPtr;
+protected:
+  RefPtrStoragePolicy() : mPtr(new T()) {}
+  RefPtrStoragePolicy(T* tp) : mPtr(tp) {}
+  T* GetPointer() { return mPtr; }
+  const T* GetConstPointer() const { return mPtr; }
+};
+
+/**
+ * RefCountingStoragePolicy provides only a zero-parameter constructor to force
+ * heap allocation of the underlying T value.
+ */
+template <typename T>
+class RefCountingStoragePolicy
+{
+  struct Holder {
+    T mVal; // must be default-constructible
+    nsAutoRefCnt mRefCnt;
+    nsrefcnt AddRef();
+    nsrefcnt Release();
+  };
+  nsRefPtr<Holder> mHolderPtr;
+protected:
+  RefCountingStoragePolicy() : mHolderPtr(new Holder()) {}
+  T* GetPointer() { return &mHolderPtr->mVal; }
+  const T* GetConstPointer() const { return &mHolderPtr->mVal; }
+};
+template <typename T>
+inline NS_IMPL_THREADSAFE_ADDREF(RefCountingStoragePolicy<T>::Holder)
+template <typename T>
+inline NS_IMPL_THREADSAFE_RELEASE(RefCountingStoragePolicy<T>::Holder)
+
+
+template
+<
+  typename T, // Reference types do not work, and that is as it should be.
+  template <typename> class StoragePolicy = RefCountingStoragePolicy
+>
+class Location : private StoragePolicy<T>
+{
+public:
+  explicit Location() {}
+  explicit Location(T* tp) : StoragePolicy<T>(tp) {}
+
+  // Any type that can be assigned to a dereferenced T* is legal here:
+  template <typename R>
+  Location& operator=(const R& rhs) {
+    *this->GetPointer() = rhs;
+    return *this;
+  }
+
+  operator T&() { return *this->GetPointer(); }
+  operator const T&() const { return *this->GetConstPointer(); }
+
+  operator T*() { return this->GetPointer(); }
+  operator const T*() const { return this->GetConstPointer(); }
+};
+
+
+/**
+ * Template type inference prefers non-reference types to reference types, so
+ * references passed to bind will be stored by VALUE unless explicitly coerced
+ * using the ref and cref (const reference) functions below.
+ */
+
+template <typename T>
+Location<T, ClientManagedStoragePolicy>
+ref(T& t)
+{
+  return Location<T, ClientManagedStoragePolicy>(&t);
+}
+
+template <typename T>
+const Location<const T, ClientManagedStoragePolicy>
+cref(const T& t)
+{
+  typedef const Location<const T, ClientManagedStoragePolicy> type;
+  return type(&t);
+}
+
+template <typename T>
+struct OutParam
+{
+  typedef Location<T, RefCountingStoragePolicy> type;
+};
+
+
+/**
+ * The BIND{1,2,...} macros save some typing by linearizing the syntax for
+ * binding multiple arguments.  Additionally, the BIND0 macro ensures that the
+ * first argument is converted to a Functor.  There is no reason to use BIND0
+ * directly instead of the global functor function(s), but you know what? do
+ * whatever you want. Life is short.
+ */
+#define BIND0(F) functor(F)
+
+// [[[cog
+// slash = "\\"
+// for (i, j) in ijs:
+//   alist = tlist("A", j)
+//   ainit = tlist(", A", i, sep="")
+//   alast = "A%d" % i;
+//   cog.out(r"""
+// #define BIND%(j)d(F, %(alist)s) %(slash)s
+//   BIND%(i)d(F%(ainit)s).bind(%(alast)s)
+// """ % locals())
+// ]]]
+
+#define BIND1(F, A0) \
+  BIND0(F).bind(A0)
+
+#define BIND2(F, A0, A1) \
+  BIND1(F, A0).bind(A1)
+
+#define BIND3(F, A0, A1, A2) \
+  BIND2(F, A0, A1).bind(A2)
+
+#define BIND4(F, A0, A1, A2, A3) \
+  BIND3(F, A0, A1, A2).bind(A3)
+
+#define BIND5(F, A0, A1, A2, A3, A4) \
+  BIND4(F, A0, A1, A2, A3).bind(A4)
+
+#define BIND6(F, A0, A1, A2, A3, A4, A5) \
+  BIND5(F, A0, A1, A2, A3, A4).bind(A5)
+
+#define BIND7(F, A0, A1, A2, A3, A4, A5, A6) \
+  BIND6(F, A0, A1, A2, A3, A4, A5).bind(A6)
+
+#define BIND8(F, A0, A1, A2, A3, A4, A5, A6, A7) \
+  BIND7(F, A0, A1, A2, A3, A4, A5, A6).bind(A7)
+
+#define BIND9(F, A0, A1, A2, A3, A4, A5, A6, A7, A8) \
+  BIND8(F, A0, A1, A2, A3, A4, A5, A6, A7).bind(A8)
+
+#define BIND10(F, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) \
+  BIND9(F, A0, A1, A2, A3, A4, A5, A6, A7, A8).bind(A9)
+// [[[end]]]
+
+#endif
diff --git a/xpcom/glue/Functor.h b/xpcom/glue/Functor.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/Functor.h
@@ -0,0 +1,821 @@
+/* -*- Mode: c++; tab-width: 2; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Functor.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef Functor_h__
+#define Functor_h__
+
+#include "nsISupports.h"
+#include "nsIRunnable.h"
+#include "nsAutoPtr.h"
+#include "TList.h"
+
+/**
+ * For an overview of Functor usage, see bug 486440.
+ *
+ * This implementation was inspired by Andrei Alexandrescu's book
+ *
+ *   Modern C++ Design: Generic Programming and Design Patterns Applied,
+ *
+ * which has a great deal more to say on the topic.
+ *
+ * Instructions pertaining to the cog.py code generation tool are available
+ * here: http://nedbatchelder.com/code/cog/
+ *
+ * Once you have installed cog.py, run
+ *
+ *   cog.py -r Functor.h
+ *
+ * to regenerate the portions of this file delimited by the triple square
+ * bracket markers.  The file changes in place, but the python generating code
+ * remains, so repeatedly regenerating the file is really very easy.
+ */
+
+// [[[cog
+// from functor_cog_utils import tlist, MAX_FUNCTOR_ARITY
+// rng = range(MAX_FUNCTOR_ARITY+1)
+// ijs = zip(rng, rng[1:])
+// ]]]
+// [[[end]]]
+
+class FunctorSupports : public nsISupports {
+  NS_DECL_ISUPPORTS
+protected:
+  virtual ~FunctorSupports() {}
+};
+inline NS_IMPL_THREADSAFE_ADDREF(FunctorSupports)
+inline NS_IMPL_THREADSAFE_RELEASE(FunctorSupports)
+inline NS_IMPL_THREADSAFE_QUERY_INTERFACE0(FunctorSupports)
+
+/**
+ * Abstract interface for the heap-allocated functor objects (CallableHandler,
+ * MethodHandler, Binder, &c.) to which Functors hold references. Since
+ * FunctorImpl inherits from FunctorSupports, derived classes inherit the
+ * AddRef and Release methods required by nsRefPtr<FunctorImpl>.
+ */
+template <typename Result, class Params>
+class FunctorImpl;
+
+// [[[cog
+// for i in rng:
+//   ctnTs = tlist(", typename T", i, sep="")
+//   Ts = tlist("T", i)
+//   cog.out("""
+// template <typename R%(ctnTs)s>
+// class FunctorImpl<R, TLIST%(i)d(%(Ts)s)> : public FunctorSupports {
+// public:
+//   virtual R operator()(%(Ts)s) = 0;
+// };""" % locals())
+// ]]]
+
+template <typename R>
+class FunctorImpl<R, TLIST0()> : public FunctorSupports {
+public:
+  virtual R operator()() = 0;
+};
+template <typename R, typename T0>
+class FunctorImpl<R, TLIST1(T0)> : public FunctorSupports {
+public:
+  virtual R operator()(T0) = 0;
+};
+template <typename R, typename T0, typename T1>
+class FunctorImpl<R, TLIST2(T0, T1)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2>
+class FunctorImpl<R, TLIST3(T0, T1, T2)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3>
+class FunctorImpl<R, TLIST4(T0, T1, T2, T3)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
+class FunctorImpl<R, TLIST5(T0, T1, T2, T3, T4)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
+class FunctorImpl<R, TLIST6(T0, T1, T2, T3, T4, T5)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
+class FunctorImpl<R, TLIST7(T0, T1, T2, T3, T4, T5, T6)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5, T6) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
+class FunctorImpl<R, TLIST8(T0, T1, T2, T3, T4, T5, T6, T7)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5, T6, T7) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
+class FunctorImpl<R, TLIST9(T0, T1, T2, T3, T4, T5, T6, T7, T8)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5, T6, T7, T8) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
+class FunctorImpl<R, TLIST10(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) = 0;
+};
+// [[[end]]]
+
+
+template <class ParentFunctor, typename Callable>
+class CallableHandler;
+
+template <class ParentFunctor, typename Method>
+class MethodHandler;
+
+template <class ParentFunctor, typename Bound>
+class Binder;
+
+template <class ParentFunctor, typename Location>
+class Voider;
+
+// [[[cog
+// cog.out("#define EXTRACT_TYPEDEFS(LIST) \\\n")
+// cog.out(tlist("  typedef typename tlist::TypeAt<LIST, 0>::type P;",
+//               MAX_FUNCTOR_ARITY, sep=" \\\n"))
+// ]]]
+#define EXTRACT_TYPEDEFS(LIST) \
+  typedef typename tlist::TypeAt<LIST, 0>::type P0; \
+  typedef typename tlist::TypeAt<LIST, 1>::type P1; \
+  typedef typename tlist::TypeAt<LIST, 2>::type P2; \
+  typedef typename tlist::TypeAt<LIST, 3>::type P3; \
+  typedef typename tlist::TypeAt<LIST, 4>::type P4; \
+  typedef typename tlist::TypeAt<LIST, 5>::type P5; \
+  typedef typename tlist::TypeAt<LIST, 6>::type P6; \
+  typedef typename tlist::TypeAt<LIST, 7>::type P7; \
+  typedef typename tlist::TypeAt<LIST, 8>::type P8; \
+  typedef typename tlist::TypeAt<LIST, 9>::type P9;
+// [[[end]]]
+
+/**
+ * The Functor class is just a value-type wrapper around the reference-type
+ * FunctorImpl object mImpl.  It isn't meant to be inherited from, so none of
+ * its methods are virtual.  It doesn't even need a virtual destructor.  You
+ * can (and should) copy Functors by value.
+ *
+ * TODO The parameter types should be made references when possible.
+ * Unfortunately, references to references are illegal, so getting this right
+ * would require some additional template trickery.
+ */
+template <typename Result, class Params>
+class Functor
+{
+public:
+  typedef FunctorImpl<Result, Params> ImplType;
+  typedef Result ResultType;
+  typedef Params ParamList;
+
+  Functor(const Functor& f) : mImpl(f.mImpl) {}
+  Functor(ImplType* impl)   : mImpl(impl) {}
+ ~Functor() {} // deliberately non-virtual
+
+  template <typename Callable>
+  static Functor callable(Callable c) {
+    return Functor(new CallableHandler<Functor, Callable>(c));
+  }
+
+  template <typename Method>
+  static Functor method(Method m) {
+    return Functor(new MethodHandler<Functor, Method>(m));
+  }
+
+  /**
+   * The bind method returns a Functor with one less parameter than the Functor
+   * object receiving the bind method invocation.  When the resulting Functor
+   * is invoked, the bound argument will be passed as the first argument to the
+   * original Functor.
+   *
+   * Note that the type used for storing the bound value is determined by the
+   * value passed to bind, not by the Functor's first parameter type.  This
+   * distinction becomes important when the stored value needs to be copied or
+   * AddRefed but the actual parameter type is just a bare pointer.
+   */
+  template <typename Bound>
+  typename Binder<Functor, Bound>::Outgoing
+  bind(Bound bound) {
+    typedef Binder<Functor, Bound> B;
+    typedef typename B::Outgoing O;
+    typedef typename O::ImplType I;
+    I* binder = new B(*this, bound);
+    return O(binder);
+  }
+
+  template <typename Location>
+  typename Voider<Functor, Location>::Outgoing
+  bind_result(Location loc) {
+    typedef Voider<Functor, Location> V;
+    typedef typename V::Outgoing O;
+    typedef typename O::ImplType I;
+    I* voider = new V(*this, loc);
+    return O(voider);
+  }
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng:
+  //   Pps = tlist("P p", i)
+  //   ps = tlist("p", i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return (*mImpl)(%(ps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    return (*mImpl)();
+  }
+  ResultType operator()(P0 p0) {
+    return (*mImpl)(p0);
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    return (*mImpl)(p0, p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    return (*mImpl)(p0, p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    return (*mImpl)(p0, p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    return (*mImpl)(p0, p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  // [[[end]]]
+
+private:
+  nsRefPtr<ImplType> mImpl;
+};
+
+/**
+ * Callable entities include global functions, objects that support operator(),
+ * and static member functions.  The implementation of this class is generic
+ * with respect to these possibilities: as long as mCallable can be called with
+ * some number of arguments between zero and MAX_FUNCTOR_ARITY (inclusive),
+ * your code will compile.
+ */
+template <class ParentFunctor, typename Callable>
+class CallableHandler
+  : public FunctorImpl<
+      typename ParentFunctor::ResultType,
+      typename ParentFunctor::ParamList>
+{
+public:
+  CallableHandler(Callable c) : mCallable(c) {}
+
+  typedef typename ParentFunctor::ResultType ResultType;
+  typedef typename ParentFunctor::ParamList  ParamList;
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng:
+  //   Pps = tlist("P p", i)
+  //   ps = tlist("p", i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return mCallable(%(ps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    return mCallable();
+  }
+  ResultType operator()(P0 p0) {
+    return mCallable(p0);
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    return mCallable(p0, p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    return mCallable(p0, p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    return mCallable(p0, p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    return mCallable(p0, p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return mCallable(p0, p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return mCallable(p0, p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return mCallable(p0, p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return mCallable(p0, p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    return mCallable(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  // [[[end]]]
+
+private:
+  Callable mCallable;
+};
+
+/**
+ * Methods of n parameters become Functors of n+1 parameters, where the first
+ * parameter names the object to receive the method invocation.
+ */
+template <class ParentFunctor, typename Method>
+class MethodHandler
+  : public FunctorImpl<
+      typename ParentFunctor::ResultType,
+      typename ParentFunctor::ParamList>
+{
+public:
+  MethodHandler(Method m) : mMethod(m) {}
+
+  typedef typename ParentFunctor::ResultType ResultType;
+  typedef typename ParentFunctor::ParamList  ParamList;
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng[1:]:
+  //   Pps = tlist("P p", i)
+  //   ps1 = tlist("p", rbegin=1, rend=i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return ((*p0).*mMethod)(%(ps1)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()(P0 p0) {
+    return ((*p0).*mMethod)();
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    return ((*p0).*mMethod)(p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    return ((*p0).*mMethod)(p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    return ((*p0).*mMethod)(p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  // [[[end]]]
+
+private:
+  Method mMethod;
+};
+
+/**
+ * Binder class for use with Functor::bind.
+ */
+template <class ParentFunctor, typename Bound>
+class Binder
+  : public FunctorImpl<typename ParentFunctor::ResultType,
+                       typename ParentFunctor::ParamList::Tail>
+{
+public:
+  Binder(ParentFunctor fun, Bound bound)
+    : mFun(fun)
+    , mBound(bound)
+  {}
+
+  typedef typename ParentFunctor::ResultType      ResultType;
+  typedef typename ParentFunctor::ParamList::Tail ParamList;
+  typedef Functor<ResultType, ParamList>          Outgoing;
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng:
+  //   Pps = tlist("P p", i)
+  //   cps = tlist(", p", i, sep="")
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return mFun(mBound%(cps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    return mFun(mBound);
+  }
+  ResultType operator()(P0 p0) {
+    return mFun(mBound, p0);
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    return mFun(mBound, p0, p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    return mFun(mBound, p0, p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    return mFun(mBound, p0, p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    return mFun(mBound, p0, p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return mFun(mBound, p0, p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return mFun(mBound, p0, p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return mFun(mBound, p0, p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return mFun(mBound, p0, p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    return mFun(mBound, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  // [[[end]]]
+
+private:
+  ParentFunctor mFun;
+  Bound mBound;
+};
+
+template <class ParentFunctor, typename Location>
+class Voider
+  : public FunctorImpl<void, typename ParentFunctor::ParamList>
+{
+public:
+  Voider(ParentFunctor fun, Location loc)
+    : mFun(fun)
+    , mLoc(loc)
+  {}
+
+  typedef void ResultType;
+  typedef typename ParentFunctor::ParamList ParamList;
+  typedef Functor<ResultType, ParamList> Outgoing;
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng:
+  //   Pps = tlist("P p", i)
+  //   cps = tlist("p", i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   mLoc = mFun(%(cps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    mLoc = mFun();
+  }
+  ResultType operator()(P0 p0) {
+    mLoc = mFun(p0);
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    mLoc = mFun(p0, p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    mLoc = mFun(p0, p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    mLoc = mFun(p0, p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    mLoc = mFun(p0, p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  // [[[end]]]
+
+private:
+  ParentFunctor mFun;
+  Location mLoc;
+};
+
+// Sayonara, macro scum!
+#undef EXTRACT_TYPEDEFS
+
+/**
+ * Herebelow lies a jungle of functor adapter functions.  I did not write them;
+ * I generated them.  Even the comments are auto-generated.  If you need to
+ * modify them, you really, really should change and re-run the generator code
+ * rather than editing the functions themselves.
+ */
+
+// Pass already-Functors through unmodified:
+template <typename Result, class Params>
+Functor<Result, Params>
+functor(Functor<Result, Params> f) {
+  return f;
+}
+
+// [[[cog
+// for (i, j) in ijs:
+//   const = ""
+//   ctnPs = tlist(", typename P", i, sep="")
+//   cPs = tlist(", P", i, sep="")
+//   Ps = tlist("P", i)
+//
+//   tmpl = """
+// template <typename R, class C%(ctnPs)s>
+// Functor<R, TLIST%(j)d(C*%(cPs)s)>
+// functor(R (C::*m)(%(Ps)s)%(const)s) {
+//   return Functor<R, TLIST%(j)d(C*%(cPs)s)>::method(m);
+// }"""
+//
+//   plural = "s"[int(i==1):]
+//
+//   cog.out("""
+// // Adapters for methods with %d parameter%s:""" % (i, plural))
+//   cog.out(tmpl % locals())
+//
+//   const = " const"
+//   cog.out(tmpl % locals())
+//
+//   cog.out("""
+// // Adapter for global functions with %d parameter%s:""" % (i, plural))
+//   cog.out("""
+// template <typename R%(ctnPs)s>
+// Functor<R, TLIST%(i)d(%(Ps)s)>
+// functor(R (*f)(%(Ps)s)) {
+//   return Functor<R, TLIST%(i)d(%(Ps)s)>::callable(f);
+// }
+//
+// """ % locals())
+// ]]]
+
+// Adapters for methods with 0 parameters:
+template <typename R, class C>
+Functor<R, TLIST1(C*)>
+functor(R (C::*m)()) {
+  return Functor<R, TLIST1(C*)>::method(m);
+}
+template <typename R, class C>
+Functor<R, TLIST1(C*)>
+functor(R (C::*m)() const) {
+  return Functor<R, TLIST1(C*)>::method(m);
+}
+// Adapter for global functions with 0 parameters:
+template <typename R>
+Functor<R, TLIST0()>
+functor(R (*f)()) {
+  return Functor<R, TLIST0()>::callable(f);
+}
+
+
+// Adapters for methods with 1 parameter:
+template <typename R, class C, typename P0>
+Functor<R, TLIST2(C*, P0)>
+functor(R (C::*m)(P0)) {
+  return Functor<R, TLIST2(C*, P0)>::method(m);
+}
+template <typename R, class C, typename P0>
+Functor<R, TLIST2(C*, P0)>
+functor(R (C::*m)(P0) const) {
+  return Functor<R, TLIST2(C*, P0)>::method(m);
+}
+// Adapter for global functions with 1 parameter:
+template <typename R, typename P0>
+Functor<R, TLIST1(P0)>
+functor(R (*f)(P0)) {
+  return Functor<R, TLIST1(P0)>::callable(f);
+}
+
+
+// Adapters for methods with 2 parameters:
+template <typename R, class C, typename P0, typename P1>
+Functor<R, TLIST3(C*, P0, P1)>
+functor(R (C::*m)(P0, P1)) {
+  return Functor<R, TLIST3(C*, P0, P1)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1>
+Functor<R, TLIST3(C*, P0, P1)>
+functor(R (C::*m)(P0, P1) const) {
+  return Functor<R, TLIST3(C*, P0, P1)>::method(m);
+}
+// Adapter for global functions with 2 parameters:
+template <typename R, typename P0, typename P1>
+Functor<R, TLIST2(P0, P1)>
+functor(R (*f)(P0, P1)) {
+  return Functor<R, TLIST2(P0, P1)>::callable(f);
+}
+
+
+// Adapters for methods with 3 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2>
+Functor<R, TLIST4(C*, P0, P1, P2)>
+functor(R (C::*m)(P0, P1, P2)) {
+  return Functor<R, TLIST4(C*, P0, P1, P2)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2>
+Functor<R, TLIST4(C*, P0, P1, P2)>
+functor(R (C::*m)(P0, P1, P2) const) {
+  return Functor<R, TLIST4(C*, P0, P1, P2)>::method(m);
+}
+// Adapter for global functions with 3 parameters:
+template <typename R, typename P0, typename P1, typename P2>
+Functor<R, TLIST3(P0, P1, P2)>
+functor(R (*f)(P0, P1, P2)) {
+  return Functor<R, TLIST3(P0, P1, P2)>::callable(f);
+}
+
+
+// Adapters for methods with 4 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3>
+Functor<R, TLIST5(C*, P0, P1, P2, P3)>
+functor(R (C::*m)(P0, P1, P2, P3)) {
+  return Functor<R, TLIST5(C*, P0, P1, P2, P3)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3>
+Functor<R, TLIST5(C*, P0, P1, P2, P3)>
+functor(R (C::*m)(P0, P1, P2, P3) const) {
+  return Functor<R, TLIST5(C*, P0, P1, P2, P3)>::method(m);
+}
+// Adapter for global functions with 4 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3>
+Functor<R, TLIST4(P0, P1, P2, P3)>
+functor(R (*f)(P0, P1, P2, P3)) {
+  return Functor<R, TLIST4(P0, P1, P2, P3)>::callable(f);
+}
+
+
+// Adapters for methods with 5 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4>
+Functor<R, TLIST6(C*, P0, P1, P2, P3, P4)>
+functor(R (C::*m)(P0, P1, P2, P3, P4)) {
+  return Functor<R, TLIST6(C*, P0, P1, P2, P3, P4)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4>
+Functor<R, TLIST6(C*, P0, P1, P2, P3, P4)>
+functor(R (C::*m)(P0, P1, P2, P3, P4) const) {
+  return Functor<R, TLIST6(C*, P0, P1, P2, P3, P4)>::method(m);
+}
+// Adapter for global functions with 5 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4>
+Functor<R, TLIST5(P0, P1, P2, P3, P4)>
+functor(R (*f)(P0, P1, P2, P3, P4)) {
+  return Functor<R, TLIST5(P0, P1, P2, P3, P4)>::callable(f);
+}
+
+
+// Adapters for methods with 6 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
+Functor<R, TLIST7(C*, P0, P1, P2, P3, P4, P5)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5)) {
+  return Functor<R, TLIST7(C*, P0, P1, P2, P3, P4, P5)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
+Functor<R, TLIST7(C*, P0, P1, P2, P3, P4, P5)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5) const) {
+  return Functor<R, TLIST7(C*, P0, P1, P2, P3, P4, P5)>::method(m);
+}
+// Adapter for global functions with 6 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
+Functor<R, TLIST6(P0, P1, P2, P3, P4, P5)>
+functor(R (*f)(P0, P1, P2, P3, P4, P5)) {
+  return Functor<R, TLIST6(P0, P1, P2, P3, P4, P5)>::callable(f);
+}
+
+
+// Adapters for methods with 7 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
+Functor<R, TLIST8(C*, P0, P1, P2, P3, P4, P5, P6)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5, P6)) {
+  return Functor<R, TLIST8(C*, P0, P1, P2, P3, P4, P5, P6)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
+Functor<R, TLIST8(C*, P0, P1, P2, P3, P4, P5, P6)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5, P6) const) {
+  return Functor<R, TLIST8(C*, P0, P1, P2, P3, P4, P5, P6)>::method(m);
+}
+// Adapter for global functions with 7 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
+Functor<R, TLIST7(P0, P1, P2, P3, P4, P5, P6)>
+functor(R (*f)(P0, P1, P2, P3, P4, P5, P6)) {
+  return Functor<R, TLIST7(P0, P1, P2, P3, P4, P5, P6)>::callable(f);
+}
+
+
+// Adapters for methods with 8 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
+Functor<R, TLIST9(C*, P0, P1, P2, P3, P4, P5, P6, P7)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5, P6, P7)) {
+  return Functor<R, TLIST9(C*, P0, P1, P2, P3, P4, P5, P6, P7)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
+Functor<R, TLIST9(C*, P0, P1, P2, P3, P4, P5, P6, P7)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5, P6, P7) const) {
+  return Functor<R, TLIST9(C*, P0, P1, P2, P3, P4, P5, P6, P7)>::method(m);
+}
+// Adapter for global functions with 8 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
+Functor<R, TLIST8(P0, P1, P2, P3, P4, P5, P6, P7)>
+functor(R (*f)(P0, P1, P2, P3, P4, P5, P6, P7)) {
+  return Functor<R, TLIST8(P0, P1, P2, P3, P4, P5, P6, P7)>::callable(f);
+}
+
+
+// Adapters for methods with 9 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
+Functor<R, TLIST10(C*, P0, P1, P2, P3, P4, P5, P6, P7, P8)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5, P6, P7, P8)) {
+  return Functor<R, TLIST10(C*, P0, P1, P2, P3, P4, P5, P6, P7, P8)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
+Functor<R, TLIST10(C*, P0, P1, P2, P3, P4, P5, P6, P7, P8)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5, P6, P7, P8) const) {
+  return Functor<R, TLIST10(C*, P0, P1, P2, P3, P4, P5, P6, P7, P8)>::method(m);
+}
+// Adapter for global functions with 9 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
+Functor<R, TLIST9(P0, P1, P2, P3, P4, P5, P6, P7, P8)>
+functor(R (*f)(P0, P1, P2, P3, P4, P5, P6, P7, P8)) {
+  return Functor<R, TLIST9(P0, P1, P2, P3, P4, P5, P6, P7, P8)>::callable(f);
+}
+
+// [[[end]]]
+
+
+#endif
diff --git a/xpcom/glue/Makefile.in b/xpcom/glue/Makefile.in
--- a/xpcom/glue/Makefile.in
+++ b/xpcom/glue/Makefile.in
@@ -122,16 +122,19 @@ SDK_HEADERS = \
 		$(NULL)
 
 EXPORTS_NAMESPACES = mozilla
 
 EXPORTS = \
 		nsThreadUtils.h \
 		nsProxyRelease.h \
 		nsXPTCUtils.h \
+		TList.h \
+		Functor.h \
+		Bind.h \
 		$(NULL)
 
 EXPORTS_mozilla = \
   BlockingResourceBase.h \
   CondVar.h \
   DeadlockDetector.h \
   Monitor.h \
   Mutex.h \
diff --git a/xpcom/glue/TList.h b/xpcom/glue/TList.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/TList.h
@@ -0,0 +1,169 @@
+/* -*- Mode: c++; tab-width: 2; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is TList/TLIST{0,1,...}.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __tlist_h__
+#define __tlist_h__
+
+/**
+ * TLists, or type lists, are Lisp-style linked lists of types.  This file only
+ * scratches the surface of what is possible with type lists, but I only needed
+ * to calculate lengths and access types by index, so that's all I bothered
+ * implementing.
+ *
+ * Andrei Alexandrescu's book
+ *
+ *   Modern C++ Design: Generic Programming and Design Patterns Applied
+ *
+ * has a great deal more to say on this topic.
+ *
+ * Instructions pertaining to the cog.py code generation tool are available
+ * here: http://nedbatchelder.com/code/cog/
+ *
+ * Once you have installed cog.py, run
+ *
+ *   cog.py -r TList.h
+ *
+ * to regenerate the portions of this file delimited by the triple square
+ * bracket markers.  The file changes in place, but the python generating code
+ * remains, so repeatedly regenerating the file is really very easy.
+ */
+
+// [[[cog
+// from functor_cog_utils import tlist, MAX_FUNCTOR_ARITY
+// rng = range(MAX_FUNCTOR_ARITY+1)
+// ijs = zip(rng, rng[1:])
+// ]]]
+// [[[end]]]
+
+class NullType {};
+struct EmptyType {};
+
+template <typename T, typename U>
+struct TList {
+  typedef T Head;
+  typedef U Tail;
+};
+
+#define TLIST0() NullType
+
+// [[[cog
+// for (i, j) in ijs:
+//   Ts = tlist("T", j)
+//   Tcdr = tlist("T", rbegin=1, rend=j)
+//   slash = "\\"
+//   cog.out("""
+// #define TLIST%(j)d(%(Ts)s) %(slash)s
+//   TList<T0, TLIST%(i)d(%(Tcdr)s)>
+// """ % locals())
+// ]]]
+
+#define TLIST1(T0) \
+  TList<T0, TLIST0()>
+
+#define TLIST2(T0, T1) \
+  TList<T0, TLIST1(T1)>
+
+#define TLIST3(T0, T1, T2) \
+  TList<T0, TLIST2(T1, T2)>
+
+#define TLIST4(T0, T1, T2, T3) \
+  TList<T0, TLIST3(T1, T2, T3)>
+
+#define TLIST5(T0, T1, T2, T3, T4) \
+  TList<T0, TLIST4(T1, T2, T3, T4)>
+
+#define TLIST6(T0, T1, T2, T3, T4, T5) \
+  TList<T0, TLIST5(T1, T2, T3, T4, T5)>
+
+#define TLIST7(T0, T1, T2, T3, T4, T5, T6) \
+  TList<T0, TLIST6(T1, T2, T3, T4, T5, T6)>
+
+#define TLIST8(T0, T1, T2, T3, T4, T5, T6, T7) \
+  TList<T0, TLIST7(T1, T2, T3, T4, T5, T6, T7)>
+
+#define TLIST9(T0, T1, T2, T3, T4, T5, T6, T7, T8) \
+  TList<T0, TLIST8(T1, T2, T3, T4, T5, T6, T7, T8)>
+
+#define TLIST10(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) \
+  TList<T0, TLIST9(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
+// [[[end]]]
+
+namespace tlist {
+
+  /**
+   * Length<List>::value gives the length of the typelist List.
+   */
+  template <typename List>
+  struct Length { enum { value = 0 }; };
+
+  template <typename T, typename U>
+  struct Length<TList<T, U> > {
+    enum { value = 1 + Length<U>::value };
+  };
+
+  template <typename List, unsigned N, typename D> struct TypeAt_;
+
+  template <unsigned N, typename D>
+  struct TypeAt_<NullType, N, D> { typedef D type; };
+
+  template <typename T, typename U, unsigned N, typename D>
+  struct TypeAt_<TList<T, U>, N, D> {
+    typedef typename TypeAt_<U, N-1, D>::type type;
+  };
+
+  template <typename T, typename U, typename D>
+  struct TypeAt_<TList<T, U>, 0, D> { typedef T type; };
+
+  /**
+   * typename TypeAt<List, N, T>::type gives the type at position N of the
+   * typelist List.  If the index is too large, the default type T will be the
+   * result.  Negative positions are also allowed: -1 corresponds to the last
+   * position in the list, -2 the second-to-last, &c.
+   */
+  template <typename List, int N, typename Default=EmptyType>
+  struct TypeAt {
+    typedef typename TypeAt_<
+        List,
+        N < 0 ? Length<List>::value + N : N,
+        Default
+      >::type type;
+  };
+
+}
+
+#endif
diff --git a/xpcom/glue/functor_cog_utils.py b/xpcom/glue/functor_cog_utils.py
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/functor_cog_utils.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python
+"""
+-*- Mode: python; tab-width: 2; c-basic-offset: 2; indent-tabs-mode: nil -*-
+***** BEGIN LICENSE BLOCK *****
+Version: MPL 1.1/GPL 2.0/LGPL 2.1
+
+The contents of this file are subject to the Mozilla Public License Version
+1.1 (the "License"); you may not use this file except in compliance with
+the License. You may obtain a copy of the License at
+http://www.mozilla.org/MPL/
+
+Software distributed under the License is distributed on an "AS IS" basis,
+WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+for the specific language governing rights and limitations under the
+License.
+
+The Original Code is tlist.
+
+The Initial Developer of the Original Code is
+  Mozilla Corporation.
+Portions created by the Initial Developer are Copyright (C) 2009
+the Initial Developer. All Rights Reserved.
+
+Contributor(s):
+  Ben Newman <b{enjam,newma}n@mozilla.com> (Original Author)
+
+Alternatively, the contents of this file may be used under the terms of
+either the GNU General Public License Version 2 or later (the "GPL"), or
+the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+in which case the provisions of the GPL or the LGPL are applicable instead
+of those above. If you wish to allow use of your version of this file only
+under the terms of either the GPL or the LGPL, and not to allow others to
+use your version of this file under the terms of the MPL, indicate your
+decision by deleting the provisions above and replace them with the notice
+and other provisions required by the GPL or the LGPL. If you do not delete
+the provisions above, a recipient may use your version of this file under
+the terms of any one of the MPL, the GPL or the LGPL.
+
+***** END LICENSE BLOCK *****
+"""
+import cog
+import re
+
+# Generate code for functors of up to this many parameters:
+MAX_FUNCTOR_ARITY = 10
+
+# A versatile list-generation tool.
+# TODO More explanation?
+tpat = re.compile(r"\b[a-z]\b", re.I)
+npat = re.compile(r"\b0\b")
+def tlist(tmpl, rend, rbegin=0, sep=", "):
+  return sep.join(tpat.sub("\g<0>%u" % i,
+                           npat.sub("%u" % i, tmpl))
+                  for i in range(rbegin, rend))
diff --git a/xpcom/tests/Makefile.in b/xpcom/tests/Makefile.in
--- a/xpcom/tests/Makefile.in
+++ b/xpcom/tests/Makefile.in
@@ -68,16 +68,17 @@ CPPSRCS		= \
 		TestRacingServiceManager.cpp \
 		TestRegistrationOrder.cpp \
 		TestThreadPoolListener.cpp \
 		TestTimers.cpp \
 		TestOOM.cpp \
 		TestBlockingProcess.cpp \
 		TestQuickReturn.cpp \
 		TestArguments.cpp \
+		TestFunctor.cpp \
 		$(NULL)
 
 ifndef MOZ_ENABLE_LIBXUL
 CPPSRCS += \
 		TestAtoms.cpp \
 		TestPermanentAtoms.cpp \
 		$(NULL)
 endif
diff --git a/xpcom/tests/TestFunctor.cpp b/xpcom/tests/TestFunctor.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/TestFunctor.cpp
@@ -0,0 +1,107 @@
+#include <iostream>
+#include "Functor.h"
+#include "Bind.h"
+
+int Succ(int n) {
+  return n + 1;
+}
+
+struct Pred
+{
+  int operator()(int n) {
+    return n - 1;
+  }
+};
+
+struct DiffStruct
+{
+  int Sub(int a, int b) {
+    return a - b;
+  }
+  static int Add2(int a, int b) {
+    return a + b;
+  }
+};
+
+void NoReturn(int x, int y) {
+  printf("%d, %d\n", x, y);
+}
+
+void is(int x, int y) {
+  std::cout << (x == y ? "OK: " : "FAIL: ")
+            << x << " = " << y << std::endl;
+}
+
+void example()
+{
+  Functor<int, TLIST1(int)> s = functor(&Succ);
+
+  Pred pred;
+  Functor<int, TLIST1(int)> p = BIND1(&Pred::operator(), &pred);
+
+  Functor<int, TLIST3(DiffStruct*, int, int)> ds =
+    functor(&DiffStruct::Sub);
+
+  Functor<int, TLIST2(int, int)> a2 = functor(&DiffStruct::Add2);
+
+  int a = 1, b = 5;
+  is(s(a), a + 1);
+  is(p(b), b - 1);
+  is(ds(new DiffStruct, s(a), p(b)), a - b + 2);
+
+  // is(std::bind1st(ds, 6)(4), 2);
+  // is(std::bind2nd(ds, 6)(4), -2);
+
+  is(a2(2, 3), 5);
+
+  functor(&NoReturn)(1, 2);
+  return functor(&NoReturn).bind(1)(2);
+}
+
+void test_bind()
+{
+  // Interesting (near-)equivalences:
+  is(Pred()(2), 1);
+  is((Pred().*(&Pred::operator()))(2), 1);
+  is(Pred().operator()(2), 1);
+  is(BIND1(&Pred::operator(), new Pred)(2), 1);
+
+  Functor<int, TLIST2(int, int)> a2 = functor(&DiffStruct::Add2);
+  is(BIND1(a2, 2)(3), 5);
+  is(BIND2(a2, 2, 3)(), 5);
+  is(BIND1(BIND1(a2, 2), 3)(), 5);
+
+  int x = 5, y = 3;
+  DiffStruct ds;
+  Functor<int, TLIST2(int, int)> sub = BIND1(&DiffStruct::Sub, &ds);
+  Functor<int, TLIST1(int)> f = BIND1(sub, x);
+  is(sub(x, y), x - y);
+  is(sub(y, x), y - x);
+  is(f(x), 0);
+  is(f(y), x - y);
+}
+
+int test_Location()
+{
+  OutParam<int>::type out;
+  int n;
+  out = n = 1;
+  ref(n) = 2;
+  // cref(n) = 3;
+  return cref(n);
+}
+
+void test_bind_result()
+{
+  int n;
+  functor(&Succ).bind_result(ref(n))(1);
+  is(n, 2);
+}
+
+int main() {
+  example();
+  test_bind();
+  test_Location();
+  test_bind_result();
+  return 0;
+}
