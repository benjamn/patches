Improved FunctorSupports and Functor::bind implementations (bug 486440).

diff --git a/xpcom/glue/Bind.h b/xpcom/glue/Bind.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/Bind.h
@@ -0,0 +1,127 @@
+/* -*- Mode: c++; tab-width: 2; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is BIND/bind.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef Bind_h__
+#define Bind_h__
+
+#include "Functor.h"
+#include "nsAutoPtr.h"
+
+/**
+ * For an overview of BIND usage, see bug 486440.
+ *
+ * This implementation was inspired by Andrei Alexandrescu's book
+ *
+ *   Modern C++ Design: Generic Programming and Design Patterns Applied,
+ *
+ * which has a great deal more to say on the topic.
+ *
+ * Instructions pertaining to the cog.py code generation tool are available
+ * here: http://nedbatchelder.com/code/cog/
+ *
+ * Once you have installed cog.py, run
+ *
+ *   cog.py -r Bind.h
+ *
+ * to regenerate the portions of this file delimited by the triple square
+ * bracket markers.  The file changes in place, but the python generating code
+ * remains, so repeatedly regenerating the file is really very easy.
+ */
+
+// [[[cog
+// from functor_cog_utils import tlist, MAX_FUNCTOR_ARITY
+// rng = range(MAX_FUNCTOR_ARITY+1)
+// ijs = zip(rng, rng[1:])
+// ]]]
+// [[[end]]]
+
+
+
+/**
+ * The BIND{1,2,...} macros save some typing by linearizing the syntax for
+ * binding multiple arguments.  Additionally, the BIND0 macro ensures that the
+ * first argument is converted to a Functor.  There is no reason to use BIND0
+ * directly instead of the global functor function(s), but you know what? do
+ * whatever you want. Life is short.
+ */
+#define BIND0(F) functor(F)
+
+// [[[cog
+// slash = "\\"
+// for (i, j) in ijs:
+//   alist = tlist("A", j)
+//   ainit = tlist(", A", i, sep="")
+//   alast = "A%d" % i;
+//   cog.out(r"""
+// #define BIND%(j)d(F, %(alist)s) %(slash)s
+//   BIND%(i)d(F%(ainit)s).bind(%(alast)s)
+// """ % locals())
+// ]]]
+
+#define BIND1(F, A0) \
+  BIND0(F).bind(A0)
+
+#define BIND2(F, A0, A1) \
+  BIND1(F, A0).bind(A1)
+
+#define BIND3(F, A0, A1, A2) \
+  BIND2(F, A0, A1).bind(A2)
+
+#define BIND4(F, A0, A1, A2, A3) \
+  BIND3(F, A0, A1, A2).bind(A3)
+
+#define BIND5(F, A0, A1, A2, A3, A4) \
+  BIND4(F, A0, A1, A2, A3).bind(A4)
+
+#define BIND6(F, A0, A1, A2, A3, A4, A5) \
+  BIND5(F, A0, A1, A2, A3, A4).bind(A5)
+
+#define BIND7(F, A0, A1, A2, A3, A4, A5, A6) \
+  BIND6(F, A0, A1, A2, A3, A4, A5).bind(A6)
+
+#define BIND8(F, A0, A1, A2, A3, A4, A5, A6, A7) \
+  BIND7(F, A0, A1, A2, A3, A4, A5, A6).bind(A7)
+
+#define BIND9(F, A0, A1, A2, A3, A4, A5, A6, A7, A8) \
+  BIND8(F, A0, A1, A2, A3, A4, A5, A6, A7).bind(A8)
+
+#define BIND10(F, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) \
+  BIND9(F, A0, A1, A2, A3, A4, A5, A6, A7, A8).bind(A9)
+// [[[end]]]
+
+#endif
diff --git a/xpcom/glue/Functor.h b/xpcom/glue/Functor.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/Functor.h
@@ -0,0 +1,858 @@
+/* -*- Mode: c++; tab-width: 2; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Functor.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef Functor_h__
+#define Functor_h__
+
+#include "nsISupports.h"
+#include "nsIRunnable.h"
+#include "nsAutoPtr.h"
+#include "TList.h"
+#include "Location.h"
+
+/**
+ * For an overview of Functor usage, see bug 486440.
+ *
+ * This implementation was inspired by Andrei Alexandrescu's book
+ *
+ *   Modern C++ Design: Generic Programming and Design Patterns Applied,
+ *
+ * which has a great deal more to say on the topic.
+ *
+ * Instructions pertaining to the cog.py code generation tool are available
+ * here: http://nedbatchelder.com/code/cog/
+ *
+ * Once you have installed cog.py, run
+ *
+ *   cog.py -r Functor.h
+ *
+ * to regenerate the portions of this file delimited by the triple square
+ * bracket markers.  The file changes in place, but the python generating code
+ * remains, so repeatedly regenerating the file is really very easy.
+ */
+
+// [[[cog
+// # Any insuffciency of functor parameters can be solved by increasing
+// # MAX_FUNCTOR_ARITY:
+// from functor_cog_utils import tlist, MAX_FUNCTOR_ARITY
+// rng = range(MAX_FUNCTOR_ARITY+1)
+// ijs = zip(rng, rng[1:])
+// ]]]
+// [[[end]]]
+
+/**
+ * Reference counting base class from which all the FunctorImpl partial
+ * specializations inherit.  AddRef and Release need to be atomic because
+ * Functors may be copied between threads, but the burden of keeping bound
+ * arguments thread-safe still falls entirely on the client.
+ */
+class FunctorSupports {
+  nsAutoRefCnt mRefCnt;
+public:
+  nsrefcnt AddRef();
+  nsrefcnt Release();
+protected:
+  virtual ~FunctorSupports() {}
+};
+inline NS_IMPL_THREADSAFE_ADDREF(FunctorSupports)
+inline NS_IMPL_THREADSAFE_RELEASE(FunctorSupports)
+
+/**
+ * Abstract interface for the heap-allocated functor objects (CallableHandler,
+ * MethodHandler, Binder, Voider, &c.) to which Functors hold references. Since
+ * FunctorImpl inherits from FunctorSupports, derived classes inherit the
+ * AddRef and Release methods required by nsRefPtr<FunctorImpl>.
+ */
+template <typename Result, class Params>
+class FunctorImpl;
+
+// [[[cog
+// for i in rng:
+//   ctnTs = tlist(", typename T", i, sep="")
+//   Ts = tlist("T", i)
+//   cog.out("""
+// template <typename R%(ctnTs)s>
+// class FunctorImpl<R, TLIST%(i)d(%(Ts)s)> : public FunctorSupports {
+// public:
+//   virtual R operator()(%(Ts)s) = 0;
+// };""" % locals())
+// ]]]
+
+template <typename R>
+class FunctorImpl<R, TLIST0()> : public FunctorSupports {
+public:
+  virtual R operator()() = 0;
+};
+template <typename R, typename T0>
+class FunctorImpl<R, TLIST1(T0)> : public FunctorSupports {
+public:
+  virtual R operator()(T0) = 0;
+};
+template <typename R, typename T0, typename T1>
+class FunctorImpl<R, TLIST2(T0, T1)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2>
+class FunctorImpl<R, TLIST3(T0, T1, T2)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3>
+class FunctorImpl<R, TLIST4(T0, T1, T2, T3)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
+class FunctorImpl<R, TLIST5(T0, T1, T2, T3, T4)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
+class FunctorImpl<R, TLIST6(T0, T1, T2, T3, T4, T5)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
+class FunctorImpl<R, TLIST7(T0, T1, T2, T3, T4, T5, T6)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5, T6) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
+class FunctorImpl<R, TLIST8(T0, T1, T2, T3, T4, T5, T6, T7)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5, T6, T7) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
+class FunctorImpl<R, TLIST9(T0, T1, T2, T3, T4, T5, T6, T7, T8)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5, T6, T7, T8) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
+class FunctorImpl<R, TLIST10(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) = 0;
+};
+// [[[end]]]
+
+
+template <class ParentFunctor, typename Callable>
+class CallableHandler;
+
+template <class ParentFunctor, typename Method>
+class MethodHandler;
+
+template <class ParentFunctor, typename Bound>
+class Binder;
+
+template <class ParentFunctor, typename LocationType>
+class Voider;
+
+// [[[cog
+// cog.out("#define EXTRACT_TYPEDEFS(LIST) \\\n")
+// cog.out(tlist("  typedef typename tlist::TypeAt<LIST, 0>::type P;",
+//               MAX_FUNCTOR_ARITY, sep=" \\\n"))
+// ]]]
+#define EXTRACT_TYPEDEFS(LIST) \
+  typedef typename tlist::TypeAt<LIST, 0>::type P0; \
+  typedef typename tlist::TypeAt<LIST, 1>::type P1; \
+  typedef typename tlist::TypeAt<LIST, 2>::type P2; \
+  typedef typename tlist::TypeAt<LIST, 3>::type P3; \
+  typedef typename tlist::TypeAt<LIST, 4>::type P4; \
+  typedef typename tlist::TypeAt<LIST, 5>::type P5; \
+  typedef typename tlist::TypeAt<LIST, 6>::type P6; \
+  typedef typename tlist::TypeAt<LIST, 7>::type P7; \
+  typedef typename tlist::TypeAt<LIST, 8>::type P8; \
+  typedef typename tlist::TypeAt<LIST, 9>::type P9;
+// [[[end]]]
+
+/**
+ * The Functor class is just a value-type wrapper around the reference-type
+ * FunctorImpl object mImpl.  It isn't meant to be inherited from, so none of
+ * its methods are virtual.  It doesn't even need a virtual destructor.  You
+ * can (and should) copy Functors by value.
+ *
+ * TODO The parameter types should be made references when possible.
+ * Unfortunately, references to references are illegal, so getting this right
+ * would require some additional template trickery.
+ */
+template <typename Result, class Params>
+class Functor
+{
+public:
+  typedef FunctorImpl<Result, Params> ImplType;
+  typedef Result ResultType;
+  typedef Params ParamList;
+
+  Functor(const Functor& f) : mImpl(f.mImpl) {}
+  Functor(ImplType* impl)   : mImpl(impl) {}
+ ~Functor() {} // deliberately non-virtual
+
+  template <typename Callable>
+  static Functor callable(Callable c) {
+    return Functor(new CallableHandler<Functor, Callable>(c));
+  }
+
+  template <typename Method>
+  static Functor method(Method m) {
+    return Functor(new MethodHandler<Functor, Method>(m));
+  }
+
+  /**
+   * The bind method returns a Functor with one less parameter than the Functor
+   * object receiving the bind method invocation.  When the resulting Functor
+   * is invoked, the bound argument will be passed as the first argument to the
+   * original Functor.
+   *
+   * Note that the type used for storing the bound value is determined by the
+   * value passed to bind, not by the Functor's first parameter type.  This
+   * distinction becomes important when the stored value needs to be copied or
+   * AddRefed but the actual parameter type is just a bare pointer.
+   */
+  template <typename Bound>
+  typename Binder<Functor, Bound>::Outgoing
+  bind(Bound bound) {
+    typedef Binder<Functor, Bound> B;
+    typedef typename B::Outgoing O;
+    typedef typename O::ImplType I;
+    I* binder = new B(*this, bound);
+    return O(binder);
+  }
+
+  /**
+   * The bind_result method may be called against non-void Functors and returns
+   * a void Functor that puts the return value of the original Functor into the
+   * provided Location<ResultType, StoragePolicy> argument.  See Location.h for
+   * an explanation of Location objects (N.B. the ref/cref functions).
+   *
+   * Example:
+   *   Counter c;
+   *   Location<int> out;
+   *   functor(&Counter::GetCount).bind_result(out)(&c);
+   *   int count = out;
+   */
+  template <typename R, template <typename> class StoragePolicy>
+  typename Voider<Functor, Location<R, StoragePolicy> >::Outgoing
+  bind_result(Location<R, StoragePolicy> loc) {
+    typedef Voider<Functor, Location<R, StoragePolicy> > V;
+    typedef typename V::Outgoing O;
+    typedef typename O::ImplType I;
+    I* voider = new V(*this, loc);
+    return O(voider);
+  }
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng:
+  //   Pps = tlist("P p", i)
+  //   ps = tlist("p", i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return (*mImpl)(%(ps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    return (*mImpl)();
+  }
+  ResultType operator()(P0 p0) {
+    return (*mImpl)(p0);
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    return (*mImpl)(p0, p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    return (*mImpl)(p0, p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    return (*mImpl)(p0, p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    return (*mImpl)(p0, p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  // [[[end]]]
+
+private:
+  nsRefPtr<ImplType> mImpl;
+};
+
+/**
+ * Callable entities include global functions, objects that support operator(),
+ * and static member functions.  The implementation of this class is generic
+ * with respect to these possibilities: as long as mCallable can be called with
+ * some number of arguments between zero and MAX_FUNCTOR_ARITY (inclusive),
+ * your code will compile.
+ */
+template <class ParentFunctor, typename Callable>
+class CallableHandler
+  : public FunctorImpl<
+      typename ParentFunctor::ResultType,
+      typename ParentFunctor::ParamList>
+{
+public:
+  CallableHandler(Callable c) : mCallable(c) {}
+
+  typedef typename ParentFunctor::ResultType ResultType;
+  typedef typename ParentFunctor::ParamList  ParamList;
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng:
+  //   Pps = tlist("P p", i)
+  //   ps = tlist("p", i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return mCallable(%(ps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    return mCallable();
+  }
+  ResultType operator()(P0 p0) {
+    return mCallable(p0);
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    return mCallable(p0, p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    return mCallable(p0, p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    return mCallable(p0, p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    return mCallable(p0, p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return mCallable(p0, p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return mCallable(p0, p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return mCallable(p0, p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return mCallable(p0, p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    return mCallable(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  // [[[end]]]
+
+private:
+  Callable mCallable;
+};
+
+/**
+ * Methods of n parameters become Functors of n+1 parameters, where the first
+ * parameter names the object to receive the method invocation.
+ */
+template <class ParentFunctor, typename Method>
+class MethodHandler
+  : public FunctorImpl<
+      typename ParentFunctor::ResultType,
+      typename ParentFunctor::ParamList>
+{
+public:
+  MethodHandler(Method m) : mMethod(m) {}
+
+  typedef typename ParentFunctor::ResultType ResultType;
+  typedef typename ParentFunctor::ParamList  ParamList;
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng[1:]:
+  //   Pps = tlist("P p", i)
+  //   ps1 = tlist("p", rbegin=1, rend=i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return ((*p0).*mMethod)(%(ps1)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()(P0 p0) {
+    return ((*p0).*mMethod)();
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    return ((*p0).*mMethod)(p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    return ((*p0).*mMethod)(p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    return ((*p0).*mMethod)(p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  // [[[end]]]
+
+private:
+  Method mMethod;
+};
+
+/**
+ * Binder class for use with Functor::bind.
+ */
+template <class ParentFunctor, typename Bound>
+class Binder
+  : public FunctorImpl<typename ParentFunctor::ResultType,
+                       typename ParentFunctor::ParamList::Tail>
+{
+public:
+  Binder(ParentFunctor fun, Bound bound)
+    : mFun(fun)
+    , mBound(bound)
+  {}
+
+  typedef typename ParentFunctor::ResultType      ResultType;
+  typedef typename ParentFunctor::ParamList::Tail ParamList;
+  typedef Functor<ResultType, ParamList>          Outgoing;
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng[:-1]:
+  //   Pps = tlist("P p", i)
+  //   cps = tlist(", p", i, sep="")
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return mFun(mBound%(cps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    return mFun(mBound);
+  }
+  ResultType operator()(P0 p0) {
+    return mFun(mBound, p0);
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    return mFun(mBound, p0, p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    return mFun(mBound, p0, p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    return mFun(mBound, p0, p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    return mFun(mBound, p0, p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return mFun(mBound, p0, p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return mFun(mBound, p0, p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return mFun(mBound, p0, p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return mFun(mBound, p0, p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  // [[[end]]]
+
+private:
+  ParentFunctor mFun;
+  Bound mBound;
+};
+
+template
+<class ParentFunctor, typename LocationType>
+class Voider
+  : public FunctorImpl<void, typename ParentFunctor::ParamList>
+{
+public:
+  Voider(ParentFunctor fun, LocationType loc)
+    : mFun(fun)
+    , mLoc(loc)
+  {}
+
+  typedef void ResultType;
+  typedef typename ParentFunctor::ParamList ParamList;
+  typedef Functor<ResultType, ParamList> Outgoing;
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng:
+  //   Pps = tlist("P p", i)
+  //   cps = tlist("p", i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   mLoc = mFun(%(cps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    mLoc = mFun();
+  }
+  ResultType operator()(P0 p0) {
+    mLoc = mFun(p0);
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    mLoc = mFun(p0, p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    mLoc = mFun(p0, p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    mLoc = mFun(p0, p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    mLoc = mFun(p0, p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  // [[[end]]]
+
+private:
+  ParentFunctor mFun;
+  LocationType mLoc;
+};
+
+// Sayonara, macro scum!
+#undef EXTRACT_TYPEDEFS
+
+/**
+ * Herebelow lies a jungle of functor adapter functions.  I did not write them;
+ * I generated them.  Even the comments are auto-generated.  If you need to
+ * modify them, you really, really should change and re-run the generator code
+ * rather than editing the functions themselves.
+ */
+
+// Pass already-Functors through unmodified:
+template <typename Result, class Params>
+Functor<Result, Params>
+functor(Functor<Result, Params> f) {
+  return f;
+}
+
+// [[[cog
+// # The i parameter specifies the number of parameters the adapted
+// # functions/functors/methods should support:
+// def output_global_adapters(i):
+//   j = i + 1
+//   ctnPs = tlist(", typename P", i, sep="")
+//   cPs = tlist(", P", i, sep="")
+//   Ps = tlist("P", i)
+//
+//   tmpl = """
+// template <typename R, class C%(ctnPs)s>
+// Functor<R, TLIST%(j)d(C*%(cPs)s)>
+// functor(R (C::*m)(%(Ps)s)%(const)s) {
+//   return Functor<R, TLIST%(j)d(C*%(cPs)s)>::method(m);
+// }"""
+//
+//   plural = "s"[int(i==1):]
+//
+//   # Can't actually handle methods with MAX_FUNCTOR_ARITY parameters, since
+//   # the first parameter is reserved for the receiving object:
+//   if i < MAX_FUNCTOR_ARITY:
+//     cog.out("""
+// // Adapters for methods with %d parameter%s:""" % (i, plural))
+//     const = ""
+//     cog.out(tmpl % locals())
+//     const = " const"
+//     cog.out(tmpl % locals())
+//
+//   cog.out("""
+// // Adapter for global functions with %d parameter%s:""" % (i, plural))
+//   cog.out("""
+// template <typename R%(ctnPs)s>
+// Functor<R, TLIST%(i)d(%(Ps)s)>
+// functor(R (*f)(%(Ps)s)) {
+//   return Functor<R, TLIST%(i)d(%(Ps)s)>::callable(f);
+// }
+//
+// """ % locals())
+//
+// for i in rng:
+//   output_global_adapters(i)
+// ]]]
+
+// Adapters for methods with 0 parameters:
+template <typename R, class C>
+Functor<R, TLIST1(C*)>
+functor(R (C::*m)()) {
+  return Functor<R, TLIST1(C*)>::method(m);
+}
+template <typename R, class C>
+Functor<R, TLIST1(C*)>
+functor(R (C::*m)() const) {
+  return Functor<R, TLIST1(C*)>::method(m);
+}
+// Adapter for global functions with 0 parameters:
+template <typename R>
+Functor<R, TLIST0()>
+functor(R (*f)()) {
+  return Functor<R, TLIST0()>::callable(f);
+}
+
+
+// Adapters for methods with 1 parameter:
+template <typename R, class C, typename P0>
+Functor<R, TLIST2(C*, P0)>
+functor(R (C::*m)(P0)) {
+  return Functor<R, TLIST2(C*, P0)>::method(m);
+}
+template <typename R, class C, typename P0>
+Functor<R, TLIST2(C*, P0)>
+functor(R (C::*m)(P0) const) {
+  return Functor<R, TLIST2(C*, P0)>::method(m);
+}
+// Adapter for global functions with 1 parameter:
+template <typename R, typename P0>
+Functor<R, TLIST1(P0)>
+functor(R (*f)(P0)) {
+  return Functor<R, TLIST1(P0)>::callable(f);
+}
+
+
+// Adapters for methods with 2 parameters:
+template <typename R, class C, typename P0, typename P1>
+Functor<R, TLIST3(C*, P0, P1)>
+functor(R (C::*m)(P0, P1)) {
+  return Functor<R, TLIST3(C*, P0, P1)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1>
+Functor<R, TLIST3(C*, P0, P1)>
+functor(R (C::*m)(P0, P1) const) {
+  return Functor<R, TLIST3(C*, P0, P1)>::method(m);
+}
+// Adapter for global functions with 2 parameters:
+template <typename R, typename P0, typename P1>
+Functor<R, TLIST2(P0, P1)>
+functor(R (*f)(P0, P1)) {
+  return Functor<R, TLIST2(P0, P1)>::callable(f);
+}
+
+
+// Adapters for methods with 3 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2>
+Functor<R, TLIST4(C*, P0, P1, P2)>
+functor(R (C::*m)(P0, P1, P2)) {
+  return Functor<R, TLIST4(C*, P0, P1, P2)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2>
+Functor<R, TLIST4(C*, P0, P1, P2)>
+functor(R (C::*m)(P0, P1, P2) const) {
+  return Functor<R, TLIST4(C*, P0, P1, P2)>::method(m);
+}
+// Adapter for global functions with 3 parameters:
+template <typename R, typename P0, typename P1, typename P2>
+Functor<R, TLIST3(P0, P1, P2)>
+functor(R (*f)(P0, P1, P2)) {
+  return Functor<R, TLIST3(P0, P1, P2)>::callable(f);
+}
+
+
+// Adapters for methods with 4 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3>
+Functor<R, TLIST5(C*, P0, P1, P2, P3)>
+functor(R (C::*m)(P0, P1, P2, P3)) {
+  return Functor<R, TLIST5(C*, P0, P1, P2, P3)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3>
+Functor<R, TLIST5(C*, P0, P1, P2, P3)>
+functor(R (C::*m)(P0, P1, P2, P3) const) {
+  return Functor<R, TLIST5(C*, P0, P1, P2, P3)>::method(m);
+}
+// Adapter for global functions with 4 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3>
+Functor<R, TLIST4(P0, P1, P2, P3)>
+functor(R (*f)(P0, P1, P2, P3)) {
+  return Functor<R, TLIST4(P0, P1, P2, P3)>::callable(f);
+}
+
+
+// Adapters for methods with 5 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4>
+Functor<R, TLIST6(C*, P0, P1, P2, P3, P4)>
+functor(R (C::*m)(P0, P1, P2, P3, P4)) {
+  return Functor<R, TLIST6(C*, P0, P1, P2, P3, P4)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4>
+Functor<R, TLIST6(C*, P0, P1, P2, P3, P4)>
+functor(R (C::*m)(P0, P1, P2, P3, P4) const) {
+  return Functor<R, TLIST6(C*, P0, P1, P2, P3, P4)>::method(m);
+}
+// Adapter for global functions with 5 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4>
+Functor<R, TLIST5(P0, P1, P2, P3, P4)>
+functor(R (*f)(P0, P1, P2, P3, P4)) {
+  return Functor<R, TLIST5(P0, P1, P2, P3, P4)>::callable(f);
+}
+
+
+// Adapters for methods with 6 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
+Functor<R, TLIST7(C*, P0, P1, P2, P3, P4, P5)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5)) {
+  return Functor<R, TLIST7(C*, P0, P1, P2, P3, P4, P5)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
+Functor<R, TLIST7(C*, P0, P1, P2, P3, P4, P5)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5) const) {
+  return Functor<R, TLIST7(C*, P0, P1, P2, P3, P4, P5)>::method(m);
+}
+// Adapter for global functions with 6 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
+Functor<R, TLIST6(P0, P1, P2, P3, P4, P5)>
+functor(R (*f)(P0, P1, P2, P3, P4, P5)) {
+  return Functor<R, TLIST6(P0, P1, P2, P3, P4, P5)>::callable(f);
+}
+
+
+// Adapters for methods with 7 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
+Functor<R, TLIST8(C*, P0, P1, P2, P3, P4, P5, P6)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5, P6)) {
+  return Functor<R, TLIST8(C*, P0, P1, P2, P3, P4, P5, P6)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
+Functor<R, TLIST8(C*, P0, P1, P2, P3, P4, P5, P6)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5, P6) const) {
+  return Functor<R, TLIST8(C*, P0, P1, P2, P3, P4, P5, P6)>::method(m);
+}
+// Adapter for global functions with 7 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
+Functor<R, TLIST7(P0, P1, P2, P3, P4, P5, P6)>
+functor(R (*f)(P0, P1, P2, P3, P4, P5, P6)) {
+  return Functor<R, TLIST7(P0, P1, P2, P3, P4, P5, P6)>::callable(f);
+}
+
+
+// Adapters for methods with 8 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
+Functor<R, TLIST9(C*, P0, P1, P2, P3, P4, P5, P6, P7)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5, P6, P7)) {
+  return Functor<R, TLIST9(C*, P0, P1, P2, P3, P4, P5, P6, P7)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
+Functor<R, TLIST9(C*, P0, P1, P2, P3, P4, P5, P6, P7)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5, P6, P7) const) {
+  return Functor<R, TLIST9(C*, P0, P1, P2, P3, P4, P5, P6, P7)>::method(m);
+}
+// Adapter for global functions with 8 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
+Functor<R, TLIST8(P0, P1, P2, P3, P4, P5, P6, P7)>
+functor(R (*f)(P0, P1, P2, P3, P4, P5, P6, P7)) {
+  return Functor<R, TLIST8(P0, P1, P2, P3, P4, P5, P6, P7)>::callable(f);
+}
+
+
+// Adapters for methods with 9 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
+Functor<R, TLIST10(C*, P0, P1, P2, P3, P4, P5, P6, P7, P8)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5, P6, P7, P8)) {
+  return Functor<R, TLIST10(C*, P0, P1, P2, P3, P4, P5, P6, P7, P8)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
+Functor<R, TLIST10(C*, P0, P1, P2, P3, P4, P5, P6, P7, P8)>
+functor(R (C::*m)(P0, P1, P2, P3, P4, P5, P6, P7, P8) const) {
+  return Functor<R, TLIST10(C*, P0, P1, P2, P3, P4, P5, P6, P7, P8)>::method(m);
+}
+// Adapter for global functions with 9 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
+Functor<R, TLIST9(P0, P1, P2, P3, P4, P5, P6, P7, P8)>
+functor(R (*f)(P0, P1, P2, P3, P4, P5, P6, P7, P8)) {
+  return Functor<R, TLIST9(P0, P1, P2, P3, P4, P5, P6, P7, P8)>::callable(f);
+}
+
+
+// Adapter for global functions with 10 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
+Functor<R, TLIST10(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9)>
+functor(R (*f)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9)) {
+  return Functor<R, TLIST10(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9)>::callable(f);
+}
+
+// [[[end]]]
+
+
+#endif
diff --git a/xpcom/glue/Location.h b/xpcom/glue/Location.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/Location.h
@@ -0,0 +1,199 @@
+/* -*- Mode: c++; tab-width: 2; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Location.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef Location_h__
+#define Location_h__
+
+#include "nsAutoPtr.h" // for nsRefPtr
+
+// Forward declaration of StoragePolicy classes:
+template <typename T> class ClientManagedStoragePolicy;
+template <typename T> class RefPtrStoragePolicy;
+template <typename T> class RefCountingStoragePolicy;
+
+/**
+ * A Location represents a single assignable place in memory.  Location
+ * objects may be cheaply copied, but every copy refers to the same location.
+ * Conversion operators expose both references and pointers to the underlying
+ * value, so Locations are good for imposing constraints on out-parameters.
+ * These constraints are expressed through a StoragePolicy template parameter,
+ * which is responsible for implementing GetPointer, GetConstPointer, and one
+ * or more constructors.  If the client avoids using a certain method (such as
+ * operator=), any demands the method makes on the StoragePolicy base class
+ * (such as the availability of a GetPointer method) are waived, because the
+ * compiler does not generate code for unused template methods.
+ *
+ * Andrei Alexandrescu has a chapter about policy classes in his Modern C++
+ * Design book.
+ */
+template
+<
+  typename T, // Reference types do not work, and that is as it should be.
+  template <typename> class StoragePolicy = RefCountingStoragePolicy
+>
+class Location : private StoragePolicy<T>
+{
+public:
+  explicit Location() {}
+  explicit Location(T* tp) : StoragePolicy<T>(tp) {}
+
+  // Any type that can be assigned to a dereferenced T* is legal here:
+  template <typename R>
+  Location& operator=(const R& rhs) {
+    *this->GetPointer() = rhs;
+    return *this;
+  }
+
+  operator T&() { return *this->GetPointer(); }
+  operator const T&() const { return *this->GetConstPointer(); }
+
+  operator T*() { return this->GetPointer(); }
+  operator const T*() const { return this->GetConstPointer(); }
+
+  /**
+   * Since Locations are always associated with persistent memory, it's
+   * reasonable to allow passing temporary Locations by reference; e.g.,
+   *
+   *   template <typename T>
+   *   void foo(T& tref) { tref = 1; }
+   *   ...
+   *   int out;
+   *   foo(Location<int, ClientManagedStoragePolicy>(&out));
+   *   foo(ref(out)); // equivalent to the previous line
+   *
+   * Here type T will be inferred as Location<int, ClientManagedStoragePolicy>.
+   * Both calls to foo have the effect of setting out to 1.  Because Locations
+   * provide a non-const Location& conversion operator, g++ doesn't complain
+   * about the creation of references to temporary values.
+   */
+  operator Location&() { return *this; }
+  operator const Location&() const { return *this; }
+};
+
+
+/**
+ * ClientManagedStoragePolicy assumes nothing about the allocation and
+ * management of T, and consequently provides the client no assistance to that
+ * end.  This policy class is intended primarily for use by ref and cref.
+ */
+template <typename T>
+class ClientManagedStoragePolicy
+{
+  T* const mPtr;
+protected:
+  ClientManagedStoragePolicy(T* tp) : mPtr(tp) {}
+  T* GetPointer() { return mPtr; }
+  const T* GetConstPointer() const { return mPtr; }
+};
+
+/**
+ * nsRefPtr<T> enforces the availability of T::AddRef and T::Release, so it may
+ * be assumed that any object of type T is both reference counted and not stack
+ * allocated.  This guarantee makes it safe to provide a T* constructor without
+ * worry that the client may pass in a stack address.  For convenience, a zero-
+ * parameter constructor is also provided for situations where T is default-
+ * constructible and the client wants RefPtrStoragePolicy to do the allocation.
+ */
+template <typename T>
+class RefPtrStoragePolicy
+{
+  nsRefPtr<T> mPtr;
+protected:
+  RefPtrStoragePolicy() : mPtr(new T()) {}
+  RefPtrStoragePolicy(T* tp) : mPtr(tp) {}
+  T* GetPointer() { return mPtr; }
+  const T* GetConstPointer() const { return mPtr; }
+};
+
+/**
+ * Unlike RefPtrStoragePolicy, this policy class is completely agnostic about
+ * the type of T and assumes full responsibility for counting references.
+ *
+ * RefCountingStoragePolicy provides only a zero-parameter constructor to force
+ * heap allocation of the underlying T value.
+ */
+template <typename T>
+class RefCountingStoragePolicy
+{
+  struct Holder {
+    T mVal; // must be default-constructible:
+    Holder() : mVal() {}
+    nsAutoRefCnt mRefCnt;
+    nsrefcnt AddRef();
+    nsrefcnt Release();
+  };
+  nsRefPtr<Holder> mHolderPtr;
+protected:
+  RefCountingStoragePolicy() : mHolderPtr(new Holder()) {}
+  T* GetPointer() { return &mHolderPtr->mVal; }
+  const T* GetConstPointer() const { return &mHolderPtr->mVal; }
+};
+template <typename T>
+NS_IMPL_THREADSAFE_ADDREF(RefCountingStoragePolicy<T>::Holder)
+template <typename T>
+NS_IMPL_THREADSAFE_RELEASE(RefCountingStoragePolicy<T>::Holder)
+
+
+/**
+ * Template type inference prefers non-reference types to reference types, so
+ * references passed to bind will be stored by VALUE unless explicitly coerced
+ * using the ref and cref (const reference) functions below.
+ */
+
+template <typename T>
+Location<T, ClientManagedStoragePolicy>
+ref(T& t)
+{
+  return Location<T, ClientManagedStoragePolicy>(&t);
+}
+
+template <typename T>
+const Location<const T, ClientManagedStoragePolicy>
+cref(const T& t)
+{
+  typedef const Location<const T, ClientManagedStoragePolicy> type;
+  return type(&t);
+}
+
+template <typename T>
+struct OutParam
+{
+  typedef Location<T, RefCountingStoragePolicy> type;
+};
+
+#endif
diff --git a/xpcom/glue/Makefile.in b/xpcom/glue/Makefile.in
--- a/xpcom/glue/Makefile.in
+++ b/xpcom/glue/Makefile.in
@@ -122,16 +122,20 @@ SDK_HEADERS = \
 		$(NULL)
 
 EXPORTS_NAMESPACES = mozilla
 
 EXPORTS = \
 		nsThreadUtils.h \
 		nsProxyRelease.h \
 		nsXPTCUtils.h \
+		Location.h \
+		TList.h \
+		Functor.h \
+		Bind.h \
 		$(NULL)
 
 EXPORTS_mozilla = \
   BlockingResourceBase.h \
   CondVar.h \
   DeadlockDetector.h \
   Monitor.h \
   Mutex.h \
diff --git a/xpcom/glue/TList.h b/xpcom/glue/TList.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/TList.h
@@ -0,0 +1,169 @@
+/* -*- Mode: c++; tab-width: 2; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is TList/TLIST{0,1,...}.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __tlist_h__
+#define __tlist_h__
+
+/**
+ * TLists, or type lists, are Lisp-style linked lists of types.  This file only
+ * scratches the surface of what is possible with type lists, but I only needed
+ * to calculate lengths and access types by index, so that's all I bothered
+ * implementing.
+ *
+ * Andrei Alexandrescu's book
+ *
+ *   Modern C++ Design: Generic Programming and Design Patterns Applied
+ *
+ * has a great deal more to say on this topic.
+ *
+ * Instructions pertaining to the cog.py code generation tool are available
+ * here: http://nedbatchelder.com/code/cog/
+ *
+ * Once you have installed cog.py, run
+ *
+ *   cog.py -r TList.h
+ *
+ * to regenerate the portions of this file delimited by the triple square
+ * bracket markers.  The file changes in place, but the python generating code
+ * remains, so repeatedly regenerating the file is really very easy.
+ */
+
+// [[[cog
+// from functor_cog_utils import tlist, MAX_FUNCTOR_ARITY
+// rng = range(MAX_FUNCTOR_ARITY+1)
+// ijs = zip(rng, rng[1:])
+// ]]]
+// [[[end]]]
+
+class NullType {};
+struct EmptyType {};
+
+template <typename T, typename U>
+struct TList {
+  typedef T Head;
+  typedef U Tail;
+};
+
+#define TLIST0() NullType
+
+// [[[cog
+// for (i, j) in ijs:
+//   Ts = tlist("T", j)
+//   Tcdr = tlist("T", rbegin=1, rend=j)
+//   slash = "\\"
+//   cog.out("""
+// #define TLIST%(j)d(%(Ts)s) %(slash)s
+//   TList<T0, TLIST%(i)d(%(Tcdr)s)>
+// """ % locals())
+// ]]]
+
+#define TLIST1(T0) \
+  TList<T0, TLIST0()>
+
+#define TLIST2(T0, T1) \
+  TList<T0, TLIST1(T1)>
+
+#define TLIST3(T0, T1, T2) \
+  TList<T0, TLIST2(T1, T2)>
+
+#define TLIST4(T0, T1, T2, T3) \
+  TList<T0, TLIST3(T1, T2, T3)>
+
+#define TLIST5(T0, T1, T2, T3, T4) \
+  TList<T0, TLIST4(T1, T2, T3, T4)>
+
+#define TLIST6(T0, T1, T2, T3, T4, T5) \
+  TList<T0, TLIST5(T1, T2, T3, T4, T5)>
+
+#define TLIST7(T0, T1, T2, T3, T4, T5, T6) \
+  TList<T0, TLIST6(T1, T2, T3, T4, T5, T6)>
+
+#define TLIST8(T0, T1, T2, T3, T4, T5, T6, T7) \
+  TList<T0, TLIST7(T1, T2, T3, T4, T5, T6, T7)>
+
+#define TLIST9(T0, T1, T2, T3, T4, T5, T6, T7, T8) \
+  TList<T0, TLIST8(T1, T2, T3, T4, T5, T6, T7, T8)>
+
+#define TLIST10(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) \
+  TList<T0, TLIST9(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
+// [[[end]]]
+
+namespace tlist {
+
+  /**
+   * Length<List>::value gives the length of the typelist List.
+   */
+  template <typename List>
+  struct Length { enum { value = 0 }; };
+
+  template <typename T, typename U>
+  struct Length<TList<T, U> > {
+    enum { value = 1 + Length<U>::value };
+  };
+
+  template <typename List, unsigned N, typename D> struct TypeAt_;
+
+  template <unsigned N, typename D>
+  struct TypeAt_<NullType, N, D> { typedef D type; };
+
+  template <typename T, typename U, unsigned N, typename D>
+  struct TypeAt_<TList<T, U>, N, D> {
+    typedef typename TypeAt_<U, N-1, D>::type type;
+  };
+
+  template <typename T, typename U, typename D>
+  struct TypeAt_<TList<T, U>, 0, D> { typedef T type; };
+
+  /**
+   * typename TypeAt<List, N, T>::type gives the type at position N of the
+   * typelist List.  If the index is too large, the default type T will be the
+   * result.  Negative positions are also allowed: -1 corresponds to the last
+   * position in the list, -2 the second-to-last, &c.
+   */
+  template <typename List, int N, typename Default=EmptyType>
+  struct TypeAt {
+    typedef typename TypeAt_<
+        List,
+        N < 0 ? Length<List>::value + N : N,
+        Default
+      >::type type;
+  };
+
+}
+
+#endif
diff --git a/xpcom/glue/functor_cog_utils.py b/xpcom/glue/functor_cog_utils.py
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/functor_cog_utils.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python
+"""
+-*- Mode: python; tab-width: 2; c-basic-offset: 2; indent-tabs-mode: nil -*-
+***** BEGIN LICENSE BLOCK *****
+Version: MPL 1.1/GPL 2.0/LGPL 2.1
+
+The contents of this file are subject to the Mozilla Public License Version
+1.1 (the "License"); you may not use this file except in compliance with
+the License. You may obtain a copy of the License at
+http://www.mozilla.org/MPL/
+
+Software distributed under the License is distributed on an "AS IS" basis,
+WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+for the specific language governing rights and limitations under the
+License.
+
+The Original Code is tlist.
+
+The Initial Developer of the Original Code is
+  Mozilla Corporation.
+Portions created by the Initial Developer are Copyright (C) 2009
+the Initial Developer. All Rights Reserved.
+
+Contributor(s):
+  Ben Newman <b{enjam,newma}n@mozilla.com> (Original Author)
+
+Alternatively, the contents of this file may be used under the terms of
+either the GNU General Public License Version 2 or later (the "GPL"), or
+the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+in which case the provisions of the GPL or the LGPL are applicable instead
+of those above. If you wish to allow use of your version of this file only
+under the terms of either the GPL or the LGPL, and not to allow others to
+use your version of this file under the terms of the MPL, indicate your
+decision by deleting the provisions above and replace them with the notice
+and other provisions required by the GPL or the LGPL. If you do not delete
+the provisions above, a recipient may use your version of this file under
+the terms of any one of the MPL, the GPL or the LGPL.
+
+***** END LICENSE BLOCK *****
+"""
+import cog
+import re
+
+# Generate code for functors of up to this many parameters:
+MAX_FUNCTOR_ARITY = 10
+
+# A versatile list-generation tool.
+# TODO More explanation?
+tpat = re.compile(r"\b[a-z]\b", re.I)
+npat = re.compile(r"\b0\b")
+def tlist(tmpl, rend, rbegin=0, sep=", "):
+  return sep.join(tpat.sub("\g<0>%u" % i,
+                           npat.sub("%u" % i, tmpl))
+                  for i in range(rbegin, rend))
diff --git a/xpcom/tests/Makefile.in b/xpcom/tests/Makefile.in
--- a/xpcom/tests/Makefile.in
+++ b/xpcom/tests/Makefile.in
@@ -43,17 +43,17 @@ VPATH		= @srcdir@
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= xpcom
 
 ifndef MOZ_ENABLE_LIBXUL
 MOZILLA_INTERNAL_API = 1
 endif
 
-DIRS		= dynamic services external
+DIRS		= dynamic services external functors
 ifeq ($(OS_ARCH),WINNT)
 DIRS		+= windows
 endif
 
 ifdef DEHYDRA_PATH
 DIRS += static-checker
 endif
 
diff --git a/xpcom/tests/functors/ArgConversionError.cpp b/xpcom/tests/functors/ArgConversionError.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/ArgConversionError.cpp
@@ -0,0 +1,8 @@
+#include "Functor.h"
+
+int main(int argc, char* argv[])
+{
+  // Binding-time argument conversion failure:
+  functor(main).bind("not an integer");
+  return 0;
+}
diff --git a/xpcom/tests/functors/CrefAssignment.cpp b/xpcom/tests/functors/CrefAssignment.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/CrefAssignment.cpp
@@ -0,0 +1,6 @@
+#include "Location.h"
+
+int main() {
+  int n;
+  cref(n) = 3;
+}
diff --git a/xpcom/tests/functors/Makefile.in b/xpcom/tests/functors/Makefile.in
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/Makefile.in
@@ -0,0 +1,111 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla 2.
+#
+# The Initial Developer of the Original Code is
+# the Mozilla Foundation <http://www.mozilla.org>.
+#
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Benjamin Smedberg <benjamin@smedbergs.us> (Inspiration)
+#   Ben Newman <b{newma,enjam}n@mozilla.com> (Author)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH = ../../..
+topsrcdir = @top_srcdir@
+srcdir = @srcdir@
+VPATH = @srcdir@
+
+# We will do compilations that create dependency files.
+NEED_MDDEPDIR = 1
+
+include $(DEPTH)/config/autoconf.mk
+
+CPP_UNIT_TESTS = \
+	TestFunctor.cpp \
+	$(NULL)
+
+# Testcases that SHOULD fail to compile.
+STATIC_FAILURE_TESTCASES = \
+  CrefAssignment.cpp \
+  ArgConversionError.cpp \
+  $(NULL)
+
+# Testcases that SHOULD compile but produce warnings.
+STATIC_WARNING_TESTCASES = \
+  $(NULL)
+
+# Testcases that SHOULD compile and produce no warnings.
+STATIC_PASS_TESTCASES = \
+  $(CPP_UNIT_TESTS) \
+  $(NULL)
+
+REQUIRES = xpcom
+
+include $(topsrcdir)/config/rules.mk
+
+# We want to compile each file and invert the result to ensure that
+# compilation failed.
+static:: \
+  $(STATIC_FAILURE_TESTCASES:.cpp=.s-fail) \
+  $(STATIC_WARNING_TESTCASES:.cpp=.s-warn) \
+  $(STATIC_PASS_TESTCASES:.cpp=.s-pass)
+
+check:: static
+
+%.s-fail: %.cpp $(GLOBAL_DEPS)
+	@printf "Compiling $(<F) to verify that it produces errors (as expected)..."
+	@if $(CCC) $(OUTOPTION)/dev/null -S $(COMPILE_CXXFLAGS) $(_VPATH_SRCS) >$(*F).errlog 2>&1; then \
+	  printf "fail:\nerror: compilation of $(<F) succeeded. It shouldn't have!\n"; \
+	  exit 1; \
+	else \
+	  printf "ok.\n"; \
+	fi
+
+%.s-warn: %.cpp $(GLOBAL_DEPS)
+	@printf "Compiling $(<F) to verify that it produces proper warnings..."
+	@if $(CCC) -Werror $(OUTOPTION)/dev/null -S $(COMPILE_CXXFLAGS) $(_VPATH_SRCS) >$(*F).errlog 2>&1; then \
+	  printf "fail:\nerror: compilation of $(<F) succeeded with -Werror. It shouldn't have!\n"; \
+	  exit 1; \
+	fi
+	@if $(CCC) $(OUTOPTION)/dev/null -S $(COMPILE_CXXFLAGS) $(_VPATH_SRCS) >$(*F).werrlog 2>&1; then \
+	  printf "ok.\n"; \
+	else \
+	  printf "fail:\nerror: compilation of $(<F) without -Werror failed. A warning should have been issued.\n"; \
+	  exit 1; \
+	fi
+
+%.s-pass: %.cpp $(GLOBAL_DEPS)
+	@printf "Compiling $(<F) just to verify that compilation succeeds..."
+	@if $(CCC) -Werror $(OUTOPTION)/dev/null -S $(COMPILE_CXXFLAGS) $(_VPATH_SRCS) >$(*F).errlog 2>&1; then \
+	  printf "ok.\n"; \
+	else \
+	  printf "fail:\nerror: compilation of $(<F) failed. It shouldn't have!\n"; \
+	  exit 1; \
+	fi
diff --git a/xpcom/tests/functors/TestFunctor.cpp b/xpcom/tests/functors/TestFunctor.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/TestFunctor.cpp
@@ -0,0 +1,225 @@
+#include "TestUtils.h"
+
+#include <sstream>
+#include "Functor.h"
+#include "Bind.h"
+
+int Succ(int n) {
+  return n + 1;
+}
+
+struct Pred
+{
+  int operator()(int n) {
+    return n - 1;
+  }
+};
+
+struct DiffStruct
+{
+  int Sub(int a, int b) {
+    return a - b;
+  }
+  static int Add2(int a, int b) {
+    return a + b;
+  }
+};
+
+void Unequal(int x, int y) {
+  ok(x != y);
+}
+
+void test_basic_usage()
+{
+  Functor<int, TLIST1(int)> s = functor(&Succ);
+
+  Pred pred;
+  Functor<int, TLIST1(int)> p = BIND1(&Pred::operator(), &pred);
+
+  Functor<int, TLIST3(DiffStruct*, int, int)> ds =
+    functor(&DiffStruct::Sub);
+
+  Functor<int, TLIST2(int, int)> a2 = functor(&DiffStruct::Add2);
+
+  int a = 1, b = 5;
+  is(s(a), a + 1);
+  is(p(b), b - 1);
+  is(ds(new DiffStruct, s(a), p(b)), a - b + 2);
+
+  is(a2(2, 3), 5);
+
+  functor(&Unequal)(1, 2);
+  return functor(&Unequal).bind(2)(3);
+}
+
+void test_bind()
+{
+  // Interesting (near-)equivalences:
+  is(Pred()(2), 1);
+  is((Pred().*(&Pred::operator()))(2), 1);
+  is(Pred().operator()(2), 1);
+  is(BIND1(&Pred::operator(), new Pred)(2), 1);
+
+  Functor<int, TLIST2(int, int)> a2 = functor(&DiffStruct::Add2);
+  is(a2.bind(2)(3), 5);
+  is(a2.bind(2).bind(3)(), 5);
+  is(BIND2(&DiffStruct::Add2, 2, 3)(), 5);
+
+  int x = 5, y = 3;
+  DiffStruct ds;
+  Functor<int, TLIST2(int, int)> sub = BIND1(&DiffStruct::Sub, &ds);
+  Functor<int, TLIST1(int)> f = BIND1(sub, x);
+  is(sub(x, y), x - y);
+  is(sub(y, x), y - x);
+  is(f(x), 0);
+  is(f(y), x - y);
+}
+
+template <typename T> void set(T t, int value) { t = value; }
+template <typename T> void set_ref(T& tref, int value) { tref = value; }
+void test_ref_cref()
+{
+  int n = 0, &nref = n;
+  set(nref, n+1);       is(n, 0);
+  set(ref(n), n+1);     is(n, 1);
+  set(ref(n), ref(n));
+  set(ref(n), cref(n));
+  set_ref(nref, cref(n));
+  set_ref(nref, n+1);   is(n, 2);
+  set_ref(ref(n), n+1); is(n, 3);
+}
+
+void test_Location_assignment()
+{
+  Location<int> out1, out2;
+  out1 = 1;
+  out2 = 2;
+  is(int(out1), 1);
+  out1 = out2;
+  is(int(out1), 2);
+  out1 = 3;
+  is(int(out2), 3);
+}
+
+template <typename T> T generic_identity(T t) { return t; }
+void test_templatized_functor()
+{
+  Functor<int, TLIST0()> f =
+    functor((int(*)(int))generic_identity).bind(2);
+  is(f(), 2);
+  is(functor(static_cast<int(*)(int)>(generic_identity))(1), 1);
+}
+
+void test_bind_result(int n)
+{
+  Location<int> out;
+  Functor<void, TLIST0()> inc =
+    functor(&Succ).bind_result(out).bind(out);
+  is(int(out), 0); // testing default construction
+  for (int i = out; i < n; ++i)
+    inc();
+  is(int(out), n);
+}
+
+struct CopyCounter {
+  int* const mCountPtr;
+  explicit CopyCounter(int* countPtr) : mCountPtr(countPtr) {}
+  CopyCounter(const CopyCounter& other)
+    : mCountPtr(other.mCountPtr)
+  { ++*mCountPtr; }
+  CopyCounter& operator=(const CopyCounter& cc) {
+    is(mCountPtr, cc.mCountPtr);
+    return *this;
+  }
+  CopyCounter Method(int a, int b, int c) { return *this; }
+};
+
+void test_result_copying()
+{
+  int count = 0;
+  CopyCounter cc(&count);
+  Functor<CopyCounter, TLIST0()> f =
+    functor(&CopyCounter::Method).bind(&cc).bind(1).bind(2).bind(3);
+  is(*f().mCountPtr, 1); // make sure the compiler can elide the tail copies
+  f(); f(); f();
+  is(count, 4);
+  Functor<void, TLIST0()> fvoid = f.bind_result(ref(cc));
+  fvoid(); fvoid(); fvoid();
+  is(count, 7);
+}
+
+void test_bind_conversion()
+{
+  char j = 'j';
+  Location<char> k;
+  // N.B. Succ is int(*)(int)
+  functor(Succ).bind(j).bind_result(k)();
+  is(char(k), 'k');
+
+  double pi = 3.14159;
+  Location<short> four;
+  functor(Succ).bind_result(four).bind(pi)();
+  is(int(four), 4);
+}
+
+class MethodGiver {
+  int mVal;
+  int Foo() { return mVal; }
+public:
+  MethodGiver(int val) : mVal(val) {}
+  Functor<int, TLIST0()>
+  GetBoundFooFunctor() {
+    return functor(&MethodGiver::Foo).bind(this);
+  }
+  Functor<int, TLIST1(MethodGiver*)>
+  GetFooFunctor() {
+    return functor(&MethodGiver::Foo);
+  }
+};
+void test_private_method_invocation()
+{
+  MethodGiver mg(1);
+  is(MethodGiver(2).GetBoundFooFunctor()(), 2);
+  is(mg.GetFooFunctor().bind(&mg)(), 1);
+}
+
+class Whammer {
+public:
+  int Wham() { return 5; }
+};
+class WhammerPtr {
+  Whammer mWhammer;
+public:
+  Whammer& operator*() { return mWhammer; }
+};
+void test_asterisk_operator_compatibility()
+{
+  is((*WhammerPtr()).Wham(), 5);
+  is(Whammer().Wham(), 5);
+  // Can't use functor(<method>) because it forces the first argument to
+  // MethodHandler::operator() to be a pointer to an instance of the method's
+  // class.  In order to use WhammerPtr as a Whammer*, we have to give up the
+  // convenience of the global functor adapter.
+  is((Functor<int, TLIST1(WhammerPtr)>::method(&Whammer::Wham).bind(WhammerPtr())()), 5);
+}
+
+int main() {
+  ScopedXPCOM xpcom("FunctorTests");
+  if (xpcom.failed())
+    return NS_ERROR_FAILURE;
+
+  nsresult rv = NS_OK;
+
+  test_basic_usage();
+  test_bind();
+  test_ref_cref();
+  test_templatized_functor();
+  test_bind_result(3);
+  test_result_copying();
+  test_Location_assignment();
+  test_bind_conversion();
+  test_private_method_invocation();
+  test_asterisk_operator_compatibility();
+
+  return rv;
+}
diff --git a/xpcom/tests/functors/TestUtils.h b/xpcom/tests/functors/TestUtils.h
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/TestUtils.h
@@ -0,0 +1,38 @@
+#ifndef TestUtils_h__
+#define TestUtils_h__
+
+#include "../TestHarness.h"
+#include <sstream>
+
+void silence_unused_function_warnings() {
+  StartProfiling("");
+  StopProfiling();
+}
+// #undef silence_unused_function_warnings
+
+template <typename T>
+void is_helper(const char* lhs_str, const char* rhs_str, T lhs, T rhs)
+{
+  std::stringstream ss;
+  if (lhs == rhs) {
+    ss << lhs_str << " == " << rhs_str << " == " << lhs;
+    passed(ss.str().c_str());
+  } else {
+    ss << lhs_str << " != " << rhs_str << ": (" << lhs << ", " << rhs << ")";
+    fail(ss.str().c_str());
+  }
+}
+
+#define is(LHS, RHS) is_helper(#LHS, #RHS, LHS, RHS)
+
+void ok_helper(const char* exp_str, bool val)
+{
+  if (val)
+    passed(exp_str);
+  else
+    fail(exp_str);
+}
+
+#define ok(VAL) ok_helper(#VAL, VAL)
+
+#endif
