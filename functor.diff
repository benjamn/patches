* * *

diff --git a/xpcom/glue/Bind.h b/xpcom/glue/Bind.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/Bind.h
@@ -0,0 +1,167 @@
+#ifndef __bind_h__
+#define __bind_h__
+
+#include "Functor.h"
+
+// [[[cog
+// from cogutil import tlist
+// MAX_FUNCTOR_ARITY = 15
+// ]]]
+// [[[end]]]
+
+template <class Incoming>
+class Binder
+  : public FunctorImpl<
+      typename Incoming::ResultType,
+      typename Incoming::ParamList::Tail>
+{
+public:
+  typedef typename Incoming::ResultType ResultType;
+  typedef typename Incoming::P1 BoundType;
+  typedef Functor<ResultType, typename Incoming::ParamList::Tail>
+          Outgoing;
+
+  COOPT_PARAM_TYPEDEFS(Outgoing)
+
+  Binder(const Incoming& fun, BoundType bound)
+    : mFun(fun)
+    , mBound(bound)
+  {}
+
+  // [[[cog
+  // prefix = "ResultType operator()("
+  // indent = " " * len(prefix)
+  // for i in range(MAX_FUNCTOR_ARITY+1):
+  //   Pps = tlist("P p", i)
+  //   ps = tlist(", p", i, sep="")
+  //   cog.out(r"""
+  // %(prefix)s%(Pps)s) {
+  //   return mFun(mBound%(ps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    return mFun(mBound);
+  }
+  ResultType operator()(P1 p1) {
+    return mFun(mBound, p1);
+  }
+  ResultType operator()(P1 p1, P2 p2) {
+    return mFun(mBound, p1, p2);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3) {
+    return mFun(mBound, p1, p2, p3);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4) {
+    return mFun(mBound, p1, p2, p3, p4);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return mFun(mBound, p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11) {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12) {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13) {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14) {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14, P15 p15) {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15);
+  }
+  // [[[end]]]
+
+private:
+  Incoming mFun;
+  BoundType mBound;
+};
+
+
+template <class Fun, typename Bound>
+typename Binder<Fun>::Outgoing
+bind(const Fun& fun, Bound bound) {
+  if (0) typename Fun::P1 p1 = bound;
+  typedef typename Binder<Fun>::Outgoing O;
+  typedef typename O::ImplType I;
+  I* binder = new Binder<Fun>(fun, bound);
+  return O(binder);
+}
+
+#define BIND1(F, A) bind(functor(F), A)
+
+// [[[cog
+// slash = "\\"
+// for i in range(2, MAX_FUNCTOR_ARITY+1):
+//   prev = i - 1
+//   alist = tlist("A", i)
+//   ainit = tlist("A", i-1)
+//   alast = "A%d" % i;
+//   cog.out(r"""
+// #define BIND%(i)d(F, %(alist)s) %(slash)s
+//    bind(BIND%(prev)d(F, %(ainit)s), %(alast)s)
+// """ % locals())
+// ]]]
+
+#define BIND2(F, A1, A2) \
+   bind(BIND1(F, A1), A2)
+
+#define BIND3(F, A1, A2, A3) \
+   bind(BIND2(F, A1, A2), A3)
+
+#define BIND4(F, A1, A2, A3, A4) \
+   bind(BIND3(F, A1, A2, A3), A4)
+
+#define BIND5(F, A1, A2, A3, A4, A5) \
+   bind(BIND4(F, A1, A2, A3, A4), A5)
+
+#define BIND6(F, A1, A2, A3, A4, A5, A6) \
+   bind(BIND5(F, A1, A2, A3, A4, A5), A6)
+
+#define BIND7(F, A1, A2, A3, A4, A5, A6, A7) \
+   bind(BIND6(F, A1, A2, A3, A4, A5, A6), A7)
+
+#define BIND8(F, A1, A2, A3, A4, A5, A6, A7, A8) \
+   bind(BIND7(F, A1, A2, A3, A4, A5, A6, A7), A8)
+
+#define BIND9(F, A1, A2, A3, A4, A5, A6, A7, A8, A9) \
+   bind(BIND8(F, A1, A2, A3, A4, A5, A6, A7, A8), A9)
+
+#define BIND10(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) \
+   bind(BIND9(F, A1, A2, A3, A4, A5, A6, A7, A8, A9), A10)
+
+#define BIND11(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) \
+   bind(BIND10(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), A11)
+
+#define BIND12(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) \
+   bind(BIND11(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), A12)
+
+#define BIND13(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) \
+   bind(BIND12(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), A13)
+
+#define BIND14(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) \
+   bind(BIND13(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), A14)
+
+#define BIND15(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) \
+   bind(BIND14(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), A15)
+// [[[end]]]
+
+#endif
\ No newline at end of file
diff --git a/xpcom/glue/Functor.h b/xpcom/glue/Functor.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/Functor.h
@@ -0,0 +1,577 @@
+#ifndef __functor_h__
+#define __functor_h__
+
+#include "nsISupports.h"
+#include "TList.h"
+#include "nsAutoPtr.h"
+
+
+class FunctorSupports : public nsISupports {
+public:
+  // nsISupports implementation must be inlined so that this file can be
+  // included across modules.  Because NS_IMPL_ISUPPORTS0 appears inline,
+  // the method prototypes for AddRef, Release, and QueryInterface provided by
+  // NS_DECL_ISUPPORTS are not needed, but the nsAutoRefCnt and
+  // NS_DECL_OWNINGTHREAD members (also provided by NS_DECL_ISUPPORTS)
+  // must now be declared manually.
+  virtual ~FunctorSupports() {}
+  NS_IMPL_ISUPPORTS0(FunctorSupports)
+protected:
+  nsAutoRefCnt mRefCnt;
+  NS_DECL_OWNINGTHREAD
+};
+
+
+// [[[cog
+// from cogutil import tlist
+// MAX_FUNCTOR_ARITY = 15
+// rng = range(MAX_FUNCTOR_ARITY+1)
+// ijs = zip(rng, rng[1:])
+// ]]]
+// [[[end]]]
+
+
+template <typename R, class Params>
+class FunctorImpl;
+
+#define DECL_FUNCTORIMPL_CLASS(R, N, TS)                                       \
+  class FunctorImpl<R, TLIST##N TS> : public FunctorSupports {                 \
+  public:                                                                      \
+    virtual R operator()TS = 0;                                                \
+  }
+
+// [[[cog
+// for i in rng:
+//   typenames = tlist(", typename T", i, sep="")
+//   Ts = tlist("T", i)
+//   cog.out("""
+// template <typename R%(typenames)s>
+// DECL_FUNCTORIMPL_CLASS(R, %(i)d, (%(Ts)s));
+// """ % locals())
+// ]]]
+
+template <typename R>
+DECL_FUNCTORIMPL_CLASS(R, 0, ());
+
+template <typename R, typename T1>
+DECL_FUNCTORIMPL_CLASS(R, 1, (T1));
+
+template <typename R, typename T1, typename T2>
+DECL_FUNCTORIMPL_CLASS(R, 2, (T1, T2));
+
+template <typename R, typename T1, typename T2, typename T3>
+DECL_FUNCTORIMPL_CLASS(R, 3, (T1, T2, T3));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4>
+DECL_FUNCTORIMPL_CLASS(R, 4, (T1, T2, T3, T4));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
+DECL_FUNCTORIMPL_CLASS(R, 5, (T1, T2, T3, T4, T5));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
+DECL_FUNCTORIMPL_CLASS(R, 6, (T1, T2, T3, T4, T5, T6));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
+DECL_FUNCTORIMPL_CLASS(R, 7, (T1, T2, T3, T4, T5, T6, T7));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
+DECL_FUNCTORIMPL_CLASS(R, 8, (T1, T2, T3, T4, T5, T6, T7, T8));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
+DECL_FUNCTORIMPL_CLASS(R, 9, (T1, T2, T3, T4, T5, T6, T7, T8, T9));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
+DECL_FUNCTORIMPL_CLASS(R, 10, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11>
+DECL_FUNCTORIMPL_CLASS(R, 11, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12>
+DECL_FUNCTORIMPL_CLASS(R, 12, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13>
+DECL_FUNCTORIMPL_CLASS(R, 13, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14>
+DECL_FUNCTORIMPL_CLASS(R, 14, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15>
+DECL_FUNCTORIMPL_CLASS(R, 15, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15));
+// [[[end]]]
+
+#undef DECL_FUNCTORIMPL_CLASS
+
+
+template <class ParentFunctor, typename Callable>
+class CallableHandler;
+
+template <class ParentFunctor, typename Method>
+class MethodHandler;
+
+
+template <typename R, class Params>
+class Functor
+{
+public:
+  typedef FunctorImpl<R, Params> ImplType;
+  typedef R ResultType;
+  typedef Params ParamList;
+
+  // [[[cog
+  // s = "typedef typename tlist::TypeAtNS<Params, %(i)d>::type P%(j)d;"
+  // cog.out("\n".join(s % locals() for (i, j) in ijs))
+  // ]]]
+  typedef typename tlist::TypeAtNS<Params, 0>::type P1;
+  typedef typename tlist::TypeAtNS<Params, 1>::type P2;
+  typedef typename tlist::TypeAtNS<Params, 2>::type P3;
+  typedef typename tlist::TypeAtNS<Params, 3>::type P4;
+  typedef typename tlist::TypeAtNS<Params, 4>::type P5;
+  typedef typename tlist::TypeAtNS<Params, 5>::type P6;
+  typedef typename tlist::TypeAtNS<Params, 6>::type P7;
+  typedef typename tlist::TypeAtNS<Params, 7>::type P8;
+  typedef typename tlist::TypeAtNS<Params, 8>::type P9;
+  typedef typename tlist::TypeAtNS<Params, 9>::type P10;
+  typedef typename tlist::TypeAtNS<Params, 10>::type P11;
+  typedef typename tlist::TypeAtNS<Params, 11>::type P12;
+  typedef typename tlist::TypeAtNS<Params, 12>::type P13;
+  typedef typename tlist::TypeAtNS<Params, 13>::type P14;
+  typedef typename tlist::TypeAtNS<Params, 14>::type P15;
+  // [[[end]]]
+
+  // for compatibility with std::bind{1st,2nd}
+  typedef P1  first_argument_type;
+  typedef P2 second_argument_type;
+  typedef R           result_type;
+
+public:
+ ~Functor() {}
+  Functor(const Functor& fun) : mImpl(fun.mImpl) {}
+  Functor(ImplType* impl)     : mImpl(impl) {}
+
+  template <typename Callable>
+  static Functor callable(Callable c) {
+    return Functor(new CallableHandler<Functor, Callable>(c));
+  }
+
+  template <typename Method>
+  static Functor method(Method m) {
+    return Functor(new MethodHandler<Functor, Method>(m));
+  }
+
+  // [[[cog
+  // for i in rng:
+  //   Pps = tlist("P p", i)
+  //   ps = tlist("p", i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return (*mImpl)(%(ps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    return (*mImpl)();
+  }
+  ResultType operator()(P1 p1) {
+    return (*mImpl)(p1);
+  }
+  ResultType operator()(P1 p1, P2 p2) {
+    return (*mImpl)(p1, p2);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3) {
+    return (*mImpl)(p1, p2, p3);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4) {
+    return (*mImpl)(p1, p2, p3, p4);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return (*mImpl)(p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return (*mImpl)(p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return (*mImpl)(p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return (*mImpl)(p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    return (*mImpl)(p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
+    return (*mImpl)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11) {
+    return (*mImpl)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12) {
+    return (*mImpl)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13) {
+    return (*mImpl)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14) {
+    return (*mImpl)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14, P15 p15) {
+    return (*mImpl)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15);
+  }
+  // [[[end]]]
+
+private:
+  nsRefPtr<ImplType> mImpl;
+};
+
+
+// For brevity of FunctorImpl::operator() signatures:
+// [[[cog
+// cog.out("#define COOPT_PARAM_TYPEDEFS(CLASS) \\\n")
+// cog.out(tlist("  typedef typename CLASS::P P;",
+//               MAX_FUNCTOR_ARITY, sep=" \\\n"))
+// ]]]
+#define COOPT_PARAM_TYPEDEFS(CLASS) \
+  typedef typename CLASS::P1 P1; \
+  typedef typename CLASS::P2 P2; \
+  typedef typename CLASS::P3 P3; \
+  typedef typename CLASS::P4 P4; \
+  typedef typename CLASS::P5 P5; \
+  typedef typename CLASS::P6 P6; \
+  typedef typename CLASS::P7 P7; \
+  typedef typename CLASS::P8 P8; \
+  typedef typename CLASS::P9 P9; \
+  typedef typename CLASS::P10 P10; \
+  typedef typename CLASS::P11 P11; \
+  typedef typename CLASS::P12 P12; \
+  typedef typename CLASS::P13 P13; \
+  typedef typename CLASS::P14 P14; \
+  typedef typename CLASS::P15 P15;
+// [[[end]]]
+
+
+template <class ParentFunctor, typename Callable>
+class CallableHandler
+  : public FunctorImpl<
+      typename ParentFunctor::ResultType,
+      typename ParentFunctor::ParamList>
+{
+public:
+  typedef typename ParentFunctor::ResultType ResultType;
+  COOPT_PARAM_TYPEDEFS(ParentFunctor)
+
+  CallableHandler(Callable c) : mCallable(c) {}
+
+  // [[[cog
+  // for i in rng:
+  //   Pps = tlist("P p", i)
+  //   ps = tlist("p", i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return mCallable(%(ps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    return mCallable();
+  }
+  ResultType operator()(P1 p1) {
+    return mCallable(p1);
+  }
+  ResultType operator()(P1 p1, P2 p2) {
+    return mCallable(p1, p2);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3) {
+    return mCallable(p1, p2, p3);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4) {
+    return mCallable(p1, p2, p3, p4);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return mCallable(p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return mCallable(p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return mCallable(p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return mCallable(p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    return mCallable(p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
+    return mCallable(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11) {
+    return mCallable(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12) {
+    return mCallable(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13) {
+    return mCallable(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14) {
+    return mCallable(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14, P15 p15) {
+    return mCallable(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15);
+  }
+  // [[[end]]]
+
+private:
+  Callable mCallable;
+};
+
+
+template <class ParentFunctor, typename Method>
+class MethodHandler
+  : public FunctorImpl<
+      typename ParentFunctor::ResultType,
+      typename ParentFunctor::ParamList>
+{
+public:
+  typedef typename ParentFunctor::ResultType ResultType;
+  COOPT_PARAM_TYPEDEFS(ParentFunctor)
+
+  MethodHandler(Method m) : mMethod(m) {}
+
+  // [[[cog
+  // for i in rng[1:]:
+  //   Pps = tlist("P p", i)
+  //   ps2 = tlist("p", rfirst=2, rlast=i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return (p1.*mMethod)(%(ps2)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()(P1 p1) {
+    return (p1.*mMethod)();
+  }
+  ResultType operator()(P1 p1, P2 p2) {
+    return (p1.*mMethod)(p2);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3) {
+    return (p1.*mMethod)(p2, p3);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4) {
+    return (p1.*mMethod)(p2, p3, p4);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return (p1.*mMethod)(p2, p3, p4, p5);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return (p1.*mMethod)(p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return (p1.*mMethod)(p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return (p1.*mMethod)(p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    return (p1.*mMethod)(p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
+    return (p1.*mMethod)(p2, p3, p4, p5, p6, p7, p8, p9, p10);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11) {
+    return (p1.*mMethod)(p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12) {
+    return (p1.*mMethod)(p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13) {
+    return (p1.*mMethod)(p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14) {
+    return (p1.*mMethod)(p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
+  }
+  ResultType operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14, P15 p15) {
+    return (p1.*mMethod)(p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15);
+  }
+  // [[[end]]]
+
+private:
+  Method mMethod;
+};
+
+
+/**
+ * To explain all this preprocessing...
+ *
+ * tPsN expands to
+ *
+ *   , typename P1, typename P2, ..., typename PN
+ *
+ * Note the initial comma! PsN expands to
+ *
+ *   P1, P2, ..., PN
+ *
+ * Note that tPs0 and Ps0 both expand to nothing.
+ */
+
+// Base cases for the pseudo-recursion:
+#define tPs0
+#define Ps0
+#define Ps1 P1
+
+// [[[cog
+// cog.out("\n".join("#define tPs%(j)d tPs%(i)d, typename P%(j)d"
+//                   % locals() for (i, j) in ijs))
+// cog.out("\n\n")
+// cog.out("\n".join("#define Ps%(j)d Ps%(i)d, P%(j)d"
+//                   % locals() for (i, j) in ijs[1:]))
+// ]]]
+#define tPs1 tPs0, typename P1
+#define tPs2 tPs1, typename P2
+#define tPs3 tPs2, typename P3
+#define tPs4 tPs3, typename P4
+#define tPs5 tPs4, typename P5
+#define tPs6 tPs5, typename P6
+#define tPs7 tPs6, typename P7
+#define tPs8 tPs7, typename P8
+#define tPs9 tPs8, typename P9
+#define tPs10 tPs9, typename P10
+#define tPs11 tPs10, typename P11
+#define tPs12 tPs11, typename P12
+#define tPs13 tPs12, typename P13
+#define tPs14 tPs13, typename P14
+#define tPs15 tPs14, typename P15
+
+#define Ps2 Ps1, P2
+#define Ps3 Ps2, P3
+#define Ps4 Ps3, P4
+#define Ps5 Ps4, P5
+#define Ps6 Ps5, P6
+#define Ps7 Ps6, P7
+#define Ps8 Ps7, P8
+#define Ps9 Ps8, P9
+#define Ps10 Ps9, P10
+#define Ps11 Ps10, P11
+#define Ps12 Ps11, P12
+#define Ps13 Ps12, P13
+#define Ps14 Ps13, P14
+#define Ps15 Ps14, P15
+// [[[end]]]
+
+// Being able to declare the const version at the same time as the non-const
+// version makes all of this macro abstraction worthwhile.
+#define DECL_GLOBAL_METHOD_ADAPTERS(TLIST, CPs, N)                            \
+  template <typename R, class C tPs##N>                                       \
+  Functor<R, TLIST CPs> functor(R (C::*m)(Ps##N)) {                           \
+    return Functor<R, TLIST CPs>::method(m);                                  \
+  }                                                                           \
+  template <typename R, class C tPs##N>                                       \
+  Functor<R, TLIST CPs> functor(R (C::*m)(Ps##N) const) {                     \
+    return Functor<R, TLIST CPs>::method(m);                                  \
+  }
+
+#define DECL_GLOBAL_FUNCTION_ADAPTER(TLIST, Ps, N)                            \
+  template <typename R tPs##N>                                                \
+  Functor<R, TLIST Ps> functor(R (*f)Ps) {                                    \
+    return Functor<R, TLIST Ps>::callable(f);                                 \
+  }
+
+// Special-casing these makes the following generator code a bit simpler:
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST1, (C), 0)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST0, (), 0)
+
+// [[[cog
+// for (i, j) in ijs[1:]:
+//   cog.out("""
+// DECL_GLOBAL_METHOD_ADAPTERS(TLIST%(j)d, (C, Ps%(i)d), %(i)d)
+// DECL_GLOBAL_FUNCTION_ADAPTER(TLIST%(i)d, (Ps%(i)d), %(i)d)
+// """ % locals())
+// ]]]
+
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST2, (C, Ps1), 1)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST1, (Ps1), 1)
+
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST3, (C, Ps2), 2)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST2, (Ps2), 2)
+
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST4, (C, Ps3), 3)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST3, (Ps3), 3)
+
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST5, (C, Ps4), 4)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST4, (Ps4), 4)
+
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST6, (C, Ps5), 5)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST5, (Ps5), 5)
+
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST7, (C, Ps6), 6)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST6, (Ps6), 6)
+
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST8, (C, Ps7), 7)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST7, (Ps7), 7)
+
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST9, (C, Ps8), 8)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST8, (Ps8), 8)
+
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST10, (C, Ps9), 9)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST9, (Ps9), 9)
+
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST11, (C, Ps10), 10)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST10, (Ps10), 10)
+
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST12, (C, Ps11), 11)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST11, (Ps11), 11)
+
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST13, (C, Ps12), 12)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST12, (Ps12), 12)
+
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST14, (C, Ps13), 13)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST13, (Ps13), 13)
+
+DECL_GLOBAL_METHOD_ADAPTERS(TLIST15, (C, Ps14), 14)
+DECL_GLOBAL_FUNCTION_ADAPTER(TLIST14, (Ps14), 14)
+// [[[end]]]
+
+// Sayonara, macro scum!
+
+#undef DECL_GLOBAL_FUNCTION_ADAPTERS
+#undef DECL_GLOBAL_METHOD_ADAPTER
+
+// [[[cog
+// cog.out("\n".join("#undef %(topt)sPs%(i)d" % locals()
+//                   for topt in ["t", ""]
+//                   for i in rng))
+// ]]]
+#undef tPs0
+#undef tPs1
+#undef tPs2
+#undef tPs3
+#undef tPs4
+#undef tPs5
+#undef tPs6
+#undef tPs7
+#undef tPs8
+#undef tPs9
+#undef tPs10
+#undef tPs11
+#undef tPs12
+#undef tPs13
+#undef tPs14
+#undef tPs15
+#undef Ps0
+#undef Ps1
+#undef Ps2
+#undef Ps3
+#undef Ps4
+#undef Ps5
+#undef Ps6
+#undef Ps7
+#undef Ps8
+#undef Ps9
+#undef Ps10
+#undef Ps11
+#undef Ps12
+#undef Ps13
+#undef Ps14
+#undef Ps15
+// [[[end]]]
+
+#endif
diff --git a/xpcom/glue/Makefile.in b/xpcom/glue/Makefile.in
--- a/xpcom/glue/Makefile.in
+++ b/xpcom/glue/Makefile.in
@@ -66,16 +66,17 @@ CSRCS		= \
 CSRCS		= \
 		$(XPCOM_GLUE_SRC_LCSRCS) \
 		$(NULL)  
 
 CPPSRCS		= \
 		$(XPCOM_GLUE_SRC_LCPPSRCS) \
 		$(XPCOM_GLUENS_SRC_LCPPSRCS) \
 		nsStringAPI.cpp \
+		test.cpp \
 		$(NULL)
 
 SDK_HEADERS = \
 		pldhash.h \
 		nsArrayEnumerator.h \
 		nsArrayUtils.h \
 		nsAutoLock.h \
 		nsBaseHashtable.h \
@@ -119,16 +120,19 @@ SDK_HEADERS = \
 		nsCycleCollectionParticipant.h \
 		nsDeque.h \
 		$(NULL)
 
 EXPORTS = \
 		nsThreadUtils.h \
 		nsProxyRelease.h \
 		nsXPTCUtils.h \
+		Functor.h \
+		TList.h \
+		Bind.h \
 		$(NULL)
 
 SDK_LIBRARY     =                        \
 		$(LIB_PREFIX)xpcomglue_s.$(LIB_SUFFIX) \
 		$(NULL)
 
 # we don't want the shared lib, but we want to force the creation of a static lib.
 FORCE_STATIC_LIB = 1
@@ -145,11 +149,13 @@ include $(topsrcdir)/config/rules.mk
 
 ifdef _MSC_VER
 # Don't include directives about which CRT to use
 OS_COMPILE_CXXFLAGS += -Zl
 OS_COMPILE_CFLAGS += -Zl
 DEFINES += -D_USE_ANSI_CPP
 endif
 
+DEFINES += -save-temps
+
 ifdef TARGET_XPCOM_ABI
 DEFINES += -DTARGET_XPCOM_ABI=\"$(TARGET_XPCOM_ABI)\"
 endif
diff --git a/xpcom/glue/TList.h b/xpcom/glue/TList.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/TList.h
@@ -0,0 +1,131 @@
+#ifndef __tlist_h__
+#define __tlist_h__
+
+// [[[cog from cogutil import tlist ]]]
+// [[[end]]]
+
+class NullType {};
+struct EmptyType {};
+
+template <typename T, typename U>
+struct TList {
+  typedef T Head;
+  typedef U Tail;
+};
+
+#define TLIST0() NullType
+
+// [[[cog
+// MAX_TUPLE_ARITY = 15
+//
+// for i in range(1, MAX_TUPLE_ARITY+1):
+//   cog.out(r"""
+// #define TLIST%(arity)d(%(tlist)s) %(slash)s
+//   TList<T1, TLIST%(arity-1)d(%(trest)s)>
+// """ % {
+//   "arity": i, "arity-1": i-1,
+//   "tlist": tlist("T", i),
+//   "trest": tlist("T", rfirst=2, rlast=i),
+//   "slash": "\\",
+// })
+// ]]]
+
+#define TLIST1(T1) \
+  TList<T1, TLIST0()>
+
+#define TLIST2(T1, T2) \
+  TList<T1, TLIST1(T2)>
+
+#define TLIST3(T1, T2, T3) \
+  TList<T1, TLIST2(T2, T3)>
+
+#define TLIST4(T1, T2, T3, T4) \
+  TList<T1, TLIST3(T2, T3, T4)>
+
+#define TLIST5(T1, T2, T3, T4, T5) \
+  TList<T1, TLIST4(T2, T3, T4, T5)>
+
+#define TLIST6(T1, T2, T3, T4, T5, T6) \
+  TList<T1, TLIST5(T2, T3, T4, T5, T6)>
+
+#define TLIST7(T1, T2, T3, T4, T5, T6, T7) \
+  TList<T1, TLIST6(T2, T3, T4, T5, T6, T7)>
+
+#define TLIST8(T1, T2, T3, T4, T5, T6, T7, T8) \
+  TList<T1, TLIST7(T2, T3, T4, T5, T6, T7, T8)>
+
+#define TLIST9(T1, T2, T3, T4, T5, T6, T7, T8, T9) \
+  TList<T1, TLIST8(T2, T3, T4, T5, T6, T7, T8, T9)>
+
+#define TLIST10(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) \
+  TList<T1, TLIST9(T2, T3, T4, T5, T6, T7, T8, T9, T10)>
+
+#define TLIST11(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) \
+  TList<T1, TLIST10(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
+
+#define TLIST12(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) \
+  TList<T1, TLIST11(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
+
+#define TLIST13(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) \
+  TList<T1, TLIST12(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
+
+#define TLIST14(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) \
+  TList<T1, TLIST13(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)>
+
+#define TLIST15(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) \
+  TList<T1, TLIST14(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)>
+// [[[end]]]
+
+namespace tlist {
+
+  template <typename List>
+  struct Length { enum { value = 0 }; };
+
+  template <typename T, typename U>
+  struct Length<TList<T, U> > {
+    enum { value = 1 + Length<U>::value };
+  };
+
+
+  template <typename List, unsigned N> struct TypeAt_;
+  template <typename T, typename U>
+  struct TypeAt_<TList<T, U>, 0> { typedef T type; };
+  template <typename T, typename U, unsigned N>
+  struct TypeAt_<TList<T, U>, N> {
+    typedef typename TypeAt_<U, N-1>::type type;
+  };
+
+  // allows negative indices
+  template <typename List, int N>
+  struct TypeAt {
+    typedef typename TypeAt_<
+        List,
+        N < 0 ? Length<List>::value + N : N
+      >::type type;
+  };
+
+
+  template <typename List, unsigned N, typename D> struct TypeAtNS_;
+  template <unsigned N, typename D>
+  struct TypeAtNS_<NullType, N, D> { typedef D type; };
+  template <typename T, typename U, unsigned N, typename D>
+  struct TypeAtNS_<TList<T, U>, N, D> {
+    typedef typename TypeAtNS_<U, N-1, D>::type type;
+  };
+  template <typename T, typename U, typename D>
+  struct TypeAtNS_<TList<T, U>, 0, D> { typedef T type; };
+
+  // allows negative indices
+  template <typename List, int N, typename Default=EmptyType>
+  struct TypeAtNS {
+    typedef typename TypeAtNS_<
+        List,
+        N < 0 ? Length<List>::value + N : N,
+        Default
+      >::type type;
+  };
+
+
+};
+
+#endif
diff --git a/xpcom/glue/cogutil.py b/xpcom/glue/cogutil.py
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/cogutil.py
@@ -0,0 +1,12 @@
+#!/usr/bin/env python
+
+import cog
+import re
+
+tpat = re.compile(r"\b[a-z]\b", re.I)
+npat = re.compile(r"\b0\b")
+def tlist(tmpl, rlast, rfirst=1, sep=", "):
+  return sep.join(tpat.sub("\g<0>%u" % i,
+                           npat.sub("%u" % i, tmpl))
+                  for i in range(rfirst, rlast+1))
+
diff --git a/xpcom/glue/test.cpp b/xpcom/glue/test.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/test.cpp
@@ -0,0 +1,86 @@
+#include <iostream>
+#include "Functor.h"
+#include "Bind.h"
+
+int Succ(int n) {
+  return n + 1;
+}
+
+struct Pred
+{
+  int operator()(int n) {
+    return n - 1;
+  }
+};
+
+struct DiffStruct
+{
+  int Sub(int a, int b) {
+    return a - b;
+  }
+  static int Add2(int a, int b) {
+    return a + b;
+  }
+};
+
+void is(int x, int y) {
+  std::cout << (x == y ? "OK: " : "FAIL: ")
+            << x << " = " << y << std::endl;
+}
+
+void example()
+{
+  // Functor<int, TLIST1(int)> s =
+  //   Functor<int, TLIST1(int)>::callable(&Succ);
+  // 
+  // Pred pred;
+  // Functor<int, TLIST1(int)> p =
+  //   Functor<int, TLIST1(int)>::callable(pred);
+  // 
+  // Functor<int, TLIST3(DiffStruct, int, int)> ds =
+  //   Functor<int, TLIST3(DiffStruct, int, int)>::method(&DiffStruct::Sub);
+  // 
+  // Functor<int, TLIST2(int, int)> a2 =
+  //   Functor<int, TLIST2(int, int)>::callable(&DiffStruct::Add2);
+  // 
+  // int a = 1, b = 5;
+  // is(s(a), a + 1);
+  // is(p(b), b - 1);
+  // is(ds(DiffStruct(), s(a), p(b)), a - b + 2);
+
+  // is(std::bind1st(ds, 6)(4), 2);
+  // is(std::bind2nd(ds, 6)(4), -2);
+
+  // is(a2(2, 3), 5);
+}
+
+void test_bind()
+{
+  // Interesting (near-)equivalences:
+  // is(Pred()(2), 1);
+  // is((Pred().*(&Pred::operator()))(2), 1);
+  // is(Pred().operator()(2), 1);
+  // is(BIND1(&Pred::operator(), Pred())(2), 1);
+
+//   Functor<int, TLIST3(int, int, int)> a3(&DiffStruct::Add3);
+//   is(BIND1(a3, 1)(2, 3), 6);
+//   is(BIND2(a3, 1, 2)(3), 6);
+//   is(BIND3(a3, 1, 2, 3)(), 6);
+//   is(BIND2(BIND1(a3, 1), 2, 3)(), 6);
+// 
+//   double x = 5, y = 3;
+//   DiffStruct ds;
+//   Functor<int, TLIST2(int, int)> sub(
+//     &ds, &DiffStruct::Sub);
+//   Functor<int, TLIST1(int)> f = BIND1(sub, x);
+//   is(sub(x, y), x - y);
+//   is(sub(y, x), y - x);
+//   is(f(x), 0);
+//   is(f(y), x - y);
+}
+
+int main() {
+  example();
+  test_bind();
+  return 0;
+}
