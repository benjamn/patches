Using a normal file instead of /dev/null for -S output, which should be more reliable on WIN32 (bug 486440).

diff --git a/xpcom/glue/Makefile.in b/xpcom/glue/Makefile.in
--- a/xpcom/glue/Makefile.in
+++ b/xpcom/glue/Makefile.in
@@ -122,16 +122,20 @@ SDK_HEADERS = \
 		$(NULL)
 
 EXPORTS_NAMESPACES = mozilla
 
 EXPORTS = \
 		nsThreadUtils.h \
 		nsProxyRelease.h \
 		nsXPTCUtils.h \
+		functors/Location.h \
+		functors/TList.h \
+		functors/Functor.h \
+		functors/FunctorAdapters.h \
 		$(NULL)
 
 EXPORTS_mozilla = \
   BlockingResourceBase.h \
   CondVar.h \
   DeadlockDetector.h \
   Monitor.h \
   Mutex.h \
diff --git a/xpcom/glue/functors/Functor.h b/xpcom/glue/functors/Functor.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/functors/Functor.h
@@ -0,0 +1,620 @@
+/* -*- Mode: c++; tab-width: 2; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Functor.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef Functor_h__
+#define Functor_h__
+
+#include "nsISupports.h"
+#include "nsIRunnable.h"
+#include "nsAutoPtr.h"
+#include "TList.h"
+#include "Location.h"
+
+/**
+ * For an overview of Functor usage, see bug 486440.
+ *
+ * This implementation was inspired by Andrei Alexandrescu's book
+ *
+ *   Modern C++ Design: Generic Programming and Design Patterns Applied,
+ *
+ * which has a great deal more to say on the topic.
+ *
+ * Instructions pertaining to the cog.py code generation tool are available
+ * here: http://nedbatchelder.com/code/cog/
+ *
+ * Once you have installed cog.py, run
+ *
+ *   cog.py -r Functor.h
+ *
+ * or (to regenerate all coggable files)
+ *
+ *   python functor_cog_utils.py
+ *
+ * to regenerate the portions of this file delimited by the triple square
+ * bracket markers.  The file changes in place, but the python generating code
+ * remains, so repeatedly regenerating the file is really very easy.
+ */
+
+// [[[cog
+// # Any insuffciency of functor parameters can be solved by increasing
+// # MAX_FUNCTOR_ARITY:
+// from functor_cog_utils import tlist, MAX_FUNCTOR_ARITY
+// rng = range(MAX_FUNCTOR_ARITY+1)
+// ijs = zip(rng, rng[1:])
+// ]]]
+// [[[end]]]
+
+/**
+ * Reference counting base class from which all the FunctorImpl partial
+ * specializations inherit.  AddRef and Release need to be atomic because
+ * Functors may be copied between threads, but the burden of keeping bound
+ * arguments thread-safe still falls entirely on the client.
+ */
+class FunctorSupports {
+  nsAutoRefCnt mRefCnt;
+public:
+  NS_IMETHOD_(nsrefcnt) AddRef();
+  NS_IMETHOD_(nsrefcnt) Release();
+protected:
+  virtual ~FunctorSupports() {}
+};
+inline NS_IMPL_THREADSAFE_ADDREF(FunctorSupports)
+inline NS_IMPL_THREADSAFE_RELEASE(FunctorSupports)
+
+/**
+ * Abstract interface for the heap-allocated functor objects (CallableHandler,
+ * MethodHandler, Binder, Voider, &c.) to which Functors hold references. Since
+ * FunctorImpl inherits from FunctorSupports, derived classes inherit the
+ * AddRef and Release methods required by nsRefPtr<FunctorImpl>.
+ */
+template <typename Result, class Params>
+class FunctorImpl;
+
+// [[[cog
+// for i in rng:
+//   ctnTs = tlist(", typename T", i, sep="")
+//   Ts = tlist("T", i)
+//   cog.out("""
+// template <typename R%(ctnTs)s>
+// class FunctorImpl<R, TLIST%(i)d(%(Ts)s)> : public FunctorSupports {
+// public:
+//   virtual R operator()(%(Ts)s) = 0;
+// };""" % locals())
+// ]]]
+
+template <typename R>
+class FunctorImpl<R, TLIST0()> : public FunctorSupports {
+public:
+  virtual R operator()() = 0;
+};
+template <typename R, typename T0>
+class FunctorImpl<R, TLIST1(T0)> : public FunctorSupports {
+public:
+  virtual R operator()(T0) = 0;
+};
+template <typename R, typename T0, typename T1>
+class FunctorImpl<R, TLIST2(T0, T1)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2>
+class FunctorImpl<R, TLIST3(T0, T1, T2)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3>
+class FunctorImpl<R, TLIST4(T0, T1, T2, T3)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
+class FunctorImpl<R, TLIST5(T0, T1, T2, T3, T4)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
+class FunctorImpl<R, TLIST6(T0, T1, T2, T3, T4, T5)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
+class FunctorImpl<R, TLIST7(T0, T1, T2, T3, T4, T5, T6)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5, T6) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
+class FunctorImpl<R, TLIST8(T0, T1, T2, T3, T4, T5, T6, T7)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5, T6, T7) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
+class FunctorImpl<R, TLIST9(T0, T1, T2, T3, T4, T5, T6, T7, T8)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5, T6, T7, T8) = 0;
+};
+template <typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
+class FunctorImpl<R, TLIST10(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)> : public FunctorSupports {
+public:
+  virtual R operator()(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) = 0;
+};
+// [[[end]]]
+
+
+template <class ParentFunctor, typename Callable>
+class CallableHandler;
+
+template <class ParentFunctor, typename Method>
+class MethodHandler;
+
+template <class ParentFunctor, typename Bound>
+class Binder;
+
+template <class ParentFunctor, typename LocationType>
+class Voider;
+
+// [[[cog
+// cog.out("#define EXTRACT_TYPEDEFS(LIST) \\\n")
+// cog.out(tlist("  typedef typename tlist::TypeAt<LIST, 0>::type P;",
+//               MAX_FUNCTOR_ARITY, sep=" \\\n"))
+// ]]]
+#define EXTRACT_TYPEDEFS(LIST) \
+  typedef typename tlist::TypeAt<LIST, 0>::type P0; \
+  typedef typename tlist::TypeAt<LIST, 1>::type P1; \
+  typedef typename tlist::TypeAt<LIST, 2>::type P2; \
+  typedef typename tlist::TypeAt<LIST, 3>::type P3; \
+  typedef typename tlist::TypeAt<LIST, 4>::type P4; \
+  typedef typename tlist::TypeAt<LIST, 5>::type P5; \
+  typedef typename tlist::TypeAt<LIST, 6>::type P6; \
+  typedef typename tlist::TypeAt<LIST, 7>::type P7; \
+  typedef typename tlist::TypeAt<LIST, 8>::type P8; \
+  typedef typename tlist::TypeAt<LIST, 9>::type P9;
+// [[[end]]]
+
+/**
+ * The Functor class is just a value-type wrapper around the reference-type
+ * FunctorImpl object mImpl.  It isn't meant to be inherited from, so none of
+ * its methods are virtual.  It doesn't even need a virtual destructor.  You
+ * can (and should) copy Functors by value.
+ *
+ * TODO The parameter types should be made references when possible.
+ * Unfortunately, references to references are illegal, so getting this right
+ * would require some additional template trickery.
+ */
+template <typename Result, class Params>
+class Functor
+{
+public:
+  typedef FunctorImpl<Result, Params> ImplType;
+  typedef Result ResultType;
+  typedef Params ParamList;
+
+  Functor(const Functor& f) : mImpl(f.mImpl) {}
+  Functor(ImplType* impl)   : mImpl(impl) {}
+ ~Functor() {} // deliberately non-virtual
+
+  template <typename Callable>
+  static Functor callable(Callable c) {
+    return Functor(new CallableHandler<Functor, Callable>(c));
+  }
+
+  template <typename Method>
+  static Functor method(Method m) {
+    return Functor(new MethodHandler<Functor, Method>(m));
+  }
+
+  /**
+   * The bind method returns a Functor with one less parameter than the Functor
+   * object receiving the bind method invocation.  When the resulting Functor
+   * is invoked, the bound argument will be passed as the first argument to the
+   * original Functor.
+   *
+   * Note that the type used for storing the bound value is determined by the
+   * value passed to bind, not by the Functor's first parameter type.  This
+   * distinction becomes important when the stored value needs to be copied or
+   * AddRefed but the actual parameter type is just a bare pointer.
+   */
+  template <typename Bound>
+  typename Binder<Functor, Bound>::Outgoing
+  bind(Bound bound) {
+    typedef Binder<Functor, Bound> B;
+    typedef typename B::Outgoing O;
+    typedef typename O::ImplType I;
+    I* binder = new B(*this, bound);
+    return O(binder);
+  }
+
+  /**
+   * The bind_result method may be called against non-void Functors and returns
+   * a void Functor that puts the return value of the original Functor into the
+   * provided Location<ResultType, StoragePolicy> argument.  See Location.h for
+   * an explanation of Location objects (N.B. the ref/cref functions).
+   *
+   * Example:
+   *   Counter c;
+   *   Location<int> out;
+   *   functor(&Counter::GetCount).bind_result(out)(&c);
+   *   int count = out;
+   */
+  template <typename R, template <typename> class StoragePolicy>
+  typename Voider<Functor, Location<R, StoragePolicy> >::Outgoing
+  bind_result(Location<R, StoragePolicy> loc) {
+    typedef Voider<Functor, Location<R, StoragePolicy> > V;
+    typedef typename V::Outgoing O;
+    typedef typename O::ImplType I;
+    I* voider = new V(*this, loc);
+    return O(voider);
+  }
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng:
+  //   Pps = tlist("P p", i)
+  //   ps = tlist("p", i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return (*mImpl)(%(ps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    return (*mImpl)();
+  }
+  ResultType operator()(P0 p0) {
+    return (*mImpl)(p0);
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    return (*mImpl)(p0, p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    return (*mImpl)(p0, p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    return (*mImpl)(p0, p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    return (*mImpl)(p0, p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    return (*mImpl)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  // [[[end]]]
+
+private:
+  nsRefPtr<ImplType> mImpl;
+};
+
+/**
+ * Callable entities include global functions, objects that support operator(),
+ * and static member functions.  The implementation of this class is generic
+ * with respect to these possibilities: as long as mCallable can be called with
+ * some number of arguments between zero and MAX_FUNCTOR_ARITY (inclusive),
+ * your code will compile.
+ */
+template <class ParentFunctor, typename Callable>
+class CallableHandler
+  : public FunctorImpl<
+      typename ParentFunctor::ResultType,
+      typename ParentFunctor::ParamList>
+{
+public:
+  CallableHandler(Callable c) : mCallable(c) {}
+
+  typedef typename ParentFunctor::ResultType ResultType;
+  typedef typename ParentFunctor::ParamList  ParamList;
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng:
+  //   Pps = tlist("P p", i)
+  //   ps = tlist("p", i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return mCallable(%(ps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    return mCallable();
+  }
+  ResultType operator()(P0 p0) {
+    return mCallable(p0);
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    return mCallable(p0, p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    return mCallable(p0, p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    return mCallable(p0, p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    return mCallable(p0, p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return mCallable(p0, p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return mCallable(p0, p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return mCallable(p0, p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return mCallable(p0, p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    return mCallable(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  // [[[end]]]
+
+private:
+  Callable mCallable;
+};
+
+/**
+ * Methods of n parameters become Functors of n+1 parameters, where the first
+ * parameter names the object to receive the method invocation.
+ */
+template <class ParentFunctor, typename Method>
+class MethodHandler
+  : public FunctorImpl<
+      typename ParentFunctor::ResultType,
+      typename ParentFunctor::ParamList>
+{
+public:
+  MethodHandler(Method m) : mMethod(m) {}
+
+  typedef typename ParentFunctor::ResultType ResultType;
+  typedef typename ParentFunctor::ParamList  ParamList;
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng[1:]:
+  //   Pps = tlist("P p", i)
+  //   ps1 = tlist("p", rbegin=1, rend=i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return ((*p0).*mMethod)(%(ps1)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()(P0 p0) {
+    return ((*p0).*mMethod)();
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    return ((*p0).*mMethod)(p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    return ((*p0).*mMethod)(p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    return ((*p0).*mMethod)(p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    return ((*p0).*mMethod)(p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  // [[[end]]]
+
+private:
+  Method mMethod;
+};
+
+/**
+ * Binder class for use with Functor::bind.
+ */
+template <class ParentFunctor, typename Bound>
+class Binder
+  : public FunctorImpl<typename ParentFunctor::ResultType,
+                       typename ParentFunctor::ParamList::Tail>
+{
+public:
+  Binder(ParentFunctor fun, Bound bound)
+    : mFun(fun)
+    , mBound(bound)
+  {}
+
+  typedef typename ParentFunctor::ResultType      ResultType;
+  typedef typename ParentFunctor::ParamList::Tail ParamList;
+  typedef Functor<ResultType, ParamList>          Outgoing;
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng[:-1]:
+  //   Pps = tlist("P p", i)
+  //   cps = tlist(", p", i, sep="")
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   return mFun(mBound%(cps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    return mFun(mBound);
+  }
+  ResultType operator()(P0 p0) {
+    return mFun(mBound, p0);
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    return mFun(mBound, p0, p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    return mFun(mBound, p0, p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    return mFun(mBound, p0, p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    return mFun(mBound, p0, p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    return mFun(mBound, p0, p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    return mFun(mBound, p0, p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    return mFun(mBound, p0, p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    return mFun(mBound, p0, p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  // [[[end]]]
+
+private:
+  ParentFunctor mFun;
+  Bound mBound;
+};
+
+template
+<class ParentFunctor, typename LocationType>
+class Voider
+  : public FunctorImpl<void, typename ParentFunctor::ParamList>
+{
+public:
+  Voider(ParentFunctor fun, LocationType loc)
+    : mFun(fun)
+    , mLoc(loc)
+  {}
+
+  typedef void ResultType;
+  typedef typename ParentFunctor::ParamList ParamList;
+  typedef Functor<ResultType, ParamList> Outgoing;
+
+  EXTRACT_TYPEDEFS(ParamList)
+
+  // [[[cog
+  // for i in rng:
+  //   Pps = tlist("P p", i)
+  //   cps = tlist("p", i)
+  //   cog.out("""
+  // ResultType operator()(%(Pps)s) {
+  //   mLoc = mFun(%(cps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() {
+    mLoc = mFun();
+  }
+  ResultType operator()(P0 p0) {
+    mLoc = mFun(p0);
+  }
+  ResultType operator()(P0 p0, P1 p1) {
+    mLoc = mFun(p0, p1);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2) {
+    mLoc = mFun(p0, p1, p2);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3) {
+    mLoc = mFun(p0, p1, p2, p3);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4) {
+    mLoc = mFun(p0, p1, p2, p3, p4);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(P0 p0, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
+    mLoc = mFun(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  // [[[end]]]
+
+private:
+  ParentFunctor mFun;
+  LocationType mLoc;
+};
+
+// Sayonara, macro scum!
+#undef EXTRACT_TYPEDEFS
+
+
+// Define global functor adapter functions with the default calling convention:
+#define CALLING_CONVENTION
+#include "FunctorAdapters.h"
+#undef CALLING_CONVENTION
+
+// Define global functor adapter functions with calling convention __stdcall on
+// the platform that supports it:
+#ifdef NS_WIN32 // see xpcom/base/nscore.h
+#  define CALLING_CONVENTION __stdcall
+#  include "FunctorAdapters.h"
+#  undef CALLING_CONVENTION
+#endif
+
+
+#endif
diff --git a/xpcom/glue/functors/FunctorAdapters.h b/xpcom/glue/functors/FunctorAdapters.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/functors/FunctorAdapters.h
@@ -0,0 +1,317 @@
+/* -*- Mode: c++; tab-width: 2; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is functor.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/**
+ * This file is meant to be #included by Functor.h, possibly more than once,
+ * for each required calling convention { __stdcall, __cdecl, __fastcall }, &c.
+ *
+ * For auto-generation instructions, see the comment at the top of Functor.h.
+ *
+ * Herebelow lies a jungle of functor adapter functions.  I did not write them;
+ * I generated them.  Even the comments are auto-generated.  If you need to
+ * modify them, you really, really should change and re-run the generator code
+ * rather than editing the functions themselves.
+ */
+
+#ifndef FunctorAdapters_h__only_once
+#define FunctorAdapters_h__only_once
+
+// Pass already-Functors through unmodified:
+template <typename Result, class Params>
+Functor<Result, Params>
+functor(Functor<Result, Params> f) { return f; }
+
+#endif // FunctorAdapters_h__only_once
+
+// [[[cog
+// from functor_cog_utils import tlist, MAX_FUNCTOR_ARITY
+// rng = range(MAX_FUNCTOR_ARITY+1)
+// ]]]
+// [[[end]]]
+
+#ifndef CALLING_CONVENTION
+#define CALLING_CONVENTION
+#define FunctorAdapters_h__must_undef_CC
+#endif
+
+// [[[cog
+// # The i parameter specifies the number of parameters the adapted
+// # functions/functors/methods should support:
+// def output_global_adapters(i):
+//   j = i + 1
+//   ctnPs = tlist(", typename P", i, sep="")
+//   cPs = tlist(", P", i, sep="")
+//   Ps = tlist("P", i)
+//
+//   tmpl = """
+// template <typename R, class C%(ctnPs)s>
+// Functor<R, TLIST%(j)d(C*%(cPs)s)>
+// functor(R (CALLING_CONVENTION C::*m)(%(Ps)s)%(const)s) {
+//   return Functor<R, TLIST%(j)d(C*%(cPs)s)>::method(m);
+// }"""
+//
+//   plural = "s"[int(i==1):]
+//
+//   # Can't actually handle methods with MAX_FUNCTOR_ARITY parameters, since
+//   # the first parameter is reserved for the receiving object:
+//   if i < MAX_FUNCTOR_ARITY:
+//     cog.out("""
+// // Adapters for methods with %d parameter%s:""" % (i, plural))
+//     const = ""
+//     cog.out(tmpl % locals())
+//     const = " const"
+//     cog.out(tmpl % locals())
+//
+//   cog.out("""
+// // Adapter for global functions with %d parameter%s:""" % (i, plural))
+//   cog.out("""
+// template <typename R%(ctnPs)s>
+// Functor<R, TLIST%(i)d(%(Ps)s)>
+// functor(R (CALLING_CONVENTION *f)(%(Ps)s)) {
+//   return Functor<R, TLIST%(i)d(%(Ps)s)>::callable(f);
+// }
+//
+// """ % locals())
+//
+// for i in rng:
+//   output_global_adapters(i)
+// ]]]
+
+// Adapters for methods with 0 parameters:
+template <typename R, class C>
+Functor<R, TLIST1(C*)>
+functor(R (CALLING_CONVENTION C::*m)()) {
+  return Functor<R, TLIST1(C*)>::method(m);
+}
+template <typename R, class C>
+Functor<R, TLIST1(C*)>
+functor(R (CALLING_CONVENTION C::*m)() const) {
+  return Functor<R, TLIST1(C*)>::method(m);
+}
+// Adapter for global functions with 0 parameters:
+template <typename R>
+Functor<R, TLIST0()>
+functor(R (CALLING_CONVENTION *f)()) {
+  return Functor<R, TLIST0()>::callable(f);
+}
+
+
+// Adapters for methods with 1 parameter:
+template <typename R, class C, typename P0>
+Functor<R, TLIST2(C*, P0)>
+functor(R (CALLING_CONVENTION C::*m)(P0)) {
+  return Functor<R, TLIST2(C*, P0)>::method(m);
+}
+template <typename R, class C, typename P0>
+Functor<R, TLIST2(C*, P0)>
+functor(R (CALLING_CONVENTION C::*m)(P0) const) {
+  return Functor<R, TLIST2(C*, P0)>::method(m);
+}
+// Adapter for global functions with 1 parameter:
+template <typename R, typename P0>
+Functor<R, TLIST1(P0)>
+functor(R (CALLING_CONVENTION *f)(P0)) {
+  return Functor<R, TLIST1(P0)>::callable(f);
+}
+
+
+// Adapters for methods with 2 parameters:
+template <typename R, class C, typename P0, typename P1>
+Functor<R, TLIST3(C*, P0, P1)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1)) {
+  return Functor<R, TLIST3(C*, P0, P1)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1>
+Functor<R, TLIST3(C*, P0, P1)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1) const) {
+  return Functor<R, TLIST3(C*, P0, P1)>::method(m);
+}
+// Adapter for global functions with 2 parameters:
+template <typename R, typename P0, typename P1>
+Functor<R, TLIST2(P0, P1)>
+functor(R (CALLING_CONVENTION *f)(P0, P1)) {
+  return Functor<R, TLIST2(P0, P1)>::callable(f);
+}
+
+
+// Adapters for methods with 3 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2>
+Functor<R, TLIST4(C*, P0, P1, P2)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1, P2)) {
+  return Functor<R, TLIST4(C*, P0, P1, P2)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2>
+Functor<R, TLIST4(C*, P0, P1, P2)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1, P2) const) {
+  return Functor<R, TLIST4(C*, P0, P1, P2)>::method(m);
+}
+// Adapter for global functions with 3 parameters:
+template <typename R, typename P0, typename P1, typename P2>
+Functor<R, TLIST3(P0, P1, P2)>
+functor(R (CALLING_CONVENTION *f)(P0, P1, P2)) {
+  return Functor<R, TLIST3(P0, P1, P2)>::callable(f);
+}
+
+
+// Adapters for methods with 4 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3>
+Functor<R, TLIST5(C*, P0, P1, P2, P3)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1, P2, P3)) {
+  return Functor<R, TLIST5(C*, P0, P1, P2, P3)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3>
+Functor<R, TLIST5(C*, P0, P1, P2, P3)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1, P2, P3) const) {
+  return Functor<R, TLIST5(C*, P0, P1, P2, P3)>::method(m);
+}
+// Adapter for global functions with 4 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3>
+Functor<R, TLIST4(P0, P1, P2, P3)>
+functor(R (CALLING_CONVENTION *f)(P0, P1, P2, P3)) {
+  return Functor<R, TLIST4(P0, P1, P2, P3)>::callable(f);
+}
+
+
+// Adapters for methods with 5 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4>
+Functor<R, TLIST6(C*, P0, P1, P2, P3, P4)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1, P2, P3, P4)) {
+  return Functor<R, TLIST6(C*, P0, P1, P2, P3, P4)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4>
+Functor<R, TLIST6(C*, P0, P1, P2, P3, P4)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1, P2, P3, P4) const) {
+  return Functor<R, TLIST6(C*, P0, P1, P2, P3, P4)>::method(m);
+}
+// Adapter for global functions with 5 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4>
+Functor<R, TLIST5(P0, P1, P2, P3, P4)>
+functor(R (CALLING_CONVENTION *f)(P0, P1, P2, P3, P4)) {
+  return Functor<R, TLIST5(P0, P1, P2, P3, P4)>::callable(f);
+}
+
+
+// Adapters for methods with 6 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
+Functor<R, TLIST7(C*, P0, P1, P2, P3, P4, P5)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1, P2, P3, P4, P5)) {
+  return Functor<R, TLIST7(C*, P0, P1, P2, P3, P4, P5)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
+Functor<R, TLIST7(C*, P0, P1, P2, P3, P4, P5)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1, P2, P3, P4, P5) const) {
+  return Functor<R, TLIST7(C*, P0, P1, P2, P3, P4, P5)>::method(m);
+}
+// Adapter for global functions with 6 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
+Functor<R, TLIST6(P0, P1, P2, P3, P4, P5)>
+functor(R (CALLING_CONVENTION *f)(P0, P1, P2, P3, P4, P5)) {
+  return Functor<R, TLIST6(P0, P1, P2, P3, P4, P5)>::callable(f);
+}
+
+
+// Adapters for methods with 7 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
+Functor<R, TLIST8(C*, P0, P1, P2, P3, P4, P5, P6)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1, P2, P3, P4, P5, P6)) {
+  return Functor<R, TLIST8(C*, P0, P1, P2, P3, P4, P5, P6)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
+Functor<R, TLIST8(C*, P0, P1, P2, P3, P4, P5, P6)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1, P2, P3, P4, P5, P6) const) {
+  return Functor<R, TLIST8(C*, P0, P1, P2, P3, P4, P5, P6)>::method(m);
+}
+// Adapter for global functions with 7 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
+Functor<R, TLIST7(P0, P1, P2, P3, P4, P5, P6)>
+functor(R (CALLING_CONVENTION *f)(P0, P1, P2, P3, P4, P5, P6)) {
+  return Functor<R, TLIST7(P0, P1, P2, P3, P4, P5, P6)>::callable(f);
+}
+
+
+// Adapters for methods with 8 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
+Functor<R, TLIST9(C*, P0, P1, P2, P3, P4, P5, P6, P7)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1, P2, P3, P4, P5, P6, P7)) {
+  return Functor<R, TLIST9(C*, P0, P1, P2, P3, P4, P5, P6, P7)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
+Functor<R, TLIST9(C*, P0, P1, P2, P3, P4, P5, P6, P7)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1, P2, P3, P4, P5, P6, P7) const) {
+  return Functor<R, TLIST9(C*, P0, P1, P2, P3, P4, P5, P6, P7)>::method(m);
+}
+// Adapter for global functions with 8 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
+Functor<R, TLIST8(P0, P1, P2, P3, P4, P5, P6, P7)>
+functor(R (CALLING_CONVENTION *f)(P0, P1, P2, P3, P4, P5, P6, P7)) {
+  return Functor<R, TLIST8(P0, P1, P2, P3, P4, P5, P6, P7)>::callable(f);
+}
+
+
+// Adapters for methods with 9 parameters:
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
+Functor<R, TLIST10(C*, P0, P1, P2, P3, P4, P5, P6, P7, P8)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1, P2, P3, P4, P5, P6, P7, P8)) {
+  return Functor<R, TLIST10(C*, P0, P1, P2, P3, P4, P5, P6, P7, P8)>::method(m);
+}
+template <typename R, class C, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
+Functor<R, TLIST10(C*, P0, P1, P2, P3, P4, P5, P6, P7, P8)>
+functor(R (CALLING_CONVENTION C::*m)(P0, P1, P2, P3, P4, P5, P6, P7, P8) const) {
+  return Functor<R, TLIST10(C*, P0, P1, P2, P3, P4, P5, P6, P7, P8)>::method(m);
+}
+// Adapter for global functions with 9 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
+Functor<R, TLIST9(P0, P1, P2, P3, P4, P5, P6, P7, P8)>
+functor(R (CALLING_CONVENTION *f)(P0, P1, P2, P3, P4, P5, P6, P7, P8)) {
+  return Functor<R, TLIST9(P0, P1, P2, P3, P4, P5, P6, P7, P8)>::callable(f);
+}
+
+
+// Adapter for global functions with 10 parameters:
+template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
+Functor<R, TLIST10(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9)>
+functor(R (CALLING_CONVENTION *f)(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9)) {
+  return Functor<R, TLIST10(P0, P1, P2, P3, P4, P5, P6, P7, P8, P9)>::callable(f);
+}
+
+// [[[end]]]
+
+#ifdef FunctorAdapters_h__must_undef_CC
+#undef CALLING_CONVENTION
+#undef FunctorAdapters_h__must_undef_CC
+#endif
diff --git a/xpcom/glue/functors/Location.h b/xpcom/glue/functors/Location.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/functors/Location.h
@@ -0,0 +1,165 @@
+/* -*- Mode: c++; tab-width: 2; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Location.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef Location_h__
+#define Location_h__
+
+#include "nsAutoPtr.h" // for nsRefPtr
+
+// Forward declaration of StoragePolicy classes:
+template <typename T> class ClientManagedStoragePolicy;
+template <typename T> class RefCountingStoragePolicy;
+
+/**
+ * A Location represents a single assignable place in memory.  Location
+ * objects may be cheaply copied, but every copy refers to the same location.
+ * Conversion operators expose both references and pointers to the underlying
+ * value, so Locations are good for imposing constraints on out-parameters.
+ * These constraints are expressed through a StoragePolicy template parameter,
+ * which is responsible for implementing GetPointer, GetConstPointer, and one
+ * or more constructors.  If the client avoids using a certain method (such as
+ * operator=), any demands the method makes on the StoragePolicy base class
+ * (such as the availability of a GetPointer method) are waived, because the
+ * compiler does not generate code for unused template methods.
+ *
+ * Andrei Alexandrescu has a chapter about policy classes in his Modern C++
+ * Design book.
+ */
+template
+<
+  typename T, // Reference types do not work, and that is as it should be.
+  template <typename> class StoragePolicy = RefCountingStoragePolicy
+>
+class Location : private StoragePolicy<T>
+{
+public:
+  explicit Location() {}
+  explicit Location(T* tp) : StoragePolicy<T>(tp) {}
+
+  // Any type that can be assigned to a dereferenced T* is legal here:
+  template <typename R>
+  Location& operator=(const R& rhs) {
+    *this->GetPointer() = rhs;
+    return *this;
+  }
+
+  operator T&() { return *this->GetPointer(); }
+  operator const T&() const { return *this->GetConstPointer(); }
+
+  operator T*() { return this->GetPointer(); }
+  operator const T*() const { return this->GetConstPointer(); }
+
+  T* operator->() { return this->GetPointer(); }
+  const T* operator->() const { return this->GetConstPointer(); }
+};
+
+
+/**
+ * ClientManagedStoragePolicy assumes nothing about the allocation and
+ * management of T, and consequently provides the client no assistance to that
+ * end.  This policy class is intended primarily for use by ref and cref.
+ */
+template <typename T>
+class ClientManagedStoragePolicy
+{
+  T* mPtr;
+protected:
+  ClientManagedStoragePolicy(T* tp) : mPtr(tp) {}
+  T* GetPointer() { return mPtr; }
+  const T* GetConstPointer() const { return mPtr; }
+};
+
+/**
+ * RefCountingStoragePolicy provides only a zero-parameter constructor to force
+ * heap allocation of the underlying T value.
+ *
+ * If T itself supports AddRef and Release methods, these methods will NOT be
+ * called.  Furthermore, deleting the pointer returned by GetPointer is UNSAFE,
+ * since that address points INSIDE a heap-allocated Holder object.  For these
+ * reasons, you probably should avoid using RefCountingStoragePolicy with
+ * intrinsically reference counted objects.
+ *
+ * It's fine to use a Location<nsISupports*, RefCountingStoragePolicy> to
+ * represent a safe out-parameter, but just realize that all you're ensuring is
+ * the safety of the sizeof(void*) bytes representing the address, not the
+ * validity of the address or the object it points to!
+ */
+template <typename T>
+class RefCountingStoragePolicy
+{
+  struct Holder {
+    T mVal; // must be default-constructible:
+    Holder() : mVal() {}
+    nsAutoRefCnt mRefCnt;
+    NS_IMETHOD_(nsrefcnt) AddRef();
+    NS_IMETHOD_(nsrefcnt) Release();
+  };
+  nsRefPtr<Holder> mHolderPtr;
+protected:
+  RefCountingStoragePolicy() : mHolderPtr(new Holder()) {}
+  T* GetPointer() { return &mHolderPtr->mVal; }
+  const T* GetConstPointer() const { return &mHolderPtr->mVal; }
+};
+template <typename T>
+NS_IMPL_THREADSAFE_ADDREF(RefCountingStoragePolicy<T>::Holder)
+template <typename T>
+NS_IMPL_THREADSAFE_RELEASE(RefCountingStoragePolicy<T>::Holder)
+
+
+/**
+ * Template type inference prefers non-reference types to reference types, so
+ * references passed to bind will be stored by VALUE unless explicitly coerced
+ * using the ref and cref (const reference) functions below.
+ */
+
+template <typename T>
+Location<T, ClientManagedStoragePolicy>
+ref(T& t)
+{
+  return Location<T, ClientManagedStoragePolicy>(&t);
+}
+
+template <typename T>
+const Location<const T, ClientManagedStoragePolicy>
+cref(const T& t)
+{
+  typedef const Location<const T, ClientManagedStoragePolicy> type;
+  return type(&t);
+}
+
+#endif
diff --git a/xpcom/glue/functors/TList.h b/xpcom/glue/functors/TList.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/functors/TList.h
@@ -0,0 +1,173 @@
+/* -*- Mode: c++; tab-width: 2; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is TList/TLIST{0,1,...}.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __tlist_h__
+#define __tlist_h__
+
+/**
+ * TLists, or type lists, are Lisp-style linked lists of types.  This file only
+ * scratches the surface of what is possible with type lists, but I only needed
+ * to calculate lengths and access types by index, so that's all I bothered
+ * implementing.
+ *
+ * Andrei Alexandrescu's book
+ *
+ *   Modern C++ Design: Generic Programming and Design Patterns Applied
+ *
+ * has a great deal more to say on this topic.
+ *
+ * Instructions pertaining to the cog.py code generation tool are available
+ * here: http://nedbatchelder.com/code/cog/
+ *
+ * Once you have installed cog.py, run
+ *
+ *   cog.py -r TList.h
+ *
+ * or (to regenerate all coggable files)
+ *
+ *   python functor_cog_utils.py
+ *
+ * to regenerate the portions of this file delimited by the triple square
+ * bracket markers.  The file changes in place, but the python generating code
+ * remains, so repeatedly regenerating the file is really very easy.
+ */
+
+// [[[cog
+// from functor_cog_utils import tlist, MAX_FUNCTOR_ARITY
+// rng = range(MAX_FUNCTOR_ARITY+1)
+// ijs = zip(rng, rng[1:])
+// ]]]
+// [[[end]]]
+
+class NullType {};
+struct EmptyType {};
+
+template <typename T, typename U>
+struct TList {
+  typedef T Head;
+  typedef U Tail;
+};
+
+#define TLIST0() NullType
+
+// [[[cog
+// for (i, j) in ijs:
+//   Ts = tlist("T", j)
+//   Tcdr = tlist("T", rbegin=1, rend=j)
+//   slash = "\\"
+//   cog.out("""
+// #define TLIST%(j)d(%(Ts)s) %(slash)s
+//   TList<T0, TLIST%(i)d(%(Tcdr)s)>
+// """ % locals())
+// ]]]
+
+#define TLIST1(T0) \
+  TList<T0, TLIST0()>
+
+#define TLIST2(T0, T1) \
+  TList<T0, TLIST1(T1)>
+
+#define TLIST3(T0, T1, T2) \
+  TList<T0, TLIST2(T1, T2)>
+
+#define TLIST4(T0, T1, T2, T3) \
+  TList<T0, TLIST3(T1, T2, T3)>
+
+#define TLIST5(T0, T1, T2, T3, T4) \
+  TList<T0, TLIST4(T1, T2, T3, T4)>
+
+#define TLIST6(T0, T1, T2, T3, T4, T5) \
+  TList<T0, TLIST5(T1, T2, T3, T4, T5)>
+
+#define TLIST7(T0, T1, T2, T3, T4, T5, T6) \
+  TList<T0, TLIST6(T1, T2, T3, T4, T5, T6)>
+
+#define TLIST8(T0, T1, T2, T3, T4, T5, T6, T7) \
+  TList<T0, TLIST7(T1, T2, T3, T4, T5, T6, T7)>
+
+#define TLIST9(T0, T1, T2, T3, T4, T5, T6, T7, T8) \
+  TList<T0, TLIST8(T1, T2, T3, T4, T5, T6, T7, T8)>
+
+#define TLIST10(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) \
+  TList<T0, TLIST9(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
+// [[[end]]]
+
+namespace tlist {
+
+  /**
+   * Length<List>::value gives the length of the typelist List.
+   */
+  template <typename List>
+  struct Length { enum { value = 0 }; };
+
+  template <typename T, typename U>
+  struct Length<TList<T, U> > {
+    enum { value = 1 + Length<U>::value };
+  };
+
+  template <typename List, unsigned N, typename D> struct TypeAt_;
+
+  template <unsigned N, typename D>
+  struct TypeAt_<NullType, N, D> { typedef D type; };
+
+  template <typename T, typename U, unsigned N, typename D>
+  struct TypeAt_<TList<T, U>, N, D> {
+    typedef typename TypeAt_<U, N-1, D>::type type;
+  };
+
+  template <typename T, typename U, typename D>
+  struct TypeAt_<TList<T, U>, 0, D> { typedef T type; };
+
+  /**
+   * typename TypeAt<List, N, T>::type gives the type at position N of the
+   * typelist List.  If the index is too large, the default type T will be the
+   * result.  Negative positions are also allowed: -1 corresponds to the last
+   * position in the list, -2 the second-to-last, &c.
+   */
+  template <typename List, int N, typename Default=EmptyType>
+  struct TypeAt {
+    typedef typename TypeAt_<
+        List,
+        N < 0 ? Length<List>::value + N : N,
+        Default
+      >::type type;
+  };
+
+}
+
+#endif
diff --git a/xpcom/glue/functors/functor_cog_utils.py b/xpcom/glue/functors/functor_cog_utils.py
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/functors/functor_cog_utils.py
@@ -0,0 +1,64 @@
+#!/usr/bin/env python
+"""
+-*- Mode: python; tab-width: 2; c-basic-offset: 2; indent-tabs-mode: nil -*-
+***** BEGIN LICENSE BLOCK *****
+Version: MPL 1.1/GPL 2.0/LGPL 2.1
+
+The contents of this file are subject to the Mozilla Public License Version
+1.1 (the "License"); you may not use this file except in compliance with
+the License. You may obtain a copy of the License at
+http://www.mozilla.org/MPL/
+
+Software distributed under the License is distributed on an "AS IS" basis,
+WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+for the specific language governing rights and limitations under the
+License.
+
+The Original Code is tlist.
+
+The Initial Developer of the Original Code is
+  Mozilla Corporation.
+Portions created by the Initial Developer are Copyright (C) 2009
+the Initial Developer. All Rights Reserved.
+
+Contributor(s):
+  Ben Newman <b{enjam,newma}n@mozilla.com> (Original Author)
+
+Alternatively, the contents of this file may be used under the terms of
+either the GNU General Public License Version 2 or later (the "GPL"), or
+the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+in which case the provisions of the GPL or the LGPL are applicable instead
+of those above. If you wish to allow use of your version of this file only
+under the terms of either the GPL or the LGPL, and not to allow others to
+use your version of this file under the terms of the MPL, indicate your
+decision by deleting the provisions above and replace them with the notice
+and other provisions required by the GPL or the LGPL. If you do not delete
+the provisions above, a recipient may use your version of this file under
+the terms of any one of the MPL, the GPL or the LGPL.
+
+***** END LICENSE BLOCK *****
+"""
+import re
+
+# Generate code for functors of up to this many parameters:
+MAX_FUNCTOR_ARITY = 10
+
+# A versatile list-generation tool.
+# TODO More explanation?
+tpat = re.compile(r"\b[a-z]\b", re.I)
+npat = re.compile(r"\b0\b")
+def tlist(tmpl, rend, rbegin=0, sep=", "):
+  return sep.join(tpat.sub("\g<0>%u" % i,
+                           npat.sub("%u" % i, tmpl))
+                  for i in range(rbegin, rend))
+
+_cog_files = [
+  "Functor.h",
+  "FunctorAdapters.h",
+  "TList.h",
+]
+
+if __name__ == "__main__":
+  from cogapp import Cog
+  for file in _cog_files:
+    Cog().main([None, "-r", file])
diff --git a/xpcom/tests/Makefile.in b/xpcom/tests/Makefile.in
--- a/xpcom/tests/Makefile.in
+++ b/xpcom/tests/Makefile.in
@@ -43,17 +43,17 @@ VPATH		= @srcdir@
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= xpcom
 
 ifndef MOZ_ENABLE_LIBXUL
 MOZILLA_INTERNAL_API = 1
 endif
 
-DIRS		= dynamic services external
+DIRS		= dynamic services external functors
 ifeq ($(OS_ARCH),WINNT)
 DIRS		+= windows
 endif
 
 ifdef DEHYDRA_PATH
 DIRS += static-checker
 endif
 
diff --git a/xpcom/tests/functors/ArgConversionError.cpp b/xpcom/tests/functors/ArgConversionError.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/ArgConversionError.cpp
@@ -0,0 +1,8 @@
+#include "Functor.h"
+
+int main(int argc, char* argv[])
+{
+  // Binding-time argument conversion failure:
+  functor(main).bind("not an integer");
+  return 0;
+}
diff --git a/xpcom/tests/functors/BindResultReferenceError.cpp b/xpcom/tests/functors/BindResultReferenceError.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/BindResultReferenceError.cpp
@@ -0,0 +1,10 @@
+#include "Functor.h"
+
+int main()
+{
+  int n;
+  // bind_result requires an explicit Location object
+  functor(main).bind_result(&n)();
+  functor(main).bind_result(n)();
+  return n;
+}
diff --git a/xpcom/tests/functors/CrefAssignmentError.cpp b/xpcom/tests/functors/CrefAssignmentError.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/CrefAssignmentError.cpp
@@ -0,0 +1,6 @@
+#include "Location.h"
+
+int main() {
+  int n;
+  cref(n) = 3;
+}
diff --git a/xpcom/tests/functors/Makefile.in b/xpcom/tests/functors/Makefile.in
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/Makefile.in
@@ -0,0 +1,101 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla 2.
+#
+# The Initial Developer of the Original Code is
+# the Mozilla Foundation <http://www.mozilla.org>.
+#
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Benjamin Smedberg <benjamin@smedbergs.us> (Inspiration)
+#   Ben Newman <b{newma,enjam}n@mozilla.com> (Author)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH = ../../..
+topsrcdir = @top_srcdir@
+srcdir = @srcdir@
+VPATH = @srcdir@
+
+# We will do compilations that create dependency files.
+NEED_MDDEPDIR = 1
+
+include $(DEPTH)/config/autoconf.mk
+
+CPP_UNIT_TESTS = \
+	TestFunctor.cpp \
+	TestLocation.cpp \
+	$(NULL)
+
+# Testcases that should fail to compile:
+STATIC_FAILURE_TESTCASES = \
+  CrefAssignmentError.cpp \
+  ArgConversionError.cpp \
+  TooManyParamsError.cpp \
+  BindResultReferenceError.cpp \
+  $(NULL)
+
+# Testcases that should compile:
+STATIC_PASS_TESTCASES = \
+  $(CPP_UNIT_TESTS) \
+  VoidReturn.cpp \
+  $(NULL)
+
+REQUIRES = xpcom
+
+include $(topsrcdir)/config/rules.mk
+
+# We want to compile each file and invert the result to ensure that
+# compilation failed.
+static:: \
+  $(STATIC_FAILURE_TESTCASES:.cpp=.s-fail) \
+  $(STATIC_PASS_TESTCASES:.cpp=.s-pass)
+
+check:: static
+
+%.s-fail: %.cpp $(GLOBAL_DEPS)
+	@printf "Compiling $(<F) to verify that it produces errors (as expected)..."
+	@if $(CCC) $(OUTOPTION)$(*F).deleteme.s -S $(COMPILE_CXXFLAGS) $(_VPATH_SRCS) >$(*F).errlog 2>&1; then \
+	  printf "fail:\nerror: compilation of $(<F) succeeded. It shouldn't have!\n"; \
+	  cat $(*F).errlog; \
+	  exit 1; \
+	else \
+	  printf "ok.\n"; \
+	fi; \
+	rm -f $(*F).deleteme.s
+
+%.s-pass: %.cpp $(GLOBAL_DEPS)
+	@printf "Compiling $(<F) just to verify that compilation succeeds..."
+	@if $(CCC) $(OUTOPTION)$(*F).deleteme.s -S $(COMPILE_CXXFLAGS) $(_VPATH_SRCS) >$(*F).errlog 2>&1; then \
+	  printf "ok.\n"; \
+	else \
+	  printf "fail:\nerror: compilation of $(<F) failed. It shouldn't have!\n"; \
+	  cat $(*F).errlog; \
+	  exit 1; \
+	fi; \
+	rm -f $(*F).deleteme.s
diff --git a/xpcom/tests/functors/TestFunctor.cpp b/xpcom/tests/functors/TestFunctor.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/TestFunctor.cpp
@@ -0,0 +1,259 @@
+#include "TestUtils.h"
+#include "nsAutoPtr.h"
+
+#include "Functor.h"
+
+int Succ(int n) {
+  return n + 1;
+}
+
+struct Pred
+{
+  int operator()(int n) {
+    return n - 1;
+  }
+};
+
+struct DiffStruct
+{
+  int Sub(int a, int b) {
+    return a - b;
+  }
+  static int Add2(int a, int b) {
+    return a + b;
+  }
+};
+
+nsresult Unequal(int x, int y) {
+  return ok(x != y);
+}
+
+nsresult test_basic_usage()
+{
+  Functor<int, TLIST1(int)> s = functor(&Succ);
+
+  Pred pred;
+  Functor<int, TLIST1(int)> p = functor(&Pred::operator()).bind(&pred);
+
+  Functor<int, TLIST3(DiffStruct*, int, int)> ds =
+    functor(&DiffStruct::Sub);
+
+  Functor<int, TLIST2(int, int)> a2 = functor(&DiffStruct::Add2);
+
+  nsresult rv = NS_OK;
+
+  int a = 1, b = 5;
+  rv |= is(s(a), a + 1);
+  rv |= is(p(b), b - 1);
+  nsAutoPtr<DiffStruct> dsp(new DiffStruct());
+  rv |= is(ds(dsp, s(a), p(b)), a - b + 2);
+
+  rv |= is(a2(2, 3), 5);
+
+  functor(&Unequal)(1, 2);
+  return functor(&Unequal).bind(2)(3);
+}
+
+nsresult test_bind()
+{
+  nsresult rv = NS_OK;
+
+  // Interesting (near-)equivalences:
+  rv |= is(Pred()(2), 1);
+  rv |= is((Pred().*(&Pred::operator()))(2), 1);
+  rv |= is(Pred().operator()(2), 1);
+  nsAutoPtr<Pred> pp(new Pred());
+  rv |= is(functor(&Pred::operator()).bind(pp)(2), 1);
+
+  Functor<int, TLIST2(int, int)> a2 = functor(&DiffStruct::Add2);
+  rv |= is(a2.bind(2)(3), 5);
+  rv |= is(a2.bind(2).bind(3)(), 5);
+  rv |= is(functor(&DiffStruct::Add2).bind(2).bind(3)(), 5);
+
+  int x = 5, y = 3;
+  DiffStruct ds;
+  Functor<int, TLIST2(int, int)> sub = functor(&DiffStruct::Sub).bind(&ds);
+  Functor<int, TLIST1(int)> f = functor(sub).bind(x); // sub already a functor (perfectly ok)
+  rv |= is(sub(x, y), x - y);
+  rv |= is(sub(y, x), y - x);
+  rv |= is(f(x), 0);
+  rv |= is(f(y), x - y);
+
+  return rv;
+}
+
+template <typename T> void set(T t, int value) { t = value; }
+template <typename T> void set_ref(T& tref, int value) { tref = value; }
+nsresult test_ref_cref()
+{
+  nsresult rv = NS_OK;
+  int n = 0, &nref = n;
+  set(nref, n+1);        rv |= is(n, 0);
+  set(ref(n), n+1);      rv |= is(n, 1);
+  set(ref(n), ref(n));
+  set(ref(n), cref(n));
+  set_ref(nref, cref(n));
+  set_ref(nref, n+1);    rv |= is(n, 2);
+  set_ref(*ref(n), n+1); rv |= is(n, 3);
+  return rv;
+}
+
+template <typename T> T generic_identity(T t) { return t; }
+nsresult test_templatized_functor()
+{
+  nsresult rv = NS_OK;
+  Functor<int, TLIST0()> f =
+    functor((int(*)(int))generic_identity).bind(2);
+  rv |= is(f(), 2);
+  rv |= is(functor(static_cast<int(*)(int)>(generic_identity))(1), 1);
+  return rv;
+}
+
+nsresult test_bind_result(int n)
+{
+  nsresult rv = NS_OK;
+  Location<int> out;
+  Functor<void, TLIST0()> inc =
+    functor(&Succ).bind_result(out).bind(out);
+  rv |= is(int(out), 0); // testing default construction
+  for (int i = out; i < n; ++i)
+    inc();
+  rv |= is(int(out), n);
+  return rv;
+}
+
+nsresult test_bind_conversion()
+{
+  nsresult rv = NS_OK;
+
+  char j = 'j';
+  Location<char> k;
+
+  // N.B. Succ is int(*)(int)
+  functor(Succ).bind(j).bind_result(k)();
+  rv |= is(char(k), 'k'); k = '\0';
+  functor(Succ).bind_result(k).bind(j)();
+  rv |= is(char(k), 'k'); k = '\0';
+  k = functor(Succ).bind(j)();
+  rv |= is(char(k), 'k'); k = '\0';
+  functor(Succ).bind_result(k)(j);
+  rv |= is(char(k), 'k');
+
+  return rv;
+}
+
+class MethodGiver {
+  int mVal;
+  int Foo() { return mVal; }
+public:
+  MethodGiver(int val) : mVal(val) {}
+  Functor<int, TLIST0()>
+  GetBoundFooFunctor() {
+    return functor(&MethodGiver::Foo).bind(this);
+  }
+  Functor<int, TLIST1(MethodGiver*)>
+  GetFooFunctor() {
+    return functor(&MethodGiver::Foo);
+  }
+};
+nsresult test_private_method_invocation()
+{
+  nsresult rv = NS_OK;
+  MethodGiver mg(1);
+  rv |= is(MethodGiver(2).GetBoundFooFunctor()(), 2);
+  rv |= is(mg.GetFooFunctor().bind(&mg)(), 1);
+  return rv;
+}
+
+class Whammer {
+  int mVal;
+public:
+  Whammer(int val) : mVal(val) {}
+  int Wham() { return mVal; }
+};
+class WhammerPtr {
+  Whammer mWhammer;
+public:
+  WhammerPtr(int val) : mWhammer(val) {}
+  Whammer& operator*() { return mWhammer; }
+  Whammer* operator->() { return &mWhammer; }
+};
+nsresult test_deref_operator_compatibility()
+{
+  nsresult rv = NS_OK;
+  WhammerPtr wp(5);
+  rv |= is(Whammer(3).Wham() + (*wp).Wham() + wp->Wham(), 3 + 5 + 5);
+  // Can't use functor(<method>) because it forces the first argument to
+  // MethodHandler::operator() to be a pointer to an instance of the method's
+  // class.  In order to use WhammerPtr as a Whammer*, we have to give up the
+  // convenience of the global functor adapter.
+  typedef Functor<int, TLIST1(WhammerPtr)> ftype;
+  rv |= is(ftype::method(&Whammer::Wham).bind(wp)(), 5);
+  return rv;
+}
+
+int deep_thought(int answer = 42) { return answer; }
+nsresult test_default_parameters()
+{
+  // This is actually illegal since default arguments are not considered part
+  // of a function's type by all compilers.  I can't think of a way to promote
+  // this inconsistency to an error on all compilers, but at least such usage
+  // is implicitly discouraged since it requires using ::callable or ::method
+  // directly instead of simply calling the 'functor' adapter.
+  // typedef Functor<int, TLIST0()> ftype;
+  // return is(functor(deep_thought).bind(2 * ftype::callable(deep_thought)())(), 84);
+
+  return is(functor(deep_thought).bind(84)(), 84); // trivial placeholder
+}
+
+class Bound : public nsISupports {
+  NS_DECL_ISUPPORTS
+public:
+  Bound(int *ptr) : mPtr(ptr) {}
+ ~Bound() { ++*mPtr; }
+  static int GetVal(Bound* b) { return *b->mPtr; }
+private:
+  int* const mPtr;
+};
+NS_IMPL_ISUPPORTS0(Bound)
+nsresult test_bound_nsRefPtr()
+{
+  nsresult rv = NS_OK;
+  int fval = 0, gval = 0;
+  {
+    Functor<int, TLIST0()>
+      f = functor(&Succ).bind(2),
+      g = f;
+    {
+      nsRefPtr<Bound>
+        fb = new Bound(&fval),
+        gb = new Bound(&gval);
+      rv |= is(f(), 3) | is(g(), 3);
+      f = functor(&Bound::GetVal).bind(fb);
+      g = functor(&Bound::GetVal).bind(gb.get());
+      rv |= is(f(), 0) | is(g(), 0);
+    }
+    rv |= is(fval, 0) | is(gval, 1);
+  }
+  rv |= is(fval, 1) | is(gval, 1);
+  return rv;
+}
+
+int main() {
+  ScopedXPCOM xpcom("FunctorTests");
+  if (xpcom.failed())
+    return NS_ERROR_FAILURE;
+
+  RUN_TEST(test_basic_usage());
+  RUN_TEST(test_bind());
+  RUN_TEST(test_ref_cref());
+  RUN_TEST(test_templatized_functor());
+  RUN_TEST(test_bind_result(3));
+  RUN_TEST(test_bind_conversion());
+  RUN_TEST(test_private_method_invocation());
+  RUN_TEST(test_deref_operator_compatibility());
+  RUN_TEST(test_default_parameters());
+  RUN_TEST(test_bound_nsRefPtr());
+
+  return NS_OK;
+}
diff --git a/xpcom/tests/functors/TestLocation.cpp b/xpcom/tests/functors/TestLocation.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/TestLocation.cpp
@@ -0,0 +1,89 @@
+#include "TestUtils.h"
+#include "Location.h"
+
+template <typename T, template <typename> class StoragePolicy>
+nsresult test_Location_assignment(Location<T, StoragePolicy> loc1,
+                                  Location<T, StoragePolicy> loc2)
+{
+  nsresult rv = NS_OK;
+  loc1 = 1;
+  loc2 = 2;
+  rv |= is(T(loc1), 1);
+  loc1 = loc2;
+  rv |= is(T(loc1), 2);
+  loc1 = 3;
+  rv |= is(T(loc2), 3);
+  return rv;
+}
+
+template <typename T, template <typename> class StoragePolicy>
+nsresult test_Location_conversion(Location<T, StoragePolicy> loc)
+{
+  nsresult rv = NS_OK;
+  T* tPtr = loc,
+   & tRef = loc;
+  *tPtr = 4;
+  rv |= is(tRef, 4);
+  rv |= is(*loc, 4);
+  loc = 5;
+  rv |= is(*tPtr, 5);
+  return rv;
+}
+
+nsresult test_client_managed_storage_policy()
+{
+  int a, b;
+  typedef Location<int, ClientManagedStoragePolicy> LocationType;
+  return test_Location_assignment(LocationType(&a), LocationType(&b))
+       | test_Location_conversion(LocationType(&a));
+}
+
+struct DestructionNotifier {
+  PRBool* mFlag;
+  DestructionNotifier() : mFlag(0) {}
+ ~DestructionNotifier() { if (mFlag) *mFlag = PR_TRUE; }
+  void SetFlag(PRBool* flag) { *(mFlag = flag) = PR_FALSE; }
+};
+nsresult test_ref_counting_storage_policy()
+{
+  nsresult rv = NS_OK;
+
+  typedef Location<int, RefCountingStoragePolicy>
+          IntLocation;
+  rv |= test_Location_assignment(IntLocation(),
+                                 IntLocation());
+
+  typedef Location<DestructionNotifier,
+                   RefCountingStoragePolicy>
+          DNLocation;
+  PRBool destroyed1, destroyed2;
+  {
+    DNLocation dnl1;
+    dnl1->SetFlag(&destroyed1);
+    {
+      DNLocation dnl2;
+      dnl2->SetFlag(&destroyed2);
+      rv |= ok(!destroyed1 && !destroyed2);
+      dnl2 = dnl1;
+      rv |= ok(!destroyed1 && destroyed2);
+    }
+    rv |= ok(!destroyed1 && destroyed2);
+  }
+  rv |= ok(destroyed1 && destroyed2);
+
+  rv |= test_Location_conversion(IntLocation());
+
+  return rv;
+}
+
+int main()
+{
+  ScopedXPCOM xpcom("FunctorTests");
+  if (xpcom.failed())
+    return NS_ERROR_FAILURE;
+
+  RUN_TEST(test_client_managed_storage_policy());
+  RUN_TEST(test_ref_counting_storage_policy());
+
+  return NS_OK;
+}
diff --git a/xpcom/tests/functors/TestUtils.h b/xpcom/tests/functors/TestUtils.h
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/TestUtils.h
@@ -0,0 +1,47 @@
+#ifndef TestUtils_h__
+#define TestUtils_h__
+
+#include "../TestHarness.h"
+#include <sstream>
+
+void silence_unused_function_warnings() {
+  StartProfiling("");
+  StopProfiling();
+}
+// #undef silence_unused_function_warnings
+
+template <typename T>
+nsresult is_helper(const char* lhs_str, const char* rhs_str, T lhs, T rhs)
+{
+  std::stringstream ss;
+  if (lhs == rhs) {
+    ss << lhs_str << " == " << rhs_str << " == " << lhs;
+    passed(ss.str().c_str());
+    return NS_OK;
+  }
+  ss << lhs_str << " != " << rhs_str << ": (" << lhs << ", " << rhs << ")";
+  fail(ss.str().c_str());
+  return NS_ERROR_FAILURE;
+}
+
+#define is(LHS, RHS) is_helper(#LHS, #RHS, LHS, RHS)
+
+nsresult ok_helper(const char* exp_str, bool val)
+{
+  if (val) {
+    passed(exp_str);
+    return NS_OK;
+  }
+  fail(exp_str);
+  return NS_ERROR_FAILURE;
+}
+
+#define ok(VAL) ok_helper(#VAL, VAL)
+
+#define RUN_TEST(TEST)                                                        \
+  PR_BEGIN_MACRO                                                              \
+    nsresult rv = TEST;                                                       \
+    NS_ENSURE_SUCCESS(rv, rv);                                                \
+  PR_END_MACRO
+
+#endif
diff --git a/xpcom/tests/functors/TooManyParamsError.cpp b/xpcom/tests/functors/TooManyParamsError.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/TooManyParamsError.cpp
@@ -0,0 +1,21 @@
+#include "Functor.h"
+
+int foo(int, int, int, int, int, int, int, int, int, int,
+        int, int, int, int, int, int, int, int, int, int,
+        int, int, int, int, int, int, int, int, int, int,
+        int, int, int, int, int, int, int, int, int, int,
+        int, int, int, int, int, int, int, int, int, int,
+        int, int, int, int, int, int, int, int, int, int,
+        int, int, int, int, int, int, int, int, int, int,
+        int, int, int, int, int, int, int, int, int, int,
+        int, int, int, int, int, int, int, int, int, int,
+        int, int, int, int, int, int, int, int, int, int)
+{
+  return 0;
+}
+
+int main()
+{
+  functor(foo);
+  return 0;
+}
diff --git a/xpcom/tests/functors/VoidReturn.cpp b/xpcom/tests/functors/VoidReturn.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/functors/VoidReturn.cpp
@@ -0,0 +1,6 @@
+void foo() { return foo(); }
+int main()
+{
+  foo();
+  return 0;
+}
