diff --git a/xpcom/glue/Bind.h b/xpcom/glue/Bind.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/Bind.h
@@ -0,0 +1,288 @@
+#ifndef __bind_h__
+#define __bind_h__
+
+#include "Functor.h"
+
+// [[[cog
+// from cogutil import tlist
+// MAX_FUNCTOR_ARITY = 15
+// ]]]
+// [[[end]]]
+
+template <class Incoming>
+class Binder
+  : public FunctorImpl<
+      typename Incoming::ResultType,
+      typename Incoming::ParamList::Tail>
+{
+public:
+  typedef typename Incoming::ResultType ResultType;
+  typedef typename Incoming::P1 BoundType;
+  typedef Functor<ResultType, typename Incoming::ParamList::Tail>
+          Outgoing;
+
+  Binder(const Incoming& fun, BoundType bound)
+    : mFun(fun)
+    , mBound(bound)
+  {}
+
+  Binder* Copy() const {
+    return new Binder(*this);
+  }
+
+  // [[[cog
+  // prefix = "ResultType operator()("
+  // indent = " " * len(prefix)
+  // for i in range(MAX_FUNCTOR_ARITY+1):
+  //   Pps = tlist("typename Outgoing::P p", i,
+  //               sep=",\n"+indent)
+  //   ps = tlist(", p", i, sep="")
+  //   cog.out(r"""
+  // %(prefix)s%(Pps)s) const
+  // {
+  //   return mFun(mBound%(ps)s);
+  // }""" % locals())
+  // ]]]
+
+  ResultType operator()() const
+  {
+    return mFun(mBound);
+  }
+  ResultType operator()(typename Outgoing::P1 p1) const
+  {
+    return mFun(mBound, p1);
+  }
+  ResultType operator()(typename Outgoing::P1 p1,
+                        typename Outgoing::P2 p2) const
+  {
+    return mFun(mBound, p1, p2);
+  }
+  ResultType operator()(typename Outgoing::P1 p1,
+                        typename Outgoing::P2 p2,
+                        typename Outgoing::P3 p3) const
+  {
+    return mFun(mBound, p1, p2, p3);
+  }
+  ResultType operator()(typename Outgoing::P1 p1,
+                        typename Outgoing::P2 p2,
+                        typename Outgoing::P3 p3,
+                        typename Outgoing::P4 p4) const
+  {
+    return mFun(mBound, p1, p2, p3, p4);
+  }
+  ResultType operator()(typename Outgoing::P1 p1,
+                        typename Outgoing::P2 p2,
+                        typename Outgoing::P3 p3,
+                        typename Outgoing::P4 p4,
+                        typename Outgoing::P5 p5) const
+  {
+    return mFun(mBound, p1, p2, p3, p4, p5);
+  }
+  ResultType operator()(typename Outgoing::P1 p1,
+                        typename Outgoing::P2 p2,
+                        typename Outgoing::P3 p3,
+                        typename Outgoing::P4 p4,
+                        typename Outgoing::P5 p5,
+                        typename Outgoing::P6 p6) const
+  {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6);
+  }
+  ResultType operator()(typename Outgoing::P1 p1,
+                        typename Outgoing::P2 p2,
+                        typename Outgoing::P3 p3,
+                        typename Outgoing::P4 p4,
+                        typename Outgoing::P5 p5,
+                        typename Outgoing::P6 p6,
+                        typename Outgoing::P7 p7) const
+  {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7);
+  }
+  ResultType operator()(typename Outgoing::P1 p1,
+                        typename Outgoing::P2 p2,
+                        typename Outgoing::P3 p3,
+                        typename Outgoing::P4 p4,
+                        typename Outgoing::P5 p5,
+                        typename Outgoing::P6 p6,
+                        typename Outgoing::P7 p7,
+                        typename Outgoing::P8 p8) const
+  {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8);
+  }
+  ResultType operator()(typename Outgoing::P1 p1,
+                        typename Outgoing::P2 p2,
+                        typename Outgoing::P3 p3,
+                        typename Outgoing::P4 p4,
+                        typename Outgoing::P5 p5,
+                        typename Outgoing::P6 p6,
+                        typename Outgoing::P7 p7,
+                        typename Outgoing::P8 p8,
+                        typename Outgoing::P9 p9) const
+  {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8, p9);
+  }
+  ResultType operator()(typename Outgoing::P1 p1,
+                        typename Outgoing::P2 p2,
+                        typename Outgoing::P3 p3,
+                        typename Outgoing::P4 p4,
+                        typename Outgoing::P5 p5,
+                        typename Outgoing::P6 p6,
+                        typename Outgoing::P7 p7,
+                        typename Outgoing::P8 p8,
+                        typename Outgoing::P9 p9,
+                        typename Outgoing::P10 p10) const
+  {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
+  }
+  ResultType operator()(typename Outgoing::P1 p1,
+                        typename Outgoing::P2 p2,
+                        typename Outgoing::P3 p3,
+                        typename Outgoing::P4 p4,
+                        typename Outgoing::P5 p5,
+                        typename Outgoing::P6 p6,
+                        typename Outgoing::P7 p7,
+                        typename Outgoing::P8 p8,
+                        typename Outgoing::P9 p9,
+                        typename Outgoing::P10 p10,
+                        typename Outgoing::P11 p11) const
+  {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);
+  }
+  ResultType operator()(typename Outgoing::P1 p1,
+                        typename Outgoing::P2 p2,
+                        typename Outgoing::P3 p3,
+                        typename Outgoing::P4 p4,
+                        typename Outgoing::P5 p5,
+                        typename Outgoing::P6 p6,
+                        typename Outgoing::P7 p7,
+                        typename Outgoing::P8 p8,
+                        typename Outgoing::P9 p9,
+                        typename Outgoing::P10 p10,
+                        typename Outgoing::P11 p11,
+                        typename Outgoing::P12 p12) const
+  {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
+  }
+  ResultType operator()(typename Outgoing::P1 p1,
+                        typename Outgoing::P2 p2,
+                        typename Outgoing::P3 p3,
+                        typename Outgoing::P4 p4,
+                        typename Outgoing::P5 p5,
+                        typename Outgoing::P6 p6,
+                        typename Outgoing::P7 p7,
+                        typename Outgoing::P8 p8,
+                        typename Outgoing::P9 p9,
+                        typename Outgoing::P10 p10,
+                        typename Outgoing::P11 p11,
+                        typename Outgoing::P12 p12,
+                        typename Outgoing::P13 p13) const
+  {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13);
+  }
+  ResultType operator()(typename Outgoing::P1 p1,
+                        typename Outgoing::P2 p2,
+                        typename Outgoing::P3 p3,
+                        typename Outgoing::P4 p4,
+                        typename Outgoing::P5 p5,
+                        typename Outgoing::P6 p6,
+                        typename Outgoing::P7 p7,
+                        typename Outgoing::P8 p8,
+                        typename Outgoing::P9 p9,
+                        typename Outgoing::P10 p10,
+                        typename Outgoing::P11 p11,
+                        typename Outgoing::P12 p12,
+                        typename Outgoing::P13 p13,
+                        typename Outgoing::P14 p14) const
+  {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
+  }
+  ResultType operator()(typename Outgoing::P1 p1,
+                        typename Outgoing::P2 p2,
+                        typename Outgoing::P3 p3,
+                        typename Outgoing::P4 p4,
+                        typename Outgoing::P5 p5,
+                        typename Outgoing::P6 p6,
+                        typename Outgoing::P7 p7,
+                        typename Outgoing::P8 p8,
+                        typename Outgoing::P9 p9,
+                        typename Outgoing::P10 p10,
+                        typename Outgoing::P11 p11,
+                        typename Outgoing::P12 p12,
+                        typename Outgoing::P13 p13,
+                        typename Outgoing::P14 p14,
+                        typename Outgoing::P15 p15) const
+  {
+    return mFun(mBound, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15);
+  }
+  // [[[end]]]
+
+private:
+  Incoming mFun;
+  BoundType mBound;
+};
+
+
+template <class Fun>
+typename Binder<Fun>::Outgoing
+bind(const Fun& fun, typename Fun::P1 bound) {
+  return typename Binder<Fun>::Outgoing(*new Binder<Fun>(fun, bound));
+}
+
+#define BIND1(F, A) bind(F, A)
+
+// [[[cog
+// slash = "\\"
+// for i in range(2, MAX_FUNCTOR_ARITY+1):
+//   prev = i - 1
+//   alist = tlist("A", i)
+//   ainit = tlist("A", i-1)
+//   alast = "A%d" % i;
+//   cog.out(r"""
+// #define BIND%(i)d(F, %(alist)s) %(slash)s
+//    bind(BIND%(prev)d(F, %(ainit)s), %(alast)s)
+// """ % locals())
+// ]]]
+
+#define BIND2(F, A1, A2) \
+   bind(BIND1(F, A1), A2)
+
+#define BIND3(F, A1, A2, A3) \
+   bind(BIND2(F, A1, A2), A3)
+
+#define BIND4(F, A1, A2, A3, A4) \
+   bind(BIND3(F, A1, A2, A3), A4)
+
+#define BIND5(F, A1, A2, A3, A4, A5) \
+   bind(BIND4(F, A1, A2, A3, A4), A5)
+
+#define BIND6(F, A1, A2, A3, A4, A5, A6) \
+   bind(BIND5(F, A1, A2, A3, A4, A5), A6)
+
+#define BIND7(F, A1, A2, A3, A4, A5, A6, A7) \
+   bind(BIND6(F, A1, A2, A3, A4, A5, A6), A7)
+
+#define BIND8(F, A1, A2, A3, A4, A5, A6, A7, A8) \
+   bind(BIND7(F, A1, A2, A3, A4, A5, A6, A7), A8)
+
+#define BIND9(F, A1, A2, A3, A4, A5, A6, A7, A8, A9) \
+   bind(BIND8(F, A1, A2, A3, A4, A5, A6, A7, A8), A9)
+
+#define BIND10(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) \
+   bind(BIND9(F, A1, A2, A3, A4, A5, A6, A7, A8, A9), A10)
+
+#define BIND11(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) \
+   bind(BIND10(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), A11)
+
+#define BIND12(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) \
+   bind(BIND11(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), A12)
+
+#define BIND13(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) \
+   bind(BIND12(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), A13)
+
+#define BIND14(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) \
+   bind(BIND13(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), A14)
+
+#define BIND15(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) \
+   bind(BIND14(F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), A15)
+// [[[end]]]
+
+#endif
\ No newline at end of file
diff --git a/xpcom/glue/Functor.h b/xpcom/glue/Functor.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/Functor.h
@@ -0,0 +1,269 @@
+#ifndef __functor_h__
+#define __functor_h__
+
+#include "nsISupports.h"
+#include "TList.h"
+#include "nsAutoPtr.h"
+
+
+class FunctorSupports : public nsISupports {
+public:
+  virtual ~FunctorSupports() {}
+  NS_IMPL_ISUPPORTS0(FunctorSupports)
+protected:
+  nsAutoRefCnt mRefCnt;
+  NS_DECL_OWNINGTHREAD
+};
+
+
+// [[[cog
+// from cogutil import tlist
+// MAX_FUNCTOR_ARITY = 15
+// ]]]
+// [[[end]]]
+
+template <typename R, class Params>
+class FunctorImpl;
+
+#define DECL_FUNCTORIMPL_CLASS(R, N, TS)                                       \
+  class FunctorImpl<R, TLIST##N TS> : public FunctorSupports {                 \
+  public:                                                                      \
+    virtual R operator()TS const = 0;                                          \
+  }
+
+// [[[cog
+// for i in range(MAX_FUNCTOR_ARITY+1):
+//   typenames = tlist(", typename T", i, sep="")
+//   Ts = tlist("T", i)
+//   cog.out("""
+// template <typename R%(typenames)s>
+// DECL_FUNCTORIMPL_CLASS(R, %(i)d, (%(Ts)s));
+// """ % locals())
+// ]]]
+
+template <typename R>
+DECL_FUNCTORIMPL_CLASS(R, 0, ());
+
+template <typename R, typename T1>
+DECL_FUNCTORIMPL_CLASS(R, 1, (T1));
+
+template <typename R, typename T1, typename T2>
+DECL_FUNCTORIMPL_CLASS(R, 2, (T1, T2));
+
+template <typename R, typename T1, typename T2, typename T3>
+DECL_FUNCTORIMPL_CLASS(R, 3, (T1, T2, T3));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4>
+DECL_FUNCTORIMPL_CLASS(R, 4, (T1, T2, T3, T4));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
+DECL_FUNCTORIMPL_CLASS(R, 5, (T1, T2, T3, T4, T5));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
+DECL_FUNCTORIMPL_CLASS(R, 6, (T1, T2, T3, T4, T5, T6));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
+DECL_FUNCTORIMPL_CLASS(R, 7, (T1, T2, T3, T4, T5, T6, T7));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
+DECL_FUNCTORIMPL_CLASS(R, 8, (T1, T2, T3, T4, T5, T6, T7, T8));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
+DECL_FUNCTORIMPL_CLASS(R, 9, (T1, T2, T3, T4, T5, T6, T7, T8, T9));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
+DECL_FUNCTORIMPL_CLASS(R, 10, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11>
+DECL_FUNCTORIMPL_CLASS(R, 11, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12>
+DECL_FUNCTORIMPL_CLASS(R, 12, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13>
+DECL_FUNCTORIMPL_CLASS(R, 13, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14>
+DECL_FUNCTORIMPL_CLASS(R, 14, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14));
+
+template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15>
+DECL_FUNCTORIMPL_CLASS(R, 15, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15));
+// [[[end]]]
+
+#undef DECL_FUNCTORIMPL_CLASS
+
+
+// [[[cog
+// slash = "\\"
+// cog.out(r"#define GEN_CALL_OPERATORS(R, FEXP, QUAL)")
+// for i in range(MAX_FUNCTOR_ARITY+1):
+//   Pps, ps = tlist(r"QUAL##0 p", i), tlist("p", i)
+//   cog.out(""" %(slash)s
+//   R operator()(%(Pps)s) const { %(slash)s
+//     return (FEXP)(%(ps)s); %(slash)s
+//   }""" % locals())
+// ]]]
+#define GEN_CALL_OPERATORS(R, FEXP, QUAL) \
+  R operator()() const { \
+    return (FEXP)(); \
+  } \
+  R operator()(QUAL##1 p1) const { \
+    return (FEXP)(p1); \
+  } \
+  R operator()(QUAL##1 p1, QUAL##2 p2) const { \
+    return (FEXP)(p1, p2); \
+  } \
+  R operator()(QUAL##1 p1, QUAL##2 p2, QUAL##3 p3) const { \
+    return (FEXP)(p1, p2, p3); \
+  } \
+  R operator()(QUAL##1 p1, QUAL##2 p2, QUAL##3 p3, QUAL##4 p4) const { \
+    return (FEXP)(p1, p2, p3, p4); \
+  } \
+  R operator()(QUAL##1 p1, QUAL##2 p2, QUAL##3 p3, QUAL##4 p4, QUAL##5 p5) const { \
+    return (FEXP)(p1, p2, p3, p4, p5); \
+  } \
+  R operator()(QUAL##1 p1, QUAL##2 p2, QUAL##3 p3, QUAL##4 p4, QUAL##5 p5, QUAL##6 p6) const { \
+    return (FEXP)(p1, p2, p3, p4, p5, p6); \
+  } \
+  R operator()(QUAL##1 p1, QUAL##2 p2, QUAL##3 p3, QUAL##4 p4, QUAL##5 p5, QUAL##6 p6, QUAL##7 p7) const { \
+    return (FEXP)(p1, p2, p3, p4, p5, p6, p7); \
+  } \
+  R operator()(QUAL##1 p1, QUAL##2 p2, QUAL##3 p3, QUAL##4 p4, QUAL##5 p5, QUAL##6 p6, QUAL##7 p7, QUAL##8 p8) const { \
+    return (FEXP)(p1, p2, p3, p4, p5, p6, p7, p8); \
+  } \
+  R operator()(QUAL##1 p1, QUAL##2 p2, QUAL##3 p3, QUAL##4 p4, QUAL##5 p5, QUAL##6 p6, QUAL##7 p7, QUAL##8 p8, QUAL##9 p9) const { \
+    return (FEXP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); \
+  } \
+  R operator()(QUAL##1 p1, QUAL##2 p2, QUAL##3 p3, QUAL##4 p4, QUAL##5 p5, QUAL##6 p6, QUAL##7 p7, QUAL##8 p8, QUAL##9 p9, QUAL##10 p10) const { \
+    return (FEXP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); \
+  } \
+  R operator()(QUAL##1 p1, QUAL##2 p2, QUAL##3 p3, QUAL##4 p4, QUAL##5 p5, QUAL##6 p6, QUAL##7 p7, QUAL##8 p8, QUAL##9 p9, QUAL##10 p10, QUAL##11 p11) const { \
+    return (FEXP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); \
+  } \
+  R operator()(QUAL##1 p1, QUAL##2 p2, QUAL##3 p3, QUAL##4 p4, QUAL##5 p5, QUAL##6 p6, QUAL##7 p7, QUAL##8 p8, QUAL##9 p9, QUAL##10 p10, QUAL##11 p11, QUAL##12 p12) const { \
+    return (FEXP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); \
+  } \
+  R operator()(QUAL##1 p1, QUAL##2 p2, QUAL##3 p3, QUAL##4 p4, QUAL##5 p5, QUAL##6 p6, QUAL##7 p7, QUAL##8 p8, QUAL##9 p9, QUAL##10 p10, QUAL##11 p11, QUAL##12 p12, QUAL##13 p13) const { \
+    return (FEXP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); \
+  } \
+  R operator()(QUAL##1 p1, QUAL##2 p2, QUAL##3 p3, QUAL##4 p4, QUAL##5 p5, QUAL##6 p6, QUAL##7 p7, QUAL##8 p8, QUAL##9 p9, QUAL##10 p10, QUAL##11 p11, QUAL##12 p12, QUAL##13 p13, QUAL##14 p14) const { \
+    return (FEXP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); \
+  } \
+  R operator()(QUAL##1 p1, QUAL##2 p2, QUAL##3 p3, QUAL##4 p4, QUAL##5 p5, QUAL##6 p6, QUAL##7 p7, QUAL##8 p8, QUAL##9 p9, QUAL##10 p10, QUAL##11 p11, QUAL##12 p12, QUAL##13 p13, QUAL##14 p14, QUAL##15 p15) const { \
+    return (FEXP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); \
+  }
+// [[[end]]]
+
+
+template <typename R, class Params>
+class Functor
+{
+public:
+  typedef FunctorImpl<R, Params> ImplType;
+  typedef R ResultType;
+  typedef Params ParamList;
+  // [[[cog
+  // for i in range(MAX_FUNCTOR_ARITY):
+  //   cog.out(r"""
+  // typedef typename tlist::TypeAtNS<Params, %(i)d>::type P%(i+1)d;""" % {
+  //     "i": i, "i+1": i+1
+  //   })
+  // ]]]
+
+  typedef typename tlist::TypeAtNS<Params, 0>::type P1;
+  typedef typename tlist::TypeAtNS<Params, 1>::type P2;
+  typedef typename tlist::TypeAtNS<Params, 2>::type P3;
+  typedef typename tlist::TypeAtNS<Params, 3>::type P4;
+  typedef typename tlist::TypeAtNS<Params, 4>::type P5;
+  typedef typename tlist::TypeAtNS<Params, 5>::type P6;
+  typedef typename tlist::TypeAtNS<Params, 6>::type P7;
+  typedef typename tlist::TypeAtNS<Params, 7>::type P8;
+  typedef typename tlist::TypeAtNS<Params, 8>::type P9;
+  typedef typename tlist::TypeAtNS<Params, 9>::type P10;
+  typedef typename tlist::TypeAtNS<Params, 10>::type P11;
+  typedef typename tlist::TypeAtNS<Params, 11>::type P12;
+  typedef typename tlist::TypeAtNS<Params, 12>::type P13;
+  typedef typename tlist::TypeAtNS<Params, 13>::type P14;
+  typedef typename tlist::TypeAtNS<Params, 14>::type P15;
+  // [[[end]]]
+
+  // for compatibility with std::bind{1st,2nd}
+  typedef P1  first_argument_type;
+  typedef P2 second_argument_type;
+  typedef R           result_type;
+
+public:
+  Functor(const Functor& fun) : mImpl(fun.mImpl) {}
+
+  template <class Fun>
+  Functor(const Fun&);
+
+  template <typename Class,
+            typename MethodPtr>
+  Functor(Class* objPtr,
+          MethodPtr methodPtr);
+
+  GEN_CALL_OPERATORS(R, *mImpl, P)
+
+private:
+  nsRefPtr<ImplType> mImpl;
+};
+
+
+template <class ParentFunctor, typename Fun>
+class FunctorHandler
+  : public FunctorImpl<
+      typename ParentFunctor::ResultType,
+      typename ParentFunctor::ParamList>
+{
+public:
+  typedef typename ParentFunctor::ResultType ResultType;
+  FunctorHandler(const Fun& fun) : mFun(*(Fun*)&fun) {}
+
+  GEN_CALL_OPERATORS(ResultType, mFun, typename ParentFunctor::P)
+
+private:
+  Fun& mFun;
+};
+
+template <class ParentFunctor,
+          typename Class, typename MethodPtr>
+class MethodHandler
+  : public FunctorImpl<
+      typename ParentFunctor::ResultType,
+      typename ParentFunctor::ParamList>
+{
+public:
+  typedef typename ParentFunctor::ResultType ResultType;
+
+  MethodHandler(Class* objPtr, MethodPtr methodPtr)
+    : mObjPtr(objPtr)
+    , mMethodPtr(methodPtr)
+  {}
+
+  GEN_CALL_OPERATORS(ResultType,
+    (*mObjPtr).*mMethodPtr,
+    typename ParentFunctor::P)
+
+private:
+  nsRefPtr<Class> mObjPtr;
+  MethodPtr mMethodPtr;
+};
+
+#undef GEN_CALL_OPERATORS
+
+template <typename R, class Params>
+template <class Fun>
+Functor<R, Params>::Functor(const Fun& fun)
+  : mImpl(new FunctorHandler<Functor, Fun>(fun))
+{}
+
+template <typename R, class Params>
+template <typename Class, typename MethodPtr>
+Functor<R, Params>::Functor(Class* objPtr,
+                            MethodPtr methodPtr)
+  : mImpl(new MethodHandler<Functor, Class, MethodPtr>(objPtr, methodPtr))
+{}
+
+
+#endif
diff --git a/xpcom/glue/FunctorSupports.cpp b/xpcom/glue/FunctorSupports.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/FunctorSupports.cpp
@@ -0,0 +1,4 @@
+#include "FunctorSupports.h"
+
+NS_IMPL_ISUPPORTS0(FunctorSupports)
+
diff --git a/xpcom/glue/FunctorSupports.h b/xpcom/glue/FunctorSupports.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/FunctorSupports.h
@@ -0,0 +1,8 @@
+#ifndef __functor_supports_h__
+#define __functor_supports_h__
+
+#include "nsISupports.h"
+
+
+
+#endif
diff --git a/xpcom/glue/Makefile.in b/xpcom/glue/Makefile.in
--- a/xpcom/glue/Makefile.in
+++ b/xpcom/glue/Makefile.in
@@ -119,16 +119,18 @@ SDK_HEADERS = \
 		nsCycleCollectionParticipant.h \
 		nsDeque.h \
 		$(NULL)
 
 EXPORTS = \
 		nsThreadUtils.h \
 		nsProxyRelease.h \
 		nsXPTCUtils.h \
+		Functor.h \
+		TList.h \
 		$(NULL)
 
 SDK_LIBRARY     =                        \
 		$(LIB_PREFIX)xpcomglue_s.$(LIB_SUFFIX) \
 		$(NULL)
 
 # we don't want the shared lib, but we want to force the creation of a static lib.
 FORCE_STATIC_LIB = 1
@@ -145,11 +147,13 @@ include $(topsrcdir)/config/rules.mk
 
 ifdef _MSC_VER
 # Don't include directives about which CRT to use
 OS_COMPILE_CXXFLAGS += -Zl
 OS_COMPILE_CFLAGS += -Zl
 DEFINES += -D_USE_ANSI_CPP
 endif
 
+DEFINES += --save-temps
+
 ifdef TARGET_XPCOM_ABI
 DEFINES += -DTARGET_XPCOM_ABI=\"$(TARGET_XPCOM_ABI)\"
 endif
diff --git a/xpcom/glue/TList.h b/xpcom/glue/TList.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/TList.h
@@ -0,0 +1,131 @@
+#ifndef __tlist_h__
+#define __tlist_h__
+
+// [[[cog from cogutil import tlist ]]]
+// [[[end]]]
+
+class NullType {};
+struct EmptyType {};
+
+template <typename T, typename U>
+struct TList {
+  typedef T Head;
+  typedef U Tail;
+};
+
+#define TLIST0() NullType
+
+// [[[cog
+// MAX_TUPLE_ARITY = 15
+//
+// for i in range(1, MAX_TUPLE_ARITY+1):
+//   cog.out(r"""
+// #define TLIST%(arity)d(%(tlist)s) %(slash)s
+//   TList<T1, TLIST%(arity-1)d(%(trest)s)>
+// """ % {
+//   "arity": i, "arity-1": i-1,
+//   "tlist": tlist("T", i),
+//   "trest": tlist("T", rfirst=2, rlast=i),
+//   "slash": "\\",
+// })
+// ]]]
+
+#define TLIST1(T1) \
+  TList<T1, TLIST0()>
+
+#define TLIST2(T1, T2) \
+  TList<T1, TLIST1(T2)>
+
+#define TLIST3(T1, T2, T3) \
+  TList<T1, TLIST2(T2, T3)>
+
+#define TLIST4(T1, T2, T3, T4) \
+  TList<T1, TLIST3(T2, T3, T4)>
+
+#define TLIST5(T1, T2, T3, T4, T5) \
+  TList<T1, TLIST4(T2, T3, T4, T5)>
+
+#define TLIST6(T1, T2, T3, T4, T5, T6) \
+  TList<T1, TLIST5(T2, T3, T4, T5, T6)>
+
+#define TLIST7(T1, T2, T3, T4, T5, T6, T7) \
+  TList<T1, TLIST6(T2, T3, T4, T5, T6, T7)>
+
+#define TLIST8(T1, T2, T3, T4, T5, T6, T7, T8) \
+  TList<T1, TLIST7(T2, T3, T4, T5, T6, T7, T8)>
+
+#define TLIST9(T1, T2, T3, T4, T5, T6, T7, T8, T9) \
+  TList<T1, TLIST8(T2, T3, T4, T5, T6, T7, T8, T9)>
+
+#define TLIST10(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) \
+  TList<T1, TLIST9(T2, T3, T4, T5, T6, T7, T8, T9, T10)>
+
+#define TLIST11(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) \
+  TList<T1, TLIST10(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
+
+#define TLIST12(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) \
+  TList<T1, TLIST11(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
+
+#define TLIST13(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) \
+  TList<T1, TLIST12(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
+
+#define TLIST14(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) \
+  TList<T1, TLIST13(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)>
+
+#define TLIST15(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) \
+  TList<T1, TLIST14(T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)>
+// [[[end]]]
+
+namespace tlist {
+
+  template <typename List>
+  struct Length { enum { value = 0 }; };
+
+  template <typename T, typename U>
+  struct Length<TList<T, U> > {
+    enum { value = 1 + Length<U>::value };
+  };
+
+
+  template <typename List, unsigned N> struct TypeAt_;
+  template <typename T, typename U>
+  struct TypeAt_<TList<T, U>, 0> { typedef T type; };
+  template <typename T, typename U, unsigned N>
+  struct TypeAt_<TList<T, U>, N> {
+    typedef typename TypeAt_<U, N-1>::type type;
+  };
+
+  // allows negative indices
+  template <typename List, int N>
+  struct TypeAt {
+    typedef typename TypeAt_<
+        List,
+        N < 0 ? Length<List>::value + N : N
+      >::type type;
+  };
+
+
+  template <typename List, unsigned N, typename D> struct TypeAtNS_;
+  template <unsigned N, typename D>
+  struct TypeAtNS_<NullType, N, D> { typedef D type; };
+  template <typename T, typename U, unsigned N, typename D>
+  struct TypeAtNS_<TList<T, U>, N, D> {
+    typedef typename TypeAtNS_<U, N-1, D>::type type;
+  };
+  template <typename T, typename U, typename D>
+  struct TypeAtNS_<TList<T, U>, 0, D> { typedef T type; };
+
+  // allows negative indices
+  template <typename List, int N, typename Default=EmptyType>
+  struct TypeAtNS {
+    typedef typename TypeAtNS_<
+        List,
+        N < 0 ? Length<List>::value + N : N,
+        Default
+      >::type type;
+  };
+
+
+};
+
+#endif
diff --git a/xpcom/glue/cogutil.py b/xpcom/glue/cogutil.py
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/cogutil.py
@@ -0,0 +1,12 @@
+#!/usr/bin/env python
+
+import cog
+import re
+
+tpat = re.compile(r"\b[a-z]\b", re.I)
+npat = re.compile(r"\b0\b")
+def tlist(tmpl, rlast, rfirst=1, sep=", "):
+  return sep.join(tpat.sub("\g<0>%u" % i,
+                           npat.sub("%u" % i, tmpl))
+                  for i in range(rfirst, rlast+1))
+
diff --git a/xpcom/glue/nsThreadUtils.h b/xpcom/glue/nsThreadUtils.h
--- a/xpcom/glue/nsThreadUtils.h
+++ b/xpcom/glue/nsThreadUtils.h
@@ -41,16 +41,17 @@
 
 #include "prthread.h"
 #include "prinrval.h"
 #include "nsIThreadManager.h"
 #include "nsIThread.h"
 #include "nsIRunnable.h"
 #include "nsStringGlue.h"
 #include "nsCOMPtr.h"
+#include "Functor.h"
 
 // This is needed on some systems to prevent collisions between the symbols
 // appearing in xpcom_core and xpcomglue.  It may be unnecessary in the future
 // with better toolchain support.
 #ifdef MOZILLA_INTERNAL_API
 # define NS_NewThread NS_NewThread_P
 # define NS_GetCurrentThread NS_GetCurrentThread_P
 # define NS_GetMainThread NS_GetMainThread_P
@@ -249,38 +250,34 @@ protected:
 // with nsRevocableEventPtr.
 template <class T>
 class nsRunnableMethod : public nsRunnable
 {
 public:
   typedef void (T::*Method)();
 
   nsRunnableMethod(T *obj, Method method)
-    : mObj(obj), mMethod(method) {
-    NS_ADDREF(mObj);
+    : mRevoked(PR_FALSE)
+    , mFun(obj, method)
+  {}
+
+  NS_IMETHOD Run() {
+    if (!mRevoked)
+      mFun();
+    return NS_OK;
   }
 
-  NS_IMETHOD Run() {
-    if (!mObj)
-      return NS_OK;
-    (mObj->*mMethod)();
-    return NS_OK;
-  }
-  
   void Revoke() {
-    NS_IF_RELEASE(mObj);
+    mRevoked = PR_TRUE;
   }
 
 private:
-  virtual ~nsRunnableMethod() {
-    NS_IF_RELEASE(mObj);
-  }
-
-  T      *mObj;
-  Method  mMethod;
+  virtual ~nsRunnableMethod() {}
+  PRBool mRevoked;
+  Functor<void, TLIST0()> mFun;
 };
 
 // Use this helper macro like so:
 //
 //   nsCOMPtr<nsIRunnable> event =
 //       NS_NEW_RUNNABLE_METHOD(MyClass, myObject, HandleEvent);
 //   NS_DispatchToCurrentThread(event);
 //
diff --git a/xpcom/glue/test.cpp b/xpcom/glue/test.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/test.cpp
@@ -0,0 +1,73 @@
+#include <iostream>
+#include "Functor.h"
+#include "Bind.h"
+
+int Succ(int n) {
+  return n + 1;
+}
+
+struct Pred
+{
+  int operator()(int n) {
+    return n + 1;
+  }
+};
+
+struct DiffStruct
+{
+  int Sub(int a, int b) {
+    return a - b;
+  }
+  static int Add3(int a, int b, int c) {
+    return a + b + c;
+  }
+};
+
+void is(int x, int y) {
+  std::cout << (x == y ? "OK: " : "FAIL: ")
+            << x << " = " << y << std::endl;
+}
+
+void example()
+{
+  Functor<int, TLIST1(int)> s(Succ);
+  Pred pred;
+  Functor<int, TLIST1(int)> p(pred);
+  Functor<int, TLIST2(int, int)> ds(
+    new DiffStruct, &DiffStruct::Sub);
+  Functor<int, TLIST3(int, int, int)> a3(DiffStruct::Add3);
+
+  int a = 1, b = 5;
+
+  is(s(a), a + 1);
+  is(p(b), b - 1);
+  is(ds(s(a), p(b)), a - b + 2);
+  is(std::bind1st(ds, 6)(4), 2);
+  is(std::bind2nd(ds, 6)(4), -2);
+  is(a3(1, 2, 3), 6);
+}
+
+void test_bind()
+{
+  Functor<int, TLIST3(int, int, int)> a3(DiffStruct::Add3);
+  is(BIND1(a3, 1)(2, 3), 6);
+  is(BIND2(a3, 1, 2)(3), 6);
+  is(BIND3(a3, 1, 2, 3)(), 6);
+  is(BIND2(BIND1(a3, 1), 2, 3)(), 6);
+
+  double x = 5, y = 3;
+  DiffStruct ds;
+  Functor<int, TLIST2(int, int)> sub(
+    &ds, &DiffStruct::Sub);
+  Functor<int, TLIST1(int)> f = BIND1(sub, x);
+  is(sub(x, y), x - y);
+  is(sub(y, x), y - x);
+  is(f(x), 0);
+  is(f(y), x - y);
+}
+
+int main() {
+  example();
+  test_bind();
+  return 0;
+}
