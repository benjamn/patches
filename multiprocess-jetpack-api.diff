Bug 556846 - Investigate multi-process Jetpack.
* * *
Port mozilla::jsipc::Handle from projects/electrolysis to mozilla-central.
* * *
Support passing objects with circular references through Jetpack messages (bug 556846).

diff --git a/ipc/ipdl/Makefile.in b/ipc/ipdl/Makefile.in
--- a/ipc/ipdl/Makefile.in
+++ b/ipc/ipdl/Makefile.in
@@ -51,16 +51,17 @@ LIBXUL_LIBRARY = 1
 EXPORT_LIBRARY = 1
 
 ##-----------------------------------------------------------------------------
 ## When you add IPDL files to a source directory, list the directory here.
 ##
 IPDLDIRS =  \
   dom/plugins  \
   js/jetpack \
+  js/ipc \
   ipc/ipdl/test/cxx  \
   $(NULL)
 ##-----------------------------------------------------------------------------
 
 ifdef MOZ_IPDL_TESTS
 DIRS += test
 endif
 
diff --git a/js/ipc/Handle.h b/js/ipc/Handle.h
new file mode 100644
--- /dev/null
+++ b/js/ipc/Handle.h
@@ -0,0 +1,300 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sw=4 et tw=80:
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef mozilla_jsipc_HandleParent_h__
+#define mozilla_jsipc_HandleParent_h__
+
+#include "mozilla/jsipc/PHandleParent.h"
+#include "mozilla/jsipc/PHandleChild.h"
+
+#include "jsapi.h"
+#include "jsobj.h"
+#include "jscntxt.h"
+
+namespace mozilla {
+namespace jsipc {
+
+template <class BaseType>
+class Handle
+    : public BaseType
+{
+    Handle(Handle* parent)
+        : mParent(parent)
+        , mObj(NULL)
+        , mRuntime(NULL)
+    {}
+
+    BaseType* AllocPHandle() {
+        return new Handle(this);
+    }
+
+    bool DeallocPHandle(BaseType* actor) {
+        delete actor;
+        return true;
+    }
+
+public:
+
+    Handle()
+        : mParent(NULL)
+        , mObj(NULL)
+        , mRuntime(NULL)
+    {}
+
+    ~Handle() { TearDown(); }
+
+    static Handle* FromJSObject(JSContext* cx, JSObject* obj) {
+        // TODO Convert non-Handles to Handles somehow?
+        return Unwrap(cx, obj);
+    }
+
+    static Handle* FromJSVal(JSContext* cx, jsval val) {
+        if (!JSVAL_IS_OBJECT(val))
+            return NULL;
+        return Unwrap(cx, JSVAL_TO_OBJECT(val));
+    }
+
+    JSObject* ToJSObject(JSContext* cx) const {
+        if (!mObj && !mRuntime) {
+            JSAutoRequest request(cx);
+
+            JSClass* clasp = const_cast<JSClass*>(&sHandle_JSClass);
+            JSObject* obj = JS_NewObject(cx, clasp, NULL, NULL);
+            if (!obj)
+                return NULL;
+            js::AutoObjectRooter root(cx, obj);
+
+            JSPropertySpec* ps = const_cast<JSPropertySpec*>(sHandle_Properties);
+            JSFunctionSpec* fs = const_cast<JSFunctionSpec*>(sHandle_Functions);
+            JSRuntime* rt;
+
+            const char* name = IsParent(this)
+                ? "mozilla::jsipc::Handle<PHandleParent>::mObj"
+                : "mozilla::jsipc::Handle<PHandleChild>::mObj";
+
+            if (JS_SetPrivate(cx, obj, (void*)this) &&
+                JS_DefineProperties(cx, obj, ps) &&
+                JS_DefineFunctions(cx, obj, fs) &&
+                JS_AddNamedRootRT(rt = JS_GetRuntime(cx), (void*)&mObj, name))
+            {
+                mObj = obj;
+                mRuntime = rt;
+            }
+        }
+        return mObj;
+    }
+
+protected:
+
+    // XXX Why not simply ActorDestroyReason?
+    void ActorDestroy(typename Handle::ActorDestroyReason why) {
+        TearDown();
+    }
+
+private:
+
+    static bool IsParent(const PHandleParent* handle) { return true; }
+    static bool IsParent(const PHandleChild* handle) { return false; }
+
+    void TearDown() {
+        if (mObj) {
+            mObj->setPrivate(NULL);
+            mObj = NULL;
+            // Nulling out mObj effectively unroots the object, but we still
+            // need to remove the root for good hygiene's sake.
+            NS_ASSERTION(mRuntime, "Should have a JSRuntime if we had an object");
+            JS_RemoveRootRT(mRuntime, (void*)&mObj);
+            // By not nulling out mRuntime, we prevent ToJSObject from
+            // reviving an invalidated/destroyed handle.
+        }
+    }
+
+    static const JSClass        sHandle_JSClass;
+    static const JSPropertySpec sHandle_Properties[];
+    static const JSFunctionSpec sHandle_Functions[];
+
+    Handle* const mParent;
+
+    // Used to cache the JSObject returned by ToJSObject, which is
+    // otherwise a const method.
+    mutable JSObject*  mObj;
+    mutable JSRuntime* mRuntime;
+
+    static Handle*
+    Unwrap(JSContext* cx, JSObject* obj) {
+        if (!obj)
+            return NULL;
+
+        while (obj->getClass() != &sHandle_JSClass)
+            if (!(obj = obj->getProto()))
+                return NULL;
+
+        Handle* self = static_cast<Handle*>(JS_GetPrivate(cx, obj));
+
+        NS_ASSERTION(!self || self->ToJSObject(cx) == obj,
+                     "Wrapper and wrapped object disagree?");
+
+        return self;
+    }
+
+    static JSBool
+    GetParent(JSContext* cx, JSObject* obj, jsval, jsval* vp) {
+        JS_SET_RVAL(cx, vp, JSVAL_NULL);
+
+        Handle* self = Unwrap(cx, obj);
+        if (!self)
+            return JS_TRUE;
+
+        Handle* parent = self->mParent;
+        if (!parent)
+            return JS_TRUE;
+
+        JSObject* pobj = parent->ToJSObject(cx);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(pobj));
+
+        return JS_TRUE;
+    }
+
+    static JSBool
+    GetIsValid(JSContext* cx, JSObject* obj, jsval, jsval* vp) {
+        Handle* self = Unwrap(cx, obj);
+        JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(!!self));
+        return JS_TRUE;
+    }
+
+    static JSBool
+    Invalidate(JSContext* cx, uintN argc, jsval* vp) {
+        if (argc > 0) {
+            JS_ReportError(cx, "invalidate takes zero arguments");
+            return JS_FALSE;
+        }
+
+        Handle* self = Unwrap(cx, JS_THIS_OBJECT(cx, vp));
+        if (self) {
+            JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_TRUE));
+            if (!Send__delete__(self)) {
+                JS_ReportError(cx, "Failed to send __delete__ while invalidating");
+                return JS_FALSE;
+            }
+        } else {
+            JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_FALSE));
+        }
+
+        return JS_TRUE;
+    }
+
+    static JSBool
+    CreateHandle(JSContext* cx, uintN argc, jsval* vp) {
+        if (argc > 0) {
+            JS_ReportError(cx, "createHandle takes zero arguments");
+            return JS_FALSE;
+        }
+
+        Handle* self = Unwrap(cx, JS_THIS_OBJECT(cx, vp));
+        if (!self) {
+            JS_ReportError(cx, "Tried to create child from invalid handle");
+            return JS_FALSE;
+        }
+
+        BaseType* child = self->SendPHandleConstructor();
+        if (!child) {
+            JS_ReportError(cx, "Failed to construct child");
+            return JS_FALSE;
+        }
+
+        JSObject* obj = static_cast<Handle*>(child)->ToJSObject(cx);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+
+        return JS_TRUE;
+    }
+
+    static void
+    Finalize(JSContext* cx, JSObject* obj) {
+        Handle* self = Unwrap(cx, obj);
+        self && Send__delete__(self);
+    }
+
+};
+
+template <class BaseType>
+const JSClass
+Handle<BaseType>::sHandle_JSClass = {
+    "IPDL Handle", JSCLASS_HAS_PRIVATE,
+    JS_PropertyStub, JS_PropertyStub,
+    JS_PropertyStub, JS_PropertyStub,
+    JS_EnumerateStub, JS_ResolveStub,
+    JS_ConvertStub, Handle::Finalize,
+    JSCLASS_NO_OPTIONAL_MEMBERS
+};
+
+#define HANDLE_PROP_FLAGS (JSPROP_READONLY | JSPROP_PERMANENT)
+
+template <class BaseType>
+const JSPropertySpec
+Handle<BaseType>::sHandle_Properties[] = {
+    { "parent",  0, HANDLE_PROP_FLAGS, GetParent,  NULL },
+    { "isValid", 0, HANDLE_PROP_FLAGS, GetIsValid, NULL },
+    { 0, 0, 0, NULL, NULL }
+};
+
+#undef HANDLE_PROP_FLAGS
+
+#define HANDLE_FUN_FLAGS (JSFUN_FAST_NATIVE |   \
+                          JSPROP_READONLY |     \
+                          JSPROP_PERMANENT)
+
+template <class BaseType>
+const JSFunctionSpec
+Handle<BaseType>::sHandle_Functions[] = {
+    JS_FN("invalidate",   Invalidate,   0, HANDLE_FUN_FLAGS),
+    JS_FN("createHandle", CreateHandle, 0, HANDLE_FUN_FLAGS),
+    JS_FS_END
+};
+
+#undef HANDLE_FUN_FLAGS
+
+// The payoff for using templates is that these two implementations are
+// guaranteed to be perfectly symmetric:
+typedef Handle<PHandleParent> HandleParent;
+typedef Handle<PHandleChild> HandleChild;
+
+}}
+
+#endif
diff --git a/js/ipc/Makefile.in b/js/ipc/Makefile.in
new file mode 100644
--- /dev/null
+++ b/js/ipc/Makefile.in
@@ -0,0 +1,64 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# The Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2010
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Newman <b{enjam,newma}n@mozilla.com> (original author)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH     = ../..
+topsrcdir = @top_srcdir@
+srcdir    = @srcdir@
+VPATH     = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE = js
+LIBRARY_NAME = jsipc_s
+LIBXUL_LIBRARY = 1
+FORCE_STATIC_LIB = 1
+EXPORT_LIBRARY = 1
+
+EXPORTS_NAMESPACES = mozilla/jsipc
+
+EXPORTS_mozilla/jsipc = \
+  Handle.h \
+  $(NULL)
+
+CPPSRCS = \
+  $(NULL)
+
+include $(topsrcdir)/config/config.mk
+include $(topsrcdir)/ipc/chromium/chromium-config.mk
+include $(topsrcdir)/config/rules.mk
+
+DEFINES += -DBIN_SUFFIX='"$(BIN_SUFFIX)"'
diff --git a/js/ipc/PHandle.ipdl b/js/ipc/PHandle.ipdl
new file mode 100644
--- /dev/null
+++ b/js/ipc/PHandle.ipdl
@@ -0,0 +1,55 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sw=4 et tw=80:
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+include protocol PJetpack;
+
+namespace mozilla {
+namespace jsipc {
+
+async protocol PHandle
+{
+    manager PJetpack or PHandle;
+    manages PHandle;
+both:
+    PHandle();
+    __delete__();
+};
+
+}}
diff --git a/js/ipc/ipdl.mk b/js/ipc/ipdl.mk
new file mode 100644
--- /dev/null
+++ b/js/ipc/ipdl.mk
@@ -0,0 +1,40 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# The Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2010
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Newman <b{enjam,newma}n@mozilla.com> (original author)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+IPDLSRCS = \
+  PHandle.ipdl \
+  $(NULL)
diff --git a/js/ipc/tests/unit/handle_child.js b/js/ipc/tests/unit/handle_child.js
new file mode 100644
--- /dev/null
+++ b/js/ipc/tests/unit/handle_child.js
@@ -0,0 +1,6 @@
+load("handle_common.js");
+
+function run_test() {
+  run_common_tests();
+}
+
diff --git a/js/ipc/tests/unit/handle_common.js b/js/ipc/tests/unit/handle_common.js
new file mode 100644
--- /dev/null
+++ b/js/ipc/tests/unit/handle_common.js
@@ -0,0 +1,105 @@
+function createHandle() {
+  return getRootHandle().createHandle();
+}
+
+function run_common_tests() {
+  test_sanity();
+  test_safe_iteration();
+  test_local_invalidation();
+  test_long_parent_chain(100);
+  test_invalid_creation();
+}
+
+function test_sanity() {
+  var root = getRootHandle(),
+      parent = createHandle(),
+      child = parent.createHandle(),
+      grandchild = child.createHandle();
+
+  do_check_neq(child, parent);
+  do_check_eq(child.parent, parent);
+  do_check_eq(parent.parent, root);
+  do_check_eq(root.parent, null);
+  do_check_eq(grandchild.parent.parent, parent);
+
+  do_check_true(child.isValid);
+  do_check_true(parent.isValid);
+
+  parent.invalidate();
+}
+
+function test_safe_iteration() {
+  var handle = createHandle(),
+      keys = [];
+  handle.foo = 42;
+  handle.self = handle;
+  for (var k in handle)
+    keys[keys.length] = k;
+  do_check_eq(keys.sort().join("~"),
+              "foo~self");
+  handle.invalidate();
+}
+
+function test_local_invalidation() {
+  var parent = createHandle(),
+      child = parent.createHandle();
+
+  do_check_true(child.invalidate());
+  do_check_false(child.isValid);
+  do_check_true(parent.isValid);
+
+  child = parent.createHandle();
+  do_check_true(child.isValid);
+
+  do_check_true(parent.invalidate());
+  do_check_false(parent.invalidate());
+  do_check_false(child.isValid);
+  do_check_false(parent.isValid);
+
+  parent = createHandle();
+  child = parent.createHandle();
+  child = child.createHandle();
+
+  var uncle = parent.createHandle(),
+      sibling = child.parent.createHandle();
+
+  do_check_eq(child.parent.parent, parent);
+  do_check_true(child.parent.isValid);
+
+  do_check_true(child.parent.invalidate());
+  do_check_false(child.isValid);
+  do_check_true(parent.isValid);
+
+  do_check_false(sibling.isValid);
+  do_check_true(uncle.isValid);
+
+  parent.invalidate();
+}
+
+function test_long_parent_chain(len) {
+  const ancestor = createHandle();
+  for (var handle = ancestor, i = 0; i < len; ++i)
+    handle = handle.createHandle();
+  const child = handle;
+
+  while (handle != ancestor)
+    handle = handle.parent;
+
+  do_check_true(child.isValid);
+  do_check_true(ancestor.invalidate());
+  do_check_false(child.isValid);
+}
+
+function test_invalid_creation() {
+  var parent = createHandle(),
+      child = parent.createHandle();
+
+  parent.invalidate();
+
+  do_check_eq(child.parent, null);
+
+  var threw = false;
+  try { child.createHandle(); }
+  catch (x) { threw = true; }
+  do_check_true(threw);
+}
diff --git a/js/ipc/tests/unit/test_handle.js b/js/ipc/tests/unit/test_handle.js
new file mode 100644
--- /dev/null
+++ b/js/ipc/tests/unit/test_handle.js
@@ -0,0 +1,11 @@
+load("handle_common.js");
+
+function run_test() {
+  run_test_in_child("handle_child.js",
+                    run_actual_tests);
+}
+
+function run_actual_tests() {
+  run_common_tests();
+  do_test_finished();
+}
diff --git a/js/jetpack/JetpackActorCommon.cpp b/js/jetpack/JetpackActorCommon.cpp
new file mode 100644
--- /dev/null
+++ b/js/jetpack/JetpackActorCommon.cpp
@@ -0,0 +1,485 @@
+/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Firefox.
+ *
+ * The Initial Developer of the Original Code is
+ * the Mozilla Foundation <http://www.mozilla.org>.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "base/basictypes.h"
+#include "jscntxt.h"
+
+#include "mozilla/jetpack/JetpackActorCommon.h"
+#include "mozilla/jetpack/PJetpack.h"
+#include "mozilla/jsipc/PHandleParent.h"
+#include "mozilla/jsipc/PHandleChild.h"
+#include "mozilla/jsipc/Handle.h"
+
+#include "jsapi.h"
+#include "jstl.h"
+#include "jshashtable.h"
+
+using mozilla::jetpack::JetpackActorCommon;
+using mozilla::jsipc::PHandleParent;
+using mozilla::jsipc::HandleParent;
+using mozilla::jsipc::PHandleChild;
+using mozilla::jsipc::HandleChild;
+
+class JetpackActorCommon::OpaqueSeenType
+{
+public:
+  typedef JSObject* KeyType;
+  typedef size_t IdType;
+  typedef js::HashMap<
+    KeyType, IdType,
+    js::DefaultHasher<KeyType>,
+    js::SystemAllocPolicy
+  > MapType;
+
+  OpaqueSeenType() {
+    NS_ASSERTION(map.init(1), "Failed to initialize map");
+  }
+
+  bool ok() { return map.initialized(); }
+
+  bool add(KeyType obj, IdType* id = NULL) {
+    MapType::AddPtr ap = map.lookupForAdd(obj);
+    if (!ap)
+      return (rmap.AppendElement(obj) &&
+              map.add(ap, obj, rmap.Length() - 1));
+    if (id)
+      *id = ap->value;
+    return false;
+  }
+
+  bool reverseLookup(IdType id, KeyType* objp) {
+    return !!(*objp = rmap.SafeElementAt(id, NULL));
+  }
+
+private:
+  MapType map;
+  nsAutoTArray<KeyType, 4> rmap;
+
+};
+
+bool
+JetpackActorCommon::jsval_to_PrimVariant(JSContext* cx, JSType type, jsval from,
+                                         PrimVariant* to)
+{
+  switch (type) {
+  case JSTYPE_VOID:
+    *to = void_t();
+    return true;
+
+  case JSTYPE_NULL:
+    *to = null_t();
+    return true;
+
+  case JSTYPE_FUNCTION:
+    return false;
+
+  case JSTYPE_OBJECT: {
+    HandleParent* hp = HandleParent::FromJSVal(cx, from);
+    HandleChild* hc = HandleChild::FromJSVal(cx, from);
+    NS_ASSERTION(!hc || !hp, "Can't be both a parent and a child");
+    if (hp) {
+      *to = hp;
+      return true;
+    }
+    if (hc) {
+      *to = hc;
+      return true;
+    }
+    return false;
+  }
+
+  case JSTYPE_STRING:
+    *to = nsDependentString((PRUnichar*)JS_GetStringChars(JSVAL_TO_STRING(from)),
+                            JS_GetStringLength(JSVAL_TO_STRING(from)));
+    return true;
+
+  case JSTYPE_NUMBER:
+    if (JSVAL_IS_INT(from))
+      *to = JSVAL_TO_INT(from);
+    else if (JSVAL_IS_DOUBLE(from))
+      *to = *JSVAL_TO_DOUBLE(from);
+    else
+      return false;
+    return true;
+
+  case JSTYPE_BOOLEAN:
+    *to = !!JSVAL_TO_BOOLEAN(from);
+    return true;
+
+  case JSTYPE_XML:
+    // fall through
+
+  default:
+    return false;
+  }
+}
+
+bool
+JetpackActorCommon::jsval_to_CompVariant(JSContext* cx, JSType type, jsval from,
+                                         CompVariant* to, OpaqueSeenType* seen)
+{
+  if (type != JSTYPE_OBJECT)
+    return false;
+
+  js::LazilyConstructed<OpaqueSeenType> lost;
+  if (!seen) {
+    lost.construct();
+    seen = lost.addr();
+    if (!seen->ok())
+      return false;
+  }
+
+  OpaqueSeenType::KeyType obj = JSVAL_TO_OBJECT(from);
+  OpaqueSeenType::IdType id;
+  if (!seen->add(obj, &id)) {
+    *to = CompVariant(id);
+    return true;
+  }
+
+  if (JS_IsArrayObject(cx, obj)) {
+    nsTArray<Variant> elems;
+    jsuint len;
+    if (!JS_GetArrayLength(cx, obj, &len))
+      return false;
+    for (jsuint i = 0; i < len; ++i) {
+      jsval val;
+      Variant* vp = elems.AppendElement();
+      if (!JS_GetElement(cx, obj, i, &val) ||
+          !jsval_to_Variant(cx, val, vp, seen))
+        *vp = void_t();
+    }
+    *to = elems;
+    return true;
+  }
+
+  js::AutoIdArray ida(cx, JS_Enumerate(cx, obj));
+  if (!ida)
+    return false;
+
+  nsTArray<KeyValue> kvs;
+  for (size_t i = 0; i < ida.length(); ++i) {
+    jsval val; // reused for both key and value
+    if (!JS_IdToValue(cx, ida[i], &val))
+      return false;
+    JSString* idStr = JS_ValueToString(cx, val);
+    if (!idStr)
+      return false;
+    if (!JS_GetPropertyById(cx, obj, ida[i], &val))
+      return false;
+    KeyValue* kv = kvs.AppendElement();
+    kv->key() = nsString((PRUnichar*)JS_GetStringChars(idStr),
+                         JS_GetStringLength(idStr));
+    if (!jsval_to_Variant(cx, val, &kv->value(), seen))
+      return false;
+  }
+  *to = kvs;
+
+  return true;
+}
+
+bool
+JetpackActorCommon::jsval_to_Variant(JSContext* cx, jsval from, Variant* to,
+                                     OpaqueSeenType* seen)
+{
+  JSType type = JS_TypeOfValue(cx, from);
+  if (JSVAL_IS_NULL(from))
+    type = JSTYPE_NULL;
+
+  PrimVariant pv;
+  if (jsval_to_PrimVariant(cx, type, from, &pv)) {
+    *to = pv;
+    return true;
+  }
+
+  CompVariant cv;
+  if (jsval_to_CompVariant(cx, type, from, &cv, seen)) {
+    *to = cv;
+    return true;
+  }
+
+  return false;
+}
+
+bool
+JetpackActorCommon::jsval_from_PrimVariant(JSContext* cx,
+                                           const PrimVariant& from,
+                                           jsval* to)
+{
+  switch (from.type()) {
+  case PrimVariant::Tvoid_t:
+    *to = JSVAL_VOID;
+    return true;
+
+  case PrimVariant::Tnull_t:
+    *to = JSVAL_NULL;
+    return true;
+
+  case PrimVariant::Tbool:
+    *to = from.get_bool() ? JSVAL_TRUE : JSVAL_FALSE;
+    return true;
+
+  case PrimVariant::Tint:
+    *to = INT_TO_JSVAL(from.get_int());
+    return true;
+
+  case PrimVariant::Tdouble:
+    return !!JS_NewDoubleValue(cx, from.get_double(), to);
+
+  case PrimVariant::TnsString: {
+    const nsString& str = from.get_nsString();
+    if (!str.Length()) {
+      *to = JS_GetEmptyStringValue(cx);
+      return true;
+    }
+    JSString* s =
+      JS_NewUCStringCopyN(cx, str.BeginReading(), str.Length());
+    if (!s)
+      return false;
+    *to = STRING_TO_JSVAL(s);
+    return true;
+  }
+
+  case PrimVariant::TPHandleParent: {
+    JSObject* hobj =
+      static_cast<const HandleParent*>(from.get_PHandleParent())->ToJSObject(cx);
+    if (!hobj)
+      return false;
+    *to = OBJECT_TO_JSVAL(hobj);
+    return true;
+  }    
+
+  case PrimVariant::TPHandleChild: {
+    JSObject* hobj =
+      static_cast<const HandleChild*>(from.get_PHandleChild())->ToJSObject(cx);
+    if (!hobj)
+      return false;
+    *to = OBJECT_TO_JSVAL(hobj);
+    return true;
+  }
+
+  default:
+    return false;
+  }
+}
+
+bool
+JetpackActorCommon::jsval_from_CompVariant(JSContext* cx,
+                                           const CompVariant& from,
+                                           jsval* to,
+                                           OpaqueSeenType* seen)
+{
+  js::LazilyConstructed<OpaqueSeenType> lost;
+  if (!seen) {
+    lost.construct();
+    seen = lost.addr();
+    if (!seen->ok())
+      return false;
+  }
+
+  JSObject* obj = NULL;
+
+  switch (from.type()) {
+  case CompVariant::TArrayOfKeyValue: {
+    if (!(obj = JS_NewObject(cx, NULL, NULL, NULL)))
+      return false;
+    js::AutoObjectRooter root(cx, obj);
+
+    if (!seen->add(obj))
+      return false;
+
+    const nsTArray<KeyValue>& kvs = from.get_ArrayOfKeyValue();
+    for (PRUint32 i = 0; i < kvs.Length(); ++i) {
+      const KeyValue& kv = kvs.ElementAt(i);
+      jsval val;
+      if (!jsval_from_Variant(cx, kv.value(), &val, seen) ||
+          !JS_SetUCProperty(cx, obj,
+                            kv.key().BeginReading(),
+                            kv.key().Length(),
+                            &val))
+        return false;
+    }
+
+    break;
+  }
+
+  case CompVariant::TArrayOfVariant: {
+    const nsTArray<Variant>& vs = from.get_ArrayOfVariant();
+    jsval* elems;
+
+    obj = js_NewArrayObjectWithCapacity(cx, vs.Length(), &elems);
+    if (!obj || !elems)
+      return false;
+    js::AutoObjectRooter root(cx, obj);
+
+    if (!seen->add(obj))
+      return false;
+
+    for (PRUint32 i = 0; i < vs.Length(); ++i)
+      if (!jsval_from_Variant(cx, vs.ElementAt(i), elems + i, seen))
+        return false;
+
+    break;
+  }
+
+  case CompVariant::Tsize_t:
+    if (!seen->reverseLookup(from.get_size_t(), &obj))
+      return false;
+    break;
+
+  default:
+    return false;
+  }
+
+  *to = OBJECT_TO_JSVAL(obj);
+  return true;
+}
+
+bool
+JetpackActorCommon::jsval_from_Variant(JSContext* cx, const Variant& from,
+                                       jsval* to, OpaqueSeenType* seen)
+{
+  switch (from.type()) {
+  case Variant::TPrimVariant:
+    return jsval_from_PrimVariant(cx, from, to);
+  case Variant::TCompVariant:
+    return jsval_from_CompVariant(cx, from, to, seen);
+  default:
+    return false;
+  }
+}
+
+bool
+JetpackActorCommon::RecvMessage(JSContext* cx,
+                                const nsString& messageName,
+                                const nsTArray<Variant>& data,
+                                nsTArray<Variant>* results)
+{
+  if (results)
+    results->Clear();
+
+  nsAutoTArray<jsval, 4> snapshot;
+  TakeSnapshot(messageName, snapshot);
+  if (!snapshot.Length())
+    return true;
+  js::AutoArrayRooter
+    snapshotRooter(cx, snapshot.Length(), snapshot.Elements());
+  JSAutoRequest request(cx);
+
+  nsAutoTArray<jsval, 4> args;
+  PRUint32 argc = data.Length() + 1;
+  jsval* argv = args.AppendElements(argc);
+  if (!argv)
+    return false;
+  for (PRUint32 i = 0; i < argc; ++i)
+    argv[i] = JSVAL_VOID;
+  js::AutoArrayRooter argvRooter(cx, argc, argv);
+
+  JSString* msgNameStr =
+    JS_NewUCStringCopyN(cx,
+                        messageName.BeginReading(),
+                        messageName.Length());
+  if (!msgNameStr)
+    return false;
+  argv[0] = STRING_TO_JSVAL(msgNameStr);
+
+  for (PRUint32 i = 0; i < data.Length(); ++i)
+    if (!jsval_from_Variant(cx, data.ElementAt(i), argv + i + 1))
+      return false;
+
+  JSObject* implGlobal = JS_GetGlobalObject(cx);
+  for (PRUint32 i = 0; i < snapshot.Length(); ++i) {
+    jsval rval;
+    if (!JS_CallFunctionValue(cx, implGlobal, snapshot.ElementAt(i), argc, argv,
+                              &rval))
+      break;
+
+    if (!results)
+      continue;
+
+    js::AutoValueRooter root(cx, rval);
+
+    Variant* vp = results->AppendElement();
+    if (!jsval_to_Variant(cx, rval, vp))
+      *vp = void_t();
+  }
+
+  return true;
+}
+
+nsresult
+JetpackActorCommon::RegisterReceiver(JSContext* cx,
+                                     const nsString& messageName,
+                                     jsval receiver)
+{
+  nsTArray<nsAutoJSValHolder>* vals;
+  while (!mReceivers.Get(messageName, &vals))
+    mReceivers.Put(messageName, new nsTArray<nsAutoJSValHolder>(1));
+  NS_ENSURE_TRUE(vals, NS_ERROR_OUT_OF_MEMORY);
+
+  if (!vals->Contains(receiver)) {
+    nsAutoJSValHolder* holder = vals->AppendElement();
+    holder->Hold(cx);
+    *holder = receiver;
+  }
+
+  return NS_OK;
+}
+
+void
+JetpackActorCommon::UnregisterReceiver(const nsString& messageName,
+                                       jsval receiver)
+{
+  nsTArray<nsAutoJSValHolder>* vals;
+  if (mReceivers.Get(messageName, &vals))
+    vals->RemoveElement(receiver);
+}
+
+void
+JetpackActorCommon::TakeSnapshot(const nsString& messageName,
+                                 nsTArray<jsval>& snapshot)
+{
+  snapshot.Clear();
+  nsTArray<nsAutoJSValHolder>* vals;
+  if (!mReceivers.Get(messageName, &vals))
+    return;
+  nsAutoJSValHolder
+    *val = vals->Elements(),
+    *end = val + vals->Length();
+  while (val != end)
+    snapshot.AppendElement(*val++);
+}
diff --git a/js/jetpack/JetpackActorCommon.h b/js/jetpack/JetpackActorCommon.h
new file mode 100644
--- /dev/null
+++ b/js/jetpack/JetpackActorCommon.h
@@ -0,0 +1,120 @@
+/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Firefox.
+ *
+ * The Initial Developer of the Original Code is
+ * the Mozilla Foundation <http://www.mozilla.org>.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef mozilla_jetpack_JetpackActorCommon_h
+#define mozilla_jetpack_JetpackActorCommon_h
+
+#include "nsClassHashtable.h"
+#include "nsHashKeys.h"
+#include "nsTArray.h"
+#include "nsAutoJSValHolder.h"
+#include "nsString.h"
+
+struct JSContext;
+
+namespace mozilla {
+namespace jetpack {
+
+class KeyValue;
+class PrimVariant;
+class CompVariant;
+class Variant;
+
+class JetpackActorCommon
+{
+public:
+
+  bool
+  RecvMessage(JSContext* cx,
+              const nsString& messageName,
+              const nsTArray<Variant>& data,
+              nsTArray<Variant>* results);
+
+  nsresult
+  RegisterReceiver(JSContext* cx,
+                   const nsString& messageName,
+                   jsval receiver);
+
+  void
+  UnregisterReceiver(const nsString& messageName,
+                     jsval receiver);
+
+  void
+  UnregisterReceivers(const nsString& messageName) {
+    mReceivers.Remove(messageName);
+  }
+
+  void ClearReceivers() {
+    mReceivers.Clear();
+  }
+
+  class OpaqueSeenType;
+  static bool jsval_to_Variant(JSContext* cx, jsval from, Variant* to,
+                               OpaqueSeenType* seen = NULL);
+  static bool jsval_from_Variant(JSContext* cx, const Variant& from, jsval* to,
+                                 OpaqueSeenType* seen = NULL);
+
+protected:
+
+  JetpackActorCommon() {
+    mReceivers.Init();
+  }
+
+private:
+
+  static bool jsval_to_PrimVariant(JSContext* cx, JSType type, jsval from,
+                                   PrimVariant* to);
+  static bool jsval_to_CompVariant(JSContext* cx, JSType type, jsval from,
+                                   CompVariant* to, OpaqueSeenType* seen);
+
+  static bool jsval_from_PrimVariant(JSContext* cx, const PrimVariant& from,
+                                     jsval* to);
+  static bool jsval_from_CompVariant(JSContext* cx, const CompVariant& from,
+                                     jsval* to, OpaqueSeenType* seen);
+
+  void TakeSnapshot(const nsString& messageName,
+                    nsTArray<jsval>& snapshot);
+
+  nsClassHashtable<nsStringHashKey,
+                   nsTArray<nsAutoJSValHolder> > mReceivers;
+
+};
+
+}}
+
+#endif
diff --git a/js/jetpack/JetpackChild.cpp b/js/jetpack/JetpackChild.cpp
--- a/js/jetpack/JetpackChild.cpp
+++ b/js/jetpack/JetpackChild.cpp
@@ -30,54 +30,398 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
+#include "base/basictypes.h"
+#include "jscntxt.h"
+
 #include "mozilla/jetpack/JetpackChild.h"
+#include "mozilla/jsipc/Handle.h"
 
-#include <stdio.h>
+#include "jsarray.h"
+
+using mozilla::jsipc::PHandleChild;
+using mozilla::jsipc::HandleChild;
 
 namespace mozilla {
 namespace jetpack {
 
 JetpackChild::JetpackChild()
 {
-  NS_ASSERTION(!gInstance, "Something terribly wrong here!");
-  gInstance = this;
 }
 
 JetpackChild::~JetpackChild()
 {
-  NS_ASSERTION(gInstance == this, "Something terribly wrong here!");
-  gInstance = nsnull;
 }
 
+#define IMPL_PROP_FLAGS (JSPROP_SHARED | \
+                         JSPROP_ENUMERATE | \
+                         JSPROP_READONLY | \
+                         JSPROP_PERMANENT)
+const JSPropertySpec
+JetpackChild::sImplProperties[] = {
+  { "jetpack", 0, IMPL_PROP_FLAGS, UserJetpackGetter, NULL },
+  { 0, 0, 0, NULL, NULL }
+};
+
+#undef IMPL_PROP_FLAGS
+
+#define IMPL_METHOD_FLAGS (JSFUN_FAST_NATIVE |  \
+                           JSPROP_ENUMERATE | \
+                           JSPROP_READONLY | \
+                           JSPROP_PERMANENT)
+const JSFunctionSpec
+JetpackChild::sImplMethods[] = {
+  JS_FN("sendMessage", SendMessage, 3, IMPL_METHOD_FLAGS),
+  JS_FN("callMessage", CallMessage, 2, IMPL_METHOD_FLAGS),
+  JS_FN("registerReceiver", RegisterReceiver, 2, IMPL_METHOD_FLAGS),
+  JS_FN("unregisterReceiver", UnregisterReceiver, 2, IMPL_METHOD_FLAGS),
+  JS_FN("unregisterReceivers", UnregisterReceivers, 1, IMPL_METHOD_FLAGS),
+  JS_FN("wrap", Wrap, 1, IMPL_METHOD_FLAGS),
+  JS_FN("createHandle", CreateHandle, 0, IMPL_METHOD_FLAGS),
+  JS_FS_END
+};
+
+#undef IMPL_METHOD_FLAGS
+
+const JSClass
+JetpackChild::sGlobalClass = {
+  "JetpackChild::sGlobalClass", JSCLASS_GLOBAL_FLAGS,
+  JS_PropertyStub,  JS_PropertyStub, JS_PropertyStub, JS_PropertyStub,
+  JS_EnumerateStub, JS_ResolveStub,  JS_ConvertStub,  JS_FinalizeStub,
+  JSCLASS_NO_OPTIONAL_MEMBERS
+};
+  
 bool
 JetpackChild::Init(base::ProcessHandle aParentProcessHandle,
                    MessageLoop* aIOLoop,
                    IPC::Channel* aChannel)
 {
   if (!Open(aChannel, aParentProcessHandle, aIOLoop))
     return false;
 
+  if (!(mRuntime = JS_NewRuntime(32L * 1024L * 1024L)) ||
+      !(mImplCx = JS_NewContext(mRuntime, 8192)) ||
+      !(mUserCx = JS_NewContext(mRuntime, 8192)))
+    return false;
+
+  {
+    JSAutoRequest request(mImplCx);
+    JS_SetContextPrivate(mImplCx, this);
+    JSObject* implGlobal =
+      JS_NewObject(mImplCx, const_cast<JSClass*>(&sGlobalClass), NULL, NULL);
+    if (!implGlobal ||
+        !JS_InitStandardClasses(mImplCx, implGlobal) ||
+        !JS_DefineProperties(mImplCx, implGlobal,
+                             const_cast<JSPropertySpec*>(sImplProperties)) ||
+        !JS_DefineFunctions(mImplCx, implGlobal,
+                            const_cast<JSFunctionSpec*>(sImplMethods)))
+      return false;
+  }
+
+  {
+    JSAutoRequest request(mUserCx);
+    JS_SetContextPrivate(mUserCx, this);
+    JSObject* userGlobal =
+      JS_NewObject(mUserCx, const_cast<JSClass*>(&sGlobalClass), NULL, NULL);
+    if (!userGlobal ||
+        !JS_InitStandardClasses(mUserCx, userGlobal))
+      return false;
+  }
+
   return true;
 }
 
 void
 JetpackChild::CleanUp()
 {
+  JS_DestroyContext(mUserCx);
+  JS_DestroyContext(mImplCx);
+  JS_DestroyRuntime(mRuntime);
+  JS_ShutDown();
 }
 
 bool
-JetpackChild::RecvLoadImplementation(const nsCString& script)
+JetpackChild::RecvSendMessage(const nsString& messageName,
+                              const nsTArray<Variant>& data)
 {
-  printf("Received LoadImplementation message: '%s'\n", script.get());
+  return JetpackActorCommon::RecvMessage(mImplCx, messageName, data, NULL);
+}
+
+static bool
+Evaluate(JSContext* cx, const nsCString& code)
+{
+  JSAutoRequest request(cx);
+  jsval v;
+  JS_EvaluateScript(cx, JS_GetGlobalObject(cx), code.get(),
+                    code.Length(), EmptyCString().get(), 1, &v);
   return true;
 }
 
-JetpackChild* JetpackChild::gInstance;
+bool
+JetpackChild::RecvLoadImplementation(const nsCString& code)
+{
+  return Evaluate(mImplCx, code);
+}
+
+bool
+JetpackChild::RecvLoadUserScript(const nsCString& code)
+{
+  return Evaluate(mUserCx, code);
+}
+
+PHandleChild*
+JetpackChild::AllocPHandle()
+{
+  return new HandleChild();
+}
+
+bool
+JetpackChild::DeallocPHandle(PHandleChild* actor)
+{
+  delete actor;
+  return true;
+}
+
+JetpackChild*
+JetpackChild::GetThis(JSContext* cx)
+{
+  JetpackChild* self =
+    static_cast<JetpackChild*>(JS_GetContextPrivate(cx));
+  JS_ASSERT(cx == self->mImplCx ||
+            cx == self->mUserCx);
+  return self;
+}
+
+JSBool
+JetpackChild::UserJetpackGetter(JSContext* cx, JSObject* obj, jsval id,
+                                jsval* vp)
+{
+  JSObject* userGlobal = JS_GetGlobalObject(GetThis(cx)->mUserCx);
+  JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(userGlobal));
+  return JS_TRUE;
+}
+
+struct MessageResult {
+  PRUnichar* msgNameChars;
+  size_t msgNameLength;
+  nsTArray<Variant> data;
+};
+
+static JSBool
+MessageCommon(JSContext* cx, uintN argc, jsval* vp,
+              MessageResult* result)
+{
+  if (argc < 1) {
+    JS_ReportError(cx, "Message requires a name, at least");
+    return JS_FALSE;
+  }
+
+  jsval* argv = JS_ARGV(cx, vp);
+
+  JSString* msgNameStr = JS_ValueToString(cx, argv[0]);
+  if (!msgNameStr) {
+    JS_ReportOutOfMemory(cx);
+    return JS_FALSE;
+  }
+
+  result->msgNameChars = (PRUnichar*)JS_GetStringChars(msgNameStr);
+  result->msgNameLength = JS_GetStringLength(msgNameStr);
+
+  result->data.Clear();
+  for (uintN i = 1; i < argc; ++i) {
+    Variant* vp = result->data.AppendElement();
+    if (!JetpackActorCommon::jsval_to_Variant(cx, argv[i], vp)) {
+      JS_ReportError(cx, "Invalid message argument at position %d", i);
+      return JS_FALSE;
+    }
+  }
+
+  return JS_TRUE;
+}
+
+JSBool
+JetpackChild::SendMessage(JSContext* cx, uintN argc, jsval* vp)
+{
+  MessageResult smr;
+  if (!MessageCommon(cx, argc, vp, &smr))
+    return JS_FALSE;
+
+  if (!GetThis(cx)->SendSendMessage(nsDependentString(smr.msgNameChars,
+                                                      smr.msgNameLength),
+                                    smr.data))
+  {
+    JS_ReportError(cx, "Failed to sendMessage");
+    return JS_FALSE;
+  }
+
+  JS_SET_RVAL(cx, vp, JSVAL_VOID);
+
+  return JS_TRUE;
+}
+
+JSBool
+JetpackChild::CallMessage(JSContext* cx, uintN argc, jsval* vp)
+{
+  MessageResult smr;
+  if (!MessageCommon(cx, argc, vp, &smr))
+    return JS_FALSE;
+
+  nsTArray<Variant> results;
+  if (!GetThis(cx)->SendCallMessage(nsDependentString(smr.msgNameChars,
+                                                      smr.msgNameLength),
+                                    smr.data,
+                                    &results))
+  {
+    JS_ReportError(cx, "Failed to callMessage");
+    return JS_FALSE;
+  }
+
+  jsval* rvals;
+  JSObject* arrObj =
+    js_NewArrayObjectWithCapacity(cx, results.Length(), &rvals);
+  if (!arrObj || !rvals) {
+    JS_ReportOutOfMemory(cx);
+    return JS_FALSE;
+  }
+  js::AutoValueRooter root(cx, arrObj);
+
+  for (PRUint32 i = 0; i < results.Length(); ++i)
+    if (!jsval_from_Variant(cx, results.ElementAt(i), rvals + i)) {
+      JS_ReportError(cx, "Invalid result from handler %d", i);
+      return JS_FALSE;
+    }
+
+  JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(arrObj));
+
+  return JS_TRUE;
+}
+
+struct ReceiverResult
+{
+  PRUnichar* msgNameChars;
+  size_t msgNameLength;
+  jsval receiver;
+};
+
+static JSBool
+ReceiverCommon(JSContext* cx, uintN argc, jsval* vp,
+               const char* methodName, uintN arity,
+               ReceiverResult* result)
+{
+  if (argc != arity) {
+    JS_ReportError(cx, "%s requires exactly %d arguments", methodName, arity);
+    return JS_FALSE;
+  }
+
+  if (arity < 1)
+    return JS_TRUE;
+
+  jsval* argv = JS_ARGV(cx, vp);
+
+  JSString* str = JS_ValueToString(cx, argv[0]);
+  if (!str) {
+    JS_ReportError(cx, "%s expects a string as its first argument", methodName);
+    return JS_FALSE;
+  }
+
+  result->msgNameChars = (PRUnichar*)JS_GetStringChars(str);
+  result->msgNameLength = JS_GetStringLength(str);
+
+  if (arity < 2)
+    return JS_TRUE;
+
+  if (!JSVAL_IS_OBJECT(argv[1]) ||
+      !JS_ObjectIsFunction(cx, JSVAL_TO_OBJECT(argv[1])))
+  {
+    JS_ReportError(cx, "%s expects a function as its second argument",
+                   methodName);
+    return JS_FALSE;
+  }
+
+  result->receiver = argv[1];
+
+  return JS_TRUE;
+}
+
+JSBool
+JetpackChild::RegisterReceiver(JSContext* cx, uintN argc, jsval* vp)
+{
+  ReceiverResult rr;
+  if (!ReceiverCommon(cx, argc, vp, "registerReceiver", 2, &rr))
+    return JS_FALSE;
+
+  JetpackActorCommon* actor = GetThis(cx);
+  nsresult rv =
+    actor->RegisterReceiver(cx,
+                            nsDependentString(rr.msgNameChars,
+                                              rr.msgNameLength),
+                            rr.receiver);
+  if (NS_FAILED(rv)) {
+    JS_ReportOutOfMemory(cx);
+    return JS_FALSE;
+  }
+
+  return JS_TRUE;
+}
+
+JSBool
+JetpackChild::UnregisterReceiver(JSContext* cx, uintN argc, jsval* vp)
+{
+  ReceiverResult rr;
+  if (!ReceiverCommon(cx, argc, vp, "unregisterReceiver", 2, &rr))
+    return JS_FALSE;
+
+  JetpackActorCommon* actor = GetThis(cx);
+  actor->UnregisterReceiver(nsDependentString(rr.msgNameChars,
+                                              rr.msgNameLength),
+                            rr.receiver);
+  return JS_TRUE;
+}
+
+JSBool
+JetpackChild::UnregisterReceivers(JSContext* cx, uintN argc, jsval* vp)
+{
+  ReceiverResult rr;
+  if (!ReceiverCommon(cx, argc, vp, "unregisterReceivers", 1, &rr))
+    return JS_FALSE;
+
+  JetpackActorCommon* actor = GetThis(cx);
+  actor->UnregisterReceivers(nsDependentString(rr.msgNameChars,
+                                               rr.msgNameLength));
+  return JS_TRUE;
+}
+
+JSBool
+JetpackChild::Wrap(JSContext* cx, uintN argc, jsval* vp)
+{
+  JS_ReportError(cx, "wrap not yet implemented (depends on bug 563010)");
+  return JS_FALSE;
+}
+
+JSBool
+JetpackChild::CreateHandle(JSContext* cx, uintN argc, jsval* vp)
+{
+  if (argc > 0) {
+    JS_ReportError(cx, "createHandle takes zero arguments");
+    return JS_FALSE;
+  }
+
+  HandleChild* handle =
+    static_cast<HandleChild*>(GetThis(cx)->SendPHandleConstructor());
+  if (!handle) {
+    JS_ReportError(cx, "Failed to construct Handle");
+    return JS_FALSE;
+  }
+
+  JSObject* hobj = handle->ToJSObject(cx);
+  JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(hobj));
+
+  return JS_TRUE;
+}
 
 } // namespace jetpack
 } // namespace mozilla
diff --git a/js/jetpack/JetpackChild.h b/js/jetpack/JetpackChild.h
--- a/js/jetpack/JetpackChild.h
+++ b/js/jetpack/JetpackChild.h
@@ -34,39 +34,73 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_jetpack_JetpackChild_h
 #define mozilla_jetpack_JetpackChild_h
 
 #include "mozilla/jetpack/PJetpackChild.h"
+#include "mozilla/jetpack/JetpackActorCommon.h"
+
+#include "nsTArray.h"
 
 namespace mozilla {
+
+namespace jsipc {
+class PHandleChild;
+}
+
 namespace jetpack {
 
-class JetpackChild : public PJetpackChild
+class JetpackChild
+  : public PJetpackChild
+  , private JetpackActorCommon
 {
 public:
   JetpackChild();
   ~JetpackChild();
 
   static JetpackChild* current();
 
   bool Init(base::ProcessHandle aParentProcessHandle,
             MessageLoop* aIOLoop,
             IPC::Channel* aChannel);
 
   void CleanUp();
 
 protected:
-  NS_OVERRIDE virtual bool RecvLoadImplementation(const nsCString& script);
+  NS_OVERRIDE virtual bool RecvSendMessage(const nsString& messageName,
+                                           const nsTArray<Variant>& data);
+  NS_OVERRIDE virtual bool RecvLoadImplementation(const nsCString& code);
+  NS_OVERRIDE virtual bool RecvLoadUserScript(const nsCString& code);
+
+  NS_OVERRIDE virtual PHandleChild* AllocPHandle();
+  NS_OVERRIDE virtual bool DeallocPHandle(PHandleChild* actor);
 
 private:
-  static JetpackChild* gInstance;
+  JSRuntime* mRuntime;
+  JSContext *mImplCx, *mUserCx;
+
+  static JetpackChild* GetThis(JSContext* cx);
+
+  static const JSPropertySpec sImplProperties[];
+  static JSBool UserJetpackGetter(JSContext* cx, JSObject* obj, jsval idval,
+                                  jsval* vp);
+
+  static const JSFunctionSpec sImplMethods[];
+  static JSBool SendMessage(JSContext* cx, uintN argc, jsval *vp);
+  static JSBool CallMessage(JSContext* cx, uintN argc, jsval *vp);
+  static JSBool RegisterReceiver(JSContext* cx, uintN argc, jsval *vp);
+  static JSBool UnregisterReceiver(JSContext* cx, uintN argc, jsval *vp);
+  static JSBool UnregisterReceivers(JSContext* cx, uintN argc, jsval *vp);
+  static JSBool Wrap(JSContext* cx, uintN argc, jsval *vp);
+  static JSBool CreateHandle(JSContext* cx, uintN argc, jsval *vp);
+
+  static const JSClass sGlobalClass;
 
   DISALLOW_EVIL_CONSTRUCTORS(JetpackChild);
 };
 
 } // namespace jetpack
 } // namespace mozilla
 
 
diff --git a/js/jetpack/JetpackParent.cpp b/js/jetpack/JetpackParent.cpp
--- a/js/jetpack/JetpackParent.cpp
+++ b/js/jetpack/JetpackParent.cpp
@@ -31,40 +31,203 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "mozilla/jetpack/JetpackParent.h"
+#include "mozilla/jsipc/Handle.h"
+
+#include "nsIURI.h"
+#include "nsNetUtil.h"
+#include "nsIVariant.h"
+#include "nsIXPConnect.h"
+
+using mozilla::jsipc::PHandleParent;
+using mozilla::jsipc::HandleParent;
 
 namespace mozilla {
 namespace jetpack {
 
-JetpackParent::JetpackParent()
+JetpackParent::JetpackParent(JSContext* cx)
   : mSubprocess(new JetpackProcessParent())
+  , mContext(cx)
 {
   mSubprocess->Launch();
   Open(mSubprocess->GetChannel(),
        mSubprocess->GetChildProcessHandle());
 }
 
 JetpackParent::~JetpackParent()
 {
   XRE_GetIOMessageLoop()
     ->PostTask(FROM_HERE, new DeleteTask<JetpackProcessParent>(mSubprocess));
 }
 
 NS_IMPL_ISUPPORTS1(JetpackParent, nsIJetpack)
 
+static nsresult
+ReadFromURI(const nsAString& aURI,
+            nsCString* content)
+{
+  nsCOMPtr<nsIURI> uri;
+  nsresult rv = NS_NewURI(getter_AddRefs(uri),
+                          NS_ConvertUTF16toUTF8(aURI));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIChannel> channel;
+  NS_NewChannel(getter_AddRefs(channel), uri);
+  NS_ENSURE_TRUE(channel, NS_ERROR_FAILURE);
+
+  nsCOMPtr<nsIInputStream> input;
+  channel->Open(getter_AddRefs(input));
+  if (input) {
+    char buffer[256];
+    PRUint32 avail = 0;
+    input->Available(&avail);
+    if (avail) {
+      PRUint32 read = 0;
+      while (NS_SUCCEEDED(input->Read(buffer, sizeof(buffer), &read)) && read) {
+        content->Append(buffer, read);
+        read = 0;
+      }
+    }
+  }
+
+  return NS_OK;
+}
+
 NS_IMETHODIMP
-JetpackParent::LoadImplementation(const nsAString& aURI)
+JetpackParent::SendMessage(const nsAString& aMessageName)
 {
-  // this is all wrong, load the URI and send the data, but for now...
-  if (!SendLoadImplementation(NS_ConvertUTF16toUTF8(aURI)))
+  nsresult rv;
+  nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsAXPCNativeCallContext* ncc = NULL;
+  rv = xpc->GetCurrentNativeCallContext(&ncc);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  JSContext* cx;
+  rv = ncc->GetJSContext(&cx);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  PRUint32 argc;
+  rv = ncc->GetArgc(&argc);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  jsval* argv;
+  rv = ncc->GetArgvPtr(&argv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsTArray<Variant> data;
+
+  for (PRUint32 i = 1; i < argc; ++i)
+    if (!jsval_to_Variant(cx, argv[i], data.AppendElement()))
+      return NS_ERROR_INVALID_ARG;
+
+  if (!SendSendMessage(nsString(aMessageName), data))
     return NS_ERROR_FAILURE;
 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+JetpackParent::RegisterReceiver(const nsAString& aMessageName,
+                                jsval aReceiver)
+{
+  return JetpackActorCommon::RegisterReceiver(mContext,
+                                              nsString(aMessageName),
+                                              aReceiver);
+}
+
+NS_IMETHODIMP
+JetpackParent::UnregisterReceiver(const nsAString& aMessageName,
+                                  jsval aReceiver)
+{
+  JetpackActorCommon::UnregisterReceiver(nsString(aMessageName),
+                                         aReceiver);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+JetpackParent::UnregisterReceivers(const nsAString& aMessageName)
+{
+  JetpackActorCommon::UnregisterReceivers(nsString(aMessageName));
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+JetpackParent::LoadImplementation(const nsAString& aURI)
+{
+  nsCString code;
+  nsresult rv = ReadFromURI(aURI, &code);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (!code.IsEmpty() &&
+      !SendLoadImplementation(code))
+    rv = NS_ERROR_FAILURE;
+
+  return rv;
+}
+
+NS_IMETHODIMP
+JetpackParent::LoadUserScript(const nsAString& aURI)
+{
+  nsCString code;
+  nsresult rv = ReadFromURI(aURI, &code);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (!code.IsEmpty() &&
+      !SendLoadUserScript(code))
+    rv = NS_ERROR_FAILURE;
+
+  return rv;
+}
+
+bool
+JetpackParent::RecvSendMessage(const nsString& messageName,
+                               const nsTArray<Variant>& data)
+{
+  return JetpackActorCommon::RecvMessage(mContext, messageName, data, NULL);
+}
+
+bool
+JetpackParent::RecvCallMessage(const nsString& messageName,
+                               const nsTArray<Variant>& data,
+                               nsTArray<Variant>* results)
+{
+  return JetpackActorCommon::RecvMessage(mContext, messageName, data, results);
+}
+
+NS_IMETHODIMP
+JetpackParent::CreateHandle(nsIVariant** aResult)
+{
+  HandleParent* handle =
+    static_cast<HandleParent*>(SendPHandleConstructor());
+  NS_ENSURE_TRUE(handle, NS_ERROR_OUT_OF_MEMORY);
+
+  nsresult rv;
+  nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  JSAutoRequest request(mContext);
+  JSObject* hobj = handle->ToJSObject(mContext);
+  return xpc->JSToVariant(mContext, OBJECT_TO_JSVAL(hobj), aResult);
+}
+
+PHandleParent*
+JetpackParent::AllocPHandle()
+{
+  return new HandleParent();
+}
+
+bool
+JetpackParent::DeallocPHandle(PHandleParent* actor)
+{
+  delete actor;
+  return true;
+}
+
 } // namespace jetpack
 } // namespace mozilla
diff --git a/js/jetpack/JetpackParent.h b/js/jetpack/JetpackParent.h
--- a/js/jetpack/JetpackParent.h
+++ b/js/jetpack/JetpackParent.h
@@ -35,34 +35,56 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_jetpack_JetpackParent_h
 #define mozilla_jetpack_JetpackParent_h
 
 #include "mozilla/jetpack/PJetpackParent.h"
 #include "mozilla/jetpack/JetpackProcessParent.h"
+#include "mozilla/jetpack/JetpackActorCommon.h"
 #include "nsIJetpack.h"
 
+#include "nsTArray.h"
+
+struct JSContext;
+
 namespace mozilla {
+
+namespace jsipc {
+class PHandleParent;
+}
+
 namespace jetpack {
 
 class JetpackParent
   : public PJetpackParent
   , public nsIJetpack
+  , private JetpackActorCommon
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIJETPACK
 
-  JetpackParent();
+  JetpackParent(JSContext* cx);
   ~JetpackParent();
 
+protected:
+  NS_OVERRIDE virtual bool RecvSendMessage(const nsString& messageName,
+                                           const nsTArray<Variant>& data);
+  NS_OVERRIDE virtual bool RecvCallMessage(const nsString& messageName,
+                                           const nsTArray<Variant>& data,
+                                           nsTArray<Variant>* results);
+
+  NS_OVERRIDE virtual PHandleParent* AllocPHandle();
+  NS_OVERRIDE virtual bool DeallocPHandle(PHandleParent* actor);
+
 private:
   JetpackProcessParent* mSubprocess;
+  JSContext* mContext;
 
   DISALLOW_EVIL_CONSTRUCTORS(JetpackParent);
 };
 
 } // namespace jetpack
 } // namespace mozilla
 
 #endif // mozilla_jetpack_JetpackParent_h
diff --git a/js/jetpack/JetpackService.cpp b/js/jetpack/JetpackService.cpp
--- a/js/jetpack/JetpackService.cpp
+++ b/js/jetpack/JetpackService.cpp
@@ -38,26 +38,33 @@
 #include "base/basictypes.h"
 #include "mozilla/jetpack/JetpackService.h"
 
 #include "mozilla/jetpack/JetpackParent.h"
 #include "nsIJetpack.h"
 
 #include "nsIGenericFactory.h"
 
+#include "nsIJSContextStack.h"
+
 namespace mozilla {
 namespace jetpack {
 
 NS_IMPL_ISUPPORTS1(JetpackService,
                    nsIJetpackService)
 
 NS_IMETHODIMP
 JetpackService::CreateJetpack(nsIJetpack** aResult)
 {
-  nsRefPtr<JetpackParent> j = new JetpackParent();
+  nsCOMPtr<nsIJSContextStack>
+    stack(do_GetService("@mozilla.org/js/xpc/ContextStack;1"));
+  JSContext* cx;
+  nsresult rv = stack->Peek(&cx);
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsRefPtr<JetpackParent> j = new JetpackParent(cx);
   *aResult = j.forget().get();
   return NS_OK;
 }
 
 NS_GENERIC_FACTORY_CONSTRUCTOR(JetpackService)
 
 } // namespace jetpack
 } // namespace mozilla
diff --git a/js/jetpack/Makefile.in b/js/jetpack/Makefile.in
--- a/js/jetpack/Makefile.in
+++ b/js/jetpack/Makefile.in
@@ -56,21 +56,27 @@ XPIDLSRCS = \
 
 EXPORTS_NAMESPACES = mozilla/jetpack
 EXPORTS_mozilla/jetpack = \
   JetpackProcessChild.h \
   JetpackProcessParent.h \
   JetpackParent.h \
   JetpackChild.h \
   JetpackService.h \
+  JetpackActorCommon.h \
   $(NULL)
 
 CPPSRCS = \
   JetpackParent.cpp \
   JetpackChild.cpp \
   JetpackProcessChild.cpp \
   JetpackProcessParent.cpp \
   JetpackService.cpp \
+  JetpackActorCommon.cpp \
   $(NULL)
 
+ifdef ENABLE_TESTS
+TOOL_DIRS += tests
+endif
+
 include $(topsrcdir)/config/config.mk
 include $(topsrcdir)/ipc/chromium/chromium-config.mk
 include $(topsrcdir)/config/rules.mk
diff --git a/js/jetpack/PJetpack.ipdl b/js/jetpack/PJetpack.ipdl
--- a/js/jetpack/PJetpack.ipdl
+++ b/js/jetpack/PJetpack.ipdl
@@ -30,19 +30,62 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
+include protocol PHandle;
+
+using mozilla::void_t;
+using mozilla::null_t;
+
 namespace mozilla {
 namespace jetpack {
 
-async protocol PJetpack
-{
-child:
-  async LoadImplementation(nsCString script);
+struct KeyValue {
+  nsString key;
+  Variant value;
 };
 
-}
-}
+union PrimVariant {
+  void_t;
+  null_t;
+  bool;
+  int;
+  double;
+  nsString;
+  PHandle;
+};
+
+union CompVariant {
+  KeyValue[];
+  Variant[];
+  size_t; // reference
+};
+  
+union Variant {
+  PrimVariant;
+  CompVariant;
+};
+
+sync protocol PJetpack
+{
+  manages PHandle;
+both:
+  async SendMessage(nsString messageName,
+                    Variant[] data);
+  async PHandle();
+
+child:
+  async LoadImplementation(nsCString code);
+  async LoadUserScript(nsCString code);
+
+parent:
+  sync CallMessage(nsString messageName,
+                   Variant[] data)
+    returns (Variant[] results);
+
+};
+
+}}
diff --git a/js/jetpack/jar.mn b/js/jetpack/jar.mn
new file mode 100644
--- /dev/null
+++ b/js/jetpack/jar.mn
@@ -0,0 +1,3 @@
+toolkit.jar:
+        content/global/jetpack/test-impl.js (tests/unit/impl.js)
+        content/global/jetpack/test-user.js (tests/unit/user.js)
diff --git a/js/jetpack/nsIJetpack.idl b/js/jetpack/nsIJetpack.idl
--- a/js/jetpack/nsIJetpack.idl
+++ b/js/jetpack/nsIJetpack.idl
@@ -32,13 +32,29 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
 
-[scriptable, uuid(be12cc9f-75d4-4f2d-b062-f549ea13446a)]
+interface nsIVariant;
+
+[scriptable, uuid(563afdf8-5d2f-4bb2-9ac0-fb82461d2922)]
 interface nsIJetpack : nsISupports
 {
+  void sendMessage(in AString aMessageName
+                   /* [optional] in jsval v1,
+                      [optional] in jsval v2,
+                      ... */);
+
+  void registerReceiver(in AString aMessageName,
+                        in jsval aReceiver);
+  void unregisterReceiver(in AString aMessageName,
+                          in jsval aReceiver);
+  void unregisterReceivers(in AString aMessageName);
+
   void loadImplementation(in AString aURI);
+  void loadUserScript(in AString aURI);
+
+  nsIVariant createHandle();
 };
diff --git a/js/jetpack/tests/Makefile.in b/js/jetpack/tests/Makefile.in
new file mode 100644
--- /dev/null
+++ b/js/jetpack/tests/Makefile.in
@@ -0,0 +1,50 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# The Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2010
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Newman <b{enjam,newma}n@mozilla.com> (original author)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH     = ../../..
+topsrcdir = @top_srcdir@
+srcdir    = @srcdir@
+VPATH     = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE = test_jetpack
+
+XPCSHELL_TESTS = unit
+
+include $(topsrcdir)/config/config.mk
+include $(topsrcdir)/config/rules.mk
diff --git a/js/jetpack/tests/unit/impl.js b/js/jetpack/tests/unit/impl.js
new file mode 100644
--- /dev/null
+++ b/js/jetpack/tests/unit/impl.js
@@ -0,0 +1,37 @@
+function echo() {
+  sendMessage.apply(this, arguments);
+}
+
+registerReceiver("echo", echo);
+
+registerReceiver("callback",
+                 function(msgName, data, handle) {
+                   sendMessage("sendback",
+                               callMessage("callback", data)[0],
+                               handle);
+                 });
+
+registerReceiver("gimmeHandle",
+                 function(msgName) {
+                   sendMessage("recvHandle", "ok", createHandle());
+                 });
+
+registerReceiver("kthx",
+                 function(msgName, data, child) {
+                   sendMessage("recvHandleAgain", data + data, child.parent);
+                 });
+
+registerReceiver("echo2", echo);
+
+registerReceiver("multireturn begin",
+                 function() {
+                   var results = callMessage("multireturn");
+                   sendMessage.apply(null, ["multireturn check"].concat(results));
+                 });
+
+registerReceiver("testarray",
+                 function(msgName, array) {
+                   sendMessage("testarray", array.reverse());
+                 });
+
+registerReceiver("test primitive types", echo);
diff --git a/js/jetpack/tests/unit/test_jetpack.js b/js/jetpack/tests/unit/test_jetpack.js
new file mode 100644
--- /dev/null
+++ b/js/jetpack/tests/unit/test_jetpack.js
@@ -0,0 +1,150 @@
+var jps = jps || Components.classes["@mozilla.org/jetpack/service;1"]
+  .getService(Components.interfaces.nsIJetpackService);
+
+function run_test() {
+  var jetpack = jps.createJetpack();
+  jetpack.loadImplementation(
+    "chrome://global/content/jetpack/test-impl.js");
+  jetpack.loadUserScript(
+    "chrome://global/content/jetpack/test-user.js");
+
+  var circ1 = {},
+      circ2 = {},
+      circ3 = {},
+      ok = false;
+  ((circ1.next = circ2).next = circ3).next = circ1;
+  try {
+    jetpack.sendMessage("ignored", circ3, circ1);
+    ok = true;
+  } catch (x) {
+    do_check_false(x);
+  }
+  do_check_true(ok);
+
+  var bad = {
+    self: "bad",
+    obj: {
+      fn: function() { return this.foo },
+      foo: 42
+    }
+  }, threw, str = "no methods";
+  try { jetpack.sendMessage(str, bad) }
+  catch (x) { threw = str }
+  do_check_eq(threw, str);
+
+  var echoHandle = jetpack.createHandle();
+  echoHandle.payload = { weight: 10 };
+  jetpack.registerReceiver("echo",
+                           function(msgName, data, handle) {
+                             do_check_eq(arguments.length, 3);
+                             do_check_eq(msgName, "echo");
+                             do_check_eq(data, "echo this");
+                             do_check_true(handle.isValid);
+                             do_check_eq(handle, echoHandle);
+                             do_check_eq(handle.payload.weight, 10);
+                             do_test_finished();
+                           });
+
+  jetpack.registerReceiver("callback",
+                           function(msgName, data) {
+                             do_check_eq(msgName, "callback");
+                             return "called back: " + data;
+                           });
+
+  var callbackHandle = echoHandle.createHandle();
+  jetpack.registerReceiver("sendback",
+                           function(msgName, data, handle) {
+                             do_check_eq(msgName, "sendback");
+                             do_check_eq(data, "called back: call me back");
+                             do_check_eq(handle, callbackHandle);
+                             do_test_finished();
+                           });
+
+  var obj;
+  jetpack.registerReceiver("recvHandle",
+                           function(msgName, data, handle) {
+                             handle.mark = obj = {};
+                             jetpack.sendMessage("kthx", data + data, handle.createHandle());
+                           });
+  jetpack.registerReceiver("recvHandleAgain",
+                           function(msgName, data, handle) {
+                             do_check_eq(data, "okokokok");
+                             do_check_eq(handle.mark, obj);
+                             do_test_finished();
+                           });
+  var obj1 = {
+    id: Math.random() + ""
+  }, obj2 = {
+    id: Math.random() + "",
+    obj: obj1
+  };
+  jetpack.registerReceiver("echo2",
+                           function(msgName, a, b) {
+                             do_check_neq(obj1, a);
+                             do_check_neq(obj2, b);
+                             do_check_eq(obj1.id, a.id);
+                             do_check_eq(obj2.id, b.id);
+                             do_check_eq(obj1.id, obj2.obj.id);
+                             do_test_finished();
+                           });
+
+  jetpack.registerReceiver("multireturn", function() { return obj1 });
+  jetpack.registerReceiver("multireturn", function() { return circ1 });
+  jetpack.registerReceiver("multireturn", function() { return obj2 });
+  jetpack.registerReceiver("multireturn check",
+                           function(msgName, rval1, rval2, rval3) {
+                             do_check_eq(rval1.id, obj1.id);
+                             do_check_eq(rval2.next.next.next, rval2);
+                             do_check_eq(rval3.id, obj2.id);
+                             do_check_eq(rval3.obj.id, obj1.id);
+                             do_test_finished();
+                           });
+
+  var testarray = [1, 1, 2, 3, 5, 8, 13];
+  jetpack.registerReceiver("testarray",
+                           function(msgName, reversed) {
+                             for (var i = 0; i < testarray.length; ++i)
+                               do_check_eq(testarray[i],
+                                           reversed[reversed.length - i - 1]);
+                             do_test_finished();
+                           });
+
+  var undefined;
+  jetpack.registerReceiver("test primitive types",
+                           function(msgName,
+                                    void_val, null_val,
+                                    bool_true, bool_false,
+                                    one, two, nine99,
+                                    one_quarter,
+                                    oyez_str)
+                           {
+                             do_check_true(void_val === undefined);
+                             do_check_true(null_val === null);
+                             do_check_true(bool_true === true);
+                             do_check_true(bool_false === false);
+                             do_check_eq(one, 1);
+                             do_check_eq(two, 2);
+                             do_check_eq(nine99, 999);
+                             do_check_eq(one_quarter, 0.25);
+                             do_check_eq(oyez_str, "oyez");
+
+                             do_test_finished();
+                           });
+
+  do_test_pending();
+  do_test_pending();
+  do_test_pending();
+  do_test_pending();
+  do_test_pending();
+  do_test_pending();
+  do_test_pending();
+
+  jetpack.sendMessage("echo", "echo this", echoHandle);
+  jetpack.sendMessage("callback", "call me back", callbackHandle);
+  jetpack.sendMessage("gimmeHandle");
+  jetpack.sendMessage("echo2", obj1, obj2);
+  jetpack.sendMessage("multireturn begin");
+  jetpack.sendMessage("testarray", testarray);
+  jetpack.sendMessage("test primitive types",
+                      undefined, null, true, false, 1, 2, 999, 1/4, "oyez");
+}
diff --git a/js/jetpack/tests/unit/user.js b/js/jetpack/tests/unit/user.js
new file mode 100644
--- /dev/null
+++ b/js/jetpack/tests/unit/user.js
@@ -0,0 +1,1 @@
+"Jetpack User Context";
diff --git a/toolkit/toolkit-makefiles.sh b/toolkit/toolkit-makefiles.sh
--- a/toolkit/toolkit-makefiles.sh
+++ b/toolkit/toolkit-makefiles.sh
@@ -81,16 +81,17 @@ MAKEFILES_dom="
   dom/src/geolocation/Makefile
   dom/src/json/Makefile
   dom/src/offline/Makefile
   dom/src/storage/Makefile
   dom/src/threads/Makefile
   dom/locales/Makefile
   dom/plugins/Makefile
   js/jetpack/Makefile
+  js/ipc/Makefile
 "
 
 MAKEFILES_editor="
   editor/Makefile
   editor/public/Makefile
   editor/idl/Makefile
   editor/txmgr/Makefile
   editor/txmgr/idl/Makefile
@@ -202,16 +203,20 @@ MAKEFILES_xpconnect="
   js/src/xpconnect/shell/Makefile
   js/src/xpconnect/src/Makefile
   js/src/xpconnect/loader/Makefile
   js/src/xpconnect/tests/Makefile
   js/src/xpconnect/tests/components/Makefile
   js/src/xpconnect/tests/idl/Makefile
 "
 
+MAKEFILES_jetpack="
+  js/jetpack/Makefile
+"
+
 MAKEFILES_jsdebugger="
   js/jsd/Makefile
   js/jsd/idl/Makefile
 "
 
 MAKEFILES_content="
   content/Makefile
   content/base/Makefile
@@ -802,16 +807,17 @@ add_makefiles "
   $MAKEFILES_db
   $MAKEFILES_dom
   $MAKEFILES_editor
   $MAKEFILES_xmlparser
   $MAKEFILES_gfx
   $MAKEFILES_htmlparser
   $MAKEFILES_intl
   $MAKEFILES_xpconnect
+  $MAKEFILES_jetpack
   $MAKEFILES_jsdebugger
   $MAKEFILES_jsctypes
   $MAKEFILES_content
   $MAKEFILES_layout
   $MAKEFILES_libimg
   $MAKEFILES_libjar
   $MAKEFILES_libreg
   $MAKEFILES_libpref
diff --git a/toolkit/toolkit-tiers.mk b/toolkit/toolkit-tiers.mk
--- a/toolkit/toolkit-tiers.mk
+++ b/toolkit/toolkit-tiers.mk
@@ -99,17 +99,17 @@ ifeq ($(OS_ARCH),WINCE)
 tier_platform_dirs += modules/lib7z
 endif
 
 #
 # "gecko" - core components
 #
 
 ifdef MOZ_IPC
-tier_platform_dirs += ipc js/jetpack
+tier_platform_dirs += ipc js/jetpack js/ipc
 endif
 
 tier_platform_dirs += \
 		js/src/xpconnect \
 		intl/chardet \
 		$(NULL)
 
 ifdef MOZ_ENABLE_GTK2
