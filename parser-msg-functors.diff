diff --git a/parser/htmlparser/src/nsParser.cpp b/parser/htmlparser/src/nsParser.cpp
--- a/parser/htmlparser/src/nsParser.cpp
+++ b/parser/htmlparser/src/nsParser.cpp
@@ -66,16 +66,19 @@
 #include "nsStreamUtils.h"
 #include "nsHTMLTokenizer.h"
 #include "nsIDocument.h"
 #include "nsNetUtil.h"
 #include "nsScriptLoader.h"
 #include "nsDataHashtable.h"
 #include "nsIThreadPool.h"
 #include "nsXPCOMCIDInternal.h"
+
+#include "Functor.h"
+#include "Bind.h"
 
 #ifdef MOZ_VIEW_SOURCE
 #include "nsViewSourceHTML.h"
 #endif
 
 #define NS_PARSER_FLAG_PARSER_ENABLED         0x00000002
 #define NS_PARSER_FLAG_OBSERVERS_ENABLED      0x00000004
 #define NS_PARSER_FLAG_PENDING_CONTINUE_EVENT 0x00000008
@@ -1689,31 +1692,40 @@ nsParser::Terminate(void)
     // got any data).  Manually break the reference cycle with the sink.
     result = mSink->DidBuildModel();
     NS_ENSURE_SUCCESS(result, result);
   }
 
   return NS_OK;
 }
 
-NS_IMETHODIMP
-nsParser::ContinueParsing()
+
+#define SIMPLE_PROXY(RTYPE, EVENT)                                            \
+  NS_IMETHODIMP_(RTYPE) nsParser::EVENT() {                                   \
+    Functor<RTYPE, TLIST0()>                                                  \
+           f(nsRefPtr<nsParser>(this),                                        \
+             &nsParser::Handle##EVENT);                                       \
+    return f();                                                               \
+  }                                                                           \
+  RTYPE nsParser::Handle##EVENT()
+
+
+SIMPLE_PROXY(nsresult, ContinueParsing)
 {
   if (mFlags & NS_PARSER_FLAG_PARSER_ENABLED) {
     NS_WARNING("Trying to continue parsing on a unblocked parser.");
     return NS_OK;
   }
 
   mFlags |= NS_PARSER_FLAG_PARSER_ENABLED;
 
   return ContinueInterruptedParsing();
 }
 
-NS_IMETHODIMP
-nsParser::ContinueInterruptedParsing()
+SIMPLE_PROXY(nsresult, ContinueInterruptedParsing)
 {
   // If there are scripts executing, then the content sink is jumping the gun
   // (probably due to a synchronous XMLHttpRequest) and will re-enable us
   // later, see bug 460706.
   if (mScriptsExecuting) {
     return NS_OK;
   }
 
@@ -1748,32 +1760,30 @@ nsParser::ContinueInterruptedParsing()
 
   return result;
 }
 
 /**
  *  Stops parsing temporarily. That's it will prevent the
  *  parser from building up content model.
  */
-NS_IMETHODIMP_(void)
-nsParser::BlockParser()
+SIMPLE_PROXY(void, BlockParser)
 {
   mFlags &= ~NS_PARSER_FLAG_PARSER_ENABLED;
   MOZ_TIMER_DEBUGLOG(("Stop: Parse Time: nsParser::BlockParser(), this=%p\n", this));
   MOZ_TIMER_STOP(mParseTime);
 }
 
 /**
  *  Open up the parser for tokenization, building up content
  *  model..etc. However, this method does not resume parsing
  *  automatically. It's the callers' responsibility to restart
  *  the parsing engine.
  */
-NS_IMETHODIMP_(void)
-nsParser::UnblockParser()
+SIMPLE_PROXY(void, UnblockParser)
 {
   if (!(mFlags & NS_PARSER_FLAG_PARSER_ENABLED)) {
     mFlags |= NS_PARSER_FLAG_PARSER_ENABLED;
     MOZ_TIMER_DEBUGLOG(("Start: Parse Time: nsParser::UnblockParser(), this=%p\n", this));
     MOZ_TIMER_START(mParseTime);
   } else {
     NS_WARNING("Trying to unblock an unblocked parser.");
   }
@@ -1877,52 +1887,69 @@ nsParser::SetCanInterrupt(PRBool aCanInt
  *  of this method.
  */
 NS_IMETHODIMP
 nsParser::Parse(nsIURI* aURL,
                 nsIRequestObserver* aListener,
                 void* aKey,
                 nsDTDMode aMode)
 {
+  NS_PRECONDITION(aURL, "Error: Null URL given");
+  NS_ENSURE_TRUE(aURL, kBadURL);
 
-  NS_PRECONDITION(aURL, "Error: Null URL given");
+  nsCAutoString spec;
+  nsresult rv = aURL->GetSpec(spec);
+  if (rv != NS_OK) {
+    return rv;
+  }
+  NS_ConvertUTF8toUTF16 theName(spec);
+
+  Functor<nsresult, TLIST4(nsString,
+                           nsRefPtr<nsIRequestObserver>,
+                           void*,
+                           nsDTDMode)>
+         f(nsRefPtr<nsParser>(this),
+           &nsParser::HandleParseUrl);
+  return BIND4(f, theName, aListener, aKey, aMode)();
+}
+
+nsresult
+nsParser::HandleParseUrl(nsString& theName,
+                         nsIRequestObserver* aListener,
+                         void* aKey,
+                         nsDTDMode aMode)
+{
   NS_ASSERTION(!mSpeculativeScriptThread, "Can't reuse a parser like this");
 
   nsresult result=kBadURL;
+  // Technically this should happen even if aURL was null, but the truthiness
+  // of aURL is supposedly a precondition, so I've opted for the simpler route.
   mObserver = aListener;
 
-  if (aURL) {
-    nsCAutoString spec;
-    nsresult rv = aURL->GetSpec(spec);
-    if (rv != NS_OK) {
-      return rv;
-    }
-    NS_ConvertUTF8toUTF16 theName(spec);
+  nsScanner* theScanner = new nsScanner(theName, PR_FALSE, mCharset,
+                                        mCharsetSource);
+  CParserContext* pc = new CParserContext(theScanner, aKey, mCommand,
+                                          aListener);
+  if (pc && theScanner) {
+    pc->mMultipart = PR_TRUE;
+    pc->mContextType = CParserContext::eCTURL;
+    pc->mDTDMode = aMode;
+    PushContext(*pc);
 
-    nsScanner* theScanner = new nsScanner(theName, PR_FALSE, mCharset,
-                                          mCharsetSource);
-    CParserContext* pc = new CParserContext(theScanner, aKey, mCommand,
-                                            aListener);
-    if (pc && theScanner) {
-      pc->mMultipart = PR_TRUE;
-      pc->mContextType = CParserContext::eCTURL;
-      pc->mDTDMode = aMode;
-      PushContext(*pc);
+    // Here, and only here, hand this parser off to the scanner. We
+    // only want to do that here since the only reason the scanner
+    // needs the parser is to call DataAdded() on it, and that's
+    // only ever wanted when parsing from an URI.
+    theScanner->SetParser(this);
 
-      // Here, and only here, hand this parser off to the scanner. We
-      // only want to do that here since the only reason the scanner
-      // needs the parser is to call DataAdded() on it, and that's
-      // only ever wanted when parsing from an URI.
-      theScanner->SetParser(this);
+    result = NS_OK;
+  } else {
+    result = mInternalState = NS_ERROR_HTMLPARSER_BADCONTEXT;
+  }
 
-      result = NS_OK;
-    } else {
-      result = mInternalState = NS_ERROR_HTMLPARSER_BADCONTEXT;
-    }
-  }
   return result;
 }
 
 /**
  * Call this method if all you want to do is parse 1 string full of HTML text.
  * In particular, this method should be called by the DOM when it has an HTML
  * string to feed to the parser in real-time.
  *
@@ -1930,16 +1957,41 @@ nsParser::Parse(nsIURI* aURL,
  * @param   aMimeType tells us what type of content to expect in the given string
  */
 NS_IMETHODIMP
 nsParser::Parse(const nsAString& aSourceBuffer,
                 void* aKey,
                 const nsACString& aMimeType,
                 PRBool aLastCall,
                 nsDTDMode aMode)
+{
+  Functor<nsresult, TLIST5(nsString,
+                           void*,
+                           nsCString,
+                           PRBool,
+                           nsDTDMode)>
+         f(nsRefPtr<nsParser>(this),
+           &nsParser::HandleParseBuffer);
+
+  Functor<nsresult, TLIST0()> f0 =
+    BIND5(f, nsString(aSourceBuffer),
+             aKey,
+             nsCString(aMimeType),
+             aLastCall,
+             aMode);
+
+  return f0();
+}
+
+nsresult
+nsParser::HandleParseBuffer(const nsAString& aSourceBuffer,
+                            void* aKey,
+                            const nsACString& aMimeType,
+                            PRBool aLastCall,
+                            nsDTDMode aMode)
 {
   nsresult result = NS_OK;
 
   // Don't bother if we're never going to parse this.
   if (mInternalState == NS_ERROR_HTMLPARSER_STOPPARSING) {
     return result;
   }
 
@@ -2055,23 +2107,52 @@ nsParser::Parse(const nsAString& aSource
         }
       }
     }
   }
 
   return result;
 }
 
+// TODO compute the tag stack on the parser thread
 NS_IMETHODIMP
 nsParser::ParseFragment(const nsAString& aSourceBuffer,
                         void* aKey,
                         nsTArray<nsString>& aTagStack,
                         PRBool aXMLMode,
                         const nsACString& aMimeType,
                         nsDTDMode aMode)
+{
+  Functor<nsresult, TLIST6(nsString,
+                           void*,
+                           nsTArray<nsString>,
+                           PRBool,
+                           nsCString,
+                           nsDTDMode)>
+         f(nsRefPtr<nsParser>(this),
+           &nsParser::HandleParseFragment);
+
+  Functor<nsresult, TLIST0()> f0 =
+    BIND6(f, nsString(aSourceBuffer),
+             aKey,
+             aTagStack,
+             aXMLMode,
+             nsCString(aMimeType),
+             aMode);
+
+  return f0();
+}
+
+nsresult
+nsParser::HandleParseFragment(const nsAString& aSourceBuffer,
+                              void* aKey,
+                              nsTArray<nsString>& aTagStack,
+                              PRBool aXMLMode,
+                              const nsACString& aMimeType,
+                              nsDTDMode aMode)
 {
   nsresult result = NS_OK;
   nsAutoString  theContext;
   PRUint32 theCount = aTagStack.Length();
   PRUint32 theIndex = 0;
 
   // Disable observers for fragments
   mFlags &= ~NS_PARSER_FLAG_OBSERVERS_ENABLED;
@@ -2390,16 +2471,26 @@ nsParser::BuildModel()
 }
 
 /*******************************************************************
   These methods are used to talk to the netlib system...
  *******************************************************************/
 
 nsresult
 nsParser::OnStartRequest(nsIRequest *request, nsISupports* aContext)
+{
+  Functor<nsresult, TLIST2(nsRefPtr<nsIRequest>,
+                           nsRefPtr<nsISupports>)>
+         f(nsRefPtr<nsParser>(this),
+           &nsParser::HandleStartRequest);
+  return BIND2(f, request, aContext)();
+}
+
+nsresult
+nsParser::HandleStartRequest(nsIRequest *request, nsISupports* aContext)
 {
   NS_PRECONDITION(eNone == mParserContext->mStreamListenerState,
                   "Parser's nsIStreamListener API was not setup "
                   "correctly in constructor.");
   if (mObserver) {
     mObserver->OnStartRequest(request, aContext);
   }
   mParserContext->mStreamListenerState = eOnStart;
@@ -2813,32 +2904,48 @@ CheckCharset(const char* aBytes,
   }
 }
 
 nsresult
 nsParser::OnDataAvailable(nsIRequest *request, nsISupports* aContext,
                           nsIInputStream *pIStream, PRUint32 sourceOffset,
                           PRUint32 aLength)
 {
-  NS_PRECONDITION((eOnStart == mParserContext->mStreamListenerState ||
-                   eOnDataAvail == mParserContext->mStreamListenerState),
-            "Error: OnStartRequest() must be called before OnDataAvailable()");
   NS_PRECONDITION(NS_InputStreamIsBuffered(pIStream),
                   "Must have a buffered input stream");
 
-  nsresult rv = NS_OK;
-
   char *data = new char[aLength + 1];
   PRUint32 totalRead;
-  rv = pIStream->Read(data, aLength, &totalRead);
+  nsresult rv = pIStream->Read(data, aLength, &totalRead);
   if (NS_FAILED(rv)) {
     delete[] data;
     return rv;
   }
   data[aLength] = 0;
+
+  Functor<nsresult, TLIST4(nsRefPtr<nsIRequest>,
+                           char*,
+                           PRUint32,
+                           PRUint32)>
+    f(nsRefPtr<nsParser>(this),
+      &nsParser::HandleDataAvailable);
+  return BIND4(f, request, data, totalRead, sourceOffset)();
+}
+
+nsresult
+nsParser::HandleDataAvailable(nsIRequest* request,
+                              char* data,
+                              PRUint32 totalRead,
+                              PRUint32 sourceOffset)
+{
+  NS_PRECONDITION((eOnStart == mParserContext->mStreamListenerState ||
+                   eOnDataAvail == mParserContext->mStreamListenerState),
+            "Error: OnStartRequest() must be called before OnDataAvailable()");
+
+  nsresult rv = NS_OK;
 
   CParserContext *theContext = mParserContext;
 
   while (theContext && theContext->mRequest != request) {
     theContext = theContext->mPrevContext;
   }
 
   if (theContext) {
@@ -2884,16 +2991,28 @@ nsParser::OnDataAvailable(nsIRequest *re
 
 /**
  *  This is called by the networking library once the last block of data
  *  has been collected from the net.
  */
 nsresult
 nsParser::OnStopRequest(nsIRequest *request, nsISupports* aContext,
                         nsresult status)
+{
+  Functor<nsresult, TLIST3(nsRefPtr<nsIRequest>,
+                           nsRefPtr<nsISupports>,
+                           nsresult)>
+         f(nsRefPtr<nsParser>(this),
+           &nsParser::HandleStopRequest);
+  return BIND3(f, request, aContext, status)();
+}
+
+nsresult
+nsParser::HandleStopRequest(nsIRequest *request, nsISupports* aContext,
+                            nsresult status)
 {
   nsresult rv = NS_OK;
 
   if (mSpeculativeScriptThread) {
     mSpeculativeScriptThread->StopParsing(PR_FALSE);
   }
 
   CParserContext *pc = mParserContext;
diff --git a/parser/htmlparser/src/nsParser.h b/parser/htmlparser/src/nsParser.h
--- a/parser/htmlparser/src/nsParser.h
+++ b/parser/htmlparser/src/nsParser.h
@@ -399,17 +399,17 @@ class nsParser : public nsIParser,
     virtual void ScriptExecuting();
 
     /**
      * Tells the parser that the script is done executing. We should now
      * continue the regular parsing process.
      */
     virtual void ScriptDidExecute();
 
- protected:
+protected:
 
     void Initialize(PRBool aConstructor = PR_FALSE);
     void Cleanup();
 
     /**
      * 
      * @update	gess5/18/98
      * @param 
@@ -421,16 +421,65 @@ class nsParser : public nsIParser,
      * 
      * @update	gess5/18/98
      * @param 
      * @return
      */
     nsresult DidBuildModel(nsresult anErrorCode);
 
     void SpeculativelyParse();
+
+    // TODO move these handlers nearer to their counterparts
+
+    nsresult HandleContinueParsing();
+    nsresult HandleContinueInterruptedParsing();
+    void     HandleBlockParser();
+    void     HandleUnblockParser();
+
+    nsresult
+    HandleStartRequest(
+      nsIRequest*  request,
+      nsISupports* context);
+
+    nsresult
+    HandleDataAvailable(
+      nsIRequest* request,
+      char*       bytes,
+      PRUint32    numBytes,
+      PRUint32    sourceOffset);
+
+    nsresult
+    HandleStopRequest(
+      nsIRequest*  request,
+      nsISupports* context,
+      nsresult     status);
+    
+    nsresult
+    HandleParseUrl(
+      nsString& spec,
+      nsIRequestObserver* aListener,
+      void* aKey,
+      nsDTDMode aMode);
+
+    nsresult
+    HandleParseBuffer(
+      const nsAString& aSourceBuffer,
+      void* aKey,
+      const nsACString& aMimeType,
+      PRBool aLastCall,
+      nsDTDMode aMode);
+
+    nsresult
+    HandleParseFragment(
+      const nsAString& aSourceBuffer,
+      void* aKey,
+      nsTArray<nsString>& aTagStack,
+      PRBool aXMLMode,
+      const nsACString& aMimeType,
+      nsDTDMode aMode);
 
 private:
 
     /*******************************************
       These are the tokenization methods...
      *******************************************/
 
     /**
