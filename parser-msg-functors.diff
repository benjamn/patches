diff --git a/parser/htmlparser/src/nsParser.cpp b/parser/htmlparser/src/nsParser.cpp
--- a/parser/htmlparser/src/nsParser.cpp
+++ b/parser/htmlparser/src/nsParser.cpp
@@ -66,16 +66,19 @@
 #include "nsStreamUtils.h"
 #include "nsHTMLTokenizer.h"
 #include "nsIDocument.h"
 #include "nsNetUtil.h"
 #include "nsScriptLoader.h"
 #include "nsDataHashtable.h"
 #include "nsIThreadPool.h"
 #include "nsXPCOMCIDInternal.h"
+
+#include "Functor.h"
+#include "Bind.h"
 
 #ifdef MOZ_VIEW_SOURCE
 #include "nsViewSourceHTML.h"
 #endif
 
 #define NS_PARSER_FLAG_PARSER_ENABLED         0x00000002
 #define NS_PARSER_FLAG_OBSERVERS_ENABLED      0x00000004
 #define NS_PARSER_FLAG_PENDING_CONTINUE_EVENT 0x00000008
@@ -2385,16 +2388,26 @@ nsParser::BuildModel()
 
 /*******************************************************************
   These methods are used to talk to the netlib system...
  *******************************************************************/
 
 nsresult
 nsParser::OnStartRequest(nsIRequest *request, nsISupports* aContext)
 {
+  Functor<nsresult, TLIST2(nsCOMPtr<nsIRequest>,
+                           nsCOMPtr<nsISupports>)>
+         f(nsRefPtr<nsParser>(this),
+           &nsParser::HandleStartRequest);
+  return BIND2(f, request, aContext)();
+}
+
+nsresult
+nsParser::HandleStartRequest(nsIRequest *request, nsISupports* aContext)
+{
   NS_PRECONDITION(eNone == mParserContext->mStreamListenerState,
                   "Parser's nsIStreamListener API was not setup "
                   "correctly in constructor.");
   if (mObserver) {
     mObserver->OnStartRequest(request, aContext);
   }
   mParserContext->mStreamListenerState = eOnStart;
   mParserContext->mAutoDetectStatus = eUnknownDetect;
@@ -2807,32 +2820,48 @@ CheckCharset(const char* aBytes,
   }
 }
 
 nsresult
 nsParser::OnDataAvailable(nsIRequest *request, nsISupports* aContext,
                           nsIInputStream *pIStream, PRUint32 sourceOffset,
                           PRUint32 aLength)
 {
-  NS_PRECONDITION((eOnStart == mParserContext->mStreamListenerState ||
-                   eOnDataAvail == mParserContext->mStreamListenerState),
-            "Error: OnStartRequest() must be called before OnDataAvailable()");
   NS_PRECONDITION(NS_InputStreamIsBuffered(pIStream),
                   "Must have a buffered input stream");
 
-  nsresult rv = NS_OK;
-
   char *data = new char[aLength + 1];
   PRUint32 totalRead;
-  rv = pIStream->Read(data, aLength, &totalRead);
+  nsresult rv = pIStream->Read(data, aLength, &totalRead);
   if (NS_FAILED(rv)) {
     delete[] data;
     return rv;
   }
   data[aLength] = 0;
+
+  Functor<nsresult, TLIST4(nsCOMPtr<nsIRequest>,
+                           char*,
+                           PRUint32,
+                           PRUint32)>
+    f(nsRefPtr<nsParser>(this),
+      &nsParser::HandleDataAvailable);
+  return BIND4(f, request, data, totalRead, sourceOffset)();
+}
+
+nsresult
+nsParser::HandleDataAvailable(nsIRequest* request,
+                              char* data,
+                              PRUint32 totalRead,
+                              PRUint32 sourceOffset)
+{
+  NS_PRECONDITION((eOnStart == mParserContext->mStreamListenerState ||
+                   eOnDataAvail == mParserContext->mStreamListenerState),
+            "Error: OnStartRequest() must be called before OnDataAvailable()");
+
+  nsresult rv = NS_OK;
 
   CParserContext *theContext = mParserContext;
 
   while (theContext && theContext->mRequest != request) {
     theContext = theContext->mPrevContext;
   }
 
   if (theContext) {
@@ -2878,16 +2907,28 @@ nsParser::OnDataAvailable(nsIRequest *re
 
 /**
  *  This is called by the networking library once the last block of data
  *  has been collected from the net.
  */
 nsresult
 nsParser::OnStopRequest(nsIRequest *request, nsISupports* aContext,
                         nsresult status)
+{
+  Functor<nsresult, TLIST3(nsCOMPtr<nsIRequest>,
+                           nsCOMPtr<nsISupports>,
+                           nsresult)>
+         f(nsRefPtr<nsParser>(this),
+           &nsParser::HandleStopRequest);
+  return BIND3(f, request, aContext, status)();
+}
+
+nsresult
+nsParser::HandleStopRequest(nsIRequest *request, nsISupports* aContext,
+                            nsresult status)
 {
   nsresult rv = NS_OK;
 
   if (mSpeculativeScriptThread) {
     mSpeculativeScriptThread->StopParsing(PR_FALSE);
   }
 
   CParserContext *pc = mParserContext;
diff --git a/parser/htmlparser/src/nsParser.h b/parser/htmlparser/src/nsParser.h
--- a/parser/htmlparser/src/nsParser.h
+++ b/parser/htmlparser/src/nsParser.h
@@ -422,16 +422,34 @@ class nsParser : public nsIParser,
      * @update	gess5/18/98
      * @param 
      * @return
      */
     nsresult DidBuildModel(nsresult anErrorCode);
 
     void SpeculativelyParse();
 
+    nsresult
+    nsParser::HandleStartRequest(
+      nsIRequest*  request,
+      nsISupports* context);
+
+    nsresult
+    HandleDataAvailable(
+      nsIRequest* request,
+      char*       bytes,
+      PRUint32    numBytes,
+      PRUint32    sourceOffset);
+
+    nsresult
+    HandleStopRequest(
+      nsIRequest*  request,
+      nsISupports* context,
+      nsresult     status);
+
 private:
 
     /*******************************************
       These are the tokenization methods...
      *******************************************/
 
     /**
      *  Part of the code sandwich, this gets called right before
