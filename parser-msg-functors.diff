diff --git a/parser/htmlparser/src/nsParser.cpp b/parser/htmlparser/src/nsParser.cpp
--- a/parser/htmlparser/src/nsParser.cpp
+++ b/parser/htmlparser/src/nsParser.cpp
@@ -66,16 +66,19 @@
 #include "nsStreamUtils.h"
 #include "nsHTMLTokenizer.h"
 #include "nsIDocument.h"
 #include "nsNetUtil.h"
 #include "nsScriptLoader.h"
 #include "nsDataHashtable.h"
 #include "nsIThreadPool.h"
 #include "nsXPCOMCIDInternal.h"
+
+#include "Functor.h"
+#include "Bind.h"
 
 #ifdef MOZ_VIEW_SOURCE
 #include "nsViewSourceHTML.h"
 #endif
 
 #define NS_PARSER_FLAG_PARSER_ENABLED         0x00000002
 #define NS_PARSER_FLAG_OBSERVERS_ENABLED      0x00000004
 #define NS_PARSER_FLAG_PENDING_CONTINUE_EVENT 0x00000008
@@ -1689,31 +1692,40 @@ nsParser::Terminate(void)
     // got any data).  Manually break the reference cycle with the sink.
     result = mSink->DidBuildModel();
     NS_ENSURE_SUCCESS(result, result);
   }
 
   return NS_OK;
 }
 
-NS_IMETHODIMP
-nsParser::ContinueParsing()
+
+#define SIMPLE_PROXY(RTYPE, EVENT)                                            \
+  NS_IMETHODIMP_(RTYPE) nsParser::EVENT() {                                   \
+    Functor<RTYPE, TLIST0()>                                                  \
+           f(nsRefPtr<nsParser>(this),                                        \
+             &nsParser::Handle##EVENT);                                       \
+    return f();                                                               \
+  }                                                                           \
+  RTYPE nsParser::Handle##EVENT()
+
+
+SIMPLE_PROXY(nsresult, ContinueParsing)
 {
   if (mFlags & NS_PARSER_FLAG_PARSER_ENABLED) {
     NS_WARNING("Trying to continue parsing on a unblocked parser.");
     return NS_OK;
   }
 
   mFlags |= NS_PARSER_FLAG_PARSER_ENABLED;
 
   return ContinueInterruptedParsing();
 }
 
-NS_IMETHODIMP
-nsParser::ContinueInterruptedParsing()
+SIMPLE_PROXY(nsresult, ContinueInterruptedParsing)
 {
   // If there are scripts executing, then the content sink is jumping the gun
   // (probably due to a synchronous XMLHttpRequest) and will re-enable us
   // later, see bug 460706.
   if (mScriptsExecuting) {
     return NS_OK;
   }
 
@@ -1748,32 +1760,30 @@ nsParser::ContinueInterruptedParsing()
 
   return result;
 }
 
 /**
  *  Stops parsing temporarily. That's it will prevent the
  *  parser from building up content model.
  */
-NS_IMETHODIMP_(void)
-nsParser::BlockParser()
+SIMPLE_PROXY(void, BlockParser)
 {
   mFlags &= ~NS_PARSER_FLAG_PARSER_ENABLED;
   MOZ_TIMER_DEBUGLOG(("Stop: Parse Time: nsParser::BlockParser(), this=%p\n", this));
   MOZ_TIMER_STOP(mParseTime);
 }
 
 /**
  *  Open up the parser for tokenization, building up content
  *  model..etc. However, this method does not resume parsing
  *  automatically. It's the callers' responsibility to restart
  *  the parsing engine.
  */
-NS_IMETHODIMP_(void)
-nsParser::UnblockParser()
+SIMPLE_PROXY(void, UnblockParser)
 {
   if (!(mFlags & NS_PARSER_FLAG_PARSER_ENABLED)) {
     mFlags |= NS_PARSER_FLAG_PARSER_ENABLED;
     MOZ_TIMER_DEBUGLOG(("Start: Parse Time: nsParser::UnblockParser(), this=%p\n", this));
     MOZ_TIMER_START(mParseTime);
   } else {
     NS_WARNING("Trying to unblock an unblocked parser.");
   }
@@ -1877,31 +1887,49 @@ nsParser::SetCanInterrupt(PRBool aCanInt
  *  of this method.
  */
 NS_IMETHODIMP
 nsParser::Parse(nsIURI* aURL,
                 nsIRequestObserver* aListener,
                 void* aKey,
                 nsDTDMode aMode)
 {
+  NS_PRECONDITION(aURL, "Error: Null URL given");
+  NS_ENSURE_TRUE(aURL, kBadURL);
 
-  NS_PRECONDITION(aURL, "Error: Null URL given");
+  nsCAutoString spec;
+  nsresult rv = aURL->GetSpec(spec);
+  if (rv != NS_OK) {
+    return rv;
+  }
+  NS_ConvertUTF8toUTF16 theName(spec);
+
+  Functor<nsresult, TLIST4(nsString,
+                           nsRefPtr<nsIRequestObserver>,
+                           void*,
+                           nsDTDMode)>
+         f(nsRefPtr<nsParser>(this),
+           &nsParser::HandleParseUrl);
+  return BIND4(f, theName, aListener, aKey, aMode)();
+}
+
+nsresult
+nsParser::HandleParseUrl(nsString& theName,
+                         nsIRequestObserver* aListener,
+                         void* aKey,
+                         nsDTDMode aMode)
+{
   NS_ASSERTION(!mSpeculativeScriptThread, "Can't reuse a parser like this");
 
   nsresult result=kBadURL;
+  // Technically this should happen even if aURL was null, but the truthiness
+  // of aURL is supposedly a precondition, so I've opted for the simpler route.
   mObserver = aListener;
 
-  if (aURL) {
-    nsCAutoString spec;
-    nsresult rv = aURL->GetSpec(spec);
-    if (rv != NS_OK) {
-      return rv;
-    }
-    NS_ConvertUTF8toUTF16 theName(spec);
-
+  if (PR_TRUE) {
     nsScanner* theScanner = new nsScanner(theName, PR_FALSE, mCharset,
                                           mCharsetSource);
     CParserContext* pc = new CParserContext(theScanner, aKey, mCommand,
                                             aListener);
     if (pc && theScanner) {
       pc->mMultipart = PR_TRUE;
       pc->mContextType = CParserContext::eCTURL;
       pc->mDTDMode = aMode;
@@ -2390,16 +2418,26 @@ nsParser::BuildModel()
 }
 
 /*******************************************************************
   These methods are used to talk to the netlib system...
  *******************************************************************/
 
 nsresult
 nsParser::OnStartRequest(nsIRequest *request, nsISupports* aContext)
+{
+  Functor<nsresult, TLIST2(nsRefPtr<nsIRequest>,
+                           nsRefPtr<nsISupports>)>
+         f(nsRefPtr<nsParser>(this),
+           &nsParser::HandleStartRequest);
+  return BIND2(f, request, aContext)();
+}
+
+nsresult
+nsParser::HandleStartRequest(nsIRequest *request, nsISupports* aContext)
 {
   NS_PRECONDITION(eNone == mParserContext->mStreamListenerState,
                   "Parser's nsIStreamListener API was not setup "
                   "correctly in constructor.");
   if (mObserver) {
     mObserver->OnStartRequest(request, aContext);
   }
   mParserContext->mStreamListenerState = eOnStart;
@@ -2813,32 +2851,48 @@ CheckCharset(const char* aBytes,
   }
 }
 
 nsresult
 nsParser::OnDataAvailable(nsIRequest *request, nsISupports* aContext,
                           nsIInputStream *pIStream, PRUint32 sourceOffset,
                           PRUint32 aLength)
 {
-  NS_PRECONDITION((eOnStart == mParserContext->mStreamListenerState ||
-                   eOnDataAvail == mParserContext->mStreamListenerState),
-            "Error: OnStartRequest() must be called before OnDataAvailable()");
   NS_PRECONDITION(NS_InputStreamIsBuffered(pIStream),
                   "Must have a buffered input stream");
 
-  nsresult rv = NS_OK;
-
   char *data = new char[aLength + 1];
   PRUint32 totalRead;
-  rv = pIStream->Read(data, aLength, &totalRead);
+  nsresult rv = pIStream->Read(data, aLength, &totalRead);
   if (NS_FAILED(rv)) {
     delete[] data;
     return rv;
   }
   data[aLength] = 0;
+
+  Functor<nsresult, TLIST4(nsRefPtr<nsIRequest>,
+                           char*,
+                           PRUint32,
+                           PRUint32)>
+    f(nsRefPtr<nsParser>(this),
+      &nsParser::HandleDataAvailable);
+  return BIND4(f, request, data, totalRead, sourceOffset)();
+}
+
+nsresult
+nsParser::HandleDataAvailable(nsIRequest* request,
+                              char* data,
+                              PRUint32 totalRead,
+                              PRUint32 sourceOffset)
+{
+  NS_PRECONDITION((eOnStart == mParserContext->mStreamListenerState ||
+                   eOnDataAvail == mParserContext->mStreamListenerState),
+            "Error: OnStartRequest() must be called before OnDataAvailable()");
+
+  nsresult rv = NS_OK;
 
   CParserContext *theContext = mParserContext;
 
   while (theContext && theContext->mRequest != request) {
     theContext = theContext->mPrevContext;
   }
 
   if (theContext) {
@@ -2884,16 +2938,28 @@ nsParser::OnDataAvailable(nsIRequest *re
 
 /**
  *  This is called by the networking library once the last block of data
  *  has been collected from the net.
  */
 nsresult
 nsParser::OnStopRequest(nsIRequest *request, nsISupports* aContext,
                         nsresult status)
+{
+  Functor<nsresult, TLIST3(nsRefPtr<nsIRequest>,
+                           nsRefPtr<nsISupports>,
+                           nsresult)>
+         f(nsRefPtr<nsParser>(this),
+           &nsParser::HandleStopRequest);
+  return BIND3(f, request, aContext, status)();
+}
+
+nsresult
+nsParser::HandleStopRequest(nsIRequest *request, nsISupports* aContext,
+                            nsresult status)
 {
   nsresult rv = NS_OK;
 
   if (mSpeculativeScriptThread) {
     mSpeculativeScriptThread->StopParsing(PR_FALSE);
   }
 
   CParserContext *pc = mParserContext;
diff --git a/parser/htmlparser/src/nsParser.h b/parser/htmlparser/src/nsParser.h
--- a/parser/htmlparser/src/nsParser.h
+++ b/parser/htmlparser/src/nsParser.h
@@ -399,17 +399,17 @@ class nsParser : public nsIParser,
     virtual void ScriptExecuting();
 
     /**
      * Tells the parser that the script is done executing. We should now
      * continue the regular parsing process.
      */
     virtual void ScriptDidExecute();
 
- protected:
+protected:
 
     void Initialize(PRBool aConstructor = PR_FALSE);
     void Cleanup();
 
     /**
      * 
      * @update	gess5/18/98
      * @param 
@@ -421,16 +421,48 @@ class nsParser : public nsIParser,
      * 
      * @update	gess5/18/98
      * @param 
      * @return
      */
     nsresult DidBuildModel(nsresult anErrorCode);
 
     void SpeculativelyParse();
+
+    // TODO move these handlers nearer to their counterparts
+
+    nsresult HandleContinueParsing();
+    nsresult HandleContinueInterruptedParsing();
+    void     HandleBlockParser();
+    void     HandleUnblockParser();
+
+    nsresult
+    HandleStartRequest(
+      nsIRequest*  request,
+      nsISupports* context);
+
+    nsresult
+    HandleDataAvailable(
+      nsIRequest* request,
+      char*       bytes,
+      PRUint32    numBytes,
+      PRUint32    sourceOffset);
+
+    nsresult
+    HandleStopRequest(
+      nsIRequest*  request,
+      nsISupports* context,
+      nsresult     status);
+    
+    nsresult
+    HandleParseUrl(
+      nsString& spec,
+      nsIRequestObserver* aListener,
+      void* aKey,
+      nsDTDMode aMode);
 
 private:
 
     /*******************************************
       These are the tokenization methods...
      *******************************************/
 
     /**
