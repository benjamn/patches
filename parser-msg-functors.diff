diff --git a/parser/htmlparser/src/nsParser.cpp b/parser/htmlparser/src/nsParser.cpp
--- a/parser/htmlparser/src/nsParser.cpp
+++ b/parser/htmlparser/src/nsParser.cpp
@@ -72,6 +72,9 @@
 #include "nsIThreadPool.h"
 #include "nsXPCOMCIDInternal.h"
 
+#include "Functor.h"
+#include "Bind.h"
+
 #ifdef MOZ_VIEW_SOURCE
 #include "nsViewSourceHTML.h"
 #endif
@@ -811,6 +814,8 @@
            NS_PARSER_FLAG_CAN_TOKENIZE;
   mScriptsExecuting = 0;
 
+  mQueue = new nsFunctorQueue(do_GetMainThread().get());
+
   MOZ_TIMER_DEBUGLOG(("Reset: Parse Time: nsParser::nsParser(), this=%p\n", this));
   MOZ_TIMER_RESET(mParseTime);
   MOZ_TIMER_RESET(mDTDTime);
@@ -1638,13 +1643,22 @@
   return pc->mKey;
 }
 
+
+#define SIMPLE_PROXY(RTYPE, EVENT)                                            \
+  NS_IMETHODIMP_(RTYPE) nsParser::EVENT() {                                   \
+    return (BIND1(&nsParser::Handle##EVENT,                                   \
+                  nsRefPtr<nsParser>(this))(),                                \
+            (RTYPE)NS_OK);                                                    \
+  }                                                                           \
+  RTYPE nsParser::Handle##EVENT()
+
+
 /**
  *  Call this when you want to *force* the parser to terminate the
  *  parsing process altogether. This is binary -- so once you terminate
  *  you can't resume without restarting altogether.
  */
-NS_IMETHODIMP
-nsParser::Terminate(void)
+SIMPLE_PROXY(nsresult, Terminate)
 {
   // We should only call DidBuildModel once, so don't do anything if this is
   // the second time that Terminate has been called.
@@ -1695,8 +1709,8 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
-nsParser::ContinueParsing()
+
+SIMPLE_PROXY(nsresult, ContinueParsing)
 {
   if (mFlags & NS_PARSER_FLAG_PARSER_ENABLED) {
     NS_WARNING("Trying to continue parsing on a unblocked parser.");
@@ -1708,8 +1722,7 @@
   return ContinueInterruptedParsing();
 }
 
-NS_IMETHODIMP
-nsParser::ContinueInterruptedParsing()
+SIMPLE_PROXY(nsresult, ContinueInterruptedParsing)
 {
   // If there are scripts executing, then the content sink is jumping the gun
   // (probably due to a synchronous XMLHttpRequest) and will re-enable us
@@ -1754,8 +1767,7 @@
  *  Stops parsing temporarily. That's it will prevent the
  *  parser from building up content model.
  */
-NS_IMETHODIMP_(void)
-nsParser::BlockParser()
+SIMPLE_PROXY(void, BlockParser)
 {
   mFlags &= ~NS_PARSER_FLAG_PARSER_ENABLED;
   MOZ_TIMER_DEBUGLOG(("Stop: Parse Time: nsParser::BlockParser(), this=%p\n", this));
@@ -1768,8 +1780,7 @@
  *  automatically. It's the callers' responsibility to restart
  *  the parsing engine.
  */
-NS_IMETHODIMP_(void)
-nsParser::UnblockParser()
+SIMPLE_PROXY(void, UnblockParser)
 {
   if (!(mFlags & NS_PARSER_FLAG_PARSER_ENABLED)) {
     mFlags |= NS_PARSER_FLAG_PARSER_ENABLED;
@@ -1883,42 +1894,57 @@
                 void* aKey,
                 nsDTDMode aMode)
 {
+  NS_PRECONDITION(aURL, "Error: Null URL given");
+  NS_ENSURE_TRUE(aURL, kBadURL);
 
-  NS_PRECONDITION(aURL, "Error: Null URL given");
+  nsCAutoString spec;
+  nsresult rv = aURL->GetSpec(spec);
+  if (rv != NS_OK) {
+    return rv;
+  }
+  NS_ConvertUTF8toUTF16 theName(spec);
+
+  mQueue->Enqueue(BIND5(&nsParser::HandleParseUrl,
+    nsRefPtr<nsParser>(this),
+    theName, aListener, aKey, aMode));
+
+  return NS_OK;
+}
+
+nsresult
+nsParser::HandleParseUrl(nsString& theName,
+                         nsIRequestObserver* aListener,
+                         void* aKey,
+                         nsDTDMode aMode)
+{
   NS_ASSERTION(!mSpeculativeScriptThread, "Can't reuse a parser like this");
 
   nsresult result=kBadURL;
+  // Technically this should happen even if aURL was null, but the truthiness
+  // of aURL is supposedly a precondition, so I've opted for the simpler route.
   mObserver = aListener;
 
-  if (aURL) {
-    nsCAutoString spec;
-    nsresult rv = aURL->GetSpec(spec);
-    if (rv != NS_OK) {
-      return rv;
-    }
-    NS_ConvertUTF8toUTF16 theName(spec);
+  nsScanner* theScanner = new nsScanner(theName, PR_FALSE, mCharset,
+                                        mCharsetSource);
+  CParserContext* pc = new CParserContext(theScanner, aKey, mCommand,
+                                          aListener);
+  if (pc && theScanner) {
+    pc->mMultipart = PR_TRUE;
+    pc->mContextType = CParserContext::eCTURL;
+    pc->mDTDMode = aMode;
+    PushContext(*pc);
 
-    nsScanner* theScanner = new nsScanner(theName, PR_FALSE, mCharset,
-                                          mCharsetSource);
-    CParserContext* pc = new CParserContext(theScanner, aKey, mCommand,
-                                            aListener);
-    if (pc && theScanner) {
-      pc->mMultipart = PR_TRUE;
-      pc->mContextType = CParserContext::eCTURL;
-      pc->mDTDMode = aMode;
-      PushContext(*pc);
+    // Here, and only here, hand this parser off to the scanner. We
+    // only want to do that here since the only reason the scanner
+    // needs the parser is to call DataAdded() on it, and that's
+    // only ever wanted when parsing from an URI.
+    theScanner->SetParser(this);
 
-      // Here, and only here, hand this parser off to the scanner. We
-      // only want to do that here since the only reason the scanner
-      // needs the parser is to call DataAdded() on it, and that's
-      // only ever wanted when parsing from an URI.
-      theScanner->SetParser(this);
+    result = NS_OK;
+  } else {
+    result = mInternalState = NS_ERROR_HTMLPARSER_BADCONTEXT;
+  }
 
-      result = NS_OK;
-    } else {
-      result = mInternalState = NS_ERROR_HTMLPARSER_BADCONTEXT;
-    }
-  }
   return result;
 }
 
@@ -1937,6 +1963,17 @@
                 PRBool aLastCall,
                 nsDTDMode aMode)
 {
+  return BIND6(&nsParser::HandleParseBuffer, nsRefPtr<nsParser>(this),
+               nsString(aSourceBuffer), aKey, nsCString(aMimeType), aLastCall, aMode)();
+}
+
+nsresult
+nsParser::HandleParseBuffer(const nsAString& aSourceBuffer,
+                            void* aKey,
+                            const nsACString& aMimeType,
+                            PRBool aLastCall,
+                            nsDTDMode aMode)
+{
   nsresult result = NS_OK;
 
   // Don't bother if we're never going to parse this.
@@ -2061,6 +2098,7 @@
   return result;
 }
 
+// TODO compute the tag stack on the parser thread
 NS_IMETHODIMP
 nsParser::ParseFragment(const nsAString& aSourceBuffer,
                         void* aKey,
@@ -2069,6 +2107,19 @@
                         const nsACString& aMimeType,
                         nsDTDMode aMode)
 {
+  return BIND7(&nsParser::HandleParseFragment, nsRefPtr<nsParser>(this),
+               nsString(aSourceBuffer), aKey, aTagStack, aXMLMode,
+               nsCString(aMimeType), aMode)();
+}
+
+nsresult
+nsParser::HandleParseFragment(const nsAString& aSourceBuffer,
+                              void* aKey,
+                              nsTArray<nsString>& aTagStack,
+                              PRBool aXMLMode,
+                              const nsACString& aMimeType,
+                              nsDTDMode aMode)
+{
   nsresult result = NS_OK;
   nsAutoString  theContext;
   PRUint32 theCount = aTagStack.Length();
@@ -2397,6 +2448,15 @@
 nsresult
 nsParser::OnStartRequest(nsIRequest *request, nsISupports* aContext)
 {
+  mQueue->Enqueue(BIND3(&nsParser::HandleStartRequest,
+    nsRefPtr<nsParser>(this),
+    request, aContext));
+  return NS_OK;
+}
+
+nsresult
+nsParser::HandleStartRequest(nsIRequest *request, nsISupports* aContext)
+{
   NS_PRECONDITION(eNone == mParserContext->mStreamListenerState,
                   "Parser's nsIStreamListener API was not setup "
                   "correctly in constructor.");
@@ -2819,23 +2879,37 @@
                           nsIInputStream *pIStream, PRUint32 sourceOffset,
                           PRUint32 aLength)
 {
-  NS_PRECONDITION((eOnStart == mParserContext->mStreamListenerState ||
-                   eOnDataAvail == mParserContext->mStreamListenerState),
-            "Error: OnStartRequest() must be called before OnDataAvailable()");
   NS_PRECONDITION(NS_InputStreamIsBuffered(pIStream),
                   "Must have a buffered input stream");
 
-  nsresult rv = NS_OK;
-
   char *data = new char[aLength + 1];
   PRUint32 totalRead;
-  rv = pIStream->Read(data, aLength, &totalRead);
+  nsresult rv = pIStream->Read(data, aLength, &totalRead);
   if (NS_FAILED(rv)) {
     delete[] data;
     return rv;
   }
   data[aLength] = 0;
 
+  mQueue->Enqueue(BIND5(&nsParser::HandleDataAvailable,
+    nsRefPtr<nsParser>(this),
+    request, data, totalRead, sourceOffset));
+
+  return NS_OK;
+}
+
+nsresult
+nsParser::HandleDataAvailable(nsIRequest* request,
+                              char* data,
+                              PRUint32 totalRead,
+                              PRUint32 sourceOffset)
+{
+  NS_PRECONDITION((eOnStart == mParserContext->mStreamListenerState ||
+                   eOnDataAvail == mParserContext->mStreamListenerState),
+            "Error: OnStartRequest() must be called before OnDataAvailable()");
+
+  nsresult rv = NS_OK;
+
   CParserContext *theContext = mParserContext;
 
   while (theContext && theContext->mRequest != request) {
@@ -2891,6 +2965,15 @@
 nsParser::OnStopRequest(nsIRequest *request, nsISupports* aContext,
                         nsresult status)
 {
+  return mQueue->Enqueue(BIND4(&nsParser::HandleStopRequest,
+    nsRefPtr<nsParser>(this),
+    request, aContext, status))->Wait();
+}
+
+nsresult
+nsParser::HandleStopRequest(nsIRequest *request, nsISupports* aContext,
+                            nsresult status)
+{
   nsresult rv = NS_OK;
 
   if (mSpeculativeScriptThread) {
diff --git a/parser/htmlparser/src/nsParser.h b/parser/htmlparser/src/nsParser.h
--- a/parser/htmlparser/src/nsParser.h
+++ b/parser/htmlparser/src/nsParser.h
@@ -90,6 +90,8 @@
 #include "nsIUnicharStreamListener.h"
 #include "nsCycleCollectionParticipant.h"
 
+#include "FunctorQueue.h"
+
 class nsICharsetConverterManager;
 class nsICharsetAlias;
 class nsIDTD;
@@ -404,7 +406,7 @@
      */
     virtual void ScriptDidExecute();
 
- protected:
+protected:
 
     void Initialize(PRBool aConstructor = PR_FALSE);
     void Cleanup();
@@ -427,6 +429,56 @@
 
     void SpeculativelyParse();
 
+    // TODO move these handlers nearer to their counterparts
+
+    nsresult HandleTerminate();
+    nsresult HandleContinueParsing();
+    nsresult HandleContinueInterruptedParsing();
+    void     HandleBlockParser();
+    void     HandleUnblockParser();
+
+    nsresult
+    HandleStartRequest(
+      nsIRequest*  request,
+      nsISupports* context);
+
+    nsresult
+    HandleDataAvailable(
+      nsIRequest* request,
+      char*       bytes,
+      PRUint32    numBytes,
+      PRUint32    sourceOffset);
+
+    nsresult
+    HandleStopRequest(
+      nsIRequest*  request,
+      nsISupports* context,
+      nsresult     status);
+    
+    nsresult
+    HandleParseUrl(
+      nsString& spec,
+      nsIRequestObserver* aListener,
+      void* aKey,
+      nsDTDMode aMode);
+
+    nsresult
+    HandleParseBuffer(
+      const nsAString& aSourceBuffer,
+      void* aKey,
+      const nsACString& aMimeType,
+      PRBool aLastCall,
+      nsDTDMode aMode);
+
+    nsresult
+    HandleParseFragment(
+      const nsAString& aSourceBuffer,
+      void* aKey,
+      nsTArray<nsString>& aTagStack,
+      PRBool aXMLMode,
+      const nsACString& aMimeType,
+      nsDTDMode aMode);
+
 private:
 
     /*******************************************
@@ -470,8 +522,9 @@
     //*********************************************
     // And now, some data members...
     //*********************************************
-    
-      
+
+    nsRefPtr<FunctorQueue> mQueue;
+
     CParserContext*              mParserContext;
     nsCOMPtr<nsIRequestObserver> mObserver;
     nsCOMPtr<nsIContentSink>     mSink;
