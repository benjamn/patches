diff --git a/xpcom/glue/Makefile.in b/xpcom/glue/Makefile.in
--- a/xpcom/glue/Makefile.in
+++ b/xpcom/glue/Makefile.in
@@ -124,16 +124,17 @@ EXPORTS = \
 EXPORTS = \
 		nsThreadUtils.h \
 		nsProxyRelease.h \
 		nsXPTCUtils.h \
 		Join.h \
 		TList.h \
 		Functor.h \
 		Bind.h \
+		nsRunnableFunctor.h \
 		$(NULL)
 
 SDK_LIBRARY     =                        \
 		$(LIB_PREFIX)xpcomglue_s.$(LIB_SUFFIX) \
 		$(NULL)
 
 # we don't want the shared lib, but we want to force the creation of a static lib.
 FORCE_STATIC_LIB = 1
diff --git a/xpcom/glue/nsProxyRelease.h b/xpcom/glue/nsProxyRelease.h
--- a/xpcom/glue/nsProxyRelease.h
+++ b/xpcom/glue/nsProxyRelease.h
@@ -31,17 +31,17 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-#ifndef nsProxyRelease_h_
+#ifndef nsProxyRelease_h__
 #define nsProxyRelease_h__
 
 #include "nsIEventTarget.h"
 #include "nsCOMPtr.h"
 
 #ifdef XPCOM_GLUE_AVOID_NSPR
 #error NS_ProxyRelease implementation depends on NSPR.
 #endif
diff --git a/xpcom/glue/nsRunnableFunctor.h b/xpcom/glue/nsRunnableFunctor.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/nsRunnableFunctor.h
@@ -0,0 +1,118 @@
+#ifndef __functorqueue_h__
+#define __functorqueue_h__
+
+#include "nsISupports.h"
+#include "nsAutoPtr.h"
+#include "nsAutoLock.h"
+#include "nsIEventTarget.h"
+#include "nsThreadUtils.h"
+#include "Functor.h"
+#include "nsProxyRelease.h"
+
+class ThreadSafeRunnable
+  : public nsIRunnable
+{
+  nsAutoRefCnt mRefCnt;
+public:
+  NS_IMPL_THREADSAFE_ISUPPORTS0(ThreadSafeRunnable)
+protected:
+  virtual ~ThreadSafeRunnable() {}
+};
+
+class nsARunnableFunctor
+  : public ThreadSafeRunnable
+{
+  PRMonitor* const mMon;
+  PRBool mRun;
+public:
+  nsARunnableFunctor()
+    : mMon(nsAutoMonitor::NewMonitor("nsARunnableFunctor"))
+    , mRun(PR_FALSE)
+  {}
+  void Wait()
+  {
+    nsAutoMonitor mon(mMon);
+    if (!mRun)
+      mon.Wait();
+  }
+  nsrefcnt Release()
+  {
+    if (NS_IsMainThread())
+      return ThreadSafeRunnable::Release();
+    nsIThread* mainThread = nsnull;
+    NS_GetMainThread(&mainThread);
+    if (mainThread)
+      NS_ProxyRelease(mainThread, this);
+    return 1;
+  }
+protected:
+  ~nsARunnableFunctor()
+  {
+    nsAutoMonitor::DestroyMonitor(mMon);
+  }
+  nsresult AfterRun()
+  {
+    nsAutoMonitor mon(mMon);
+    mRun = PR_TRUE;
+    mon.NotifyAll();
+    return NS_OK;
+  }
+};
+
+template <typename Result, typename Functor>
+class nsRunnableFunctor
+  : public nsARunnableFunctor
+{
+  Result mResult;
+  Functor mFunctor;
+public:
+  nsRunnableFunctor(Functor& functor)
+    : mFunctor(functor)
+  {}
+  Result& Wait()
+  {
+    nsARunnableFunctor::Wait();
+    return mResult;
+  }
+  nsresult Run()
+  {
+    mResult = mFunctor();
+    return AfterRun();
+  }
+};
+
+template <typename Functor>
+class nsRunnableFunctor<void, Functor>
+  : public nsARunnableFunctor
+{
+  Functor mFunctor;
+public:
+  nsRunnableFunctor(Functor& functor)
+    : mFunctor(functor)
+  {}
+  nsresult Run()
+  {
+    mFunctor();
+    return AfterRun();
+  }
+};
+
+#define  FTYPE(RTYPE) Functor<Result, TLIST0()> 
+#define RFTYPE(RTYPE) nsRunnableFunctor<Result, FTYPE(Result)> 
+
+template <typename Result>
+nsRefPtr<RFTYPE(Result)>
+proxy(nsIEventTarget* target,
+      FTYPE(Result) functor,
+      PRUint32 flags = NS_DISPATCH_NORMAL)
+{
+  typedef RFTYPE(Result) rf_t;
+  nsRefPtr<rf_t> rfp(new rf_t(functor));
+  target->Dispatch(rfp, flags);
+  return rfp;
+}
+
+#undef RFTYPE
+#undef  FTYPE
+
+#endif
\ No newline at end of file
