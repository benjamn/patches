diff --git a/xpcom/glue/FunctorQueue.h b/xpcom/glue/FunctorQueue.h
new file mode 100644
--- /dev/null
+++ b/xpcom/glue/FunctorQueue.h
@@ -0,0 +1,228 @@
+#ifndef __functorqueue_h__
+#define __functorqueue_h__
+
+#include "nsISupports.h"
+#include "nsAutoPtr.h"
+#include "nsAutoLock.h"
+#include "nsIEventTarget.h"
+#include "nsThreadUtils.h"
+#include "Functor.h"
+
+#include <vector>
+
+// This class guarantees the atomicity of AddRef and Release, but it cannot
+// guarantee another vital invariant: that Release always happens on the main
+// thread.  For that, see the macro INHERIT_MAIN_THREAD_RELEASE below.
+class ThreadSafeReferent
+{
+  nsAutoRefCnt mRefCnt;
+public:
+  NS_IMPL_THREADSAFE_RELEASE(ThreadSafeReferent)
+  NS_IMPL_THREADSAFE_ADDREF(ThreadSafeReferent)
+protected:
+  virtual ~ThreadSafeReferent() {}
+};
+
+// Use this macro to to guarantee that Release always happens on the main
+// thread.  Note that AddRef may happen on any thread, but must happen
+// synchronously.  It would be a bug to let AddRef and Release both happen
+// asynchronously, as the order of NS_Dispatch*ed execution is not guaranteed
+// to be FIFO.
+#define INHERIT_MAIN_THREAD_RELEASE(BASE)                                     \
+  void Release() { Release(NS_IsMainThread()); }                              \
+  void Release(PRBool isMainThread) {                                         \
+    if (isMainThread)                                                         \
+      BASE::Release();                                                        \
+    else                                                                      \
+      NS_DispatchToMainThread(NS_NEW_RUNNABLE_METHOD(                         \
+        BASE, static_cast<BASE*>(this), Release));                            \
+  }
+
+class PayloadBase : public ThreadSafeReferent
+{
+  PRMonitor* const mMon;
+  PRBool mDelivered;
+
+public:
+
+  PayloadBase()
+    : mMon(nsAutoMonitor::NewMonitor("PayloadBase"))
+    , mDelivered(PR_FALSE)
+  {}
+
+  INHERIT_MAIN_THREAD_RELEASE(ThreadSafeReferent)
+
+  void Wait()
+  {
+    nsAutoMonitor mon(mMon);
+    if (!mDelivered)
+      mon.Wait();
+  }
+
+  virtual void Deliver() = 0;
+
+protected:
+
+  ~PayloadBase()
+  {
+    nsAutoMonitor::DestroyMonitor(mMon);
+  }
+
+  void PostDelivery()
+  {
+    nsAutoMonitor mon(mMon);
+    mDelivered = PR_TRUE;
+    mon.NotifyAll();
+  }
+
+};
+
+
+template <typename Result>
+class Payload : public PayloadBase
+{
+  Result mResult;
+  typedef Functor<Result, TLIST0()> functor_type;
+  functor_type mFun;
+
+public:
+
+  Payload(functor_type fun) : mFun(fun) {}
+
+  Result& Wait()
+  {
+    PayloadBase::Wait();
+    return mResult;
+  }
+
+  void Deliver() {
+    mResult = mFun();
+    PostDelivery();
+  }
+
+};
+
+
+template <>
+class Payload<void> : public PayloadBase
+{
+  typedef Functor<void, TLIST0()> functor_type;
+  functor_type mFun;
+
+public:
+
+  Payload(functor_type fun) : mFun(fun) {}
+
+  void Deliver() {
+    mFun();
+    PostDelivery();
+  }
+
+};
+
+
+class FunctorQueue
+  : public ThreadSafeReferent
+{
+  typedef std::vector<PayloadBase*> queue_type;
+
+  PRLock* mLock;
+  queue_type mQueue;
+
+  nsAutoRefCnt mRefCnt;
+
+public:
+
+  FunctorQueue()
+    : mLock(nsAutoLock::NewLock("FunctorQueue"))
+  {}
+
+  INHERIT_MAIN_THREAD_RELEASE(ThreadSafeReferent)
+
+  virtual ~FunctorQueue()
+  {
+    NS_ASSERTION(mQueue.empty(), "Deleting non-empty FunctorQueue");
+    nsAutoLock::DestroyLock(mLock);
+  }
+
+  virtual void Flush()
+  {
+    queue_type temp;
+
+    { nsAutoLock sync(mLock);
+      temp = mQueue;
+      mQueue.clear(); }
+
+    PRBool isMainThread = NS_IsMainThread();
+
+    queue_type::const_iterator end = temp.end();
+    for (queue_type::iterator it = temp.begin(); end != it; ++it)
+    {
+      PayloadBase* const pl = *it;
+      pl->Deliver();
+      pl->Release(isMainThread);
+    }
+  }
+
+  // Despite the name, subclasses may implement AsyncFlush synchronously:
+  virtual void AsyncFlush() = 0;
+
+  template <typename Result>
+  nsRefPtr<Payload<Result> >
+  Enqueue(Functor<Result, TLIST0()> f)
+  {
+    nsRefPtr<Payload<Result> >
+      pl(new Payload<Result>(f));
+    NS_ENSURE_TRUE(pl, 0);
+
+    pl->AddRef(); // balances the Release call in Flush
+
+    { nsAutoLock sync(mLock);
+      mQueue.push_back(pl); }
+
+    AsyncFlush();
+
+    // pl's refcnt still >= 1, even if already Flushed
+    return pl;
+  }
+
+};
+
+class nsFunctorQueue
+  : public FunctorQueue
+{
+  nsRefPtr<nsIEventTarget> mTarget;
+  const void* mPendingEvent;
+
+public:
+
+  nsFunctorQueue(nsIEventTarget* target)
+    : mTarget(target)
+    , mPendingEvent(nsnull)
+  {}
+
+  const nsIEventTarget* GetTarget() const { return mTarget; }
+
+  void Flush() {
+    mPendingEvent = nsnull;
+    FunctorQueue::Flush();
+  }
+
+  void AsyncFlush()
+  {
+    PRBool sameThread;
+    // TODO IsOnCurrentThread not safe for threadpools!!!
+    if (NS_SUCCEEDED(mTarget->IsOnCurrentThread(&sameThread)) && !sameThread) {
+      if (mPendingEvent)
+        return;
+      nsIRunnable* event = NS_NEW_RUNNABLE_METHOD(nsFunctorQueue, this, Flush);
+      mTarget->Dispatch(event, NS_DISPATCH_NORMAL);
+      mPendingEvent = event;
+    } else {
+      Flush();
+    }
+  }
+
+};
+
+#endif
\ No newline at end of file
diff --git a/xpcom/glue/Makefile.in b/xpcom/glue/Makefile.in
--- a/xpcom/glue/Makefile.in
+++ b/xpcom/glue/Makefile.in
@@ -124,16 +124,17 @@ EXPORTS = \
 EXPORTS = \
 		nsThreadUtils.h \
 		nsProxyRelease.h \
 		nsXPTCUtils.h \
 		Join.h \
 		TList.h \
 		Functor.h \
 		Bind.h \
+		FunctorQueue.h \
 		$(NULL)
 
 SDK_LIBRARY     =                        \
 		$(LIB_PREFIX)xpcomglue_s.$(LIB_SUFFIX) \
 		$(NULL)
 
 # we don't want the shared lib, but we want to force the creation of a static lib.
 FORCE_STATIC_LIB = 1
