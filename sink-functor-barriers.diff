diff --git a/content/html/document/src/nsHTMLContentSink.cpp b/content/html/document/src/nsHTMLContentSink.cpp
--- a/content/html/document/src/nsHTMLContentSink.cpp
+++ b/content/html/document/src/nsHTMLContentSink.cpp
@@ -119,16 +119,20 @@
 #include "nsIDocShellTreeItem.h"
 
 #include "nsEscape.h"
 #include "nsIElementObserver.h"
 #include "nsNodeInfoManager.h"
 #include "nsContentCreatorFunctions.h"
 #include "mozAutoDocUpdate.h"
 
+#include "Bind.h"
+#include "FunctorQueue.h"
+#include "nsThreadUtils.h"
+
 #ifdef NS_DEBUG
 static PRLogModuleInfo* gSinkLogModuleInfo;
 
 #define SINK_TRACE_NODE(_bit, _msg, _tag, _sp, _obj) \
   _obj->SinkTraceNode(_bit, _msg, _tag, _sp, this)
 
 #else
 #define SINK_TRACE_NODE(_bit, _msg, _tag, _sp, _obj)
@@ -149,16 +153,59 @@ NS_NewHTMLNOTUSEDElement(nsINodeInfo *aN
 #define HTML_OTHER(_tag) NS_NewHTMLNOTUSEDElement,
 static const contentCreatorCallback sContentCreatorCallbacks[] = {
   NS_NewHTMLUnknownElement,
 #include "nsHTMLTagList.h"
 #undef HTML_TAG
 #undef HTML_OTHER
   NS_NewHTMLUnknownElement
 };
+
+#define PROXY_SYNC(BOUND)                                                     \
+  PR_BEGIN_MACRO                                                              \
+    nsIThread* thread = nsnull;                                               \
+    NS_GetCurrentThread(&thread);                                             \
+    if (mQueue->GetTarget() != thread)                                        \
+      return mQueue->Enqueue(BOUND)->Wait();                                  \
+  PR_END_MACRO
+
+#define TRIVIAL_PROXY_SYNC(METHOD)                                            \
+  PROXY_SYNC(BIND1(&HTMLContentSink::METHOD,                                  \
+                   nsRefPtr<HTMLContentSink>                                  \
+                           (const_cast<HTMLContentSink*>(this))))
+
+template <typename T>
+class AutoDerefHolder {
+  T* mPtr;
+public:
+  AutoDerefHolder(T& t) : mPtr(&t) {}
+  operator T&() { return *mPtr; }
+  operator T*() { return mPtr; }
+};
+
+template <typename T>
+static AutoDerefHolder<T>
+make_adf(T& t) {
+  return AutoDerefHolder<T>(t);
+}
+
+#define PARSER_NODE_PROXY_SYNC(METHOD, NODE)                                  \
+  PROXY_SYNC(BIND2(&HTMLContentSink::METHOD,                                  \
+                   nsRefPtr<HTMLContentSink>(this),                           \
+                   make_adf(NODE)))
+
+#define PROXY_ASYNC(BOUND, RESULT)                                            \
+  PR_BEGIN_MACRO                                                              \
+    nsIThread* thread = nsnull;                                               \
+    NS_GetCurrentThread(&thread);                                             \
+    if (mQueue->GetTarget() != thread) {                                      \
+      mQueue->Enqueue(BOUND);                                                 \
+      return (RESULT);                                                        \
+    }                                                                         \
+  PR_END_MACRO
 
 class SinkContext;
 class HTMLContentSink;
 
 static void MaybeSetForm(nsGenericHTMLElement*, nsHTMLTag, HTMLContentSink*);
 
 class HTMLContentSink : public nsContentSink,
 #ifdef DEBUG
@@ -229,16 +276,18 @@ protected:
 
 #ifdef NS_DEBUG
   void SinkTraceNode(PRUint32 aBit,
                      const char* aMsg,
                      const nsHTMLTag aTag,
                      PRInt32 aStackPos,
                      void* aThis);
 #endif
+
+  nsRefPtr<nsFunctorQueue> mQueue;
 
   nsIHTMLDocument* mHTMLDocument;
 
   // The maximum length of a text run
   PRInt32 mMaxTextRun;
 
   nsGenericHTMLElement* mRoot;
   nsGenericHTMLElement* mBody;
@@ -1628,16 +1677,19 @@ nsresult
 nsresult
 HTMLContentSink::Init(nsIDocument* aDoc,
                       nsIURI* aURI,
                       nsISupports* aContainer,
                       nsIChannel* aChannel)
 {
   NS_ENSURE_TRUE(aContainer, NS_ERROR_NULL_POINTER);
 
+  nsIThread* mainThread = nsnull;
+  NS_GetMainThread(&mainThread);
+  mQueue = new nsFunctorQueue(mainThread);
 
   MOZ_TIMER_DEBUGLOG(("Reset and start: nsHTMLContentSink::Init(), this=%p\n",
                       this));
   MOZ_TIMER_RESET(mWatch);
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = nsContentSink::Init(aDoc, aURI, aContainer, aChannel);
   if (NS_FAILED(rv)) {
@@ -1739,22 +1791,25 @@ HTMLContentSink::Init(nsIDocument* aDoc,
   MOZ_TIMER_STOP(mWatch);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::WillParse(void)
 {
+  TRIVIAL_PROXY_SYNC(WillParse);
   return WillParseImpl();
 }
 
 NS_IMETHODIMP
 HTMLContentSink::WillBuildModel(void)
 {
+  TRIVIAL_PROXY_SYNC(WillBuildModel);
+
   WillBuildModelImpl();
   if (mHTMLDocument) {
     NS_ASSERTION(mParser, "no parser");
     nsCompatibility mode = eCompatibility_NavQuirks;
     if (mParser) {
       nsDTDMode dtdMode = mParser->GetParseMode();
       switch (dtdMode) {
         case eDTDMode_full_standards:
@@ -1778,16 +1833,18 @@ HTMLContentSink::WillBuildModel(void)
   mDocument->BeginLoad();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::DidBuildModel(void)
 {
+  TRIVIAL_PROXY_SYNC(DidBuildModel);
+
   // NRA Dump stopwatch stop info here
 #ifdef MOZ_PERF_METRICS
   MOZ_TIMER_DEBUGLOG(("Stop: nsHTMLContentSink::DidBuildModel(), this=%p\n",
                       this));
   MOZ_TIMER_STOP(mWatch);
   MOZ_TIMER_LOG(("Content creation time (this=%p): ", this));
   MOZ_TIMER_PRINT(mWatch);
 #endif
@@ -1842,30 +1899,39 @@ HTMLContentSink::ReadyToCallDidBuildMode
 HTMLContentSink::ReadyToCallDidBuildModel(PRBool aTerminated)
 {
   return ReadyToCallDidBuildModelImpl(aTerminated);
 }
 
 NS_IMETHODIMP
 HTMLContentSink::SetParser(nsIParser* aParser)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::SetParser,
+                   nsRefPtr<HTMLContentSink>(this),
+                   nsRefPtr<nsIParser>(aParser)));
+
   NS_PRECONDITION(aParser, "Should have a parser here!");
   mParser = aParser;
   return NS_OK;
 }
 
 NS_IMETHODIMP_(PRBool)
 HTMLContentSink::IsFormOnStack()
 {
+  TRIVIAL_PROXY_SYNC(IsFormOnStack);
   return mFormOnStack;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::BeginContext(PRInt32 aPosition)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::BeginContext,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aPosition));
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::BeginContext()\n"));
   MOZ_TIMER_START(mWatch);
   NS_PRECONDITION(aPosition > -1, "out of bounds");
 
   // Create new context
   SinkContext* sc = new SinkContext(this);
   if (!sc) {
     MOZ_TIMER_DEBUGLOG(("Stop: nsHTMLContentSink::BeginContext()\n"));
@@ -1914,16 +1980,20 @@ HTMLContentSink::BeginContext(PRInt32 aP
   MOZ_TIMER_STOP(mWatch);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::EndContext(PRInt32 aPosition)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::EndContext,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aPosition));
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::EndContext()\n"));
   MOZ_TIMER_START(mWatch);
   NS_PRECONDITION(mCurrentContext && aPosition > -1, "non-existing context");
 
   PRInt32 n = mContextStack.Count() - 1;
   SinkContext* sc = (SinkContext*) mContextStack.ElementAt(n);
 
   const SinkContext::Node &bottom = mCurrentContext->mStack[0];
@@ -2004,16 +2074,18 @@ HTMLContentSink::CloseHTML()
   MOZ_TIMER_STOP(mWatch);
 
   return NS_OK;
 }
 
 nsresult
 HTMLContentSink::OpenHead()
 {
+  TRIVIAL_PROXY_SYNC(OpenHead);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::OpenHead()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = OpenHeadContext();
 
   MOZ_TIMER_DEBUGLOG(("Stop: nsHTMLContentSink::OpenHead()\n"));
   MOZ_TIMER_STOP(mWatch);
 
@@ -2296,32 +2368,39 @@ HTMLContentSink::CloseFrameset()
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::IsEnabled(PRInt32 aTag, PRBool* aReturn)
 {
+  PROXY_SYNC(BIND3(&HTMLContentSink::IsEnabled,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aTag,
+                   aReturn));
+
   nsHTMLTag theHTMLTag = nsHTMLTag(aTag);
 
   if (theHTMLTag == eHTMLTag_script) {
     *aReturn = mScriptEnabled;
   } else if (theHTMLTag == eHTMLTag_frameset) {
     *aReturn = mFramesEnabled;
   } else {
     *aReturn = PR_FALSE;
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::OpenContainer(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(OpenContainer, aNode);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::OpenContainer()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = NS_OK;
 
   switch (aNode.GetNodeType()) {
     case eHTMLTag_frameset:
       rv = OpenFrameset(aNode);
@@ -2359,16 +2438,20 @@ HTMLContentSink::OpenContainer(const nsI
   MOZ_TIMER_STOP(mWatch);
 
   return rv;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::CloseContainer(const eHTMLTags aTag)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::CloseContainer,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aTag));
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::CloseContainer()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = NS_OK;
 
   switch (aTag) {
     case eHTMLTag_frameset:
       rv = CloseFrameset();
@@ -2400,16 +2483,18 @@ HTMLContentSink::CloseMalformedContainer
 HTMLContentSink::CloseMalformedContainer(const eHTMLTags aTag)
 {
   return mCurrentContext->CloseContainer(aTag, PR_TRUE);
 }
 
 NS_IMETHODIMP
 HTMLContentSink::AddLeaf(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(AddLeaf, aNode);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::AddLeaf()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv;
 
   nsHTMLTag nodeType = nsHTMLTag(aNode.GetNodeType());
   switch (nodeType) {
   case eHTMLTag_link:
@@ -2433,16 +2518,18 @@ HTMLContentSink::AddLeaf(const nsIParser
  * This gets called by the parsing system when we find a comment
  * @update	gess11/9/98
  * @param   aNode contains a comment token
  * @return  error code
  */
 nsresult
 HTMLContentSink::AddComment(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(AddComment, aNode);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::AddComment()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsresult rv = mCurrentContext->AddComment(aNode);
 
   MOZ_TIMER_DEBUGLOG(("Stop: nsHTMLContentSink::AddComment()\n"));
   MOZ_TIMER_STOP(mWatch);
 
@@ -2453,16 +2540,18 @@ HTMLContentSink::AddComment(const nsIPar
  * This gets called by the parsing system when we find a PI
  * @update	gess11/9/98
  * @param   aNode contains a comment token
  * @return  error code
  */
 nsresult
 HTMLContentSink::AddProcessingInstruction(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(AddProcessingInstruction, aNode);
+
   nsresult result = NS_OK;
 
   MOZ_TIMER_START(mWatch);
   // Implementation of AddProcessingInstruction() should start here
 
   MOZ_TIMER_STOP(mWatch);
 
   return result;
@@ -2471,16 +2560,18 @@ HTMLContentSink::AddProcessingInstructio
 /**
  *  This gets called by the parser when it encounters
  *  a DOCTYPE declaration in the HTML document.
  */
 
 NS_IMETHODIMP
 HTMLContentSink::AddDocTypeDecl(const nsIParserNode& aNode)
 {
+  PARSER_NODE_PROXY_SYNC(AddDocTypeDecl, aNode);
+
   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::AddDocTypeDecl()\n"));
   MOZ_TIMER_START(mWatch);
 
   nsAutoString docTypeStr(aNode.GetText());
   nsresult rv = NS_OK;
 
   PRInt32 publicStart = docTypeStr.Find("PUBLIC", PR_TRUE);
   PRInt32 systemStart = docTypeStr.Find("SYSTEM", PR_TRUE);
@@ -2715,34 +2806,39 @@ HTMLContentSink::WillProcessAToken(void)
 HTMLContentSink::WillProcessAToken(void)
 {
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::DidProcessAToken(void)
 {
+  TRIVIAL_PROXY_SYNC(DidProcessAToken);
   return DidProcessATokenImpl();
 }
 
 NS_IMETHODIMP
 HTMLContentSink::WillInterrupt()
 {
+  TRIVIAL_PROXY_SYNC(WillInterrupt);
   return WillInterruptImpl();
 }
 
 NS_IMETHODIMP
 HTMLContentSink::WillResume()
 {
+  TRIVIAL_PROXY_SYNC(WillResume);
   return WillResumeImpl();
 }
 
 NS_IMETHODIMP
 HTMLContentSink::NotifyTagObservers(nsIParserNode* aNode)
 {
+  PARSER_NODE_PROXY_SYNC(NotifyTagObservers, *aNode);
+
   // Bug 125317
   // Inform observers that we're handling a document.write().
   // This information is necessary for the charset observer, atleast,
   // to make a decision whether a new charset loading is required or not.
 
   if (!mObservers) {
     return NS_OK;
   }
@@ -3184,16 +3280,20 @@ HTMLContentSink::ProcessSTYLEEndTag(nsGe
   }
 
   return rv;
 }
 
 void
 HTMLContentSink::FlushPendingNotifications(mozFlushType aType)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::FlushPendingNotifications,
+                   nsRefPtr<HTMLContentSink>(this),
+                   aType));
+
   // Only flush tags if we're not doing the notification ourselves
   // (since we aren't reentrant)
   if (!mInNotification) {
     if (aType >= Flush_ContentAndNotify) {
       FlushTags();
     }
     else if (mCurrentContext) {
       mCurrentContext->FlushText();
@@ -3215,16 +3315,20 @@ HTMLContentSink::FlushTags()
   }
   
   return mCurrentContext ? mCurrentContext->FlushTags() : NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLContentSink::SetDocumentCharset(nsACString& aCharset)
 {
+  PROXY_SYNC(BIND2(&HTMLContentSink::SetDocumentCharset,
+                   nsRefPtr<HTMLContentSink>(this),
+                   nsCString(aCharset)));
+
   if (mDocShell) {
     // the following logic to get muCV is copied from
     // nsHTMLDocument::StartDocumentLoad
     // We need to call muCV->SetPrevDocCharacterSet here in case
     // the charset is detected by parser DetectMetaTag
     nsCOMPtr<nsIMarkupDocumentViewer> muCV;
     nsCOMPtr<nsIContentViewer> cv;
     mDocShell->GetContentViewer(getter_AddRefs(cv));
@@ -3263,16 +3367,17 @@ HTMLContentSink::SetDocumentCharset(nsAC
   }
 
   return NS_OK;
 }
 
 nsISupports *
 HTMLContentSink::GetTarget()
 {
+  TRIVIAL_PROXY_SYNC(GetTarget);
   return mDocument;
 }
 
 #ifdef DEBUG
 /**
  *  This will dump content model into the output file.
  *
  *  @update  harishd 05/25/00
