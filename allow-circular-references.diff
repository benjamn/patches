# HG changeset patch
# Parent 5ebc8f1139032699df19e3fc94508d9ca397b0b2
Support passing objects with circular references through Jetpack messages (bug 556846).

diff --git a/js/jetpack/JetpackActorCommon.cpp b/js/jetpack/JetpackActorCommon.cpp
--- a/js/jetpack/JetpackActorCommon.cpp
+++ b/js/jetpack/JetpackActorCommon.cpp
@@ -45,220 +45,344 @@
 #include "mozilla/jsipc/PHandleChild.h"
 #include "mozilla/jsipc/Handle.h"
 
 #include "jsapi.h"
 #include "jstl.h"
 #include "jshashtable.h"
 
 using mozilla::jetpack::JetpackActorCommon;
-using mozilla::jetpack::Variant;
 using mozilla::jsipc::PHandleParent;
 using mozilla::jsipc::HandleParent;
 using mozilla::jsipc::PHandleChild;
 using mozilla::jsipc::HandleChild;
 
-struct JetpackActorCommon::OpaqueSeenType {
-  typedef js::HashSet<
-    JSObject*,
-    js::DefaultHasher<JSObject*>,
+class JetpackActorCommon::OpaqueSeenType
+{
+public:
+  typedef JSObject* KeyType;
+  typedef size_t IdType;
+  typedef js::HashMap<
+    KeyType, IdType,
+    js::DefaultHasher<KeyType>,
     js::SystemAllocPolicy
-  > SetType;
+  > MapType;
 
   OpaqueSeenType() {
-    NS_ASSERTION(set.init(1), "Failed to allocate HashSet");
+    NS_ASSERTION(map.init(1), "Failed to initialize map");
   }
 
-  bool ok() { return set.initialized(); }
+  bool ok() { return map.initialized(); }
 
-  SetType set;
+  bool add(KeyType obj, IdType* id = NULL) {
+    MapType::AddPtr ap = map.lookupForAdd(obj);
+    if (!ap)
+      return (rmap.AppendElement(obj) &&
+              map.add(ap, obj, rmap.Length() - 1));
+    if (id)
+      *id = ap->value;
+    return false;
+  }
+
+  bool reverseLookup(IdType id, KeyType* objp) {
+    return !!(*objp = rmap.SafeElementAt(id, NULL));
+  }
+
+private:
+  MapType map;
+  nsAutoTArray<KeyType, 4> rmap;
+
 };
 
 bool
-JetpackActorCommon::jsval_to_Variant(JSContext* cx, jsval from, Variant* to,
-                                     OpaqueSeenType* seen)
+JetpackActorCommon::jsval_to_PrimVariant(JSContext* cx, JSType type, jsval from,
+                                         PrimVariant* to)
 {
-  switch (JS_TypeOfValue(cx, from)) {
+  switch (type) {
   case JSTYPE_VOID:
     *to = void_t();
     return true;
+
   case JSTYPE_NULL:
     *to = null_t();
     return true;
+
   case JSTYPE_FUNCTION:
     return false;
+
   case JSTYPE_OBJECT: {
     HandleParent* hp = HandleParent::FromJSVal(cx, from);
     HandleChild* hc = HandleChild::FromJSVal(cx, from);
     NS_ASSERTION(!hc || !hp, "Can't be both a parent and a child");
     if (hp) {
       *to = hp;
       return true;
     }
     if (hc) {
       *to = hc;
       return true;
     }
+    return false;
+  }
 
-    JSObject* obj = JSVAL_TO_OBJECT(from);
-
-    js::LazilyConstructed<OpaqueSeenType> lost;
-    if (!seen) {
-      lost.construct();
-      seen = lost.addr();
-      if (!seen->ok())
-        return false;
-    }
-    OpaqueSeenType::SetType::AddPtr ap =
-      seen->set.lookupForAdd(obj);
-    if (ap || !seen->set.add(ap, obj))
-      return false;
-
-    if (JS_IsArrayObject(cx, obj)) {
-      nsTArray<Variant> elems;
-      jsuint len;
-      if (!JS_GetArrayLength(cx, obj, &len))
-        return false;
-      for (jsuint i = 0; i < len; ++i) {
-        jsval val;
-        Variant* vp = elems.AppendElement();
-        if (!JS_GetElement(cx, obj, i, &val) ||
-            !jsval_to_Variant(cx, val, vp, seen))
-          *vp = void_t();
-      }
-      *to = elems;
-      return true;
-    }
-
-    js::AutoIdArray ida(cx, JS_Enumerate(cx, obj));
-    if (!ida)
-      return false;
-
-    nsTArray<KeyValue> kvs;
-    for (size_t i = 0; i < ida.length(); ++i) {
-      jsval val; // reused for both key and value
-      if (!JS_IdToValue(cx, ida[i], &val))
-        return false;
-      JSString* idStr = JS_ValueToString(cx, val);
-      if (!idStr)
-        return false;
-      if (!JS_GetPropertyById(cx, obj, ida[i], &val))
-        return false;
-      KeyValue* kv = kvs.AppendElement();
-      kv->key() = nsString((PRUnichar*)JS_GetStringChars(idStr),
-                           JS_GetStringLength(idStr));
-      if (!jsval_to_Variant(cx, val, &kv->value(), seen))
-        return false;
-    }
-    *to = kvs;
-    return true;
-  }
   case JSTYPE_STRING:
     *to = nsDependentString((PRUnichar*)JS_GetStringChars(JSVAL_TO_STRING(from)),
                             JS_GetStringLength(JSVAL_TO_STRING(from)));
     return true;
+
   case JSTYPE_NUMBER:
     if (JSVAL_IS_INT(from))
       *to = JSVAL_TO_INT(from);
     else if (JSVAL_IS_DOUBLE(from))
       *to = *JSVAL_TO_DOUBLE(from);
     else
       return false;
     return true;
+
   case JSTYPE_BOOLEAN:
     *to = !!JSVAL_TO_BOOLEAN(from);
     return true;
+
   case JSTYPE_XML:
     // fall through
+
   default:
     return false;
   }
 }
 
 bool
-JetpackActorCommon::jsval_from_Variant(JSContext* cx, const Variant& from,
-                                       jsval* to)
+JetpackActorCommon::jsval_to_CompVariant(JSContext* cx, JSType type, jsval from,
+                                         CompVariant* to, OpaqueSeenType* seen)
+{
+  if (type != JSTYPE_OBJECT)
+    return false;
+
+  js::LazilyConstructed<OpaqueSeenType> lost;
+  if (!seen) {
+    lost.construct();
+    seen = lost.addr();
+    if (!seen->ok())
+      return false;
+  }
+
+  OpaqueSeenType::KeyType obj = JSVAL_TO_OBJECT(from);
+  OpaqueSeenType::IdType id;
+  if (!seen->add(obj, &id)) {
+    *to = CompVariant(id);
+    return true;
+  }
+
+  if (JS_IsArrayObject(cx, obj)) {
+    nsTArray<Variant> elems;
+    jsuint len;
+    if (!JS_GetArrayLength(cx, obj, &len))
+      return false;
+    for (jsuint i = 0; i < len; ++i) {
+      jsval val;
+      Variant* vp = elems.AppendElement();
+      if (!JS_GetElement(cx, obj, i, &val) ||
+          !jsval_to_Variant(cx, val, vp, seen))
+        *vp = void_t();
+    }
+    *to = elems;
+    return true;
+  }
+
+  js::AutoIdArray ida(cx, JS_Enumerate(cx, obj));
+  if (!ida)
+    return false;
+
+  nsTArray<KeyValue> kvs;
+  for (size_t i = 0; i < ida.length(); ++i) {
+    jsval val; // reused for both key and value
+    if (!JS_IdToValue(cx, ida[i], &val))
+      return false;
+    JSString* idStr = JS_ValueToString(cx, val);
+    if (!idStr)
+      return false;
+    if (!JS_GetPropertyById(cx, obj, ida[i], &val))
+      return false;
+    KeyValue* kv = kvs.AppendElement();
+    kv->key() = nsString((PRUnichar*)JS_GetStringChars(idStr),
+                         JS_GetStringLength(idStr));
+    if (!jsval_to_Variant(cx, val, &kv->value(), seen))
+      return false;
+  }
+  *to = kvs;
+
+  return true;
+}
+
+bool
+JetpackActorCommon::jsval_to_Variant(JSContext* cx, jsval from, Variant* to,
+                                     OpaqueSeenType* seen)
+{
+  JSType type = JS_TypeOfValue(cx, from);
+  if (JSVAL_IS_NULL(from))
+    type = JSTYPE_NULL;
+
+  PrimVariant pv;
+  if (jsval_to_PrimVariant(cx, type, from, &pv)) {
+    *to = pv;
+    return true;
+  }
+
+  CompVariant cv;
+  if (jsval_to_CompVariant(cx, type, from, &cv, seen)) {
+    *to = cv;
+    return true;
+  }
+
+  return false;
+}
+
+bool
+JetpackActorCommon::jsval_from_PrimVariant(JSContext* cx,
+                                           const PrimVariant& from,
+                                           jsval* to)
 {
   switch (from.type()) {
-  case Variant::Tvoid_t:
+  case PrimVariant::Tvoid_t:
     *to = JSVAL_VOID;
     return true;
-  case Variant::Tnull_t:
+
+  case PrimVariant::Tnull_t:
     *to = JSVAL_NULL;
     return true;
-  case Variant::Tbool:
+
+  case PrimVariant::Tbool:
     *to = from.get_bool() ? JSVAL_TRUE : JSVAL_FALSE;
     return true;
-  case Variant::Tint:
+
+  case PrimVariant::Tint:
     *to = INT_TO_JSVAL(from.get_int());
     return true;
-  case Variant::Tdouble:
+
+  case PrimVariant::Tdouble:
     return !!JS_NewDoubleValue(cx, from.get_double(), to);
-  case Variant::TnsString: {
+
+  case PrimVariant::TnsString: {
     const nsString& str = from.get_nsString();
     if (!str.Length()) {
       *to = JS_GetEmptyStringValue(cx);
       return true;
     }
     JSString* s =
       JS_NewUCStringCopyN(cx, str.BeginReading(), str.Length());
     if (!s)
       return false;
     *to = STRING_TO_JSVAL(s);
     return true;
   }
-  case Variant::TPHandleParent: {
+
+  case PrimVariant::TPHandleParent: {
     JSObject* hobj =
       static_cast<const HandleParent*>(from.get_PHandleParent())->ToJSObject(cx);
     if (!hobj)
       return false;
     *to = OBJECT_TO_JSVAL(hobj);
     return true;
   }    
-  case Variant::TPHandleChild: {
+
+  case PrimVariant::TPHandleChild: {
     JSObject* hobj =
       static_cast<const HandleChild*>(from.get_PHandleChild())->ToJSObject(cx);
     if (!hobj)
       return false;
     *to = OBJECT_TO_JSVAL(hobj);
     return true;
   }
-  case Variant::TArrayOfKeyValue: {
-    const nsTArray<KeyValue>& kvs = from.get_ArrayOfKeyValue();
-    JSObject* obj = JS_NewObject(cx, NULL, NULL, NULL);
-    if (!obj)
+
+  default:
+    return false;
+  }
+}
+
+bool
+JetpackActorCommon::jsval_from_CompVariant(JSContext* cx,
+                                           const CompVariant& from,
+                                           jsval* to,
+                                           OpaqueSeenType* seen)
+{
+  js::LazilyConstructed<OpaqueSeenType> lost;
+  if (!seen) {
+    lost.construct();
+    seen = lost.addr();
+    if (!seen->ok())
+      return false;
+  }
+
+  JSObject* obj = NULL;
+
+  switch (from.type()) {
+  case CompVariant::TArrayOfKeyValue: {
+    if (!(obj = JS_NewObject(cx, NULL, NULL, NULL)))
       return false;
     js::AutoObjectRooter root(cx, obj);
+
+    if (!seen->add(obj))
+      return false;
+
+    const nsTArray<KeyValue>& kvs = from.get_ArrayOfKeyValue();
     for (PRUint32 i = 0; i < kvs.Length(); ++i) {
       const KeyValue& kv = kvs.ElementAt(i);
       jsval val;
-      if (!jsval_from_Variant(cx, kv.value(), &val) ||
+      if (!jsval_from_Variant(cx, kv.value(), &val, seen) ||
           !JS_SetUCProperty(cx, obj,
                             kv.key().BeginReading(),
                             kv.key().Length(),
                             &val))
         return false;
     }
-    *to = OBJECT_TO_JSVAL(obj);
-    return true;
+
+    break;
   }
-  case Variant::TArrayOfVariant: {
+
+  case CompVariant::TArrayOfVariant: {
     const nsTArray<Variant>& vs = from.get_ArrayOfVariant();
     jsval* elems;
-    JSObject* arrObj =
-      js_NewArrayObjectWithCapacity(cx, vs.Length(), &elems);
-    if (!arrObj || !elems)
+
+    obj = js_NewArrayObjectWithCapacity(cx, vs.Length(), &elems);
+    if (!obj || !elems)
       return false;
-    js::AutoObjectRooter root(cx, arrObj);
+    js::AutoObjectRooter root(cx, obj);
+
+    if (!seen->add(obj))
+      return false;
+
     for (PRUint32 i = 0; i < vs.Length(); ++i)
-      if (!jsval_from_Variant(cx, vs.ElementAt(i), elems + i))
+      if (!jsval_from_Variant(cx, vs.ElementAt(i), elems + i, seen))
         return false;
-    *to = OBJECT_TO_JSVAL(arrObj);
-    return true;
+
+    break;
   }
+
+  case CompVariant::Tsize_t:
+    if (!seen->reverseLookup(from.get_size_t(), &obj))
+      return false;
+    break;
+
+  default:
+    return false;
+  }
+
+  *to = OBJECT_TO_JSVAL(obj);
+  return true;
+}
+
+bool
+JetpackActorCommon::jsval_from_Variant(JSContext* cx, const Variant& from,
+                                       jsval* to, OpaqueSeenType* seen)
+{
+  switch (from.type()) {
+  case Variant::TPrimVariant:
+    return jsval_from_PrimVariant(cx, from, to);
+  case Variant::TCompVariant:
+    return jsval_from_CompVariant(cx, from, to, seen);
   default:
     return false;
   }
 }
 
 bool
 JetpackActorCommon::RecvMessage(JSContext* cx,
                                 const nsString& messageName,
@@ -302,16 +426,18 @@ JetpackActorCommon::RecvMessage(JSContex
     jsval rval;
     if (!JS_CallFunctionValue(cx, implGlobal, snapshot.ElementAt(i), argc, argv,
                               &rval))
       break;
 
     if (!results)
       continue;
 
+    js::AutoValueRooter root(cx, rval);
+
     Variant* vp = results->AppendElement();
     if (!jsval_to_Variant(cx, rval, vp))
       *vp = void_t();
   }
 
   return true;
 }
 
diff --git a/js/jetpack/JetpackActorCommon.h b/js/jetpack/JetpackActorCommon.h
--- a/js/jetpack/JetpackActorCommon.h
+++ b/js/jetpack/JetpackActorCommon.h
@@ -46,16 +46,18 @@
 #include "nsString.h"
 
 struct JSContext;
 
 namespace mozilla {
 namespace jetpack {
 
 class KeyValue;
+class PrimVariant;
+class CompVariant;
 class Variant;
 
 class JetpackActorCommon
 {
 public:
 
   bool
   RecvMessage(JSContext* cx,
@@ -76,29 +78,40 @@ public:
   UnregisterReceivers(const nsString& messageName) {
     mReceivers.Remove(messageName);
   }
 
   void ClearReceivers() {
     mReceivers.Clear();
   }
 
-  struct OpaqueSeenType;
+  class OpaqueSeenType;
   static bool jsval_to_Variant(JSContext* cx, jsval from, Variant* to,
                                OpaqueSeenType* seen = NULL);
-  static bool jsval_from_Variant(JSContext* cx, const Variant& from, jsval* to);
+  static bool jsval_from_Variant(JSContext* cx, const Variant& from, jsval* to,
+                                 OpaqueSeenType* seen = NULL);
 
 protected:
 
   JetpackActorCommon() {
     mReceivers.Init();
   }
 
 private:
 
+  static bool jsval_to_PrimVariant(JSContext* cx, JSType type, jsval from,
+                                   PrimVariant* to);
+  static bool jsval_to_CompVariant(JSContext* cx, JSType type, jsval from,
+                                   CompVariant* to, OpaqueSeenType* seen);
+
+  static bool jsval_from_PrimVariant(JSContext* cx, const PrimVariant& from,
+                                     jsval* to);
+  static bool jsval_from_CompVariant(JSContext* cx, const CompVariant& from,
+                                     jsval* to, OpaqueSeenType* seen);
+
   void TakeSnapshot(const nsString& messageName,
                     nsTArray<jsval>& snapshot);
 
   nsClassHashtable<nsStringHashKey,
                    nsTArray<nsAutoJSValHolder> > mReceivers;
 
 };
 
diff --git a/js/jetpack/PJetpack.ipdl b/js/jetpack/PJetpack.ipdl
--- a/js/jetpack/PJetpack.ipdl
+++ b/js/jetpack/PJetpack.ipdl
@@ -43,26 +43,35 @@ using mozilla::null_t;
 namespace mozilla {
 namespace jetpack {
 
 struct KeyValue {
   nsString key;
   Variant value;
 };
 
-union Variant {
+union PrimVariant {
   void_t;
   null_t;
   bool;
   int;
   double;
   nsString;
   PHandle;
+};
+
+union CompVariant {
   KeyValue[];
   Variant[];
+  size_t; // reference
+};
+  
+union Variant {
+  PrimVariant;
+  CompVariant;
 };
 
 sync protocol PJetpack
 {
   manages PHandle;
 both:
   async SendMessage(nsString messageName,
                     Variant[] data);
diff --git a/js/jetpack/tests/unit/impl.js b/js/jetpack/tests/unit/impl.js
--- a/js/jetpack/tests/unit/impl.js
+++ b/js/jetpack/tests/unit/impl.js
@@ -1,12 +1,13 @@
-registerReceiver("echo",
-                 function(msgName, data, handle) {
-                   sendMessage(msgName, data, handle);
-                 });
+function echo() {
+  sendMessage.apply(this, arguments);
+}
+
+registerReceiver("echo", echo);
 
 registerReceiver("callback",
                  function(msgName, data, handle) {
                    sendMessage("sendback",
                                callMessage("callback", data)[0],
                                handle);
                  });
 
@@ -15,23 +16,22 @@ registerReceiver("gimmeHandle",
                    sendMessage("recvHandle", "ok", createHandle());
                  });
 
 registerReceiver("kthx",
                  function(msgName, data, child) {
                    sendMessage("recvHandleAgain", data + data, child.parent);
                  });
 
-registerReceiver("echo2",
-                 function(msgName, obj1, obj2) {
-                   sendMessage("echo2", obj1, obj2);
-                 });
+registerReceiver("echo2", echo);
 
 registerReceiver("multireturn begin",
                  function() {
                    var results = callMessage("multireturn");
                    sendMessage.apply(null, ["multireturn check"].concat(results));
                  });
 
 registerReceiver("testarray",
                  function(msgName, array) {
                    sendMessage("testarray", array.reverse());
                  });
+
+registerReceiver("test primitive types", echo);
diff --git a/js/jetpack/tests/unit/test_jetpack.js b/js/jetpack/tests/unit/test_jetpack.js
--- a/js/jetpack/tests/unit/test_jetpack.js
+++ b/js/jetpack/tests/unit/test_jetpack.js
@@ -6,20 +6,34 @@ function run_test() {
   jetpack.loadImplementation(
     "chrome://global/content/jetpack/test-impl.js");
   jetpack.loadUserScript(
     "chrome://global/content/jetpack/test-user.js");
 
   var circ1 = {},
       circ2 = {},
       circ3 = {},
-      str = "circular references forbidden",
-      threw;
-  ((circ1.obj = circ2).obj = circ3).obj = circ1;
-  try { jetpack.sendMessage(str, circ3, circ1) }
+      ok = false;
+  ((circ1.next = circ2).next = circ3).next = circ1;
+  try {
+    jetpack.sendMessage("ignored", circ3, circ1);
+    ok = true;
+  } catch (x) {
+    do_check_false(x);
+  }
+  do_check_true(ok);
+
+  var bad = {
+    self: "bad",
+    obj: {
+      fn: function() { return this.foo },
+      foo: 42
+    }
+  }, threw, str = "no methods";
+  try { jetpack.sendMessage(str, bad) }
   catch (x) { threw = str }
   do_check_eq(threw, str);
 
   var echoHandle = jetpack.createHandle();
   echoHandle.payload = { weight: 10 };
   jetpack.registerReceiver("echo",
                            function(msgName, data, handle) {
                              do_check_eq(arguments.length, 3);
@@ -69,44 +83,68 @@ function run_test() {
                              do_check_neq(obj1, a);
                              do_check_neq(obj2, b);
                              do_check_eq(obj1.id, a.id);
                              do_check_eq(obj2.id, b.id);
                              do_check_eq(obj1.id, obj2.obj.id);
                              do_test_finished();
                            });
 
-  var undefined;
   jetpack.registerReceiver("multireturn", function() { return obj1 });
   jetpack.registerReceiver("multireturn", function() { return circ1 });
   jetpack.registerReceiver("multireturn", function() { return obj2 });
   jetpack.registerReceiver("multireturn check",
                            function(msgName, rval1, rval2, rval3) {
                              do_check_eq(rval1.id, obj1.id);
-                             do_check_eq(rval2, undefined);
+                             do_check_eq(rval2.next.next.next, rval2);
                              do_check_eq(rval3.id, obj2.id);
                              do_check_eq(rval3.obj.id, obj1.id);
                              do_test_finished();
                            });
 
   var testarray = [1, 1, 2, 3, 5, 8, 13];
   jetpack.registerReceiver("testarray",
                            function(msgName, reversed) {
                              for (var i = 0; i < testarray.length; ++i)
                                do_check_eq(testarray[i],
                                            reversed[reversed.length - i - 1]);
                              do_test_finished();
                            });
 
+  var undefined;
+  jetpack.registerReceiver("test primitive types",
+                           function(msgName,
+                                    void_val, null_val,
+                                    bool_true, bool_false,
+                                    one, two, nine99,
+                                    one_quarter,
+                                    oyez_str)
+                           {
+                             do_check_true(void_val === undefined);
+                             do_check_true(null_val === null);
+                             do_check_true(bool_true === true);
+                             do_check_true(bool_false === false);
+                             do_check_eq(one, 1);
+                             do_check_eq(two, 2);
+                             do_check_eq(nine99, 999);
+                             do_check_eq(one_quarter, 0.25);
+                             do_check_eq(oyez_str, "oyez");
+
+                             do_test_finished();
+                           });
+
+  do_test_pending();
   do_test_pending();
   do_test_pending();
   do_test_pending();
   do_test_pending();
   do_test_pending();
   do_test_pending();
 
   jetpack.sendMessage("echo", "echo this", echoHandle);
   jetpack.sendMessage("callback", "call me back", callbackHandle);
   jetpack.sendMessage("gimmeHandle");
   jetpack.sendMessage("echo2", obj1, obj2);
   jetpack.sendMessage("multireturn begin");
   jetpack.sendMessage("testarray", testarray);
+  jetpack.sendMessage("test primitive types",
+                      undefined, null, true, false, 1, 2, 999, 1/4, "oyez");
 }
