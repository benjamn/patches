# HG changeset patch
# Parent 5ebc8f1139032699df19e3fc94508d9ca397b0b2

diff --git a/js/jetpack/JetpackActorCommon.cpp b/js/jetpack/JetpackActorCommon.cpp
--- a/js/jetpack/JetpackActorCommon.cpp
+++ b/js/jetpack/JetpackActorCommon.cpp
@@ -46,90 +46,116 @@
 #include "mozilla/jsipc/Handle.h"
 
 #include "jsapi.h"
 #include "jstl.h"
 #include "jshashtable.h"
 
 using mozilla::jetpack::JetpackActorCommon;
 using mozilla::jetpack::Variant;
+using mozilla::jetpack::CompVariant;
 using mozilla::jsipc::PHandleParent;
 using mozilla::jsipc::HandleParent;
 using mozilla::jsipc::PHandleChild;
 using mozilla::jsipc::HandleChild;
 
-struct JetpackActorCommon::OpaqueSeenType {
-  typedef js::HashSet<
-    JSObject*,
-    js::DefaultHasher<JSObject*>,
+class JetpackActorCommon::OpaqueSeenType
+{
+public:
+  typedef JSObject* KeyType;
+  typedef size_t IdType;
+  typedef js::HashMap<
+    KeyType, IdType,
+    js::DefaultHasher<KeyType>,
     js::SystemAllocPolicy
-  > SetType;
+  > MapType;
 
   OpaqueSeenType() {
-    NS_ASSERTION(set.init(1), "Failed to allocate HashSet");
+    NS_ASSERTION(map.init(1), "Failed to initialize map");
   }
 
-  bool ok() { return set.initialized(); }
+  bool ok() { return map.initialized(); }
 
-  SetType set;
+  // TODO Make this responsible for rooting.
+  bool add(KeyType obj, IdType* id) {
+    MapType::AddPtr ap = map.lookupForAdd(obj);
+    if (!ap)
+      return (rmap.AppendElement(obj) &&
+              map.add(ap, obj, rmap.Length() - 1));
+    *id = ap->value;
+    return false;
+  }
+
+  bool reverseLookup(IdType id, KeyType* objp) {
+    return !!(*objp = rmap.SafeElementAt(id, NULL));
+  }
+
+private:
+  MapType map;
+  nsAutoTArray<KeyType, 4> rmap;
+
 };
 
 bool
 JetpackActorCommon::jsval_to_Variant(JSContext* cx, jsval from, Variant* to,
                                      OpaqueSeenType* seen)
 {
   switch (JS_TypeOfValue(cx, from)) {
   case JSTYPE_VOID:
     *to = void_t();
     return true;
+
   case JSTYPE_NULL:
     *to = null_t();
     return true;
+
   case JSTYPE_FUNCTION:
     return false;
+
   case JSTYPE_OBJECT: {
     HandleParent* hp = HandleParent::FromJSVal(cx, from);
     HandleChild* hc = HandleChild::FromJSVal(cx, from);
     NS_ASSERTION(!hc || !hp, "Can't be both a parent and a child");
     if (hp) {
       *to = hp;
       return true;
     }
     if (hc) {
       *to = hc;
       return true;
     }
 
-    JSObject* obj = JSVAL_TO_OBJECT(from);
-
     js::LazilyConstructed<OpaqueSeenType> lost;
     if (!seen) {
       lost.construct();
       seen = lost.addr();
       if (!seen->ok())
         return false;
     }
-    OpaqueSeenType::SetType::AddPtr ap =
-      seen->set.lookupForAdd(obj);
-    if (ap || !seen->set.add(ap, obj))
-      return false;
+
+    OpaqueSeenType::KeyType obj = JSVAL_TO_OBJECT(from);
+    OpaqueSeenType::IdType id;
+    if (!seen->add(obj, &id)) {
+      *to = CompVariant(void_t(), id);
+      return true;
+    }
 
     if (JS_IsArrayObject(cx, obj)) {
       nsTArray<Variant> elems;
       jsuint len;
       if (!JS_GetArrayLength(cx, obj, &len))
         return false;
       for (jsuint i = 0; i < len; ++i) {
         jsval val;
         Variant* vp = elems.AppendElement();
         if (!JS_GetElement(cx, obj, i, &val) ||
             !jsval_to_Variant(cx, val, vp, seen))
           *vp = void_t();
       }
-      *to = elems;
+      *to = CompVariant(elems, id);
       return true;
     }
 
     js::AutoIdArray ida(cx, JS_Enumerate(cx, obj));
     if (!ida)
       return false;
 
     nsTArray<KeyValue> kvs;
@@ -143,121 +169,193 @@ JetpackActorCommon::jsval_to_Variant(JSC
       if (!JS_GetPropertyById(cx, obj, ida[i], &val))
         return false;
       KeyValue* kv = kvs.AppendElement();
       kv->key() = nsString((PRUnichar*)JS_GetStringChars(idStr),
                            JS_GetStringLength(idStr));
       if (!jsval_to_Variant(cx, val, &kv->value(), seen))
         return false;
     }
-    *to = kvs;
+    *to = CompVariant(kvs, id);
     return true;
   }
+
   case JSTYPE_STRING:
     *to = nsDependentString((PRUnichar*)JS_GetStringChars(JSVAL_TO_STRING(from)),
                             JS_GetStringLength(JSVAL_TO_STRING(from)));
     return true;
+
   case JSTYPE_NUMBER:
     if (JSVAL_IS_INT(from))
       *to = JSVAL_TO_INT(from);
     else if (JSVAL_IS_DOUBLE(from))
       *to = *JSVAL_TO_DOUBLE(from);
     else
       return false;
     return true;
+
   case JSTYPE_BOOLEAN:
     *to = !!JSVAL_TO_BOOLEAN(from);
     return true;
+
   case JSTYPE_XML:
     // fall through
+
   default:
     return false;
   }
 }
 
 bool
-JetpackActorCommon::jsval_from_Variant(JSContext* cx, const Variant& from,
-                                       jsval* to)
+JetpackActorCommon::jsval_from_PrimVariant(JSContext* cx,
+                                           const PrimVariant& from,
+                                           jsval* to)
 {
   switch (from.type()) {
-  case Variant::Tvoid_t:
+  case PrimVariant::Tvoid_t:
     *to = JSVAL_VOID;
     return true;
-  case Variant::Tnull_t:
+
+  case PrimVariant::Tnull_t:
     *to = JSVAL_NULL;
     return true;
-  case Variant::Tbool:
+
+  case PrimVariant::Tbool:
     *to = from.get_bool() ? JSVAL_TRUE : JSVAL_FALSE;
     return true;
-  case Variant::Tint:
+
+  case PrimVariant::Tint:
     *to = INT_TO_JSVAL(from.get_int());
     return true;
-  case Variant::Tdouble:
+
+  case PrimVariant::Tdouble:
     return !!JS_NewDoubleValue(cx, from.get_double(), to);
-  case Variant::TnsString: {
+
+  case PrimVariant::TnsString: {
     const nsString& str = from.get_nsString();
     if (!str.Length()) {
       *to = JS_GetEmptyStringValue(cx);
       return true;
     }
     JSString* s =
       JS_NewUCStringCopyN(cx, str.BeginReading(), str.Length());
     if (!s)
       return false;
     *to = STRING_TO_JSVAL(s);
     return true;
   }
-  case Variant::TPHandleParent: {
+
+  case PrimVariant::TPHandleParent: {
     JSObject* hobj =
       static_cast<const HandleParent*>(from.get_PHandleParent())->ToJSObject(cx);
     if (!hobj)
       return false;
     *to = OBJECT_TO_JSVAL(hobj);
     return true;
   }    
-  case Variant::TPHandleChild: {
+
+  case PrimVariant::TPHandleChild: {
     JSObject* hobj =
       static_cast<const HandleChild*>(from.get_PHandleChild())->ToJSObject(cx);
     if (!hobj)
       return false;
     *to = OBJECT_TO_JSVAL(hobj);
     return true;
   }
-  case Variant::TArrayOfKeyValue: {
-    const nsTArray<KeyValue>& kvs = from.get_ArrayOfKeyValue();
-    JSObject* obj = JS_NewObject(cx, NULL, NULL, NULL);
+
+  default:
+    return false;
+  }
+}
+
+bool
+JetpackActorCommon::jsval_from_CompVariant(JSContext* cx,
+                                           const CompVariant& from,
+                                           jsval* to,
+                                           OpaqueSeenType* seen)
+{
+  JSObject* obj = NULL;
+  const CompVariantValue& value = from.value();
+
+  switch (value.type()) {
+  case CompVariantValue::TArrayOfKeyValue: {
+    const nsTArray<KeyValue>& kvs = value.get_ArrayOfKeyValue();
+    obj = JS_NewObject(cx, NULL, NULL, NULL);
     if (!obj)
       return false;
     js::AutoObjectRooter root(cx, obj);
+
+    OpaqueSeenType::IdType id;
+    if (!seen->add(obj, &id) ||
+        from.id() != id)
+      return false;
+
     for (PRUint32 i = 0; i < kvs.Length(); ++i) {
       const KeyValue& kv = kvs.ElementAt(i);
       jsval val;
-      if (!jsval_from_Variant(cx, kv.value(), &val) ||
+      if (!jsval_from_Variant(cx, kv.value(), &val, seen) ||
           !JS_SetUCProperty(cx, obj,
                             kv.key().BeginReading(),
                             kv.key().Length(),
                             &val))
         return false;
     }
-    *to = OBJECT_TO_JSVAL(obj);
-    return true;
+
+    break;
   }
-  case Variant::TArrayOfVariant: {
-    const nsTArray<Variant>& vs = from.get_ArrayOfVariant();
+
+  case CompVariantValue::TArrayOfVariant: {
+    const nsTArray<Variant>& vs = value.get_ArrayOfVariant();
     jsval* elems;
-    JSObject* arrObj =
-      js_NewArrayObjectWithCapacity(cx, vs.Length(), &elems);
-    if (!arrObj || !elems)
+    obj = js_NewArrayObjectWithCapacity(cx, vs.Length(), &elems);
+    if (!obj || !elems)
       return false;
-    js::AutoObjectRooter root(cx, arrObj);
+    js::AutoObjectRooter root(cx, obj);
+
+    OpaqueSeenType::IdType id; 
+    if (!seen->add(obj, &id) ||
+        from.id() != id)
+      return false;
+
     for (PRUint32 i = 0; i < vs.Length(); ++i)
-      if (!jsval_from_Variant(cx, vs.ElementAt(i), elems + i))
+      if (!jsval_from_Variant(cx, vs.ElementAt(i), elems + i, seen))
         return false;
-    *to = OBJECT_TO_JSVAL(arrObj);
-    return true;
+
+    break;
+  }
+
+  case CompVariantValue::Tvoid_t:
+    if (!seen->reverseLookup(from.id(), &obj))
+      return false;
+    break;
+
+  default:
+    return false;
+  }
+
+  *to = OBJECT_TO_JSVAL(obj);
+  return true;
+}
+
+bool
+JetpackActorCommon::jsval_from_Variant(JSContext* cx, const Variant& from,
+                                       jsval* to, OpaqueSeenType* seen)
+{
+  switch (from.type()) {
+  case Variant::TPrimVariant:
+    return jsval_from_PrimVariant(cx, from, to);
+  case Variant::TCompVariant: {
+    js::LazilyConstructed<OpaqueSeenType> lost;
+    if (!seen) {
+      lost.construct();
+      seen = lost.addr();
+      if (!seen->ok())
+        return false;
+    }
+    return jsval_from_CompVariant(cx, from, to, seen);
   }
   default:
     return false;
   }
 }
 
 bool
 JetpackActorCommon::RecvMessage(JSContext* cx,
diff --git a/js/jetpack/JetpackActorCommon.h b/js/jetpack/JetpackActorCommon.h
--- a/js/jetpack/JetpackActorCommon.h
+++ b/js/jetpack/JetpackActorCommon.h
@@ -46,16 +46,18 @@
 #include "nsString.h"
 
 struct JSContext;
 
 namespace mozilla {
 namespace jetpack {
 
 class KeyValue;
+class PrimVariant;
+class CompVariant;
 class Variant;
 
 class JetpackActorCommon
 {
 public:
 
   bool
   RecvMessage(JSContext* cx,
@@ -76,29 +78,35 @@ public:
   UnregisterReceivers(const nsString& messageName) {
     mReceivers.Remove(messageName);
   }
 
   void ClearReceivers() {
     mReceivers.Clear();
   }
 
-  struct OpaqueSeenType;
+  class OpaqueSeenType;
   static bool jsval_to_Variant(JSContext* cx, jsval from, Variant* to,
                                OpaqueSeenType* seen = NULL);
-  static bool jsval_from_Variant(JSContext* cx, const Variant& from, jsval* to);
+  static bool jsval_from_Variant(JSContext* cx, const Variant& from, jsval* to,
+                                 OpaqueSeenType* seen = NULL);
 
 protected:
 
   JetpackActorCommon() {
     mReceivers.Init();
   }
 
 private:
 
+  static bool jsval_from_PrimVariant(JSContext* cx, const PrimVariant& from,
+                                     jsval* to);
+  static bool jsval_from_CompVariant(JSContext* cx, const CompVariant& from,
+                                     jsval* to, OpaqueSeenType* seen);
+
   void TakeSnapshot(const nsString& messageName,
                     nsTArray<jsval>& snapshot);
 
   nsClassHashtable<nsStringHashKey,
                    nsTArray<nsAutoJSValHolder> > mReceivers;
 
 };
 
diff --git a/js/jetpack/PJetpack.ipdl b/js/jetpack/PJetpack.ipdl
--- a/js/jetpack/PJetpack.ipdl
+++ b/js/jetpack/PJetpack.ipdl
@@ -43,26 +43,40 @@ using mozilla::null_t;
 namespace mozilla {
 namespace jetpack {
 
 struct KeyValue {
   nsString key;
   Variant value;
 };
 
-union Variant {
+union PrimVariant {
   void_t;
   null_t;
   bool;
   int;
   double;
   nsString;
   PHandle;
+};
+
+union CompVariantValue {
   KeyValue[];
   Variant[];
+  void_t; // treat id as reference
+};
+
+struct CompVariant {
+  CompVariantValue value;
+  int id;
+};
+  
+union Variant {
+  PrimVariant;
+  CompVariant;
 };
 
 sync protocol PJetpack
 {
   manages PHandle;
 both:
   async SendMessage(nsString messageName,
                     Variant[] data);
diff --git a/js/jetpack/tests/unit/test_jetpack.js b/js/jetpack/tests/unit/test_jetpack.js
--- a/js/jetpack/tests/unit/test_jetpack.js
+++ b/js/jetpack/tests/unit/test_jetpack.js
@@ -8,17 +8,17 @@ function run_test() {
   jetpack.loadUserScript(
     "chrome://global/content/jetpack/test-user.js");
 
   var circ1 = {},
       circ2 = {},
       circ3 = {},
       str = "circular references forbidden",
       threw;
-  ((circ1.obj = circ2).obj = circ3).obj = circ1;
+  ((circ1.next = circ2).next = circ3).next = circ1;
   try { jetpack.sendMessage(str, circ3, circ1) }
   catch (x) { threw = str }
   do_check_eq(threw, str);
 
   var echoHandle = jetpack.createHandle();
   echoHandle.payload = { weight: 10 };
   jetpack.registerReceiver("echo",
                            function(msgName, data, handle) {
