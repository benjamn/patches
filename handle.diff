Port mozilla::jsipc::Handle from projects/electrolysis to mozilla-central.

diff --git a/ipc/ipdl/Makefile.in b/ipc/ipdl/Makefile.in
--- a/ipc/ipdl/Makefile.in
+++ b/ipc/ipdl/Makefile.in
@@ -51,16 +51,17 @@ LIBXUL_LIBRARY = 1
 EXPORT_LIBRARY = 1
 
 ##-----------------------------------------------------------------------------
 ## When you add IPDL files to a source directory, list the directory here.
 ##
 IPDLDIRS =  \
   dom/plugins  \
   js/jetpack \
+  js/ipc \
   ipc/ipdl/test/cxx  \
   $(NULL)
 ##-----------------------------------------------------------------------------
 
 ifdef MOZ_IPDL_TESTS
 DIRS += test
 endif
 
diff --git a/js/ipc/Handle.h b/js/ipc/Handle.h
new file mode 100644
--- /dev/null
+++ b/js/ipc/Handle.h
@@ -0,0 +1,300 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sw=4 et tw=80:
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef mozilla_jsipc_HandleParent_h__
+#define mozilla_jsipc_HandleParent_h__
+
+#include "mozilla/jsipc/PHandleParent.h"
+#include "mozilla/jsipc/PHandleChild.h"
+
+#include "jsapi.h"
+#include "jsobj.h"
+#include "jscntxt.h"
+
+namespace mozilla {
+namespace jsipc {
+
+template <class BaseType>
+class Handle
+    : public BaseType
+{
+    Handle(Handle* parent)
+        : mParent(parent)
+        , mObj(NULL)
+        , mRuntime(NULL)
+    {}
+
+    BaseType* AllocPHandle() {
+        return new Handle(this);
+    }
+
+    bool DeallocPHandle(BaseType* actor) {
+        delete actor;
+        return true;
+    }
+
+public:
+
+    Handle()
+        : mParent(NULL)
+        , mObj(NULL)
+        , mRuntime(NULL)
+    {}
+
+    ~Handle() { TearDown(); }
+
+    static Handle* FromJSObject(JSContext* cx, JSObject* obj) {
+        // TODO Convert non-Handles to Handles somehow?
+        return Unwrap(cx, obj);
+    }
+
+    static Handle* FromJSVal(JSContext* cx, jsval val) {
+        if (!JSVAL_IS_OBJECT(val))
+            return NULL;
+        return Unwrap(cx, JSVAL_TO_OBJECT(val));
+    }
+
+    JSObject* ToJSObject(JSContext* cx) const {
+        if (!mObj && !mRuntime) {
+            JSAutoRequest request(cx);
+
+            JSClass* clasp = const_cast<JSClass*>(&sHandle_JSClass);
+            JSObject* obj = JS_NewObject(cx, clasp, NULL, NULL);
+            if (!obj)
+                return NULL;
+            js::AutoValueRooter avr(cx, obj);
+
+            JSPropertySpec* ps = const_cast<JSPropertySpec*>(sHandle_Properties);
+            JSFunctionSpec* fs = const_cast<JSFunctionSpec*>(sHandle_Functions);
+            JSRuntime* rt;
+
+            const char* name = IsParent(this)
+                ? "mozilla::jsipc::Handle<PHandleParent>::mObj"
+                : "mozilla::jsipc::Handle<PHandleChild>::mObj";
+
+            if (JS_SetPrivate(cx, obj, (void*)this) &&
+                JS_DefineProperties(cx, obj, ps) &&
+                JS_DefineFunctions(cx, obj, fs) &&
+                JS_AddNamedRootRT(rt = JS_GetRuntime(cx), (void*)&mObj, name))
+            {
+                mObj = obj;
+                mRuntime = rt;
+            }
+        }
+        return mObj;
+    }
+
+protected:
+
+    // XXX Why not simply ActorDestroyReason?
+    void ActorDestroy(typename Handle::ActorDestroyReason why) {
+        TearDown();
+    }
+
+private:
+
+    static bool IsParent(const PHandleParent* handle) { return true; }
+    static bool IsParent(const PHandleChild* handle) { return false; }
+
+    void TearDown() {
+        if (mObj) {
+            mObj->setPrivate(NULL);
+            mObj = NULL;
+            // Nulling out mObj effectively unroots the object, but we still
+            // need to remove the root for good hygiene's sake.
+            NS_ASSERTION(mRuntime, "Should have a JSRuntime if we had an object");
+            JS_RemoveRootRT(mRuntime, (void*)&mObj);
+            // By not nulling out mRuntime, we prevent ToJSObject from
+            // reviving an invalidated/destroyed handle.
+        }
+    }
+
+    static const JSClass        sHandle_JSClass;
+    static const JSPropertySpec sHandle_Properties[];
+    static const JSFunctionSpec sHandle_Functions[];
+
+    Handle* const mParent;
+
+    // Used to cache the JSObject returned by ToJSObject, which is
+    // otherwise a const method.
+    mutable JSObject*  mObj;
+    mutable JSRuntime* mRuntime;
+
+    static Handle*
+    Unwrap(JSContext* cx, JSObject* obj) {
+        if (!obj)
+            return NULL;
+
+        while (obj->getClass() != &sHandle_JSClass)
+            if (!(obj = obj->getProto()))
+                return NULL;
+
+        Handle* self = static_cast<Handle*>(JS_GetPrivate(cx, obj));
+
+        NS_ASSERTION(!self || self->ToJSObject(cx) == obj,
+                     "Wrapper and wrapped object disagree?");
+
+        return self;
+    }
+
+    static JSBool
+    GetParent(JSContext* cx, JSObject* obj, jsval, jsval* vp) {
+        JS_SET_RVAL(cx, vp, JSVAL_NULL);
+
+        Handle* self = Unwrap(cx, obj);
+        if (!self)
+            return JS_TRUE;
+
+        Handle* parent = self->mParent;
+        if (!parent)
+            return JS_TRUE;
+
+        JSObject* pobj = parent->ToJSObject(cx);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(pobj));
+
+        return JS_TRUE;
+    }
+
+    static JSBool
+    GetIsValid(JSContext* cx, JSObject* obj, jsval, jsval* vp) {
+        Handle* self = Unwrap(cx, obj);
+        JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(!!self));
+        return JS_TRUE;
+    }
+
+    static JSBool
+    Invalidate(JSContext* cx, uintN argc, jsval* vp) {
+        if (argc > 0) {
+            JS_ReportError(cx, "invalidate takes zero arguments");
+            return JS_FALSE;
+        }
+
+        Handle* self = Unwrap(cx, JS_THIS_OBJECT(cx, vp));
+        if (self) {
+            JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_TRUE));
+            if (!Send__delete__(self)) {
+                JS_ReportError(cx, "Failed to send __delete__ while invalidating");
+                return JS_FALSE;
+            }
+        } else {
+            JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_FALSE));
+        }
+
+        return JS_TRUE;
+    }
+
+    static JSBool
+    CreateHandle(JSContext* cx, uintN argc, jsval* vp) {
+        if (argc > 0) {
+            JS_ReportError(cx, "createHandle takes zero arguments");
+            return JS_FALSE;
+        }
+
+        Handle* self = Unwrap(cx, JS_THIS_OBJECT(cx, vp));
+        if (!self) {
+            JS_ReportError(cx, "Tried to create child from invalid handle");
+            return JS_FALSE;
+        }
+
+        BaseType* child = self->SendPHandleConstructor();
+        if (!child) {
+            JS_ReportError(cx, "Failed to construct child");
+            return JS_FALSE;
+        }
+
+        JSObject* obj = static_cast<Handle*>(child)->ToJSObject(cx);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+
+        return JS_TRUE;
+    }
+
+    static void
+    Finalize(JSContext* cx, JSObject* obj) {
+        Handle* self = Unwrap(cx, obj);
+        self && Send__delete__(self);
+    }
+
+};
+
+template <class BaseType>
+const JSClass
+Handle<BaseType>::sHandle_JSClass = {
+    "IPDL Handle", JSCLASS_HAS_PRIVATE,
+    JS_PropertyStub, JS_PropertyStub,
+    JS_PropertyStub, JS_PropertyStub,
+    JS_EnumerateStub, JS_ResolveStub,
+    JS_ConvertStub, Handle::Finalize,
+    JSCLASS_NO_OPTIONAL_MEMBERS
+};
+
+#define HANDLE_PROP_FLAGS (JSPROP_READONLY | JSPROP_PERMANENT)
+
+template <class BaseType>
+const JSPropertySpec
+Handle<BaseType>::sHandle_Properties[] = {
+    { "parent",  0, HANDLE_PROP_FLAGS, GetParent,  NULL },
+    { "isValid", 0, HANDLE_PROP_FLAGS, GetIsValid, NULL },
+    { 0, 0, 0, NULL, NULL }
+};
+
+#undef HANDLE_PROP_FLAGS
+
+#define HANDLE_FUN_FLAGS (JSFUN_FAST_NATIVE |   \
+                          JSPROP_READONLY |     \
+                          JSPROP_PERMANENT)
+
+template <class BaseType>
+const JSFunctionSpec
+Handle<BaseType>::sHandle_Functions[] = {
+    JS_FN("invalidate",   Invalidate,   0, HANDLE_FUN_FLAGS),
+    JS_FN("createHandle", CreateHandle, 0, HANDLE_FUN_FLAGS),
+    JS_FS_END
+};
+
+#undef HANDLE_FUN_FLAGS
+
+// The payoff for using templates is that these two implementations are
+// guaranteed to be perfectly symmetric:
+typedef Handle<PHandleParent> HandleParent;
+typedef Handle<PHandleChild> HandleChild;
+
+}}
+
+#endif
diff --git a/js/ipc/Makefile.in b/js/ipc/Makefile.in
new file mode 100644
--- /dev/null
+++ b/js/ipc/Makefile.in
@@ -0,0 +1,64 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# The Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2010
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Newman <b{enjam,newma}n@mozilla.com> (original author)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH     = ../..
+topsrcdir = @top_srcdir@
+srcdir    = @srcdir@
+VPATH     = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE = js
+LIBRARY_NAME = jsipc_s
+LIBXUL_LIBRARY = 1
+FORCE_STATIC_LIB = 1
+EXPORT_LIBRARY = 1
+
+EXPORTS_NAMESPACES = mozilla/jsipc
+
+EXPORTS_mozilla/jsipc = \
+  Handle.h \
+  $(NULL)
+
+CPPSRCS = \
+  $(NULL)
+
+include $(topsrcdir)/config/config.mk
+include $(topsrcdir)/ipc/chromium/chromium-config.mk
+include $(topsrcdir)/config/rules.mk
+
+DEFINES += -DBIN_SUFFIX='"$(BIN_SUFFIX)"'
diff --git a/js/ipc/PHandle.ipdl b/js/ipc/PHandle.ipdl
new file mode 100644
--- /dev/null
+++ b/js/ipc/PHandle.ipdl
@@ -0,0 +1,55 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sw=4 et tw=80:
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+include protocol PJetpack;
+
+namespace mozilla {
+namespace jsipc {
+
+async protocol PHandle
+{
+    manager PJetpack or PHandle;
+    manages PHandle;
+both:
+    PHandle();
+    __delete__();
+};
+
+}}
diff --git a/js/ipc/ipdl.mk b/js/ipc/ipdl.mk
new file mode 100644
--- /dev/null
+++ b/js/ipc/ipdl.mk
@@ -0,0 +1,40 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# The Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2010
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Newman <b{enjam,newma}n@mozilla.com> (original author)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+IPDLSRCS = \
+  PHandle.ipdl \
+  $(NULL)
diff --git a/js/ipc/tests/unit/handle_child.js b/js/ipc/tests/unit/handle_child.js
new file mode 100644
--- /dev/null
+++ b/js/ipc/tests/unit/handle_child.js
@@ -0,0 +1,6 @@
+load("handle_common.js");
+
+function run_test() {
+  run_common_tests();
+}
+
diff --git a/js/ipc/tests/unit/handle_common.js b/js/ipc/tests/unit/handle_common.js
new file mode 100644
--- /dev/null
+++ b/js/ipc/tests/unit/handle_common.js
@@ -0,0 +1,105 @@
+function createHandle() {
+  return getRootHandle().createHandle();
+}
+
+function run_common_tests() {
+  test_sanity();
+  test_safe_iteration();
+  test_local_invalidation();
+  test_long_parent_chain(100);
+  test_invalid_creation();
+}
+
+function test_sanity() {
+  var root = getRootHandle(),
+      parent = createHandle(),
+      child = parent.createHandle(),
+      grandchild = child.createHandle();
+
+  do_check_neq(child, parent);
+  do_check_eq(child.parent, parent);
+  do_check_eq(parent.parent, root);
+  do_check_eq(root.parent, null);
+  do_check_eq(grandchild.parent.parent, parent);
+
+  do_check_true(child.isValid);
+  do_check_true(parent.isValid);
+
+  parent.invalidate();
+}
+
+function test_safe_iteration() {
+  var handle = createHandle(),
+      keys = [];
+  handle.foo = 42;
+  handle.self = handle;
+  for (var k in handle)
+    keys[keys.length] = k;
+  do_check_eq(keys.sort().join("~"),
+              "foo~self");
+  handle.invalidate();
+}
+
+function test_local_invalidation() {
+  var parent = createHandle(),
+      child = parent.createHandle();
+
+  do_check_true(child.invalidate());
+  do_check_false(child.isValid);
+  do_check_true(parent.isValid);
+
+  child = parent.createHandle();
+  do_check_true(child.isValid);
+
+  do_check_true(parent.invalidate());
+  do_check_false(parent.invalidate());
+  do_check_false(child.isValid);
+  do_check_false(parent.isValid);
+
+  parent = createHandle();
+  child = parent.createHandle();
+  child = child.createHandle();
+
+  var uncle = parent.createHandle(),
+      sibling = child.parent.createHandle();
+
+  do_check_eq(child.parent.parent, parent);
+  do_check_true(child.parent.isValid);
+
+  do_check_true(child.parent.invalidate());
+  do_check_false(child.isValid);
+  do_check_true(parent.isValid);
+
+  do_check_false(sibling.isValid);
+  do_check_true(uncle.isValid);
+
+  parent.invalidate();
+}
+
+function test_long_parent_chain(len) {
+  const ancestor = createHandle();
+  for (var handle = ancestor, i = 0; i < len; ++i)
+    handle = handle.createHandle();
+  const child = handle;
+
+  while (handle != ancestor)
+    handle = handle.parent;
+
+  do_check_true(child.isValid);
+  do_check_true(ancestor.invalidate());
+  do_check_false(child.isValid);
+}
+
+function test_invalid_creation() {
+  var parent = createHandle(),
+      child = parent.createHandle();
+
+  parent.invalidate();
+
+  do_check_eq(child.parent, null);
+
+  var threw = false;
+  try { child.createHandle(); }
+  catch (x) { threw = true; }
+  do_check_true(threw);
+}
diff --git a/js/ipc/tests/unit/test_handle.js b/js/ipc/tests/unit/test_handle.js
new file mode 100644
--- /dev/null
+++ b/js/ipc/tests/unit/test_handle.js
@@ -0,0 +1,11 @@
+load("handle_common.js");
+
+function run_test() {
+  run_test_in_child("handle_child.js",
+                    run_actual_tests);
+}
+
+function run_actual_tests() {
+  run_common_tests();
+  do_test_finished();
+}
diff --git a/js/jetpack/JetpackActorCommon.cpp b/js/jetpack/JetpackActorCommon.cpp
--- a/js/jetpack/JetpackActorCommon.cpp
+++ b/js/jetpack/JetpackActorCommon.cpp
@@ -43,30 +43,31 @@
 #include "jsapi.h"
 
 using mozilla::jetpack::JetpackActorCommon;
 
 bool
 JetpackActorCommon::RecvMessage(JSContext* cx,
                                 const nsString& messageName,
                                 const nsString& inData,
+                                JSObject* obj,
                                 nsTArray<nsString>* outData)
 {
   if (outData)
     outData->Clear();
 
   nsAutoTArray<jsval, 4> snapshot;
   TakeSnapshot(messageName, snapshot);
   if (!snapshot.Length())
     return true;
   
   JSAutoRequest request(cx);
 
-  jsval argv[2];
-  js::AutoArrayRooter argvRooter(cx, 2, argv);
+  jsval argv[3];
+  js::AutoArrayRooter argvRooter(cx, 3, argv);
 
   JSString* msgNameStr =
     JS_NewUCStringCopyN(cx,
                         messageName.BeginReading(),
                         messageName.Length());
   if (!msgNameStr)
     return false;
   argv[0] = STRING_TO_JSVAL(msgNameStr);
@@ -78,21 +79,24 @@ JetpackActorCommon::RecvMessage(JSContex
                           inData.Length());
     if (!inDataStr)
       return false;
     argv[1] = STRING_TO_JSVAL(inDataStr);
   } else {
     argv[1] = JS_GetEmptyStringValue(cx);
   }
 
+  if (obj)
+    argv[2] = OBJECT_TO_JSVAL(obj);
+
   JSObject* implGlobal = JS_GetGlobalObject(cx);
   for (PRUint32 i = 0; i < snapshot.Length(); ++i) {
     jsval rval;
-    if (!JS_CallFunctionValue(cx, implGlobal, snapshot.ElementAt(i), 2,
-                              argv, &rval))
+    if (!JS_CallFunctionValue(cx, implGlobal, snapshot.ElementAt(i),
+                              obj ? 3 : 2, argv, &rval))
       break;
 
     if (!outData)
       continue;
 
     nsString* elem = outData->AppendElement();
     JSString* rstr = JS_ValueToString(cx, rval);
 
diff --git a/js/jetpack/JetpackActorCommon.h b/js/jetpack/JetpackActorCommon.h
--- a/js/jetpack/JetpackActorCommon.h
+++ b/js/jetpack/JetpackActorCommon.h
@@ -53,16 +53,17 @@ namespace jetpack {
 class JetpackActorCommon
 {
 public:
 
   bool
   RecvMessage(JSContext* cx,
               const nsString& messageName,
               const nsString& inData, // TODO
+              JSObject* handle,
               nsTArray<nsString>* outData); // TODO
 
   nsresult
   RegisterReceiver(JSContext* cx,
                    const nsString& messageName,
                    jsval receiver);
 
   void
diff --git a/js/jetpack/JetpackChild.cpp b/js/jetpack/JetpackChild.cpp
--- a/js/jetpack/JetpackChild.cpp
+++ b/js/jetpack/JetpackChild.cpp
@@ -34,19 +34,23 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "base/basictypes.h"
 #include "jscntxt.h"
 
 #include "mozilla/jetpack/JetpackChild.h"
+#include "mozilla/jsipc/Handle.h"
 
 #include "jsarray.h"
 
+using mozilla::jsipc::PHandleChild;
+using mozilla::jsipc::HandleChild;
+
 namespace mozilla {
 namespace jetpack {
 
 JetpackChild::JetpackChild()
 {
 }
 
 JetpackChild::~JetpackChild()
@@ -66,22 +70,23 @@ JetpackChild::sImplProperties[] = {
 #undef IMPL_PROP_FLAGS
 
 #define IMPL_METHOD_FLAGS (JSFUN_FAST_NATIVE |  \
                            JSPROP_ENUMERATE | \
                            JSPROP_READONLY | \
                            JSPROP_PERMANENT)
 const JSFunctionSpec
 JetpackChild::sImplMethods[] = {
-  JS_FN("sendMessage", SendMessage, 2, IMPL_METHOD_FLAGS),
+  JS_FN("sendMessage", SendMessage, 3, IMPL_METHOD_FLAGS),
   JS_FN("callMessage", CallMessage, 2, IMPL_METHOD_FLAGS),
   JS_FN("registerReceiver", RegisterReceiver, 2, IMPL_METHOD_FLAGS),
   JS_FN("unregisterReceiver", UnregisterReceiver, 2, IMPL_METHOD_FLAGS),
   JS_FN("unregisterReceivers", UnregisterReceivers, 1, IMPL_METHOD_FLAGS),
   JS_FN("wrap", Wrap, 1, IMPL_METHOD_FLAGS),
+  JS_FN("createHandle", CreateHandle, 0, IMPL_METHOD_FLAGS),
   JS_FS_END
 };
 
 #undef IMPL_METHOD_FLAGS
 
 bool
 JetpackChild::Init(base::ProcessHandle aParentProcessHandle,
                    MessageLoop* aIOLoop,
@@ -126,19 +131,24 @@ JetpackChild::CleanUp()
   JS_DestroyContext(mUserCx);
   JS_DestroyContext(mImplCx);
   JS_DestroyRuntime(mRuntime);
   JS_ShutDown();
 }
 
 bool
 JetpackChild::RecvSendMessage(const nsString& messageName,
-                              const nsString& data) // TODO
+                              const nsString& data,
+                              PHandleChild* handle)
 {
-  return JetpackActorCommon::RecvMessage(mImplCx, messageName, data, NULL);
+  JSObject* hobj = NULL;
+  if (handle)
+    hobj = static_cast<HandleChild*>(handle)->ToJSObject(mImplCx);
+  return JetpackActorCommon::RecvMessage(mImplCx, messageName, data, hobj,
+                                         NULL);
 }
 
 static bool
 Evaluate(JSContext* cx, const nsCString& code)
 {
   JSAutoRequest request(cx);
   jsval v;
   JS_EvaluateScript(cx, JS_GetGlobalObject(cx), code.get(),
@@ -153,16 +163,29 @@ JetpackChild::RecvLoadImplementation(con
 }
 
 bool
 JetpackChild::RecvLoadUserScript(const nsCString& code)
 {
   return Evaluate(mUserCx, code);
 }
 
+PHandleChild*
+JetpackChild::AllocPHandle()
+{
+  return new HandleChild();
+}
+
+bool
+JetpackChild::DeallocPHandle(PHandleChild* actor)
+{
+  delete actor;
+  return true;
+}
+
 JetpackChild*
 JetpackChild::GetThis(JSContext* cx)
 {
   JetpackChild* self =
     static_cast<JetpackChild*>(JS_GetContextPrivate(cx));
   JS_ASSERT(cx == self->mImplCx ||
             cx == self->mUserCx);
   return self;
@@ -177,59 +200,65 @@ JetpackChild::UserJetpackGetter(JSContex
   return JS_TRUE;
 }
 
 struct MessageResult {
   PRUnichar* msgNameChars;
   size_t msgNameLength;
   PRUnichar* dataChars;
   size_t dataLength;
+  HandleChild* handleObj;
 };
 
 static JSBool
 MessageCommon(JSContext* cx, uintN argc, jsval* vp,
               MessageResult* result)
 {
-  if (argc < 1 || argc > 2) {
-    JS_ReportError(cx, "message takes one or two arguments");
+  if (argc < 1 || argc > 3) {
+    // XXX CallMessage takes only one or two, strictly speaking.
+    JS_ReportError(cx, "message takes one, two, or three arguments");
     return JS_FALSE;
   }
 
   jsval* argv = JS_ARGV(cx, vp);
 
   JSString
     * msgNameStr = JS_ValueToString(cx, argv[0]),
-    * dataStr = (argc == 2 ?
+    * dataStr = (argc > 1 ?
                  JS_ValueToString(cx, argv[1]) :
                  JSVAL_TO_STRING(JS_GetEmptyStringValue(cx)));
 
   if (!msgNameStr || !dataStr) {
     JS_ReportOutOfMemory(cx);
     return JS_FALSE;
   }
 
   result->msgNameChars = (PRUnichar*)JS_GetStringChars(msgNameStr);
   result->msgNameLength = JS_GetStringLength(msgNameStr);
   result->dataChars = (PRUnichar*)JS_GetStringChars(dataStr);
   result->dataLength = JS_GetStringLength(dataStr);
+  result->handleObj = NULL;
+  if (argc > 2)
+    result->handleObj = HandleChild::FromJSVal(cx, argv[2]);
 
   return JS_TRUE;
 }
 
 JSBool
 JetpackChild::SendMessage(JSContext* cx, uintN argc, jsval* vp)
 {
   MessageResult smr;
   if (!MessageCommon(cx, argc, vp, &smr))
     return JS_FALSE;
 
   if (!GetThis(cx)->SendSendMessage(nsDependentString(smr.msgNameChars,
                                                       smr.msgNameLength),
                                     nsDependentString(smr.dataChars,
-                                                      smr.dataLength)))
+                                                      smr.dataLength),
+                                    smr.handleObj))
   {
     JS_ReportError(cx, "Failed to sendMessage");
     return JS_FALSE;
   }
 
   JS_SET_RVAL(cx, vp, JSVAL_VOID);
 
   return JS_TRUE;
@@ -376,10 +405,31 @@ JetpackChild::UnregisterReceivers(JSCont
 
 JSBool
 JetpackChild::Wrap(JSContext* cx, uintN argc, jsval* vp)
 {
   JS_ReportError(cx, "wrap not yet implemented (depends on bug 563010)");
   return JS_FALSE;
 }
 
+JSBool
+JetpackChild::CreateHandle(JSContext* cx, uintN argc, jsval* vp)
+{
+  if (argc > 0) {
+    JS_ReportError(cx, "createHandle takes zero arguments");
+    return JS_FALSE;
+  }
+
+  HandleChild* handle =
+    static_cast<HandleChild*>(GetThis(cx)->SendPHandleConstructor());
+  if (!handle) {
+    JS_ReportError(cx, "Failed to construct Handle");
+    return JS_FALSE;
+  }
+
+  JSObject* hobj = handle->ToJSObject(cx);
+  JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(hobj));
+
+  return JS_TRUE;
+}
+
 } // namespace jetpack
 } // namespace mozilla
diff --git a/js/jetpack/JetpackChild.h b/js/jetpack/JetpackChild.h
--- a/js/jetpack/JetpackChild.h
+++ b/js/jetpack/JetpackChild.h
@@ -37,16 +37,21 @@
 
 #ifndef mozilla_jetpack_JetpackChild_h
 #define mozilla_jetpack_JetpackChild_h
 
 #include "mozilla/jetpack/PJetpackChild.h"
 #include "mozilla/jetpack/JetpackActorCommon.h"
 
 namespace mozilla {
+
+namespace jsipc {
+class PHandleChild;
+}
+
 namespace jetpack {
 
 class JetpackChild
   : public PJetpackChild
   , private JetpackActorCommon
 {
 public:
   JetpackChild();
@@ -57,20 +62,24 @@ public:
   bool Init(base::ProcessHandle aParentProcessHandle,
             MessageLoop* aIOLoop,
             IPC::Channel* aChannel);
 
   void CleanUp();
 
 protected:
   NS_OVERRIDE virtual bool RecvSendMessage(const nsString& messageName,
-                                           const nsString& data); // TODO
+                                           const nsString& data,
+                                           PHandleChild* handle);
   NS_OVERRIDE virtual bool RecvLoadImplementation(const nsCString& code);
   NS_OVERRIDE virtual bool RecvLoadUserScript(const nsCString& code);
 
+  NS_OVERRIDE virtual PHandleChild* AllocPHandle();
+  NS_OVERRIDE virtual bool DeallocPHandle(PHandleChild* actor);
+
 private:
   JSRuntime* mRuntime;
   JSContext *mImplCx, *mUserCx;
 
   static JetpackChild* GetThis(JSContext* cx);
 
   static const JSPropertySpec sImplProperties[];
   static JSBool UserJetpackGetter(JSContext* cx, JSObject* obj, jsval idval,
@@ -78,16 +87,17 @@ private:
 
   static const JSFunctionSpec sImplMethods[];
   static JSBool SendMessage(JSContext* cx, uintN argc, jsval *vp);
   static JSBool CallMessage(JSContext* cx, uintN argc, jsval *vp);
   static JSBool RegisterReceiver(JSContext* cx, uintN argc, jsval *vp);
   static JSBool UnregisterReceiver(JSContext* cx, uintN argc, jsval *vp);
   static JSBool UnregisterReceivers(JSContext* cx, uintN argc, jsval *vp);
   static JSBool Wrap(JSContext* cx, uintN argc, jsval *vp);
+  static JSBool CreateHandle(JSContext* cx, uintN argc, jsval *vp);
 
   DISALLOW_EVIL_CONSTRUCTORS(JetpackChild);
 };
 
 } // namespace jetpack
 } // namespace mozilla
 
 
diff --git a/js/jetpack/JetpackParent.cpp b/js/jetpack/JetpackParent.cpp
--- a/js/jetpack/JetpackParent.cpp
+++ b/js/jetpack/JetpackParent.cpp
@@ -31,20 +31,25 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "mozilla/jetpack/JetpackParent.h"
+#include "mozilla/jsipc/Handle.h"
 
 #include "nsIURI.h"
 #include "nsNetUtil.h"
 #include "nsIVariant.h"
+#include "nsIXPConnect.h"
+
+using mozilla::jsipc::PHandleParent;
+using mozilla::jsipc::HandleParent;
 
 namespace mozilla {
 namespace jetpack {
 
 JetpackParent::JetpackParent(JSContext* cx)
   : mSubprocess(new JetpackProcessParent())
   , mContext(cx)
 {
@@ -89,21 +94,29 @@ ReadFromURI(const nsAString& aURI,
     }
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 JetpackParent::SendMessage(const nsAString& aMessageName,
-                           const nsAString& aData)
+                           const nsAString& aData,
+                           nsIVariant* aHandle,
+                           PRUint8 optArgc)
 {
+  jsval hval = JSVAL_NULL;
+  if (optArgc == 2 && aHandle)
+    aHandle->GetAsJSVal(&hval);
+
   if (!SendSendMessage(nsString(aMessageName),
-                       nsString(aData)))
+                       nsString(aData),
+                       HandleParent::FromJSVal(mContext, hval)))
     return NS_ERROR_FAILURE;
+
   return NS_OK;
 }
 
 static bool
 GetReceiver(JSContext* cx, nsIVariant* receiver, jsval* rval)
 {
   return (NS_SUCCEEDED(receiver->GetAsJSVal(rval)) &&
           JSVAL_IS_OBJECT(*rval) &&
@@ -168,24 +181,58 @@ JetpackParent::LoadUserScript(const nsAS
       !SendLoadUserScript(code))
     rv = NS_ERROR_FAILURE;
 
   return rv;
 }
 
 bool
 JetpackParent::RecvSendMessage(const nsString& messageName,
-                               const nsString& data) // TODO
+                               const nsString& data,
+                               PHandleParent* handle)
 {
-  return JetpackActorCommon::RecvMessage(mContext, messageName, data, NULL);
+  JSObject* hobj = NULL;
+  if (handle)
+    hobj = static_cast<HandleParent*>(handle)->ToJSObject(mContext);
+  return JetpackActorCommon::RecvMessage(mContext, messageName, data, hobj,
+                                         NULL);
 }
 
 bool
 JetpackParent::RecvCallMessage(const nsString& messageName,
                                const nsString& inData, // TODO
                                nsTArray<nsString>* outData) // TODO
 {
-  return JetpackActorCommon::RecvMessage(mContext, messageName, inData,
+  return JetpackActorCommon::RecvMessage(mContext, messageName, inData, NULL,
                                          outData);
 }
 
+NS_IMETHODIMP
+JetpackParent::CreateHandle(nsIVariant** aResult)
+{
+  HandleParent* handle =
+    static_cast<HandleParent*>(SendPHandleConstructor());
+  NS_ENSURE_TRUE(handle, NS_ERROR_OUT_OF_MEMORY);
+
+  nsresult rv;
+  nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  JSAutoRequest request(mContext);
+  JSObject* hobj = handle->ToJSObject(mContext);
+  return xpc->JSToVariant(mContext, OBJECT_TO_JSVAL(hobj), aResult);
+}
+
+PHandleParent*
+JetpackParent::AllocPHandle()
+{
+  return new HandleParent();
+}
+
+bool
+JetpackParent::DeallocPHandle(PHandleParent* actor)
+{
+  delete actor;
+  return true;
+}
+
 } // namespace jetpack
 } // namespace mozilla
diff --git a/js/jetpack/JetpackParent.h b/js/jetpack/JetpackParent.h
--- a/js/jetpack/JetpackParent.h
+++ b/js/jetpack/JetpackParent.h
@@ -43,36 +43,46 @@
 #include "mozilla/jetpack/JetpackActorCommon.h"
 #include "nsIJetpack.h"
 
 #include "nsTArray.h"
 
 struct JSContext;
 
 namespace mozilla {
+
+namespace jsipc {
+class PHandleParent;
+}
+
 namespace jetpack {
 
 class JetpackParent
   : public PJetpackParent
   , public nsIJetpack
   , private JetpackActorCommon
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIJETPACK
 
   JetpackParent(JSContext* cx);
   ~JetpackParent();
 
 protected:
   NS_OVERRIDE virtual bool RecvSendMessage(const nsString& messageName,
-                                           const nsString& data); // TODO
+                                           const nsString& data,
+                                           PHandleParent* handle);
   NS_OVERRIDE virtual bool RecvCallMessage(const nsString& messageName,
                                            const nsString& inData, // TODO
                                            nsTArray<nsString>* outData); // TODO
+
+  NS_OVERRIDE virtual PHandleParent* AllocPHandle();
+  NS_OVERRIDE virtual bool DeallocPHandle(PHandleParent* actor);
+
 private:
   JetpackProcessParent* mSubprocess;
   JSContext* mContext;
 
   DISALLOW_EVIL_CONSTRUCTORS(JetpackParent);
 };
 
 } // namespace jetpack
diff --git a/js/jetpack/PJetpack.ipdl b/js/jetpack/PJetpack.ipdl
--- a/js/jetpack/PJetpack.ipdl
+++ b/js/jetpack/PJetpack.ipdl
@@ -30,24 +30,29 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
+include protocol PHandle;
+
 namespace mozilla {
 namespace jetpack {
 
 sync protocol PJetpack
 {
+  manages PHandle;
 both:
   async SendMessage(nsString messageName,
-                    nsString data); // TODO
+                    nsString data,
+                    nullable PHandle handle);
+  async PHandle();
 
 child:
   async LoadImplementation(nsCString code);
   async LoadUserScript(nsCString code);
 
 parent:
   sync CallMessage(nsString messageName,
                    nsString inData) // TODO
diff --git a/js/jetpack/jar.mn b/js/jetpack/jar.mn
--- a/js/jetpack/jar.mn
+++ b/js/jetpack/jar.mn
@@ -1,3 +1,3 @@
 toolkit.jar:
-        content/global/jetpack/bootstrap-impl.js (bootstrap-impl.js)
-        content/global/jetpack/bootstrap-user.js (bootstrap-user.js)
+        content/global/jetpack/test-impl.js (tests/unit/impl.js)
+        content/global/jetpack/test-user.js (tests/unit/user.js)
diff --git a/js/jetpack/nsIJetpack.idl b/js/jetpack/nsIJetpack.idl
--- a/js/jetpack/nsIJetpack.idl
+++ b/js/jetpack/nsIJetpack.idl
@@ -34,23 +34,27 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
 
 interface nsIVariant;
 
-[scriptable, uuid(be12cc9f-75d4-4f2d-b062-f549ea13446a)]
+[scriptable, uuid(563afdf8-5d2f-4bb2-9ac0-fb82461d2922)]
 interface nsIJetpack : nsISupports
 {
+  [optional_argc]
   void sendMessage(in AString aMessageName,
-                   in AString aData); // TODO
+                   [optional] in AString aData,
+                   [optional] in nsIVariant handle); // TODO
 
   void registerReceiver(in AString aMessageName,
                         in nsIVariant aReceiver);
   void unregisterReceiver(in AString aMessageName,
                           in nsIVariant aReceiver);
   void unregisterReceivers(in AString aMessageName);
 
   void loadImplementation(in AString aURI);
   void loadUserScript(in AString aURI);
+
+  nsIVariant createHandle();
 };
diff --git a/js/jetpack/bootstrap-impl.js b/js/jetpack/tests/unit/impl.js
rename from js/jetpack/bootstrap-impl.js
rename to js/jetpack/tests/unit/impl.js
--- a/js/jetpack/bootstrap-impl.js
+++ b/js/jetpack/tests/unit/impl.js
@@ -1,7 +1,21 @@
-registerReceiver("echo", function(msgName, data) {
-  sendMessage(msgName, data);
-});
+registerReceiver("echo",
+                 function(msgName, data, handle) {
+                   sendMessage(msgName, data, handle);
+                 });
 
-registerReceiver("callback", function(msgName, data) {
-  sendMessage("sendback", callMessage("callback", data)[0]);
-});
+registerReceiver("callback",
+                 function(msgName, data, handle) {
+                   sendMessage("sendback",
+                               callMessage("callback", data)[0],
+                               handle);
+                 });
+
+registerReceiver("gimmeHandle",
+                 function(msgName) {
+                   sendMessage("recvHandle", "ok", createHandle());
+                 });
+
+registerReceiver("kthx",
+                 function(msgName, data, child) {
+                   sendMessage("recvHandleAgain", data + data, child.parent);
+                 });
diff --git a/js/jetpack/tests/unit/test_jetpack.js b/js/jetpack/tests/unit/test_jetpack.js
--- a/js/jetpack/tests/unit/test_jetpack.js
+++ b/js/jetpack/tests/unit/test_jetpack.js
@@ -1,33 +1,59 @@
 var jps = jps || Components.classes["@mozilla.org/jetpack/service;1"]
   .getService(Components.interfaces.nsIJetpackService);
 
 function run_test() {
   var jetpack = jps.createJetpack();
   jetpack.loadImplementation(
-    "chrome://global/content/jetpack/bootstrap-impl.js");
+    "chrome://global/content/jetpack/test-impl.js");
   jetpack.loadUserScript(
-    "chrome://global/content/jetpack/bootstrap-user.js");
+    "chrome://global/content/jetpack/test-user.js");
 
-  jetpack.registerReceiver("echo", function(msgName, data) {
-    do_check_eq(msgName, "echo");
-    do_check_eq(data, "echo this");
-    do_test_finished();
-  });
+  var echoHandle = jetpack.createHandle();
+  echoHandle.payload = { weight: 10 };
+  jetpack.registerReceiver("echo",
+                           function(msgName, data, handle) {
+                             do_check_eq(arguments.length, 3);
+                             do_check_eq(msgName, "echo");
+                             do_check_eq(data, "echo this");
+                             do_check_true(handle.isValid);
+                             do_check_eq(handle, echoHandle);
+                             do_check_eq(handle.payload.weight, 10);
+                             do_test_finished();
+                           });
 
-  jetpack.registerReceiver("callback", function(msgName, data) {
-    do_check_eq(msgName, "callback");
-    return "called back: " + data;
-  });
+  jetpack.registerReceiver("callback",
+                           function(msgName, data) {
+                             do_check_eq(msgName, "callback");
+                             return "called back: " + data;
+                           });
 
-  jetpack.registerReceiver("sendback", function(msgName, data) {
-    do_check_eq(msgName, "sendback");
-    do_check_eq(data, "called back: call me back");
-    do_test_finished();
-  });
+  var callbackHandle = echoHandle.createHandle();
+  jetpack.registerReceiver("sendback",
+                           function(msgName, data, handle) {
+                             do_check_eq(msgName, "sendback");
+                             do_check_eq(data, "called back: call me back");
+                             do_check_eq(handle, callbackHandle);
+                             do_test_finished();
+                           });
+
+  var obj;
+  jetpack.registerReceiver("recvHandle",
+                           function(msgName, data, handle) {
+                             handle.mark = obj = {};
+                             jetpack.sendMessage("kthx", data + data, handle.createHandle());
+                           });
+  jetpack.registerReceiver("recvHandleAgain",
+                           function(msgName, data, handle) {
+                             do_check_eq(data, "okokokok");
+                             do_check_eq(handle.mark, obj);
+                             do_test_finished();
+                           });
 
   do_test_pending();
   do_test_pending();
+  do_test_pending();
 
-  jetpack.sendMessage("echo", "echo this");
-  jetpack.sendMessage("callback", "call me back");
+  jetpack.sendMessage("echo", "echo this", echoHandle);
+  jetpack.sendMessage("callback", "call me back", callbackHandle);
+  jetpack.sendMessage("gimmeHandle");
 }
diff --git a/js/jetpack/bootstrap-user.js b/js/jetpack/tests/unit/user.js
rename from js/jetpack/bootstrap-user.js
rename to js/jetpack/tests/unit/user.js
diff --git a/toolkit/toolkit-makefiles.sh b/toolkit/toolkit-makefiles.sh
--- a/toolkit/toolkit-makefiles.sh
+++ b/toolkit/toolkit-makefiles.sh
@@ -81,16 +81,17 @@ MAKEFILES_dom="
   dom/src/geolocation/Makefile
   dom/src/json/Makefile
   dom/src/offline/Makefile
   dom/src/storage/Makefile
   dom/src/threads/Makefile
   dom/locales/Makefile
   dom/plugins/Makefile
   js/jetpack/Makefile
+  js/ipc/Makefile
 "
 
 MAKEFILES_editor="
   editor/Makefile
   editor/public/Makefile
   editor/idl/Makefile
   editor/txmgr/Makefile
   editor/txmgr/idl/Makefile
diff --git a/toolkit/toolkit-tiers.mk b/toolkit/toolkit-tiers.mk
--- a/toolkit/toolkit-tiers.mk
+++ b/toolkit/toolkit-tiers.mk
@@ -99,17 +99,17 @@ ifeq ($(OS_ARCH),WINCE)
 tier_platform_dirs += modules/lib7z
 endif
 
 #
 # "gecko" - core components
 #
 
 ifdef MOZ_IPC
-tier_platform_dirs += ipc js/jetpack
+tier_platform_dirs += ipc js/jetpack js/ipc
 endif
 
 tier_platform_dirs += \
 		js/src/xpconnect \
 		intl/chardet \
 		$(NULL)
 
 ifdef MOZ_ENABLE_GTK2
