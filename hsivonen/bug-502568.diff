# HG changeset patch
# User Ben Newman <bnewman@mozilla.com>
# Date 1259197501 28800
# Node ID f9ce1a631fbaa03807a3240698a1b4665d193d4c
# Parent  d757244cec7687c28d2318aedf99462b64d191d2
[mq]: hsivonen/bug-502568.diff

diff --git a/modules/libpref/src/init/all.js b/modules/libpref/src/init/all.js
--- a/modules/libpref/src/init/all.js
+++ b/modules/libpref/src/init/all.js
@@ -2819,8 +2819,17 @@ pref("gfx.color_management.mode", 0);
 
 // Enable/Disable the geolocation API for content
 pref("geo.enabled", true);
 
 // Enable/Disable HTML5 parser
 pref("html5.enable", false);
 // Toggle which thread the HTML5 parser uses for streama parsing
 pref("html5.offmainthread", true);
+// Time in milliseconds between the start of the network stream and the 
+// first time the flush timer fires in the off-the-main-thread HTML5 parser.
+pref("html5.flushtimer.startdelay", 200);
+// Time in milliseconds between the return to non-speculating more and the 
+// first time the flush timer fires thereafter.
+pref("html5.flushtimer.continuedelay", 150);
+// Time in milliseconds between timer firings once the timer has starting 
+// firing.
+pref("html5.flushtimer.interval", 100);
diff --git a/parser/html/nsAHtml5TreeOpSink.h b/parser/html/nsAHtml5TreeOpSink.h
--- a/parser/html/nsAHtml5TreeOpSink.h
+++ b/parser/html/nsAHtml5TreeOpSink.h
@@ -43,21 +43,15 @@
  * (main-thread case), a tree op stage (non-speculative off-the-main-thread
  * case) or a speculation (speculative case).
  */
 class nsAHtml5TreeOpSink {
   public:
   
     /**
      * Flush the operations from the tree operations from the argument
-     * queue if flushing is not expensive.
+     * queue into this sink unconditionally.
      */
-    virtual void MaybeFlush(nsTArray<nsHtml5TreeOperation>& aOpQueue) = 0;
-
-    /**
-     * Flush the operations from the tree operations from the argument
-     * queue unconditionally.
-     */
-    virtual void ForcedFlush(nsTArray<nsHtml5TreeOperation>& aOpQueue) = 0;
+    virtual void MoveOpsFrom(nsTArray<nsHtml5TreeOperation>& aOpQueue) = 0;
     
 };
 
 #endif /* nsAHtml5TreeOpSink_h___ */
diff --git a/parser/html/nsHtml5Module.cpp b/parser/html/nsHtml5Module.cpp
--- a/parser/html/nsHtml5Module.cpp
+++ b/parser/html/nsHtml5Module.cpp
@@ -64,16 +64,17 @@ nsHtml5Module::InitializeStatics()
   nsHtml5ElementName::initializeStatics();
   nsHtml5HtmlAttributes::initializeStatics();
   nsHtml5NamedCharacters::initializeStatics();
   nsHtml5Portability::initializeStatics();
   nsHtml5StackNode::initializeStatics();
   nsHtml5Tokenizer::initializeStatics();
   nsHtml5TreeBuilder::initializeStatics();
   nsHtml5UTF16Buffer::initializeStatics();
+  nsHtml5StreamParser::InitializeStatics();
 #ifdef DEBUG
   sNsHtml5ModuleInitialized = PR_TRUE;
 #endif
 }
 
 // static
 void
 nsHtml5Module::ReleaseStatics()
diff --git a/parser/html/nsHtml5Speculation.cpp b/parser/html/nsHtml5Speculation.cpp
--- a/parser/html/nsHtml5Speculation.cpp
+++ b/parser/html/nsHtml5Speculation.cpp
@@ -50,28 +50,22 @@ nsHtml5Speculation::nsHtml5Speculation(n
 }
 
 nsHtml5Speculation::~nsHtml5Speculation()
 {
   MOZ_COUNT_DTOR(nsHtml5Speculation);
 }
 
 void
-nsHtml5Speculation::MaybeFlush(nsTArray<nsHtml5TreeOperation>& aOpQueue)
-{
-  // No-op
-}
-
-void
-nsHtml5Speculation::ForcedFlush(nsTArray<nsHtml5TreeOperation>& aOpQueue)
+nsHtml5Speculation::MoveOpsFrom(nsTArray<nsHtml5TreeOperation>& aOpQueue)
 {
   if (mOpQueue.IsEmpty()) {
     mOpQueue.SwapElements(aOpQueue);
     return;
   }
   mOpQueue.MoveElementsFrom(aOpQueue);
 }
 
 void
 nsHtml5Speculation::FlushToSink(nsAHtml5TreeOpSink* aSink)
 {
-  aSink->ForcedFlush(mOpQueue);
+  aSink->MoveOpsFrom(mOpQueue);
 }
diff --git a/parser/html/nsHtml5Speculation.h b/parser/html/nsHtml5Speculation.h
--- a/parser/html/nsHtml5Speculation.h
+++ b/parser/html/nsHtml5Speculation.h
@@ -67,25 +67,20 @@ class nsHtml5Speculation : public nsAHtm
       return mStartLineNumber;
     }
     
     nsAHtml5TreeBuilderState* GetSnapshot() {
       return mSnapshot;
     }
 
     /**
-     * No-op.
-     */
-    virtual void MaybeFlush(nsTArray<nsHtml5TreeOperation>& aOpQueue);
-
-    /**
      * Flush the operations from the tree operations from the argument
      * queue unconditionally.
      */
-    virtual void ForcedFlush(nsTArray<nsHtml5TreeOperation>& aOpQueue);
+    virtual void MoveOpsFrom(nsTArray<nsHtml5TreeOperation>& aOpQueue);
     
     void FlushToSink(nsAHtml5TreeOpSink* aSink);
 
   private:
     /**
      * The first buffer in the pending UTF-16 buffer queue
      */
     nsRefPtr<nsHtml5UTF16Buffer>        mBuffer;
diff --git a/parser/html/nsHtml5StreamParser.cpp b/parser/html/nsHtml5StreamParser.cpp
--- a/parser/html/nsHtml5StreamParser.cpp
+++ b/parser/html/nsHtml5StreamParser.cpp
@@ -49,29 +49,49 @@
 #include "nsHtml5Parser.h"
 #include "nsHtml5TreeBuilder.h"
 #include "nsHtml5AtomTable.h"
 #include "nsHtml5Module.h"
 #include "nsHtml5RefPtr.h"
 
 static NS_DEFINE_CID(kCharsetAliasCID, NS_CHARSETALIAS_CID);
 
+PRInt32 nsHtml5StreamParser::sTimerStartDelay = 200;
+PRInt32 nsHtml5StreamParser::sTimerContinueDelay = 150;
+PRInt32 nsHtml5StreamParser::sTimerInterval = 100;
+
+// static
+void
+nsHtml5StreamParser::InitializeStatics()
+{
+  nsContentUtils::AddIntPrefVarCache("html5.flushtimer.startdelay", 
+                                     &sTimerStartDelay);
+  nsContentUtils::AddIntPrefVarCache("html5.flushtimer.continuedelay", 
+                                     &sTimerContinueDelay);
+  nsContentUtils::AddIntPrefVarCache("html5.flushtimer.interval",
+                                     &sTimerInterval);
+}
+
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsHtml5StreamParser)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsHtml5StreamParser)
 
 NS_INTERFACE_TABLE_HEAD(nsHtml5StreamParser)
   NS_INTERFACE_TABLE2(nsHtml5StreamParser, 
                       nsIStreamListener, 
                       nsICharsetDetectionObserver)
   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsHtml5StreamParser)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsHtml5StreamParser)
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsHtml5StreamParser)
+  if (tmp->mFlushTimer) {
+    tmp->mFlushTimer->Cancel();
+    tmp->mFlushTimer = nsnull;
+  }
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mObserver)
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mRequest)
   tmp->mOwner = nsnull;
   tmp->mExecutorFlusher = nsnull;
   tmp->mExecutor = nsnull;
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocument)
   tmp->mTreeBuilder->DropSpeculativeLoader();
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
@@ -120,16 +140,17 @@ nsHtml5StreamParser::nsHtml5StreamParser
   , mTreeBuilder(new nsHtml5TreeBuilder(mExecutor->GetStage()))
   , mTokenizer(new nsHtml5Tokenizer(mTreeBuilder))
   , mTokenizerMutex("nsHtml5StreamParser mTokenizerMutex")
   , mOwner(aOwner)
   , mSpeculationMutex("nsHtml5StreamParser mSpeculationMutex")
   , mTerminatedMutex("nsHtml5StreamParser mTerminatedMutex")
   , mThread(nsHtml5Module::GetStreamParserThread())
   , mExecutorFlusher(new nsHtml5ExecutorFlusher(aExecutor))
+  , mFlushTimer(do_CreateInstance("@mozilla.org/timer;1"))
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
   mAtomTable.Init(); // we aren't checking for OOM anyway...
   #ifdef DEBUG
     mAtomTable.SetPermittedLookupThread(mThread);
   #endif
   mTokenizer->setInterner(&mAtomTable);
   mTokenizer->setEncodingDeclarationHandler(this);
@@ -145,16 +166,20 @@ nsHtml5StreamParser::~nsHtml5StreamParse
   mUnicodeDecoder = nsnull;
   mSniffingBuffer = nsnull;
   mMetaScanner = nsnull;
   mFirstBuffer = nsnull;
   mExecutor = nsnull;
   mTreeBuilder = nsnull;
   mTokenizer = nsnull;
   mOwner = nsnull;
+  if (mFlushTimer) {
+    mFlushTimer->Cancel();
+    mFlushTimer = nsnull;
+  }
 }
 
 void
 nsHtml5StreamParser::SetSpeculativeLoaderWithDocument(nsIDocument* aDocument) {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
   mDocument = aDocument;
   mTreeBuilder->SetSpeculativeLoaderWithDocument(aDocument);
 }
@@ -478,16 +503,21 @@ nsHtml5StreamParser::OnStartRequest(nsIR
   mExecutor->StartReadingFromStage();
   /*
    * If you move the following line, be very careful not to cause 
    * WillBuildModel to be called before the document has had its 
    * script global object set.
    */
   mExecutor->WillBuildModel(eDTDMode_unknown);
   
+  mFlushTimer->InitWithFuncCallback(nsHtml5StreamParser::TimerCallback, 
+                                    static_cast<void*> (this), 
+                                    sTimerStartDelay, 
+                                    nsITimer::TYPE_ONE_SHOT);
+
   nsresult rv = NS_OK;
 
   mReparseForbidden = PR_FALSE;
   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mRequest, &rv));
   if (NS_SUCCEEDED(rv)) {
     nsCAutoString method;
     httpChannel->GetRequestMethod(method);
     // XXX does Necko have a way to renavigate POST, etc. without hitting
@@ -714,17 +744,16 @@ nsHtml5StreamParser::ParseAvailableData(
         switch (mStreamState) {
           case STREAM_BEING_READ:
             // never release the last buffer.
             if (!mSpeculating) {
               // reuse buffer space if not speculating
               mFirstBuffer->setStart(0);
               mFirstBuffer->setEnd(0);
             }
-            mTreeBuilder->Flush();
             return; // no more data for now but expecting more
           case STREAM_ENDED:
             if (mAtEOF) {
                 return;
             }
             mAtEOF = PR_TRUE;
             mTokenizer->eof();
             mTreeBuilder->StreamEnded();
@@ -767,17 +796,16 @@ nsHtml5StreamParser::ParseAvailableData(
         }
         mTreeBuilder->SetOpSink(speculation);
         mSpeculations.AppendElement(speculation); // adopts the pointer
         mSpeculating = PR_TRUE;
       }
       if (IsTerminatedOrInterrupted()) {
         return;
       }
-      mTreeBuilder->MaybeFlush();
     }
     continue;
   }
 }
 
 class nsHtml5StreamParserContinuation : public nsRunnable
 {
 private:
@@ -868,16 +896,21 @@ nsHtml5StreamParser::ContinueAfterScript
                              // run here synchronously on the main thread...
 
       mTreeBuilder->flushCharacters(); // empty the pending buffer
       mTreeBuilder->ClearOps(); // now get rid of the failed ops
 
       mTreeBuilder->SetOpSink(mExecutor->GetStage());
       mExecutor->StartReadingFromStage();
       mSpeculating = PR_FALSE;
+      mFlushTimer->Cancel(); // just in case
+      mFlushTimer->InitWithFuncCallback(nsHtml5StreamParser::TimerCallback, 
+                                        static_cast<void*> (this), 
+                                        sTimerContinueDelay, 
+                                        nsITimer::TYPE_ONE_SHOT);
       // Copy state over
       mLastWasCR = aLastWasCR;
       mTokenizer->loadState(aTokenizer);
       mTreeBuilder->loadState(aTreeBuilder, &mAtomTable);
     } else {    
       // We've got a successful speculation and at least a moment ago it was
       // the current speculation
       mSpeculations.ElementAt(0)->FlushToSink(mExecutor);
@@ -885,16 +918,21 @@ nsHtml5StreamParser::ContinueAfterScript
         NS_WARNING("failed to dispatch executor flush event");
       }
       mSpeculations.RemoveElementAt(0);
       if (mSpeculations.IsEmpty()) {
         // yes, it was still the only speculation. Now stop speculating
         mTreeBuilder->SetOpSink(mExecutor->GetStage());
         mExecutor->StartReadingFromStage();
         mSpeculating = PR_FALSE;
+        mFlushTimer->Cancel(); // just in case
+        mFlushTimer->InitWithFuncCallback(nsHtml5StreamParser::TimerCallback, 
+                                          static_cast<void*> (this), 
+                                          sTimerContinueDelay, 
+                                          nsITimer::TYPE_ONE_SHOT);
       }
     }
     Uninterrupt();
     nsCOMPtr<nsIRunnable> event = new nsHtml5StreamParserContinuation(this);
     if (NS_FAILED(mThread->Dispatch(event, nsIThread::DISPATCH_NORMAL))) {
       NS_WARNING("Failed to dispatch ParseAvailableData event");
     }
     // A stream event might run before this event runs, but that's harmless.
@@ -907,11 +945,94 @@ nsHtml5StreamParser::ContinueAfterScript
 void
 nsHtml5StreamParser::ContinueAfterFailedCharsetSwitch()
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
   mozilla::MutexAutoLock tokenizerAutoLock(mTokenizerMutex);
   Uninterrupt();
   nsCOMPtr<nsIRunnable> event = new nsHtml5StreamParserContinuation(this);
   if (NS_FAILED(mThread->Dispatch(event, nsIThread::DISPATCH_NORMAL))) {
-    NS_WARNING("Failed to dispatch ParseAvailableData event");
-  }  
+    NS_WARNING("Failed to dispatch nsHtml5StreamParserContinuation");
+  }
 }
+
+// Using a static, because the method name Notify is taken by the chardet 
+// callback.
+void
+nsHtml5StreamParser::TimerCallback(nsITimer* aTimer, void* aClosure)
+{
+  (static_cast<nsHtml5StreamParser*> (aClosure))->PostTimerFlush();
+}
+
+void
+nsHtml5StreamParser::TimerFlush()
+{
+  NS_ASSERTION(IsParserThread(), "Wrong thread!");
+  mTokenizerMutex.AssertCurrentThreadOwns();
+
+  if (mSpeculating) {
+    return;
+  }
+
+  // we aren't speculating and we don't know when new data is
+  // going to arrive. Send data to the main thread.
+  // However, don't do if the current element on the stack is a 
+  // foster-parenting element and there's pending text, because flushing in 
+  // that case would make the tree shape dependent on where the flush points 
+  // fall.
+  if (mTreeBuilder->IsDiscretionaryFlushSafe()) {
+    mTreeBuilder->flushCharacters();
+    if (mTreeBuilder->Flush()) {
+      if (NS_FAILED(NS_DispatchToMainThread(mExecutorFlusher))) {
+        NS_WARNING("failed to dispatch executor flush event");
+      }
+    }
+  }
+}
+
+class nsHtml5StreamParserTimerFlusher : public nsRunnable
+{
+private:
+  nsHtml5RefPtr<nsHtml5StreamParser> mStreamParser;
+public:
+  nsHtml5StreamParserTimerFlusher(nsHtml5StreamParser* aStreamParser)
+    : mStreamParser(aStreamParser)
+  {}
+  NS_IMETHODIMP Run()
+  {
+    mozilla::MutexAutoLock autoLock(mStreamParser->mTokenizerMutex);
+    mStreamParser->TimerFlush();
+    return NS_OK;
+  }
+};
+
+void
+nsHtml5StreamParser::PostTimerFlush()
+{
+  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+
+  mFlushTimer->Cancel(); // just in case
+
+  // The following line reads a mutex-protected variable without acquiring 
+  // the mutex. This is OK, because failure to exit early here is harmless.
+  // The early exit here is merely an optimization. Note that parser thread
+  // may have set mSpeculating to true where it previously was false--not 
+  // the other way round. mSpeculating is set to false only on the main thread.
+  if (mSpeculating) {
+    // No need for timer flushes when speculating
+    return;
+  }
+
+  // Schedule the next timer shot
+  mFlushTimer->InitWithFuncCallback(nsHtml5StreamParser::TimerCallback, 
+                                    static_cast<void*> (this), 
+                                    sTimerInterval, 
+                                    nsITimer::TYPE_ONE_SHOT);
+
+  // TODO: (If mDocument isn't in the frontmost tab or If the user isn't 
+  // interacting with the browser) and this isn't every nth timer flush, return
+
+  nsCOMPtr<nsIRunnable> event = new nsHtml5StreamParserTimerFlusher(this);
+  if (NS_FAILED(mThread->Dispatch(event, nsIThread::DISPATCH_NORMAL))) {
+    NS_WARNING("Failed to dispatch nsHtml5StreamParserTimerFlusher");
+  }
+}
+
diff --git a/parser/html/nsHtml5StreamParser.h b/parser/html/nsHtml5StreamParser.h
--- a/parser/html/nsHtml5StreamParser.h
+++ b/parser/html/nsHtml5StreamParser.h
@@ -47,16 +47,17 @@
 #include "nsIUnicodeDecoder.h"
 #include "nsHtml5TreeOpExecutor.h"
 #include "nsHtml5UTF16Buffer.h"
 #include "nsIInputStream.h"
 #include "nsICharsetAlias.h"
 #include "mozilla/Mutex.h"
 #include "nsHtml5AtomTable.h"
 #include "nsHtml5Speculation.h"
+#include "nsITimer.h"
 
 class nsHtml5Parser;
 
 #define NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE 1024
 #define NS_HTML5_STREAM_PARSER_SNIFFING_BUFFER_SIZE 512
 
 enum eBomState {
   /**
@@ -101,22 +102,25 @@ enum eHtml5StreamState {
 };
 
 class nsHtml5StreamParser : public nsIStreamListener,
                             public nsICharsetDetectionObserver {
 
   friend class nsHtml5RequestStopper;
   friend class nsHtml5DataAvailable;
   friend class nsHtml5StreamParserContinuation;
+  friend class nsHtml5StreamParserTimerFlusher;
 
   public:
     NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
     NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsHtml5StreamParser, nsIStreamListener)
 
+    static void InitializeStatics();
+
     nsHtml5StreamParser(nsHtml5TreeOpExecutor* aExecutor,
                         nsHtml5Parser* aOwner);
                         
     virtual ~nsHtml5StreamParser();
 
     // nsIRequestObserver methods:
     NS_DECL_NSIREQUESTOBSERVER
     // nsIStreamListener methods:
@@ -296,16 +300,33 @@ class nsHtml5StreamParser : public nsISt
      *                     or UTF-8)
      * @param aDecoderCharsetName The actual name for the decoder's charset
      *                            (UTF-16BE, UTF-16LE or UTF-8; the BOM has
      *                            been swallowed)
      */
     nsresult SetupDecodingFromBom(const char* aCharsetName,
                                   const char* aDecoderCharsetName);
 
+    /**
+     * Callback for mFlushTimer.
+     */
+    static void TimerCallback(nsITimer* aTimer, void* aClosure);
+
+    /**
+     * Main thread entry point for (maybe) flushing the ops and posting
+     * a flush runnable back on the main thread.
+     */
+    void PostTimerFlush();
+
+    /**
+     * Parser thread entry point for (maybe) flushing the ops and posting
+     * a flush runnable back on the main thread.
+     */
+    void TimerFlush();
+
     nsCOMPtr<nsIRequest>          mRequest;
     nsCOMPtr<nsIRequestObserver>  mObserver;
 
     /**
      * The Unicode decoder
      */
     nsCOMPtr<nsIUnicodeDecoder>   mUnicodeDecoder;
 
@@ -430,11 +451,36 @@ class nsHtml5StreamParser : public nsISt
     nsCOMPtr<nsIThread>           mThread;
     
     nsCOMPtr<nsIRunnable>         mExecutorFlusher;
     
     /**
      * The document wrapped by the speculative loader.
      */
     nsCOMPtr<nsIDocument>         mDocument;
+
+    /**
+     * Timer for flushing tree ops once in a while when not speculating.
+     */
+    nsCOMPtr<nsITimer>            mFlushTimer;
+
+    /**
+     * The pref html5.flushtimer.startdelay: Time in milliseconds between
+     * the start of the network stream and the first time the flush timer
+     * fires.
+     */
+    static PRInt32                sTimerStartDelay;
+
+    /**
+     * The pref html5.flushtimer.continuedelay: Time in milliseconds between
+     * the return to non-speculating more and the first time the flush timer
+     * fires thereafter.
+     */
+    static PRInt32                sTimerContinueDelay;
+
+    /**
+     * The pref html5.flushtimer.interval: Time in milliseconds between
+     * timer firings once the timer has starting firing.
+     */
+    static PRInt32                sTimerInterval;
 };
 
 #endif // nsHtml5StreamParser_h__
diff --git a/parser/html/nsHtml5TreeBuilderCppSupplement.h b/parser/html/nsHtml5TreeBuilderCppSupplement.h
--- a/parser/html/nsHtml5TreeBuilderCppSupplement.h
+++ b/parser/html/nsHtml5TreeBuilderCppSupplement.h
@@ -319,25 +319,19 @@ nsHtml5TreeBuilder::insertFosterParented
 {
   NS_PRECONDITION(aBuffer, "Null buffer");
   NS_PRECONDITION(aTable, "Null table");
   NS_PRECONDITION(aStackParent, "Null stack parent");
 
   PRUnichar* bufferCopy = new PRUnichar[aLength];
   memcpy(bufferCopy, aBuffer, aLength * sizeof(PRUnichar));
   
-  nsIContent** text = AllocateContentHandle();
-
   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
   NS_ASSERTION(treeOp, "Tree op allocation failed.");
-  treeOp->Init(eTreeOpCreateTextNode, bufferCopy, aLength, text);
-
-  treeOp = mOpQueue.AppendElement();
-  NS_ASSERTION(treeOp, "Tree op allocation failed.");
-  treeOp->Init(eTreeOpFosterParent, text, aStackParent, aTable);
+  treeOp->Init(eTreeOpFosterParentText, bufferCopy, aLength, aStackParent, aTable);
 }
 
 void
 nsHtml5TreeBuilder::insertFosterParentedChild(nsIContent** aChild, nsIContent** aTable, nsIContent** aStackParent)
 {
   NS_PRECONDITION(aChild, "Null child");
   NS_PRECONDITION(aTable, "Null table");
   NS_PRECONDITION(aStackParent, "Null stack parent");
@@ -351,64 +345,46 @@ void
 nsHtml5TreeBuilder::appendCharacters(nsIContent** aParent, PRUnichar* aBuffer, PRInt32 aStart, PRInt32 aLength)
 {
   NS_PRECONDITION(aBuffer, "Null buffer");
   NS_PRECONDITION(aParent, "Null parent");
 
   PRUnichar* bufferCopy = new PRUnichar[aLength];
   memcpy(bufferCopy, aBuffer, aLength * sizeof(PRUnichar));
   
-  nsIContent** text = AllocateContentHandle();
-
   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
   NS_ASSERTION(treeOp, "Tree op allocation failed.");
-  treeOp->Init(eTreeOpCreateTextNode, bufferCopy, aLength, text);
-
-  treeOp = mOpQueue.AppendElement();
-  NS_ASSERTION(treeOp, "Tree op allocation failed.");
-  treeOp->Init(eTreeOpAppend, text, aParent);
+  treeOp->Init(eTreeOpAppendText, bufferCopy, aLength, aParent);
 }
 
 void
 nsHtml5TreeBuilder::appendComment(nsIContent** aParent, PRUnichar* aBuffer, PRInt32 aStart, PRInt32 aLength)
 {
   NS_PRECONDITION(aBuffer, "Null buffer");
   NS_PRECONDITION(aParent, "Null parent");
 
   PRUnichar* bufferCopy = new PRUnichar[aLength];
   memcpy(bufferCopy, aBuffer, aLength * sizeof(PRUnichar));
   
-  nsIContent** comment = AllocateContentHandle();
-
   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
   NS_ASSERTION(treeOp, "Tree op allocation failed.");
-  treeOp->Init(eTreeOpCreateComment, bufferCopy, aLength, comment);
-
-  treeOp = mOpQueue.AppendElement();
-  NS_ASSERTION(treeOp, "Tree op allocation failed.");
-  treeOp->Init(eTreeOpAppend, comment, aParent);
+  treeOp->Init(eTreeOpAppendComment, bufferCopy, aLength, aParent);
 }
 
 void
 nsHtml5TreeBuilder::appendCommentToDocument(PRUnichar* aBuffer, PRInt32 aStart, PRInt32 aLength)
 {
   NS_PRECONDITION(aBuffer, "Null buffer");
 
   PRUnichar* bufferCopy = new PRUnichar[aLength];
   memcpy(bufferCopy, aBuffer, aLength * sizeof(PRUnichar));
   
-  nsIContent** comment = AllocateContentHandle();
-
   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
   NS_ASSERTION(treeOp, "Tree op allocation failed.");
-  treeOp->Init(eTreeOpCreateComment, bufferCopy, aLength, comment);
-
-  treeOp = mOpQueue.AppendElement();
-  NS_ASSERTION(treeOp, "Tree op allocation failed.");
-  treeOp->Init(eTreeOpAppendToDocument, comment);
+  treeOp->Init(eTreeOpAppendCommentToDocument, bufferCopy, aLength);
 }
 
 void
 nsHtml5TreeBuilder::addAttributesToElement(nsIContent** aElement, nsHtml5HtmlAttributes* aAttributes)
 {
   NS_PRECONDITION(aElement, "Null element");
   NS_PRECONDITION(aAttributes, "Null attributes");
 
@@ -448,25 +424,19 @@ nsHtml5TreeBuilder::end()
 #endif
 }
 
 void
 nsHtml5TreeBuilder::appendDoctypeToDocument(nsIAtom* aName, nsString* aPublicId, nsString* aSystemId)
 {
   NS_PRECONDITION(aName, "Null name");
 
-  nsIContent** content = AllocateContentHandle();
-
   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
   NS_ASSERTION(treeOp, "Tree op allocation failed.");
-  treeOp->Init(aName, *aPublicId, *aSystemId, content);
-  
-  treeOp = mOpQueue.AppendElement();
-  NS_ASSERTION(treeOp, "Tree op allocation failed.");
-  treeOp->Init(eTreeOpAppendToDocument, content);
+  treeOp->Init(aName, *aPublicId, *aSystemId);
   // nsXMLContentSink can flush here, but what's the point?
   // It can also interrupt here, but we can't.
 }
 
 void
 nsHtml5TreeBuilder::elementPushed(PRInt32 aNamespace, nsIAtom* aName, nsIContent** aElement)
 {
   NS_ASSERTION(aNamespace == kNameSpaceID_XHTML || aNamespace == kNameSpaceID_SVG || aNamespace == kNameSpaceID_MathML, "Element isn't HTML, SVG or MathML!");
@@ -619,26 +589,24 @@ nsHtml5TreeBuilder::HasScript()
 {
   PRUint32 len = mOpQueue.Length();
   if (!len) {
     return PR_FALSE;
   }
   return mOpQueue.ElementAt(len - 1).IsRunScript();
 }
 
-void
+PRBool
 nsHtml5TreeBuilder::Flush()
 {
-  mOpSink->ForcedFlush(mOpQueue);
-}
-
-void
-nsHtml5TreeBuilder::MaybeFlush()
-{
-  mOpSink->MaybeFlush(mOpQueue);
+  PRBool hasOps = !mOpQueue.IsEmpty();
+  if (hasOps) {
+    mOpSink->MoveOpsFrom(mOpQueue);
+  }
+  return hasOps;
 }
 
 void
 nsHtml5TreeBuilder::SetDocumentCharset(nsACString& aCharset)
 {
   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
   NS_ASSERTION(treeOp, "Tree op allocation failed.");
   treeOp->Init(eTreeOpSetDocumentCharset, aCharset);  
@@ -681,16 +649,24 @@ nsHtml5TreeBuilder::SetSpeculativeLoader
   mSpeculativeLoader = new nsHtml5SpeculativeLoader(aDocument);
 }
 
 void
 nsHtml5TreeBuilder::DropSpeculativeLoader() {
   mSpeculativeLoader = nsnull;
 }
 
+PRBool 
+nsHtml5TreeBuilder::IsDiscretionaryFlushSafe()
+{
+  return !(charBufferLen && 
+           currentPtr >= 0 && 
+           stack[currentPtr]->fosterParenting);
+}
+
 // DocumentModeHandler
 void
 nsHtml5TreeBuilder::documentMode(nsHtml5DocumentMode m)
 {
   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
   NS_ASSERTION(treeOp, "Tree op allocation failed.");
   treeOp->Init(m);
 }
diff --git a/parser/html/nsHtml5TreeBuilderHSupplement.h b/parser/html/nsHtml5TreeBuilderHSupplement.h
--- a/parser/html/nsHtml5TreeBuilderHSupplement.h
+++ b/parser/html/nsHtml5TreeBuilderHSupplement.h
@@ -59,33 +59,33 @@
     nsIContent** AllocateContentHandle();
     
   public:
 
     nsHtml5TreeBuilder(nsAHtml5TreeOpSink* aOpSink);
 
     ~nsHtml5TreeBuilder();
     
+    PRBool IsDiscretionaryFlushSafe();
+
     PRBool HasScript();
     
     void SetOpSink(nsAHtml5TreeOpSink* aOpSink) {
       mOpSink = aOpSink;
     }
 
     void ClearOps() {
       mOpQueue.Clear();
     }
     
     void SetSpeculativeLoaderWithDocument(nsIDocument* aDocument);
 
     void DropSpeculativeLoader();
 
-    void Flush();
-    
-    void MaybeFlush();
+    PRBool Flush();
     
     void SetDocumentCharset(nsACString& aCharset);
 
     void StreamEnded();
 
     void NeedsCharsetSwitchTo(const nsACString& aEncoding);
 
     void AddSnapshotToScript(nsAHtml5TreeBuilderState* aSnapshot, PRInt32 aLine);
diff --git a/parser/html/nsHtml5TreeOpExecutor.cpp b/parser/html/nsHtml5TreeOpExecutor.cpp
--- a/parser/html/nsHtml5TreeOpExecutor.cpp
+++ b/parser/html/nsHtml5TreeOpExecutor.cpp
@@ -55,63 +55,44 @@
 #include "nsHtml5Parser.h"
 #include "nsHtml5Tokenizer.h"
 #include "nsHtml5TreeBuilder.h"
 #include "nsHtml5StreamParser.h"
 
 #define NS_HTML5_TREE_OP_EXECUTOR_MAX_QUEUE_TIME 3000UL // milliseconds
 #define NS_HTML5_TREE_OP_EXECUTOR_DEFAULT_QUEUE_LENGTH 200
 #define NS_HTML5_TREE_OP_EXECUTOR_MIN_QUEUE_LENGTH 100
-#define NS_HTML5_TREE_OP_EXECUTOR_MAX_TIME_WITHOUT_FLUSH 5000 // milliseconds
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsHtml5TreeOpExecutor)
 
 NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHtml5TreeOpExecutor)
   NS_INTERFACE_TABLE_INHERITED1(nsHtml5TreeOpExecutor, 
                                 nsIContentSink)
 NS_INTERFACE_TABLE_TAIL_INHERITING(nsContentSink)
 
 NS_IMPL_ADDREF_INHERITED(nsHtml5TreeOpExecutor, nsContentSink)
 
 NS_IMPL_RELEASE_INHERITED(nsHtml5TreeOpExecutor, nsContentSink)
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHtml5TreeOpExecutor, nsContentSink)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFlushTimer)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mOwnedElements)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mOwnedNonElements)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsHtml5TreeOpExecutor, nsContentSink)
-  if (tmp->mFlushTimer) {
-    tmp->mFlushTimer->Cancel();
-  }
-  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFlushTimer)
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mOwnedElements)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mOwnedNonElements)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 nsHtml5TreeOpExecutor::nsHtml5TreeOpExecutor()
-  : mFlushTimer(do_CreateInstance("@mozilla.org/timer;1"))
 {
-  // zeroing operator new for everything else
+  // zeroing operator new for everything
 }
 
 nsHtml5TreeOpExecutor::~nsHtml5TreeOpExecutor()
 {
   NS_ASSERTION(mOpQueue.IsEmpty(), "Somehow there's stuff in the op queue.");
-  if (mFlushTimer) {
-    mFlushTimer->Cancel(); // XXX why is this even necessary? it is, though.
-  }
-  mFlushTimer = nsnull;
-}
-
-static void
-TimerCallbackFunc(nsITimer* aTimer, void* aClosure)
-{
-  (static_cast<nsHtml5TreeOpExecutor*> (aClosure))->Flush();
 }
 
 // nsIContentSink
 NS_IMETHODIMP
 nsHtml5TreeOpExecutor::WillParse()
 {
   NS_NOTREACHED("No one should call this");
   return NS_ERROR_NOT_IMPLEMENTED;
@@ -278,30 +259,29 @@ nsHtml5TreeOpExecutor::UpdateStyleSheet(
   // Re-open update
   BeginDocUpdate();
 }
 
 void
 nsHtml5TreeOpExecutor::Flush()
 {
   if (!mParser) {
-    mFlushTimer->Cancel();
     return;
   }
   if (mFlushState != eNotFlushing) {
     return;
   }
   
   mFlushState = eInFlush;
 
   nsRefPtr<nsHtml5TreeOpExecutor> kungFuDeathGrip(this); // avoid crashing near EOF
   nsCOMPtr<nsIParser> parserKungFuDeathGrip(mParser);
 
   if (mReadingFromStage) {
-    mStage.RetrieveOperations(mOpQueue);
+    mStage.MoveOpsTo(mOpQueue);
   }
   
   nsIContent* scriptElement = nsnull;
   
   BeginDocUpdate();
 
   PRIntervalTime flushStart = 0;
   PRUint32 opQueueLength = mOpQueue.Length();
@@ -343,33 +323,21 @@ nsHtml5TreeOpExecutor::Flush()
   EndDocUpdate();
 
   mFlushState = eNotFlushing;
 
   if (!mParser) {
     return;
   }
 
-  ScheduleTimer();
-
   if (scriptElement) {
     RunScript(scriptElement); // must be tail call when mFlushState is eNotFlushing
   }
 }
 
-void
-nsHtml5TreeOpExecutor::ScheduleTimer()
-{
-  mFlushTimer->Cancel();
-  mFlushTimer->InitWithFuncCallback(TimerCallbackFunc, 
-                                    static_cast<void*> (this), 
-                                    NS_HTML5_TREE_OP_EXECUTOR_MAX_TIME_WITHOUT_FLUSH, 
-                                    nsITimer::TYPE_ONE_SHOT);
-}
-
 nsresult
 nsHtml5TreeOpExecutor::ProcessBASETag(nsIContent* aContent)
 {
   NS_ASSERTION(aContent, "missing base-element");
   if (mHasProcessedBase) {
     return NS_OK;
   }
   mHasProcessedBase = PR_TRUE;
@@ -523,17 +491,16 @@ nsHtml5TreeOpExecutor::Init(nsIDocument*
   return rv;
 }
 
 void
 nsHtml5TreeOpExecutor::Start()
 {
   NS_PRECONDITION(!mStarted, "Tried to start when already started.");
   mStarted = PR_TRUE;
-  ScheduleTimer();
 }
 
 void
 nsHtml5TreeOpExecutor::NeedsCharsetSwitchTo(const char* aEncoding)
 {
   EndDocUpdate();
 
   if(NS_UNLIKELY(!mParser)) {
@@ -581,23 +548,17 @@ nsHtml5TreeOpExecutor::Reset() {
   mReadingFromStage = PR_FALSE;
   mOpQueue.Clear();
   mStarted = PR_FALSE;
   mFlushState = eNotFlushing;
   mFragmentMode = PR_FALSE;
 }
 
 void
-nsHtml5TreeOpExecutor::MaybeFlush(nsTArray<nsHtml5TreeOperation>& aOpQueue)
-{
-  // no-op
-}
-
-void
-nsHtml5TreeOpExecutor::ForcedFlush(nsTArray<nsHtml5TreeOperation>& aOpQueue)
+nsHtml5TreeOpExecutor::MoveOpsFrom(nsTArray<nsHtml5TreeOperation>& aOpQueue)
 {
   NS_PRECONDITION(mFlushState == eNotFlushing, "mOpQueue modified during tree op execution.");
   if (mOpQueue.IsEmpty()) {
     mOpQueue.SwapElements(aOpQueue);
     return;
   }
   mOpQueue.MoveElementsFrom(aOpQueue);
 }
diff --git a/parser/html/nsHtml5TreeOpExecutor.h b/parser/html/nsHtml5TreeOpExecutor.h
--- a/parser/html/nsHtml5TreeOpExecutor.h
+++ b/parser/html/nsHtml5TreeOpExecutor.h
@@ -45,17 +45,16 @@
 #include "nsIDocument.h"
 #include "nsTraceRefcnt.h"
 #include "nsHtml5TreeOperation.h"
 #include "nsHtml5PendingNotification.h"
 #include "nsTArray.h"
 #include "nsContentSink.h"
 #include "nsNodeInfoManager.h"
 #include "nsHtml5DocumentMode.h"
-#include "nsITimer.h"
 #include "nsIScriptElement.h"
 #include "nsIParser.h"
 #include "nsCOMArray.h"
 #include "nsAHtml5TreeOpSink.h"
 #include "nsHtml5TreeOpStage.h"
 
 class nsHtml5TreeBuilder;
 class nsHtml5Tokenizer;
@@ -90,28 +89,22 @@ class nsHtml5TreeOpExecutor : public nsC
 
     /**
      * Whether EOF needs to be suppressed
      */
     PRBool                               mSuppressEOF;
     
     PRBool                               mHasProcessedBase;
     PRBool                               mReadingFromStage;
-    nsCOMPtr<nsITimer>                   mFlushTimer;
     nsTArray<nsHtml5TreeOperation>       mOpQueue;
     nsTArray<nsIContentPtr>              mElementsSeenInThisAppendBatch;
     nsTArray<nsHtml5PendingNotification> mPendingNotifications;
     nsHtml5StreamParser*                 mStreamParser;
     nsCOMArray<nsIContent>               mOwnedElements;
     
-    // This could be optimized away by introducing more tree ops so that 
-    // non-elements wouldn't use the handle setup but the text node / comment
-    // / doctype operand would be remembered by the tree op executor.
-    nsCOMArray<nsIContent>               mOwnedNonElements;
-  
     /**
      * Whether the parser has started
      */
     PRBool                        mStarted;
 
     nsHtml5TreeOpStage            mStage;
 
     eHtml5FlushState              mFlushState;
@@ -295,31 +288,31 @@ class nsHtml5TreeOpExecutor : public nsC
       if (mElementsSeenInThisAppendBatch.Length() > sAppendBatchMaxSize) {
         sAppendBatchMaxSize = mElementsSeenInThisAppendBatch.Length();
       }
 #endif
       mElementsSeenInThisAppendBatch.Clear();
       mFlushState = eInDocUpdate;
     }
     
-    inline PRBool HaveNotified(nsIContent* aElement) {
-      NS_PRECONDITION(aElement, "HaveNotified called with null argument.");
+    inline PRBool HaveNotified(nsIContent* aNode) {
+      NS_PRECONDITION(aNode, "HaveNotified called with null argument.");
       const nsHtml5PendingNotification* start = mPendingNotifications.Elements();
       const nsHtml5PendingNotification* end = start + mPendingNotifications.Length();
       for (;;) {
-        nsIContent* parent = aElement->GetParent();
+        nsIContent* parent = aNode->GetParent();
         if (!parent) {
           return PR_TRUE;
         }
         for (nsHtml5PendingNotification* iter = (nsHtml5PendingNotification*)start; iter < end; ++iter) {
           if (iter->Contains(parent)) {
-            return iter->HaveNotifiedIndex(parent->IndexOf(aElement));
+            return iter->HaveNotifiedIndex(parent->IndexOf(aNode));
           }
         }
-        aElement = parent;
+        aNode = parent;
       }
     }
 
     void StartLayout() {
       nsIDocument* doc = GetDocument();
       if (doc) {
         FlushPendingAppendNotifications();
         nsContentSink::StartLayout(PR_FALSE);
@@ -354,45 +347,34 @@ class nsHtml5TreeOpExecutor : public nsC
     void RunScript(nsIContent* aScriptElement);
     
     void Reset();
     
     inline void HoldElement(nsIContent* aContent) {
       mOwnedElements.AppendObject(aContent);
     }
 
-    inline void HoldNonElement(nsIContent* aContent) {
-      mOwnedNonElements.AppendObject(aContent);
-    }
-
     // The following two methods are for the main-thread case
 
     /**
-     * No-op
-     */    
-    virtual void MaybeFlush(nsTArray<nsHtml5TreeOperation>& aOpQueue);
-
-    /**
      * Flush the operations from the tree operations from the argument
      * queue unconditionally.
      */
-    virtual void ForcedFlush(nsTArray<nsHtml5TreeOperation>& aOpQueue);
+    virtual void MoveOpsFrom(nsTArray<nsHtml5TreeOperation>& aOpQueue);
     
     nsAHtml5TreeOpSink* GetStage() {
       return &mStage;
     }
     
     void StartReadingFromStage() {
       mReadingFromStage = PR_TRUE;
     }
 
     void StreamEnded();
     
-    void ScheduleTimer();
-
 #ifdef DEBUG
     void AssertStageEmpty() {
       mStage.AssertEmpty();
     }
 #endif
 
   private:
 
diff --git a/parser/html/nsHtml5TreeOpStage.cpp b/parser/html/nsHtml5TreeOpStage.cpp
--- a/parser/html/nsHtml5TreeOpStage.cpp
+++ b/parser/html/nsHtml5TreeOpStage.cpp
@@ -42,37 +42,28 @@ nsHtml5TreeOpStage::nsHtml5TreeOpStage()
 {
 }
     
 nsHtml5TreeOpStage::~nsHtml5TreeOpStage()
 {
 }
 
 void
-nsHtml5TreeOpStage::MaybeFlush(nsTArray<nsHtml5TreeOperation>& aOpQueue)
-{
-  mozilla::MutexAutoLock autoLock(mMutex);
-  if (mOpQueue.IsEmpty()) {
-    mOpQueue.SwapElements(aOpQueue);
-  }  
-}
-
-void
-nsHtml5TreeOpStage::ForcedFlush(nsTArray<nsHtml5TreeOperation>& aOpQueue)
+nsHtml5TreeOpStage::MoveOpsFrom(nsTArray<nsHtml5TreeOperation>& aOpQueue)
 {
   mozilla::MutexAutoLock autoLock(mMutex);
   if (mOpQueue.IsEmpty()) {
     mOpQueue.SwapElements(aOpQueue);
     return;
   }
   mOpQueue.MoveElementsFrom(aOpQueue);
 }
     
 void
-nsHtml5TreeOpStage::RetrieveOperations(nsTArray<nsHtml5TreeOperation>& aOpQueue)
+nsHtml5TreeOpStage::MoveOpsTo(nsTArray<nsHtml5TreeOperation>& aOpQueue)
 {
   mozilla::MutexAutoLock autoLock(mMutex);
   if (aOpQueue.IsEmpty()) {
     mOpQueue.SwapElements(aOpQueue);
     return;
   }
   aOpQueue.MoveElementsFrom(mOpQueue);
 }
diff --git a/parser/html/nsHtml5TreeOpStage.h b/parser/html/nsHtml5TreeOpStage.h
--- a/parser/html/nsHtml5TreeOpStage.h
+++ b/parser/html/nsHtml5TreeOpStage.h
@@ -47,30 +47,24 @@ class nsHtml5TreeOpStage : public nsAHtm
   public:
   
     nsHtml5TreeOpStage();
     
     ~nsHtml5TreeOpStage();
   
     /**
      * Flush the operations from the tree operations from the argument
-     * queue if flushing is not expensive.
-     */
-    virtual void MaybeFlush(nsTArray<nsHtml5TreeOperation>& aOpQueue);
-
-    /**
-     * Flush the operations from the tree operations from the argument
      * queue unconditionally.
      */
-    virtual void ForcedFlush(nsTArray<nsHtml5TreeOperation>& aOpQueue);
+    virtual void MoveOpsFrom(nsTArray<nsHtml5TreeOperation>& aOpQueue);
     
     /**
      * Retrieve the staged operations into the argument.
      */
-    void RetrieveOperations(nsTArray<nsHtml5TreeOperation>& aOpQueue);
+    void MoveOpsTo(nsTArray<nsHtml5TreeOperation>& aOpQueue);
 
 #ifdef DEBUG
     void AssertEmpty();
 #endif
 
   private:
     nsTArray<nsHtml5TreeOperation> mOpQueue;
     mozilla::Mutex                 mMutex;
diff --git a/parser/html/nsHtml5TreeOperation.cpp b/parser/html/nsHtml5TreeOperation.cpp
--- a/parser/html/nsHtml5TreeOperation.cpp
+++ b/parser/html/nsHtml5TreeOperation.cpp
@@ -52,16 +52,17 @@
 #include "nsContentCreatorFunctions.h"
 #include "nsIScriptElement.h"
 #include "nsIDTD.h"
 #include "nsTraceRefcnt.h"
 #include "nsIDOMHTMLFormElement.h"
 #include "nsIFormControl.h"
 #include "nsIStyleSheetLinkingElement.h"
 #include "nsIDOMDocumentType.h"
+#include "nsIMutationObserver.h"
 
 /**
  * Helper class that opens a notification batch if the current doc
  * is different from the executor doc.
  */
 class NS_STACK_CLASS nsHtml5OtherDocUpdate {
   public:
     nsHtml5OtherDocUpdate(nsIDocument* aCurrentDoc, nsIDocument* aExecutorDoc)
@@ -100,63 +101,145 @@ nsHtml5TreeOperation::~nsHtml5TreeOperat
   NS_ASSERTION(mOpCode != eTreeOpUninitialized, "Uninitialized tree op.");
   switch(mOpCode) {
     case eTreeOpAddAttributes:
       delete mTwo.attributes;
       break;
     case eTreeOpCreateElement:
       delete mThree.attributes;
       break;
-    case eTreeOpCreateDoctype:
+    case eTreeOpAppendDoctypeToDocument:
       delete mTwo.stringPair;
       break;
-    case eTreeOpCreateTextNode:
-    case eTreeOpCreateComment:
+    case eTreeOpFosterParentText:
+    case eTreeOpAppendText:
+    case eTreeOpAppendComment:
+    case eTreeOpAppendCommentToDocument:
       delete[] mTwo.unicharPtr;
       break;
     case eTreeOpSetDocumentCharset:
     case eTreeOpNeedsCharsetSwitchTo:
       delete[] mOne.charPtr;
       break;
     default: // keep the compiler happy
       break;
   }
 }
 
 nsresult
+nsHtml5TreeOperation::AppendTextToTextNode(PRUnichar* aBuffer,
+                                           PRInt32 aLength,
+                                           nsIContent* aTextNode,
+                                           nsHtml5TreeOpExecutor* aBuilder)
+{
+  NS_PRECONDITION(aTextNode, "Got null text node.");
+
+  if (aBuilder->HaveNotified(aTextNode)) {
+    // This text node has already been notified on, so it's necessary to
+    // notify on the append
+    nsresult rv = NS_OK;
+    PRUint32 oldLength = aTextNode->TextLength();
+    CharacterDataChangeInfo info = {
+      PR_TRUE,
+      oldLength,
+      oldLength,
+      aLength
+    };
+    nsNodeUtils::CharacterDataWillChange(aTextNode, &info);
+
+    rv = aTextNode->AppendText(aBuffer, aLength, PR_FALSE);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsNodeUtils::CharacterDataChanged(aTextNode, &info);
+    return rv;
+  }
+
+  return aTextNode->AppendText(aBuffer, aLength, PR_FALSE);
+}
+
+
+nsresult
+nsHtml5TreeOperation::AppendText(PRUnichar* aBuffer,
+                                 PRInt32 aLength,
+                                 nsIContent* aParent,
+                                 nsHtml5TreeOpExecutor* aBuilder)
+{
+  nsresult rv = NS_OK;
+  nsIContent* lastChild = aParent->GetLastChild();
+  if (lastChild && lastChild->IsNodeOfType(nsINode::eTEXT)) {
+    nsHtml5OtherDocUpdate update(aParent->GetOwnerDoc(),
+                                 aBuilder->GetDocument());
+    return AppendTextToTextNode(aBuffer, 
+                                aLength, 
+                                lastChild, 
+                                aBuilder);
+  }
+
+  nsCOMPtr<nsIContent> text;
+  NS_NewTextNode(getter_AddRefs(text), aBuilder->GetNodeInfoManager());
+  NS_ASSERTION(text, "Infallible malloc failed?");
+  rv = text->SetText(aBuffer, aLength, PR_FALSE);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return Append(text, aParent, aBuilder);
+}
+
+nsresult
+nsHtml5TreeOperation::Append(nsIContent* aNode,
+                             nsIContent* aParent,
+                             nsHtml5TreeOpExecutor* aBuilder)
+{
+  nsresult rv = NS_OK;
+  nsIDocument* executorDoc = aBuilder->GetDocument();
+  NS_ASSERTION(executorDoc, "Null doc on executor");
+  nsIDocument* parentDoc = aParent->GetOwnerDoc();
+  NS_ASSERTION(parentDoc, "Null owner doc on old node.");
+
+  if (NS_LIKELY(executorDoc == parentDoc)) {
+    // the usual case. the parent is in the parser's doc
+    aBuilder->PostPendingAppendNotification(aParent, aNode);
+    rv = aParent->AppendChildTo(aNode, PR_FALSE);
+    return rv;
+  }
+
+  // The parent has been moved to another doc
+  parentDoc->BeginUpdate(UPDATE_CONTENT_MODEL);
+
+  PRUint32 childCount = aParent->GetChildCount();
+  rv = aParent->AppendChildTo(aNode, PR_FALSE);
+  nsNodeUtils::ContentAppended(aParent, childCount);
+
+  parentDoc->EndUpdate(UPDATE_CONTENT_MODEL);
+  return rv;
+}
+
+nsresult
+nsHtml5TreeOperation::AppendToDocument(nsIContent* aNode,
+                                       nsHtml5TreeOpExecutor* aBuilder)
+{
+  nsresult rv = NS_OK;
+  aBuilder->FlushPendingAppendNotifications();
+  nsIDocument* doc = aBuilder->GetDocument();
+  PRUint32 childCount = doc->GetChildCount();
+  rv = doc->AppendChildTo(aNode, PR_FALSE);
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsNodeUtils::ContentInserted(doc, aNode, childCount);
+  return rv;
+}
+
+nsresult
 nsHtml5TreeOperation::Perform(nsHtml5TreeOpExecutor* aBuilder,
                               nsIContent** aScriptElement)
 {
   nsresult rv = NS_OK;
   switch(mOpCode) {
     case eTreeOpAppend: {
       nsIContent* node = *(mOne.node);
       nsIContent* parent = *(mTwo.node);
-
-      nsIDocument* executorDoc = aBuilder->GetDocument();
-      NS_ASSERTION(executorDoc, "Null doc on executor");
-      nsIDocument* parentDoc = parent->GetOwnerDoc();
-      NS_ASSERTION(parentDoc, "Null owner doc on old node.");
-
-      if (NS_LIKELY(executorDoc == parentDoc)) {
-        // the usual case. the parent is in the parser's doc
-        aBuilder->PostPendingAppendNotification(parent, node);
-        rv = parent->AppendChildTo(node, PR_FALSE);
-        return rv;
-      }
-      
-      // The parent has been moved to another doc
-      parentDoc->BeginUpdate(UPDATE_CONTENT_MODEL);
-
-      PRUint32 childCount = parent->GetChildCount();
-      rv = parent->AppendChildTo(node, PR_FALSE);
-      nsNodeUtils::ContentAppended(parent, childCount);
-
-      parentDoc->EndUpdate(UPDATE_CONTENT_MODEL);
-      return rv;
+      return Append(node, parent, aBuilder);
     }
     case eTreeOpDetach: {
       nsIContent* node = *(mOne.node);
       aBuilder->FlushPendingAppendNotifications();
       nsIContent* parent = node->GetParent();
       if (parent) {
         nsHtml5OtherDocUpdate update(parent->GetOwnerDoc(),
                                      aBuilder->GetDocument());
@@ -204,47 +287,21 @@ nsHtml5TreeOperation::Perform(nsHtml5Tre
 
         PRUint32 pos = foster->IndexOf(table);
         rv = foster->InsertChildAt(node, pos, PR_FALSE);
         NS_ENSURE_SUCCESS(rv, rv);
         nsNodeUtils::ContentInserted(foster, node, pos);
         return rv;
       }
 
-      nsIDocument* executorDoc = aBuilder->GetDocument();
-      NS_ASSERTION(executorDoc, "Null doc on executor");
-      nsIDocument* parentDoc = parent->GetOwnerDoc();
-      NS_ASSERTION(parentDoc, "Null owner doc on old node.");
-
-      if (NS_LIKELY(executorDoc == parentDoc)) {
-        // the usual case. the parent is in the parser's doc
-        aBuilder->PostPendingAppendNotification(parent, node);
-        rv = parent->AppendChildTo(node, PR_FALSE);
-        return rv;
-      }
-      
-      // The parent has been moved to another doc
-      parentDoc->BeginUpdate(UPDATE_CONTENT_MODEL);
-
-      PRUint32 childCount = parent->GetChildCount();
-      rv = parent->AppendChildTo(node, PR_FALSE);
-      nsNodeUtils::ContentAppended(parent, childCount);
-
-      parentDoc->EndUpdate(UPDATE_CONTENT_MODEL);
-      return rv;
+      return Append(node, parent, aBuilder);
     }
     case eTreeOpAppendToDocument: {
       nsIContent* node = *(mOne.node);
-      aBuilder->FlushPendingAppendNotifications();
-      nsIDocument* doc = aBuilder->GetDocument();
-      PRUint32 childCount = doc->GetChildCount();
-      rv = doc->AppendChildTo(node, PR_FALSE);
-      NS_ENSURE_SUCCESS(rv, rv);
-      nsNodeUtils::ContentInserted(doc, node, childCount);
-      return rv;
+      return AppendToDocument(node, aBuilder);
     }
     case eTreeOpAddAttributes: {
       nsIContent* node = *(mOne.node);
       nsHtml5HtmlAttributes* attributes = mTwo.attributes;
 
       nsHtml5OtherDocUpdate update(node->GetOwnerDoc(),
                                    aBuilder->GetDocument());
 
@@ -344,51 +401,91 @@ nsHtml5TreeOperation::Perform(nsHtml5Tre
       // TODO: uncomment the above line when <output> (bug 346485) and <keygen> (bug 101019) are supported by Gecko
       nsCOMPtr<nsIDOMHTMLFormElement> formElement(do_QueryInterface(parent));
       NS_ASSERTION(formElement, "The form element doesn't implement nsIDOMHTMLFormElement.");
       if (formControl) { // avoid crashing on <output> and <keygen>
         formControl->SetForm(formElement);
       }
       return rv;
     }
-    case eTreeOpCreateTextNode: {
-      nsIContent** target = mOne.node;
+    case eTreeOpAppendText: {
+      nsIContent* parent = *mOne.node;
       PRUnichar* buffer = mTwo.unicharPtr;
       PRInt32 length = mInt;
+      return AppendText(buffer, length, parent, aBuilder);
+    }
+    case eTreeOpFosterParentText: {
+      nsIContent* stackParent = *mOne.node;
+      PRUnichar* buffer = mTwo.unicharPtr;
+      PRInt32 length = mInt;
+      nsIContent* table = *mThree.node;
       
-      nsCOMPtr<nsIContent> text;
-      NS_NewTextNode(getter_AddRefs(text), aBuilder->GetNodeInfoManager());
-      // XXX nsresult and comment null check?
-      text->SetText(buffer, length, PR_FALSE);
-      // XXX nsresult
+      nsIContent* foster = table->GetParent();
+
+      if (foster && foster->IsNodeOfType(nsINode::eELEMENT)) {
+        aBuilder->FlushPendingAppendNotifications();
+
+        nsHtml5OtherDocUpdate update(foster->GetOwnerDoc(),
+                                     aBuilder->GetDocument());
+
+        PRUint32 pos = foster->IndexOf(table);
+        
+        nsIContent* previousSibling = foster->GetChildAt(pos - 1);
+        if (previousSibling && previousSibling->IsNodeOfType(nsINode::eTEXT)) {
+          return AppendTextToTextNode(buffer, 
+                                      length, 
+                                      previousSibling, 
+                                      aBuilder);
+        }
+        
+        nsCOMPtr<nsIContent> text;
+        NS_NewTextNode(getter_AddRefs(text), aBuilder->GetNodeInfoManager());
+        NS_ASSERTION(text, "Infallible malloc failed?");
+        rv = text->SetText(buffer, length, PR_FALSE);
+        NS_ENSURE_SUCCESS(rv, rv);
+        
+        rv = foster->InsertChildAt(text, pos, PR_FALSE);
+        NS_ENSURE_SUCCESS(rv, rv);
+        nsNodeUtils::ContentInserted(foster, text, pos);
+        return rv;
+      }
       
-      aBuilder->HoldNonElement(*target = text);
-      return rv;
+      return AppendText(buffer, length, stackParent, aBuilder);
     }
-    case eTreeOpCreateComment: {
-      nsIContent** target = mOne.node;
+    case eTreeOpAppendComment: {
+      nsIContent* parent = *mOne.node;
       PRUnichar* buffer = mTwo.unicharPtr;
       PRInt32 length = mInt;
       
       nsCOMPtr<nsIContent> comment;
       NS_NewCommentNode(getter_AddRefs(comment), aBuilder->GetNodeInfoManager());
-      // XXX nsresult and comment null check?
-      comment->SetText(buffer, length, PR_FALSE);
-      // XXX nsresult
+      NS_ASSERTION(comment, "Infallible malloc failed?");
+      rv = comment->SetText(buffer, length, PR_FALSE);
+      NS_ENSURE_SUCCESS(rv, rv);
       
-      aBuilder->HoldNonElement(*target = comment);
-      return rv;
+      return Append(comment, parent, aBuilder);
     }
-    case eTreeOpCreateDoctype: {
+    case eTreeOpAppendCommentToDocument: {
+      PRUnichar* buffer = mTwo.unicharPtr;
+      PRInt32 length = mInt;
+      
+      nsCOMPtr<nsIContent> comment;
+      NS_NewCommentNode(getter_AddRefs(comment), aBuilder->GetNodeInfoManager());
+      NS_ASSERTION(comment, "Infallible malloc failed?");
+      rv = comment->SetText(buffer, length, PR_FALSE);
+      NS_ENSURE_SUCCESS(rv, rv);
+      
+      return AppendToDocument(comment, aBuilder);
+    }
+    case eTreeOpAppendDoctypeToDocument: {
       nsCOMPtr<nsIAtom> name = Reget(mOne.atom);
       nsHtml5TreeOperationStringPair* pair = mTwo.stringPair;
       nsString publicId;
       nsString systemId;
       pair->Get(publicId, systemId);
-      nsIContent** target = mThree.node;
       
       // Adapted from nsXMLContentSink
       // Create a new doctype node
       nsCOMPtr<nsIDOMDocumentType> docType;
       nsAutoString voidString;
       voidString.SetIsVoid(PR_TRUE);
       NS_NewDOMDocumentType(getter_AddRefs(docType),
                             aBuilder->GetNodeInfoManager(),
@@ -396,18 +493,17 @@ nsHtml5TreeOperation::Perform(nsHtml5Tre
                             name,
                             nsnull,
                             nsnull,
                             publicId,
                             systemId,
                             voidString);
       NS_ASSERTION(docType, "Doctype creation failed.");
       nsCOMPtr<nsIContent> asContent = do_QueryInterface(docType);
-      aBuilder->HoldNonElement(*target = asContent);      
-      return rv;
+      return AppendToDocument(asContent, aBuilder);
     }
     case eTreeOpRunScript: {
       nsIContent* node = *(mOne.node);
       nsAHtml5TreeBuilderState* snapshot = mTwo.state;
       if (snapshot) {
         aBuilder->InitializeDocWriteParserState(snapshot, mInt);
       }
       *aScriptElement = node;
diff --git a/parser/html/nsHtml5TreeOperation.h b/parser/html/nsHtml5TreeOperation.h
--- a/parser/html/nsHtml5TreeOperation.h
+++ b/parser/html/nsHtml5TreeOperation.h
@@ -54,19 +54,21 @@ enum eHtml5TreeOperation {
   eTreeOpDetach,
   eTreeOpAppendChildrenToNewParent,
   eTreeOpFosterParent,
   eTreeOpAppendToDocument,
   eTreeOpAddAttributes,
   eTreeOpDocumentMode,
   eTreeOpCreateElement,
   eTreeOpSetFormElement,
-  eTreeOpCreateTextNode,
-  eTreeOpCreateComment,
-  eTreeOpCreateDoctype,
+  eTreeOpAppendText,
+  eTreeOpFosterParentText,
+  eTreeOpAppendComment,
+  eTreeOpAppendCommentToDocument,
+  eTreeOpAppendDoctypeToDocument,
   // Gecko-specific on-pop ops
   eTreeOpRunScript,
   eTreeOpRunScriptAsyncDefer,
   eTreeOpDoneAddingChildren,
   eTreeOpDoneCreatingElement,
   eTreeOpSetDocumentCharset,
   eTreeOpNeedsCharsetSwitchTo,
   eTreeOpUpdateStyleSheet,
@@ -183,45 +185,70 @@ class nsHtml5TreeOperation {
       } else {
         mThree.attributes = aAttributes;
       }
     }
 
     inline void Init(eHtml5TreeOperation aOpCode, 
                      PRUnichar* aBuffer, 
                      PRInt32 aLength, 
-                     nsIContent** aTarget) {
+                     nsIContent** aStackParent,
+                     nsIContent** aTable) {
       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
         "Op code must be uninitialized when initializing.");
       NS_PRECONDITION(aBuffer, "Initialized tree op with null buffer.");
       mOpCode = aOpCode;
-      mOne.node = aTarget;
+      mOne.node = aStackParent;
+      mTwo.unicharPtr = aBuffer;
+      mThree.node = aTable;
+      mInt = aLength;
+    }
+
+    inline void Init(eHtml5TreeOperation aOpCode, 
+                     PRUnichar* aBuffer, 
+                     PRInt32 aLength, 
+                     nsIContent** aParent) {
+      NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
+        "Op code must be uninitialized when initializing.");
+      NS_PRECONDITION(aBuffer, "Initialized tree op with null buffer.");
+      mOpCode = aOpCode;
+      mOne.node = aParent;
+      mTwo.unicharPtr = aBuffer;
+      mInt = aLength;
+    }
+
+    inline void Init(eHtml5TreeOperation aOpCode, 
+                     PRUnichar* aBuffer, 
+                     PRInt32 aLength) {
+      NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
+        "Op code must be uninitialized when initializing.");
+      NS_PRECONDITION(aBuffer, "Initialized tree op with null buffer.");
+      mOpCode = aOpCode;
       mTwo.unicharPtr = aBuffer;
       mInt = aLength;
     }
     
     inline void Init(nsIContent** aElement,
                      nsHtml5HtmlAttributes* aAttributes) {
       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
         "Op code must be uninitialized when initializing.");
       NS_PRECONDITION(aElement, "Initialized tree op with null element.");
       mOpCode = eTreeOpAddAttributes;
       mOne.node = aElement;
       mTwo.attributes = aAttributes;
     }
     
     inline void Init(nsIAtom* aName, 
                      const nsAString& aPublicId, 
-                     const nsAString& aSystemId, nsIContent** aTarget) {
+                     const nsAString& aSystemId) {
       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
         "Op code must be uninitialized when initializing.");
-      mOpCode = eTreeOpCreateDoctype;
+      mOpCode = eTreeOpAppendDoctypeToDocument;
       mOne.atom = aName;
       mTwo.stringPair = new nsHtml5TreeOperationStringPair(aPublicId, aSystemId);
-      mThree.node = aTarget;
     }
     
     inline void Init(eHtml5TreeOperation aOpCode, const nsACString& aString) {
       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
         "Op code must be uninitialized when initializing.");
 
       PRInt32 len = aString.Length();
       char* str = new char[len + 1];
@@ -265,16 +292,33 @@ class nsHtml5TreeOperation {
         return aAtom;
       }
       nsAutoString str;
       aAtom->ToString(str);
       return do_GetAtom(str);
     }
 
   private:
+
+    nsresult AppendTextToTextNode(PRUnichar* aBuffer,
+                                  PRInt32 aLength,
+                                  nsIContent* aTextNode,
+                                  nsHtml5TreeOpExecutor* aBuilder);
+
+    nsresult AppendText(PRUnichar* aBuffer,
+                        PRInt32 aLength,
+                        nsIContent* aParent,
+                        nsHtml5TreeOpExecutor* aBuilder);
+
+    nsresult Append(nsIContent* aNode,
+                    nsIContent* aParent,
+                    nsHtml5TreeOpExecutor* aBuilder);
+
+    nsresult AppendToDocument(nsIContent* aNode,
+                              nsHtml5TreeOpExecutor* aBuilder);
   
     // possible optimization:
     // Make the queue take items the size of pointer and make the op code
     // decide how many operands it dequeues after it.
     eHtml5TreeOperation mOpCode;
     union {
       nsIContent**                    node;
       nsIAtom*                        atom;
